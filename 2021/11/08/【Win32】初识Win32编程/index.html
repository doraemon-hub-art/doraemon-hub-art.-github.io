<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>【Win32】初识Win32编程 | 半生瓜のblog</title><meta name="keywords" content="-Win32 - -C"><meta name="author" content="快乐的威猛先生"><meta name="copyright" content="快乐的威猛先生"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="相关视频——链接  Windows编程应用程序分类 控制台程序Console DOS程序，本身没有窗口，通过Windows DOS窗口执行。(DOS是操作系统预留的)   窗口程序 拥有自己的窗口，可以与用户交互。   库程序 存放代码、数据的程序、执行文件可以从中取出代码执行和获取数据 静态库程序:扩展名LIB,在编译链接程序时，将代码放入到执行文件中。 动态库程序：扩展名DLL，在执行文件时">
<meta property="og:type" content="article">
<meta property="og:title" content="【Win32】初识Win32编程">
<meta property="og:url" content="https://doraemon-hub-art.github.io/2021/11/08/%E3%80%90Win32%E3%80%91%E5%88%9D%E8%AF%86Win32%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="半生瓜のblog">
<meta property="og:description" content="相关视频——链接  Windows编程应用程序分类 控制台程序Console DOS程序，本身没有窗口，通过Windows DOS窗口执行。(DOS是操作系统预留的)   窗口程序 拥有自己的窗口，可以与用户交互。   库程序 存放代码、数据的程序、执行文件可以从中取出代码执行和获取数据 静态库程序:扩展名LIB,在编译链接程序时，将代码放入到执行文件中。 动态库程序：扩展名DLL，在执行文件时">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://doraemon-hub-art.github.io/img/win7.jpg">
<meta property="article:published_time" content="2021-11-08T00:48:10.000Z">
<meta property="article:modified_time" content="2021-11-13T03:23:51.151Z">
<meta property="article:author" content="快乐的威猛先生">
<meta property="article:tag" content="-Win32 - -C">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://doraemon-hub-art.github.io/img/win7.jpg"><link rel="shortcut icon" href="/img/doraemon2.png"><link rel="canonical" href="https://doraemon-hub-art.github.io/2021/11/08/%E3%80%90Win32%E3%80%91%E5%88%9D%E8%AF%86Win32%E7%BC%96%E7%A8%8B/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?4bd5c0d5704ac1dd90d20a471e6a167a";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-11-13 11:23:51'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><link rel="stylesheet" href="/css/xiaotubiao.css"><link rel="stylesheet" href="/footermeihua.css"><link rel="stylesheet" href="/css/hua.css"><link rel="stylesheet" href="/css/background.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Swiper/4.1.6/css/swiper.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-butterfly-swiper/lib/swiperstyle.css"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="半生瓜のblog" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/doraemon2.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">131</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">55</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 伙伴</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/win7.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">半生瓜のblog</a><div id="tp-weather-widget"></div></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 伙伴</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【Win32】初识Win32编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-11-08T00:48:10.000Z" title="发表于 2021-11-08 08:48:10">2021-11-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-11-13T03:23:51.151Z" title="更新于 2021-11-13 11:23:51">2021-11-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Win32/">Win32</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="【Win32】初识Win32编程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><hr>
<p>相关视频——<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1NA411K7aN?p=1">链接</a></p>
<hr>
<h1 id="Windows编程"><a href="#Windows编程" class="headerlink" title="Windows编程"></a>Windows编程</h1><h2 id="应用程序分类"><a href="#应用程序分类" class="headerlink" title="应用程序分类"></a>应用程序分类</h2><ul>
<li>控制台程序Console<ul>
<li>DOS程序，<strong>本身没有窗口</strong>，通过Windows DOS窗口执行。(DOS是操作系统预留的)</li>
</ul>
</li>
<li>窗口程序<ul>
<li>拥有自己的窗口，可以与用户交互。</li>
</ul>
</li>
<li>库程序<ul>
<li>存放代码、数据的程序、执行文件可以从中取出代码执行和获取数据</li>
<li>静态库程序:扩展名LIB,在编译链接程序时，将代码放入到执行文件中。</li>
<li>动态库程序：扩展名DLL，在执行文件时从中获取代码 。</li>
</ul>
静态库中的代码是直接嵌入到你的项目中，而动态库中的内容是通过地址来找到。<ul>
<li><strong>静态库程序无法执行，也就是说它最终生成的文件无法进入内存。</strong></li>
<li>动态库程序有入口函数，可以执行。<strong>但是它不能独立运行。</strong>谁调动态库里面的东西，它就依附于谁。</li>
</ul>
</li>
</ul>
<h2 id="应用程序对比"><a href="#应用程序对比" class="headerlink" title="应用程序对比"></a>应用程序对比</h2><ul>
<li>入口函数<ul>
<li>控制台程序-main</li>
<li>窗口程序-WinMain</li>
<li>动态库程序-DllMain</li>
<li>静态库程序-无入口函数</li>
</ul>
</li>
<li>文件存在方式<ul>
<li>控制台程序、窗口程序-EXE文件</li>
<li>动态库程序-DLL文件</li>
<li>静态库程序-LIB文件</li>
</ul>
</li>
</ul>
<h2 id="编译工具"><a href="#编译工具" class="headerlink" title="编译工具"></a>编译工具</h2><ul>
<li>编译器CL.EXE,将源代码编译成目标代码.obj。</li>
<li>链接器LINK.EXE,将目标代码、库链接生成最终文件。</li>
<li>资源编译器RC.EXE,(.rc)将资源编译，最终通过链接器存入最终文件</li>
</ul>
<h2 id="库文件和头文件"><a href="#库文件和头文件" class="headerlink" title="库文件和头文件"></a>库文件和头文件</h2><p><strong>库文件</strong></p>
<ul>
<li>kernel32.dll-提供核心的API,消息进程，线程，内存管理等。</li>
<li>user32.dll-提供了窗口、消息等API。</li>
<li>gdi32.dll-绘图相关的API</li>
</ul>
<p><strong>头文件</strong></p>
<ul>
<li>windows.h——所有windows头文件的集合</li>
<li>windef.h——windows数据类型</li>
<li>winbase.h——kernel32的API</li>
<li>wingdi.h——user32的API</li>
<li>winnt.h——UNICODE字符集支持</li>
</ul>
<h2 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">wWinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    HINSTANCE hInstance,<span class="comment">//当前程序的实例句柄，找到你当前进程所占据的那块内存</span></span></span></span><br><span class="line"><span class="function"><span class="params">    HINSTANCE hPrevInstance,<span class="comment">//当前程序前一个示例句柄，废弃了</span></span></span></span><br><span class="line"><span class="function"><span class="params">    PWSTR pCmdLine, <span class="comment">//命令行参数字符串</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> nCmdShow<span class="comment">//窗口的显示方式</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>暂时可以将句柄理解成，句柄是用来找到内存的东西，但绝对不是指针。</strong></p>
<hr>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MessageBox</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional] HWND    hWnd,<span class="comment">//父窗口句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional] LPCTSTR lpText,<span class="comment">//显示在消息框中的文字</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional] LPCTSTR lpCaption,<span class="comment">//显示在标题栏中的文字</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in]           UINT    uType<span class="comment">//消息框中的按钮、图标显示了类型</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;<span class="comment">//返回点击的按钮ID</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>能够将程序暂停在这里，说明它是个阻塞函数。它执行，可能不会立即返回。</p>
<hr>
<p><strong>如何理解分析一个阻塞函数</strong>？<br>1.这个函数什么情况下阻塞。</p>
<p>2.这个函数什么情况下解除阻塞返回。</p>
<hr>
<p><strong>看到数据类型以H开头，多半就是个句柄。</strong></p>
<hr>
<h2 id="程序编译过程"><a href="#程序编译过程" class="headerlink" title="程序编译过程"></a>程序编译过程</h2><ul>
<li><p>可以直接用vs集成好的环境。<img src="/images/win32(1).assets/image-20211029171632365.png" alt="image-20211029171632365"></p>
</li>
<li><p>编译程序-CL,CL.EXE -C xxx.c，生成obj文件</p>
</li>
<li><p>链接程序-LINK，LINK.EXE xxx.obj xxx.lib</p>
</li>
<li><p>执行生成的exe文件</p>
</li>
</ul>
<hr>
<ul>
<li>编写资源的文件，.rc资源脚本文件</li>
<li>编译rc文件，RC.EXE</li>
<li>将资源链接到程序中，LINK.EXE</li>
</ul>
<p>.res文件和.obj文件统称为目标文件(中间文件，因为不是最终文件)</p>
<hr>
<p> <strong>编译链接过程</strong>：将代码转换为机器语言，将生成的res文件和obj文件加上使用的库链接到一起，整合出一个exe文件，这是用编译器所感受不到的。</p>
<p><img src="/images/win32(1).assets/image-20211029172712321.png" alt="image-20211029172712321"></p>
<hr>
<h2 id="窗口创建过程"><a href="#窗口创建过程" class="headerlink" title="窗口创建过程"></a>窗口创建过程</h2><ul>
<li>定义WinMain函数</li>
<li>定义窗口的处理函数(自定义，消息处理)</li>
<li>注册窗口类(向操作系统中写入一些数据)</li>
<li>创建窗口(内存中创建窗口)</li>
<li>显示窗口(绘制窗口的图像)</li>
<li>消息循环(获取/翻译/派发消息)</li>
<li>消息处理</li>
</ul>
<h2 id="第一个windows窗口"><a href="#第一个windows窗口" class="headerlink" title="第一个windows窗口"></a>第一个windows窗口</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//窗口处理函数（自定义、处理消息）</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hWnd, UINT msgID, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> DefWindowProc(hWnd, msgID, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入口函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> CALLBACK <span class="title">WinMain</span><span class="params">(HINSTANCE hIns, HINSTANCE hPerIns, LPSTR lpCmdLine, <span class="keyword">int</span> nCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//注册窗口类</span></span><br><span class="line">	WNDCLASS wc = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="comment">//申请两种不用的缓冲区</span></span><br><span class="line">	wc.cbClsExtra = <span class="number">0</span>;</span><br><span class="line">	wc.cbWndExtra = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + <span class="number">1</span>);</span><br><span class="line">	wc.hCursor = <span class="literal">NULL</span>;</span><br><span class="line">	wc.hIcon = <span class="literal">NULL</span>;</span><br><span class="line">	wc.hInstance = hIns;</span><br><span class="line">	wc.lpfnWndProc = WndProc;</span><br><span class="line">	wc.lpszClassName = <span class="string">&quot;myWindow&quot;</span>;</span><br><span class="line">	wc.lpszMenuName = <span class="literal">NULL</span>;</span><br><span class="line">	wc.style = CS_HREDRAW | CS_VREDRAW;</span><br><span class="line">	<span class="comment">//将上面赋的这些值全部写入操作系统</span></span><br><span class="line">	RegisterClass(&amp;wc);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//在内存中创建窗口</span></span><br><span class="line">	HWND hWnd = CreateWindow(<span class="string">&quot;myWindow&quot;</span>, <span class="string">&quot;menu&quot;</span>, WS_OVERLAPPEDWINDOW, <span class="number">100</span>, <span class="number">100</span>, <span class="number">500</span>, <span class="number">500</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, hIns, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//显示窗口</span></span><br><span class="line">	ShowWindow(hWnd, SW_SHOW);</span><br><span class="line">	<span class="comment">//再画一遍(刷新窗口)</span></span><br><span class="line">	UpdateWindow(hWnd);</span><br><span class="line">	<span class="comment">//消息循环</span></span><br><span class="line">	MSG nMsg = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">while</span> (GetMessage(&amp;nMsg,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		TranslateMessage(&amp;nMsg);</span><br><span class="line">		DispatchMessage(&amp;nMsg);<span class="comment">//将消息交给窗口处理函数来处理</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>窗口有无与进程退不退没有关系。</p>
<h2 id="Unit04字符编码"><a href="#Unit04字符编码" class="headerlink" title="Unit04字符编码"></a>Unit04字符编码</h2><p><strong>编码历史背景</strong></p>
<ul>
<li>ASC——7位代表一个字符</li>
<li>ASCII——8位代表一个字符</li>
<li>DBCS——<strong>单双字节混合编码</strong>，没有同一标准，存在解析问题。</li>
<li>UNICODE——字符集，有多种编码方式，一般windows只的是utf-16(所有的字符无论中文汉子还是英文字母，都按两个字符编码。),linux utf-8,有统一标准，不存在解析问题。</li>
</ul>
<h2 id="宽字节数据类型"><a href="#宽字节数据类型" class="headerlink" title="宽字节数据类型"></a>宽字节数据类型</h2><p>这个数据类型下的所有字符， 都占2个字节。</p>
<blockquote>
<p>wchar_t每个字符占2个字节，wchar_t实际上是unsigned short类型，定义时，需要增加‘L’，通知编译器按照双字节编译字符串，采用UNICODE编码。</p>
<p>需要使用支持wchar_t函数操作宽字节字符串，例如:<br>wchar_t* s1=  L”123456”;</p>
<p>wprintf(L”%s\n”,s1);</p>
</blockquote>
<hr>
<p>有操作char类型字符串的函数，肯定就有对应操作宽字节字符串的函数。</p>
<hr>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">wchar_t</span>* s1 = <span class="string">L&quot;hello&quot;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, wcslen(s1));<span class="comment">//5,有效字符个数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="TCHAR"><a href="#TCHAR" class="headerlink" title="TCHAR"></a>TCHAR</h2><p>如果定义了unicode宏，该字符串为wchar*类型，反之为char *类型。</p>
<h2 id="打印UNICODE字符"><a href="#打印UNICODE字符" class="headerlink" title="打印UNICODE字符"></a>打印UNICODE字符</h2><p>UNICODE字符打印，wprintf对UNICODE字符打印支持不完善。</p>
<p>在windows下使用<strong>WriteConsole</strong>打印UNICODE字符。</p>
<p>GetStdHandle获取标准句柄(标准输入句柄、标准输出句柄、标准错误句柄)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WriteConsole(标准输出句柄，pszText,wcslen(pszText),<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>下面的使用案例</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> width = LOWORD(lParam);</span><br><span class="line"><span class="keyword">short</span> height = HIWORD(lParam);</span><br><span class="line"><span class="keyword">char</span> szText[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">sprintf_s(szText, <span class="string">&quot;WM_SIZE:宽度%d，高度：%d\n&quot;</span>, width, height);</span><br><span class="line">WriteConsole(g_HOUTPUT, szText, <span class="built_in">strlen</span>(szText), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>



<hr>
<p>创建项目时候为什么要改成多字节字符集?</p>
<p>如果项目的属性选择是UNICODE字符集，编译器会自动给你增加一个UNICODE的宏定义。反之，则不会。</p>
<hr>
<p><strong>系统调用函数的参数类型</strong>：</p>
<p>(对已有的类型进行重命名)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LPSTR =&gt; <span class="keyword">char</span>*</span><br><span class="line">LPSTR =&gt; <span class="keyword">const</span> <span class="keyword">char</span>*</span><br><span class="line">LPWSTR =&gt; <span class="keyword">wchar_t</span>*</span><br><span class="line">LPCWSTR =&gt; <span class="keyword">const</span> <span class="keyword">wchar_t</span>*</span><br><span class="line">   </span><br><span class="line">用的多的是这两个</span><br><span class="line">LPTSTR =&gt; TCHAR </span><br><span class="line">LPCTSTR =&gt; <span class="keyword">const</span> TCHAR*</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="注册窗口类"><a href="#注册窗口类" class="headerlink" title="注册窗口类"></a>注册窗口类</h2><p><strong>窗口类的概念</strong></p>
<ul>
<li>窗口类是包含了窗口的各种参数信息的数据结构。 </li>
<li>每个窗口都具有窗口类，基于窗口类创建窗口。</li>
<li>每个窗口类都具有一个名称，使用前必须注册到系统。</li>
</ul>
<p><strong>在操作系统内核里存着就叫窗口类，在程序里存着就叫窗口类。</strong></p>
<hr>
<p><strong>窗口类的分类</strong>：</p>
<ul>
<li>系统窗口类<ul>
<li>系统已经定义好的窗口类，<strong>所有</strong>应用程序都可以直接使用。</li>
<li>不需要注册，直接使用窗口类即可。系统已经注册好了。</li>
<li>例如:按钮-BUTTON,编辑框-EDIT</li>
</ul>
</li>
<li>应用程序全局窗口类<ul>
<li>由用户自己定义，当前应用程序所有模块都可以使用。</li>
</ul>
</li>
<li>应用程序局部窗口类<ul>
<li>由用户自己定义，当前应用程序中本模块可以直接使用。</li>
</ul>
</li>
</ul>
<p><strong>全局及局部窗口类</strong> ：</p>
<p>注册窗口类的函数</p>
<p>(ATOM——unsigned short)</p>
<p>ATOM RegisterClass(</p>
<p>​    CONST WNDCLASS *lpWndClass//窗口类的数据);</p>
<p>//注册成功后 ，返回一个数字标识。(0失败，非0成功。)</p>
<p><img src="/images/win32(1).assets/image-20211030091746959.png" alt="image-20211030091746959"></p>
<hr>
<p><strong>style窗口类风格</strong></p>
<p>应用程序全局窗口类的注册，需要在窗口类的风格中添加CS_GLOBALCLASS。</p>
<p>应用程序局部类窗口类注册，无需添加如上风格。</p>
<p><strong>不建议使用全局窗口类</strong>——因为局部窗口类能完成全局窗口类的功能，并且全局窗口类可能会产生冗余。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CS_HREDRAW ——当窗口水平变化时，窗口重新绘制</span><br><span class="line">CS_VREDRAW ——当窗口垂直变化时，窗口重新绘制</span><br><span class="line">CS_DBLCLKS ——允许窗口接收鼠标双击</span><br><span class="line">CS_NOCLOSE ——窗口没有关闭按钮</span><br></pre></td></tr></table></figure>

<h2 id="窗口创建"><a href="#窗口创建" class="headerlink" title="窗口创建"></a>窗口创建</h2><p><strong>窗口创建</strong>：</p>
<p>CreateWindow / CreateWindowEx</p>
<p><img src="/images/win32(1).assets/image-20211030092735421.png" alt="image-20211030092735421"></p>
<p><strong>CreateWindow内部是如何实现的</strong></p>
<ul>
<li>系统(CreateWindows函数内部)根据传入的窗口类名称，在应用程序局部窗口类中查找，如果找到执行2 ，没找到执行3。</li>
<li>比较局部窗口与创建窗口时传入的HINSTANCE变量。如果有发现相等。创建和注册类在同一模块，创建窗口返回。如果不相等，继续执行3。</li>
<li>在应用程序全局窗口类，如果找到，执行4， 没找到执行5。</li>
<li>使用找到的窗口类信息，创建窗口返回。</li>
<li>在系统窗口类中查找，如果找到创建窗口返回，否则创建窗口失败。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//窗口处理函数（自定义、处理消息）</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hWnd, UINT msgID, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (msgID)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">		PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> DefWindowProc(hWnd, msgID, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入口函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> CALLBACK <span class="title">WinMain</span><span class="params">(HINSTANCE hIns, HINSTANCE hPerIns, LPSTR lpCmdLine, <span class="keyword">int</span> nCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//注册窗口类</span></span><br><span class="line">	WNDCLASS wc = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="comment">//申请两种不用的缓冲区</span></span><br><span class="line">	wc.cbClsExtra = <span class="number">0</span>;</span><br><span class="line">	wc.cbWndExtra = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + <span class="number">1</span>);</span><br><span class="line">	wc.hCursor = <span class="literal">NULL</span>;</span><br><span class="line">	wc.hIcon = <span class="literal">NULL</span>;</span><br><span class="line">	wc.hInstance = hIns;</span><br><span class="line">	wc.lpfnWndProc = WndProc;</span><br><span class="line">	wc.lpszClassName = <span class="string">&quot;myWindow&quot;</span>;</span><br><span class="line">	wc.lpszMenuName = <span class="literal">NULL</span>;</span><br><span class="line">	wc.style = CS_HREDRAW | CS_VREDRAW;</span><br><span class="line">	<span class="comment">//将上面赋的这些值全部写入操作系统</span></span><br><span class="line">	RegisterClass(&amp;wc);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//在内存中创建窗口</span></span><br><span class="line">	HWND hWnd = CreateWindow(<span class="string">&quot;myWindow&quot;</span>, <span class="string">&quot;menu&quot;</span>, WS_OVERLAPPEDWINDOW, <span class="number">100</span>, <span class="number">100</span>, <span class="number">500</span>, <span class="number">500</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, hIns, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//显示窗口</span></span><br><span class="line">	ShowWindow(hWnd, SW_SHOW);</span><br><span class="line">	<span class="comment">//再画一遍(刷新窗口)</span></span><br><span class="line">	UpdateWindow(hWnd);</span><br><span class="line">	<span class="comment">//消息循环</span></span><br><span class="line">	MSG nMsg = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">while</span> (GetMessage(&amp;nMsg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		TranslateMessage(&amp;nMsg);</span><br><span class="line">		DispatchMessage(&amp;nMsg);<span class="comment">//将消息交给窗口处理函数来处理</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>子窗口创建过程</strong></p>
<ul>
<li>创建时要设置父窗口句柄</li>
<li>创建风格要增加WS_CHILD | WS_VISBLE</li>
</ul>
<p>(<strong>根据注册的窗口类，来创建多个窗口。</strong>)</p>
<p>(个人理解发现：注册的窗口可以复用(覆盖创建一个新的))。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HWND hChild1 = CreateWindowEx(<span class="number">0</span>, <span class="string">&quot;Child&quot;</span>, <span class="string">&quot;C1&quot;</span>, WS_CHILD | WS_VISIBLE | WS_OVERLAPPEDWINDOW, <span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>, hWnd, <span class="literal">NULL</span>, hIns, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">HWND hChild2 = CreateWindowEx(<span class="number">0</span>, <span class="string">&quot;Child&quot;</span>, <span class="string">&quot;C2&quot;</span>, WS_CHILD | WS_VISIBLE | WS_OVERLAPPEDWINDOW, <span class="number">200</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>, hWnd, <span class="literal">NULL</span>, hIns, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<h2 id="消息基础"><a href="#消息基础" class="headerlink" title="消息基础"></a>消息基础</h2><h3 id="消息的概念和作用"><a href="#消息的概念和作用" class="headerlink" title="消息的概念和作用"></a>消息的概念和作用</h3><ul>
<li>消息组成(windows平台下)<ul>
<li>窗口句柄</li>
<li>消息ID</li>
<li>消息的两个参数(两个附带信息)</li>
<li>消息产生的时间</li>
<li>消息产生时的鼠标位置</li>
</ul>
</li>
<li>消息的作用<ul>
<li>当系统通知窗口工作时，就采用消息的方式(DispatchMessage)派发给(<strong>调用</strong>)窗口的<strong>窗口处理函数</strong>(将MSG的前四个信息传递给消息处理函数)。</li>
<li><strong>每一个窗口都有窗口处理函数</strong></li>
</ul>
</li>
</ul>
<p><strong>MSG结构体接收消息</strong></p>
<p>结构体定义如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对应解释同上消息组成</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagMSG</span> &#123;</span></span><br><span class="line">    HWND        hwnd;</span><br><span class="line">    UINT        message;</span><br><span class="line">    WPARAM      wParam;</span><br><span class="line">    LPARAM      lParam;</span><br><span class="line">    DWORD       time;</span><br><span class="line">    POINT       pt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _MAC</span></span><br><span class="line">    DWORD       lPrivate;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; MSG, *PMSG, NEAR *NPMSG, FAR *LPMSG;</span><br></pre></td></tr></table></figure>

<p><strong>DispatchMessage如何找到窗口处理函数</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nMsg.hwnd-&gt;保存窗口数据的内存-&gt;找到对应的窗口处理函数-&gt;WndProc</span><br><span class="line">    </span><br><span class="line">回到你自己定义的消息处理函数-&gt;传递参数-&gt;处理消息</span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hWnd, UINT msgID, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line">    传递这四个参数，不用关系后两个</span><br></pre></td></tr></table></figure>

<h3 id="窗口处理函数"><a href="#窗口处理函数" class="headerlink" title="窗口处理函数"></a>窗口处理函数</h3><p><strong>每个窗口都必需有窗口处理函数，只要基于窗口类创建窗口，就肯定要有个窗口处理函数。</strong></p>
<p><strong>窗口处理依照如下结构定义</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProc</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	HWND hWnd;<span class="comment">//窗口句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">	UINT uMsg;<span class="comment">//消息ID</span></span></span></span><br><span class="line"><span class="function"><span class="params">	WPARAM wParam;<span class="comment">//消息参数</span></span></span></span><br><span class="line"><span class="function"><span class="params">	LPARAM lParam;<span class="comment">//消息参数</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>当系统通知窗口时，(<strong>DispatchMessage</strong>)会调用窗口处理函数，同时将消息ID和消息参数传递给窗口处理函数。</p>
<p>在窗口处理函数中，<strong>不处理的消息</strong>，<strong>使用缺省窗口处理函数</strong>。</p>
<p>例如:**DefWindowProc(可以给各种消息做默认处理)**。</p>
<hr>
<h3 id="消息循环中的相关函数-浅谈"><a href="#消息循环中的相关函数-浅谈" class="headerlink" title="消息循环中的相关函数(浅谈)"></a>消息循环中的相关函数(浅谈)</h3><p><strong>GetMessage-到系统的某个地方抓本进程的消息</strong></p>
<p>函数原型如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">GetMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	LPMSG lpMsg,<span class="comment">//存放获取到消息的BUFF，</span></span></span></span><br><span class="line"><span class="function"><span class="params">    HWND hWndp;<span class="comment">//窗口句柄，要是定为NULL，将会抓取本进程中所有窗口中的消息</span></span></span></span><br><span class="line"><span class="function"><span class="params">    UNIT wMsgFilterMin,<span class="comment">//获取的最小ID</span></span></span></span><br><span class="line"><span class="function"><span class="params">    UNIT wMsgFilterMax<span class="comment">//获取消息的最大ID</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">//最后两个参数都为0，就是不管ID有多大，只要是本进程的消息都抓过来</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>其中后三个参数可以限制抓取消息的范围</strong>，如果设置为NULL,0,0那其实就是没有进行限制，只要是本进程的消息我都把它抓过来。</p>
<p><strong>GetMessage的返回值</strong></p>
<p>消息WM_QUIT会使GetMessage返回0，从而中终止消息接收。</p>
<p>PostQuitMessage(0);会在进程中扔出WM_QUIT这个消息，get后从而使得消息循环终止。</p>
<hr>
<p><strong>TranslateMessage-翻译消息</strong>——它可不是什么消息都翻译。</p>
<p><strong>将按键(可见字符按键，a~z)消息翻译成字符消息。</strong></p>
<p>所以进入到它的内部， 它所做的第一件事就是检查这个消息是否合法，是否是它要翻译的消息类型。 </p>
<p><strong>如果不是按键类型消息</strong>，不做任何处理，继续执行。</p>
<p>函数原型如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOL TranslateMessage</span><br><span class="line">&#123;</span><br><span class="line">    CONST  MSG* lpMsg;<span class="comment">//要翻译的消息地址	</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>DispatchMessage-派发消息(调用对应窗口的消息处理函数)</strong></p>
<p>函数原型如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT <span class="title">DispatchMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	CONST MSG* lpmsg<span class="comment">//要派发的消息</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="常见消息"><a href="#常见消息" class="headerlink" title="常见消息"></a>常见消息</h2><p><strong>如何学习一个消息</strong></p>
<p>1.掌握这个消息的<strong>产生时间</strong>。</p>
<ol start="2">
<li>分析每个消息附带的<strong>两个信息</strong>。</li>
<li> 这个消息可以用来干什么(<strong>一般用法</strong>)。 </li>
</ol>
<h3 id="WM-DESTORY"><a href="#WM-DESTORY" class="headerlink" title="WM_DESTORY"></a>WM_DESTORY</h3><ul>
<li>产生时间:窗口被销毁时产生</li>
<li>附带信息:wParam:为0，lParam:为0</li>
<li>一般用法:常用于在窗口被销毁前，做相应的善后处理，例如资源、内存等(<strong>该回收回收，该释放释放。</strong>)。</li>
</ul>
<h3 id="WM-SYSCOMMAND"><a href="#WM-SYSCOMMAND" class="headerlink" title="WM_SYSCOMMAND"></a>WM_SYSCOMMAND</h3><ul>
<li>产生时间：当点击窗口最大化，最小化，关闭等。</li>
<li>附带信息:<ul>
<li>wParam:具体点击的位置，例如关闭SC_CLOSE等，</li>
<li>lParam:鼠标光标的位置(<strong>这个不重要，我们只需要知道点没点就行，具体在哪个位置其实无所谓(具体情况具体使用)</strong>)，LOWORD(lParam);水平位置，HIWORD(lParam)；垂直位置。(<strong>高两字节传纵坐标，低两字节传横坐标。</strong>)</li>
</ul>
</li>
<li>一般用法:常用在窗口关闭时，提示用户处理。</li>
</ul>
<hr>
<h3 id="WM-CREATE"><a href="#WM-CREATE" class="headerlink" title="WM_CREATE"></a>WM_CREATE</h3><ul>
<li>产生时间:在窗口创建成功但还没显示时。</li>
<li>附带信息:<ul>
<li>wParam:为0</li>
<li>lParam:为CREATESTRUCT类型的指针(<strong>强转成这个类型再用</strong>)，通过这个指针可以获取CreatWindowEx中全部12个参数的信息。</li>
</ul>
</li>
<li>一般用法：常用于初始化窗口函数、资源等等，包括创建子窗口等。</li>
</ul>
<hr>
<h3 id="WM-SIZE"><a href="#WM-SIZE" class="headerlink" title="WM_SIZE"></a>WM_SIZE</h3><ul>
<li>产生时间:在窗口的大小发生变化后。</li>
<li>附带信息:<ul>
<li>wParam:窗口大小变化的原因。</li>
<li>lParam:窗口变化后的大小<ul>
<li>LOWORD(lParam)变化后的宽度</li>
<li>HIWORD(lParam)变化后的高度</li>
</ul>
</li>
</ul>
</li>
<li>一般用法:常用于窗口大小发生变化后，调整窗口内各个部分的布局。</li>
</ul>
<hr>
<h3 id="WM-QUIT"><a href="#WM-QUIT" class="headerlink" title="WM_QUIT"></a>WM_QUIT</h3><ul>
<li>产生时间:程序员发送。</li>
<li>附带信息:<ul>
<li>wPram:PostQuitmessage函数传递的参数。</li>
<li>lParam：0。</li>
</ul>
</li>
<li>一般用法:用于结束消息循环，当GetMessage收到这个消息后，会返回FALSE,结束while处理，退出消息循环。</li>
</ul>
<p><strong>这个消息不用我们去处理</strong>,进不去我们定义的窗口处理函数,GetMessage()返回了0，无法进入循环获取消息。</p>
<hr>
<h3 id="WM-PAINT"><a href="#WM-PAINT" class="headerlink" title="WM_PAINT"></a>WM_PAINT</h3><ul>
<li>产生时间:当窗口需要绘制的时候 or( GetMessage没消息可抓的时候，详情请看下面。)</li>
<li>附带信息:(没用)<ul>
<li>wParam: 0</li>
<li>lParam:0</li>
</ul>
</li>
<li>专职用法:就是用于绘图。</li>
</ul>
<p>第一个WM_PAINT是系统发送的，当第一次创建窗口。</p>
<p>也就是说产生WM_SIZE消息的同时肯定回产生WM_PAINT消息，重新绘制。</p>
<p><strong>相关函数</strong></p>
<ul>
<li>窗口无效区域:需要重新绘制的区域。</li>
<li>调用这个函数，让窗口需要重新绘制，<strong>GetMessAge</strong>会发送WM_PAINT消息，<strong>注意，是谁发送消息</strong>。  (就可以理解说这个函数告诉GetMessage说，这个窗口需要绘制了，GetMessage发送消息到消息队列，然后转发到对应进程的消息队列中，开始执行。)</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">InvalidateRect</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] HWND       hWnd,<span class="comment">//窗口句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">const</span> RECT *lpRect,<span class="comment">//区域的矩形坐标，对窗口的哪一部分进行重新绘制</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] BOOL       bErase<span class="comment">//重绘前是否先擦除</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="调试技巧"><a href="#调试技巧" class="headerlink" title="调试技巧"></a>调试技巧</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">设置一个全局变量</span><br><span class="line">    HANDLE g_HOUTPUT = <span class="number">0</span>;<span class="comment">//接收标准输出句柄</span></span><br><span class="line">增加一个dos窗口</span><br><span class="line">	AllocConsole();</span><br><span class="line">	g_HOUTPUT = GetStdHandle(STD_OUTPUT_HANDLE);</span><br></pre></td></tr></table></figure>

<p>  <strong>dos窗口只能接收字符串类型</strong></p>
<p><strong>sprintf转，writeconsole打印</strong></p>
<hr>
<h2 id="消息循环的原理"><a href="#消息循环的原理" class="headerlink" title="消息循环的原理"></a>消息循环的原理</h2><h3 id="消息循环的阻塞"><a href="#消息循环的阻塞" class="headerlink" title="消息循环的阻塞"></a>消息循环的阻塞</h3><ul>
<li>GetMessage-从系统获取消息，将消息从系统中移除，阻塞函数。当系统无消息时，会等候下一条消息。</li>
</ul>
<blockquote>
<p>对人来说消息是一直存在的，但是对于CPU来说(速度接近光速)，消息不是经常有的，所以会经常发生阻塞。这样程序的效率就不高，从而引出下面这个函数。</p>
</blockquote>
<ul>
<li>PeekMessage-以查看的方式从系统中获取消息，可以不将消息从系统出移除，非阻塞函数。当系统无消息时，返回FALSE,继续执行后续代码。</li>
</ul>
<p><strong>函数原型如下:</strong></p>
<p>(前四个参数同GetMessage)</p>
<p>最后一个参数是，是否赋予它抓取消息的能力，一般是不给它的，也就是填写</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">PeekMessageA</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [out]          LPMSG lpMsg,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional] HWND  hWnd,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]           UINT  wMsgFilterMin,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]           UINT  wMsgFilterMax,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]           UINT  wRemoveMsg</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>也就是说</strong>，更好的流程是，先派PeekMessage去侦查是否有消息，有就告诉GetMessage让它来处 理。没有就不要派Get去了，因为它会一直在那里等着消息的出现。</p>
<p><strong>例如</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (PeekMessage(&amp;nMsg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, PM_NOREMOVE))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//有消息-判断是否是WM_QUIT</span></span><br><span class="line">			<span class="keyword">if</span> (GetMessage(&amp;nMsg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">			&#123;</span><br><span class="line">				TranslateMessage(&amp;nMsg);</span><br><span class="line">				DispatchMessage(&amp;nMsg);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//没有消息——空闲处理</span></span><br><span class="line">			WriteConsole(g_HOUTPUT, <span class="string">&quot;空闲ing\n&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;空闲ing&quot;</span>), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><p><strong>Windows平台上的消息，都是它们两个造出来的。</strong></p>
<ul>
<li>SendMessage-发送消息，会等候消息处理的结果。</li>
<li>PostMessage-投递消息，消息发出后立刻返回，不等候消息执行结果。</li>
</ul>
<p><strong>函数原型如下</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT <span class="title">SendMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] HWND   hWnd,<span class="comment">//消息发送的目的创建</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] UINT   Msg,<span class="comment">//消息ID</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] WPARAM wParam,<span class="comment">//消息参数</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] LPARAM lParam<span class="comment">//消息参数</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这四个参数就是一个消息的前四个参数，剩下的两个参数函数内部以某种手段自加来获取。 </p>
<p>（<strong>其中，</strong>sendmessage的消息扔到哪去，我们不知道，在之后的课程中会补充。postmessage的消息会扔到getmessage能接收到的区域）</p>
<h3 id="消息分类"><a href="#消息分类" class="headerlink" title="消息分类"></a>消息分类</h3><ul>
<li>系统消息-ID范围0~0x03FF<ul>
<li>由系统定义好的消息，可以在程序中直接使用。</li>
<li>程序员只负责一头，要么发送不用处理，要么处理不用发送。</li>
</ul>
</li>
<li>用户自定义的消息-ID范围0x0400(WM_USER) -  0x7FFF(31743)<ul>
<li>由用户自己定义，满足用户自己的需求。由用户自己发出消息，并响应处理。</li>
<li>由程序员，自己定制，自己发送，自己处理。</li>
<li>自定义消息宏：WM_USER(叫什么都行)</li>
</ul>
</li>
</ul>
<p><strong>例如</strong>:</p>
<p>定义消息名称</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WM_MYMESSAGE WM_USER+1001</span></span><br></pre></td></tr></table></figure>

<p>发送,在哪发都可以,附加消息，你自己的，附加什么都行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PostMessage/SendMessage(hWnd, WM_MYMESSAGE, <span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><h3 id="消息队列的概念"><a href="#消息队列的概念" class="headerlink" title="消息队列的概念"></a>消息队列的概念</h3><ul>
<li>消息队列是用于存放消息的队列。</li>
<li>消息在队列中先进先出。</li>
<li>所有窗口都具有消息队列。</li>
<li>程序(<strong>GetMessage()</strong>)可以从队列中获取消息。</li>
</ul>
<hr>
<h3 id="消息队列的分类"><a href="#消息队列的分类" class="headerlink" title="消息队列的分类"></a>消息队列的分类</h3><ul>
<li>系统消息队列——由系统维护的消息队列。存放系统产生的消息，例如鼠标、键盘等。</li>
<li>程序消息队列——属于每个应用程序的(线程)的消息队列。由应用程序(线程)维护。</li>
</ul>
<blockquote>
<p>每个进程都有一个消息队列，都有GetMessage(),在本进程的消息队列中抓取消息。</p>
<p>细节解释:<br>所有进程产生的消息都先进系统消息队列，操作系统会每个一段时间，将消息转发到各个进程中去。所以才能在本进程中抓到本进程的消息。</p>
<p>如何做到正确转发:<br>消息的第一个参数是窗口句柄，保存窗口数据的内存，通过它可以找到当前程序实例句柄，找到本进程对应内存，从而正确转发。</p>
</blockquote>
<p>SendMessage既没有扔到系统消息队列里，也没有扔到进程消息队列中。</p>
<hr>
<h3 id="消息和消息队列的关系"><a href="#消息和消息队列的关系" class="headerlink" title="消息和消息队列的关系"></a>消息和消息队列的关系</h3><ul>
<li><p>消息和消息队列的关系</p>
<ul>
<li>当鼠标、键盘产生消息时，会将消息存放到消息队列中。</li>
<li>系统会根据存放的消息，找到对应程序的消息队列。</li>
<li>将消息投递到程序的消息队列中</li>
</ul>
</li>
<li><p>根据消息和消息队列之间使用关系，将消息分成两类</p>
<ul>
<li>队列消息-消息的发送和获取，都是通过消息队列完成。<ul>
<li>消息发送后，首先放入队列，然后通过消息循环，从队列中获取。</li>
<li>GetMessage-从消息队列中获取消息</li>
<li>PostMessage-将消息投递到消息队列</li>
<li>常见的消息队列:WM_PAINT、键盘、鼠标、定时器</li>
</ul>
</li>
<li>非队列消息-消息的发送和获取，是直接调用消息的窗口处理函数完成。 <ul>
<li>消息发送时，首先找到消息接收窗口的窗口处理函数，直接调用处理函数，完成消息。<ul>
<li>SendMessage-<strong>直接将消息发送窗口的处理函数，并等待处理结果</strong>。</li>
<li>常见消息:WM_CREATE(它是必须不能进队列的，否则就没办法把它抓出来了)、WM_SIZE等。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="GetMessage"><a href="#GetMessage" class="headerlink" title="GetMessage"></a>GetMessage</h3><ul>
<li>在程序(线程)消息队列查找消息，如果队列有消息，**检查消息是否满足指定条件(HWND,ID范围)**，不满足条件就不会取出消息，否则从队列取出消息返回。</li>
<li>如果程序(线程)消息队列没有消息，会向系统消息队列获取(<strong>找系统要，发起请求</strong>)属于班本程序的消息(<strong>之前说系统会定时分发属于对应进程的消息，如果这个时间没到，但是有的进程没消息了，会打破这个时间，提前分发。</strong>)。如果系统队列的当前消息属于本程序，系统会将消息转发到程序消息队列中。</li>
<li><strong>如果系统消息也没有消息(那也不闲着)<strong>，检查当前进程的所有窗口需要重新绘制的区域，如果发现有需要绘制的区域，</strong>产生WM_PAINT消息扔到系统的消息队列</strong>，取得消息返回处理。</li>
<li><strong>如果没有重新绘制区域</strong>，检查定时器，如果有到时的定时器，产生WM_TIMER，返回处理执行。</li>
<li>如果没有到时的定时器，整理程序的资源、内存等等。</li>
<li>GetMessage会继续等候下一条消息。PeekMessage会返回FASLE,交出程序的控制权。</li>
<li>注意:GetMessage如果获取到的是WM_QUIT，函数会返回FALSE。</li>
</ul>
<p><strong>总结</strong>：总结起来就是，GetMessage非常的死心眼，没消息就找系统要，要不来就自己造，造不来就整理下资源(干点打扫卫生的活儿)，还没有消息来，那就阻塞，等待消息的传来，<strong>但是依然不返回</strong>。</p>
<p>阻塞了，就说明GetMessage已经尽力了。</p>
<p>PeekMessage也会干上面的事儿，<strong>但是它最后不会傻等</strong>。</p>
<h2 id="键盘消息"><a href="#键盘消息" class="headerlink" title="键盘消息"></a>键盘消息</h2><h3 id="键盘消息分类"><a href="#键盘消息分类" class="headerlink" title="键盘消息分类"></a>键盘消息分类</h3><ul>
<li>WM_KEYDOWN-按键被按下时产生</li>
<li>WM_KEYUP-按键被放开时产生</li>
<li>WM_SYSKEYDOWN-系统键按下时产生，比如ALT、F10</li>
<li>WM_SYSKEYUP-系统键放开时产生</li>
</ul>
<p>附带信息:<br>.WPARAM-按键的Virtual Key(每个这个对应一个按键-这个虚拟键码值无法区分大小写，所以我们才需要去翻译消息)</p>
<p>LPARAM-按键的参数，例如按下的次数 </p>
<h3 id="字符消息-WM-CHAR"><a href="#字符消息-WM-CHAR" class="headerlink" title="字符消息(WM_CHAR)"></a>字符消息(WM_CHAR)</h3><ul>
<li>TranslateMessage在转换WM_KEYDOWN消息时，对于可见字符可以产生WM_CHAR,不可见字符无此消息。</li>
<li>附带信息:<ul>
<li>WMPARAM-<strong>输入的字符的ASCII字符编码值</strong></li>
<li>LPARAM-按键的相关参数</li>
</ul>
</li>
</ul>
<p>翻译消息的内部大致流程，如下图所示:</p>
<p><img src="/images/win32(1).assets/image-20211031160052913.png" alt="image-20211031160052913"></p>
<p><strong>文字解释</strong>:</p>
<p>先检查是否有按键被按下， 没有直接return,有则判断是否是可见字符消息（<strong>刚才的按键消息再一次被GET过来时，已经变成了字符消息</strong>，不是按键消息，在这部就直接return了），不是直接return,都通过了，那就判断大写键是否打开，根据大小写发出相应的消息。    </p>
<h2 id="鼠标消息"><a href="#鼠标消息" class="headerlink" title="鼠标消息"></a>鼠标消息</h2><h3 id="鼠标消息的分类"><a href="#鼠标消息的分类" class="headerlink" title="鼠标消息的分类"></a>鼠标消息的分类</h3><ul>
<li>基本鼠标消息<ul>
<li>WM_LBUTTONDOWN-鼠标左键按下</li>
<li>WM_LBUTTONUP-鼠标左键抬起</li>
<li>WM_RBUTTONDOWN-鼠标右键按下</li>
<li>WM_RBUTTONUO-鼠标右键抬起</li>
<li>WM_MOUSEMOVE-鼠标移动消息</li>
</ul>
</li>
<li>双击消息<ul>
<li>WM_ LBUTTONDBLCLK-鼠标左键双击</li>
<li>WM_RBUTTONDBLCLK-鼠标右键双击</li>
</ul>
</li>
<li>滚轮消息<ul>
<li>WM_MOUSEWHEEL-鼠标滚轮消息</li>
</ul>
</li>
</ul>
<h3 id="鼠标基本消息"><a href="#鼠标基本消息" class="headerlink" title="鼠标基本消息"></a>鼠标基本消息</h3><ul>
<li>附带信息<ul>
<li>WPARAM:其他按键的状态，例如Ctrl/Shift等。<ul>
<li>LPARAM:鼠标的位置，窗口客户区坐标系。<ul>
<li>LOWWORD X坐标位置</li>
<li>HIWORD Y坐标位置</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>一般情况鼠标按下/抬起成对出现。在鼠标移动过程中，会根据移动速度产生一系列的WM_ MOUSEMOVE消息。</li>
</ul>
<h3 id="鼠标双击消息"><a href="#鼠标双击消息" class="headerlink" title="鼠标双击消息"></a>鼠标双击消息</h3><ul>
<li>附带消息:<ul>
<li>WPARAM-其它按键的状态，例如CTRL/SHIFT。</li>
<li>LPARAM-鼠标的位置，窗口客户区坐标系。<ul>
<li>LOWORD(lParam)-X坐标位置</li>
<li>HIWORD(lParam)-Y坐标位置</li>
</ul>
</li>
</ul>
</li>
<li>消息产生顺序<ul>
<li>一左键双击为例:<ul>
<li>WM_LBUTTONDOWN</li>
<li>WM_LBUTTONUP</li>
<li>WM_LBUTTONDBLCLK</li>
<li>WM_LBUTTONU</li>
<li>使用时需要在注册窗口类的时候添加CS_DBLCLKS风格。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="鼠标滚轮消息"><a href="#鼠标滚轮消息" class="headerlink" title="鼠标滚轮消息"></a>鼠标滚轮消息</h3><ul>
<li>附带消息<ul>
<li>WPARAM<ul>
<li>LOWORD-其他按键的状态</li>
<li>HIWORD-滚轮的偏移量(120的倍数 )，通过正负值表示滚轮的方向</li>
<li>正-向前滚动，负-向后滚动</li>
</ul>
</li>
<li>LPARAM:鼠标当前的位置，屏幕坐标系<ul>
<li>LOWORD-X坐标</li>
<li>HIWORD-Y坐标</li>
</ul>
</li>
</ul>
</li>
<li>使用:通过偏移量，获取滚轮的方向和距离</li>
</ul>
<h2 id="定时器消息"><a href="#定时器消息" class="headerlink" title="定时器消息"></a>定时器消息</h2><h3 id="定时器消息介绍"><a href="#定时器消息介绍" class="headerlink" title="定时器消息介绍"></a>定时器消息介绍</h3><ul>
<li>产生时间:<br>在程序中创建定时器，当到达时间间隔时，定时器会向程序发送一个WM_TIMER消息。定时器的精度是毫秒，但是准确度很低。例如时间间隔为1000ms，但是会在非1000毫秒到达消息。</li>
<li>附带信息:<ul>
<li>WPARAM:<strong>定时器ID(到时间的)</strong></li>
<li>LPARAM:定时器处理函数的指针</li>
</ul>
</li>
</ul>
<p>GetMessage肯定有没事干的时候，所以WM_TIMER消息肯定会产生。</p>
<p>按照一定周期去执行，时间要求不严格，都可以用这个定时器。</p>
<h3 id="创建销毁定时器"><a href="#创建销毁定时器" class="headerlink" title="创建销毁定时器"></a>创建销毁定时器</h3><ul>
<li>创建定时器</li>
</ul>
<p>函数原型如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UINT_PTR <span class="title">SetTimer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional] HWND      hWnd,<span class="comment">//定时器窗口句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in]           UINT_PTR  nIDEvent,<span class="comment">//定时器ID	</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in]           UINT      uElapse,<span class="comment">//时间间隔(毫秒为单位)</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional] TIMERPROC lpTimerFunc；<span class="comment">//定时器处理函数指针(一般不使用，为NULL)创建成功，返回非0。</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>关闭定时器</li>
</ul>
<p>函数原型如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">KillTimer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional] HWND     hWnd,<span class="comment">//窗口句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in]           UINT_PTR uIDEvent<span class="comment">//定时器ID</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="菜单资源"><a href="#菜单资源" class="headerlink" title="菜单资源"></a>菜单资源</h2><h3 id="菜单分类"><a href="#菜单分类" class="headerlink" title="菜单分类"></a>菜单分类</h3><ul>
<li>窗口的顶层菜单(不需要也不能设置ID,因为它的唯一作用的就是弹出下拉次菜单)</li>
<li>弹出式菜单</li>
<li>系统菜单</li>
</ul>
<p>HMENU(<strong>菜单句柄</strong>)类型表示菜单，ID表示菜单项。</p>
<h3 id="资源相关"><a href="#资源相关" class="headerlink" title="资源相关"></a>资源相关</h3><ul>
<li>资源脚本文件:.rc文件</li>
<li>编译器:RC.EXE</li>
</ul>
<h3 id="菜单资源的使用"><a href="#菜单资源的使用" class="headerlink" title="菜单资源的使用"></a>菜单资源的使用</h3><ul>
<li>添加菜单资源-添加文件.rc文件</li>
<li>加载菜单资源<ol>
<li>注册窗口类时设置菜单<ol>
<li>(wc.lpszMenuName = (char*)IDR_MENU1;//菜单设置)</li>
</ol>
</li>
<li>创建窗口传参设置菜单<ol>
<li>CreateWindow的导数第三个参数 </li>
</ol>
</li>
<li>在主窗口WM_CREATE消息中利用SetMenu函数设置菜单</li>
</ol>
</li>
</ul>
<p>LoadMenuW函数原型:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HMENU <span class="title">LoadMenuW</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional] HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]           LPCWSTR   lpMenuName</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>SetMenu函数原型:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">SetMenu</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]           HWND  hWnd,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional] HMENU hMenu</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="命令消息-WM-COMMAND-处理"><a href="#命令消息-WM-COMMAND-处理" class="headerlink" title="命令消息(WM_COMMAND)处理"></a>命令消息(WM_COMMAND)处理</h3><ul>
<li>附带消息:<ul>
<li>WPARAM：<ul>
<li>HIWORD-对于菜单为0(没用)</li>
<li>LOWRD-<strong>被鼠标点击的</strong>菜单项的ID</li>
</ul>
</li>
<li>LPARAM<ul>
<li>对于菜单项为0(没用)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Windows资源"><a href="#Windows资源" class="headerlink" title="Windows资源"></a>Windows资源</h2><h3 id="图标资源"><a href="#图标资源" class="headerlink" title="图标资源"></a>图标资源</h3><p><strong>指的就是.ico为后缀的图片</strong></p>
<ul>
<li>添加资源<ul>
<li>注意图标的大小， 一个图标文件中，可以有多个不同大小的图标。</li>
</ul>
</li>
<li>加载</li>
</ul>
<p>函数原型如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">到本进程的内存中找图标的数据同loadMenu</span><br><span class="line"><span class="function">HICON <span class="title">LoadIconA</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional] HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]           LPCSTR    lpIconName</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;<span class="comment">//成功返回HICON句柄</span></span><br><span class="line"></span><br><span class="line">例：使用</span><br><span class="line">wc.hIcon = LoadIcon(hIns,(<span class="keyword">char</span>*)IDI_ICON1);</span><br></pre></td></tr></table></figure>

<ul>
<li>设置<ul>
<li>注册窗口类</li>
</ul>
</li>
</ul>
<h3 id="光标资源"><a href="#光标资源" class="headerlink" title="光标资源"></a>光标资源</h3><ul>
<li>添加光标的资源<ul>
<li>光标的大小默认是32X32像素，每个光标有HotSpot,是当前鼠标的热点(点击图标生效的那个点)。</li>
</ul>
</li>
<li>加载资源</li>
</ul>
<p>函数原型如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HCURSOR <span class="title">LoadCursorW</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional] HINSTANCE hInstance,<span class="comment">//可以为NULL，获取系统默认的Cursor</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in]           LPCWSTR   lpCursorName</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>设置资源</p>
<ul>
<li>在注册窗口时，设置光标。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc.hCursor = LoadCursor(hIns,(<span class="keyword">char</span>*)IDC_CURSOR1);</span><br></pre></td></tr></table></figure>



<ul>
<li>使用SetCursor设置光标。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HCURSOR <span class="title">SetCursor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	HCURSOR hCursor</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//必须放在处理下面这个消息的时候调用</span></span><br></pre></td></tr></table></figure>

<ul>
<li>WM_SETCURSOR消息参数<ul>
<li>WPARAM-当前使用的光标句柄</li>
<li>LPARAM-LOWORD-当前区域代码(Hit-Test code)HICLIENT/HTCAPTION…</li>
<li>HIWORD-当前鼠标消息ID</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="字符串资源"><a href="#字符串资源" class="headerlink" title="字符串资源"></a>字符串资源</h3><ul>
<li>添加字符串资源<ul>
<li>添加字符串资源，在表中增加字符串。</li>
</ul>
</li>
<li>字符串资源的使用<ul>
<li>函数原型如下</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LoadStringW</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional] HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]           UINT      uID,<span class="comment">//字符串ID</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [out]          LPWSTR    lpBuffer,<span class="comment">//存放字符串 </span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in]           <span class="keyword">int</span>       cchBufferMax</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;<span class="comment">//成功返回字符串长度，失败0</span></span><br></pre></td></tr></table></figure>

<p>使用:例如实现中英文两版的软件。使用这个就非常方便。</p>
<hr>
<p><strong>字符串能写就写在这张字符串表中，容易修改。</strong></p>
<p>用loadstring去读，然后在字符串表中改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> szTitle[<span class="number">256</span>] = &#123; &#125;;</span><br><span class="line">LoadString(hIns, IDS_WIND, szTitle, <span class="number">256</span>);</span><br></pre></td></tr></table></figure>



<p><img src="/images/win32(1).assets/image-20211102190831358.png" alt="image-20211102190831358"></p>
<hr>
<h3 id="加速键资源"><a href="#加速键资源" class="headerlink" title="加速键资源"></a>加速键资源</h3><p>什么ctrl+c,v之类的，就是快捷键呗。</p>
<p>能使用加速键(组合键)的功能，在菜单栏中也对应有一个，一般是绑定使用。</p>
<ul>
<li>添加,资源添加<strong>加速键表</strong>，增加命令ID对应的加速键。</li>
<li>使用:</li>
</ul>
<p>函数原型如下:</p>
<p>加载加速键表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HACCEL <span class="title">LoadAcceleratorsA</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional] HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]           LPCSTR    lpTableName<span class="comment">//加速键表资源ID</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;<span class="comment">//返回加速键表句柄</span></span><br></pre></td></tr></table></figure>

<p>翻译加速键</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TranslateAcceleratorA</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] HWND   hWnd,<span class="comment">//处理消息的句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] HACCEL hAccTable,<span class="comment">//加速键句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] LPMSG  lpMsg<span class="comment">//消息</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;<span class="comment">//如果是加速键，返回非0</span></span><br><span class="line"></span><br><span class="line">位置：一定是放在GetMessage的后面，因为它不抓哪来的消息。</span><br><span class="line">并且放在TranslateMessage的后面，假如我按了ctrl+m，我是想让他区分按的是大M还是小m吗？不是，我为的是实现对应的功能(产生对应的消息WM_COMMAND。)</span><br><span class="line">    </span><br><span class="line">如果按的是加速键，在内部会发送出WM_COMMAND消息。</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<p> <strong>代码示例</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HACCEL hAcc = LoadAccelerators(hIns, (<span class="keyword">char</span>*)IDR_ACCELERATOR1);<span class="comment">//加载加速键表</span></span><br><span class="line"><span class="keyword">while</span> (GetMessage(&amp;nMsg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!TranslateAccelerator(hWnd, hAcc, &amp;nMsg))<span class="comment">//不是加速键</span></span><br><span class="line">	&#123;</span><br><span class="line">		TranslateMessage(&amp;nMsg);</span><br><span class="line">		DispatchMessage(&amp;nMsg);<span class="comment">//将消息交给窗口处理函数来处理</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>注意</strong>：<br>由TranslateAccelerator发出的WM_COMMMAND消息,HIWORD(WPARAM)为1。</p>
<p>而鼠标点击菜单资源的HIWORD(WPARAM)为0。</p>
<p>LOWORD(WPARAM)都代表命令ID。</p>
<p>LPARAM为0。</p>
<hr>
<h2 id="绘图编程"><a href="#绘图编程" class="headerlink" title="绘图编程"></a>绘图编程</h2><h3 id="绘图基础"><a href="#绘图基础" class="headerlink" title="绘图基础"></a>绘图基础</h3><ul>
<li>绘图设备(上下文/描述表)DC(Device Context)绘图上下文/绘图描述表</li>
<li>HDC - DC句柄，表示绘图设备，<strong>绘图设备句柄</strong>。 </li>
<li>GDI-Windows graphics device interface(Win32提供的绘图API)</li>
<li>颜色<ul>
<li>计算机使用红、绿、蓝(RGB)</li>
<li>每个点颜色是3个字节24位保存0~2^24 - 1种颜色</li>
<li>16位：5,5,6</li>
<li>32位：8,8,8,8绘图或透明度</li>
</ul>
</li>
<li>颜色的使用<ul>
<li>COLORREF-实际DWORD<ul>
<li>例如:COLORREF nColor = 0;</li>
</ul>
</li>
<li>赋值使用RGB宏<ul>
<li>例如:nColor = RGB(0,0,255);</li>
</ul>
</li>
<li>获取RGB值<ul>
<li>GetRBValue/GetGValue/GetBValue</li>
<li>例如:BYTE nRed  =GetRValue(nColor);</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="基本图形绘制"><a href="#基本图形绘制" class="headerlink" title="基本图形绘制"></a>基本图形绘制</h3><p><strong>在绘图消息中绘图</strong></p>
<p><strong>绘制点</strong></p>
<ul>
<li>SetPixel设置指定点的颜色</li>
</ul>
<p>函数原型如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">COLORREF <span class="title">SetPixel</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] HDC      hdc,<span class="comment">//绘图设备句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>      x,<span class="comment">//X坐标 </span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>      y,<span class="comment">//Y坐标</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] COLORREF color<span class="comment">//设置的颜色</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;<span class="comment">//返回点原来的颜色</span></span><br></pre></td></tr></table></figure>

<p><strong>例如</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PAINTSTRUCT PS = &#123; &#125;;<span class="comment">//抓到画家</span></span><br><span class="line">HDC hdc = BeginPaint(hwnd, &amp;PS);<span class="comment">//开始绘图	</span></span><br><span class="line">SetPixel(hdc,<span class="number">100</span>,<span class="number">100</span>,RGB(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">EndPaint(hwnd,&amp;PS);<span class="comment">//放掉画家</span></span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li><p>线的使用(直线、弧线)</p>
<ul>
<li><p>MoveToEx-指名窗口当前点(更改窗口当前点) </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">MoveToEx</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]  HDC     hdc,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]  <span class="keyword">int</span>     x,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]  <span class="keyword">int</span>     y,</span></span></span><br><span class="line"><span class="function"><span class="params">  [out] LPPOINT lppt<span class="comment">//为空则不返回上一个点</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>



<ul>
<li>LineTo-从窗口当前点到指定点绘制一条直线(并且致命窗口当前点我)</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">LineTo</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] HDC hdc,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span> x,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span> y</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>



<ul>
<li>当前点：上一次绘图时的最后一点，初始为(0,0)点</li>
</ul>
</li>
</ul>
</li>
<li><p>封闭图形:能够使用画刷填充的图形(反之则不是)。</p>
<ul>
<li>Rectangle/Ellipse——(圆形/矩形)</li>
</ul>
</li>
</ul>
<p><img src="/images/win32(1).assets/image-20211103164837584.png" alt="image-20211103164837584"></p>
<p><img src="/images/win32(1).assets/image-20211103164851493.png" alt="image-20211103164851493"></p>
<p>内切圆，参数相同。</p>
<h2 id="GDI绘图对象"><a href="#GDI绘图对象" class="headerlink" title="GDI绘图对象"></a>GDI绘图对象</h2><h3 id="画笔"><a href="#画笔" class="headerlink" title="画笔"></a>画笔</h3><ul>
<li>画笔的作用<ul>
<li>线的颜色、线型、线粗。</li>
<li>HPAN-画笔句柄</li>
</ul>
</li>
<li>画笔的使用</li>
</ul>
<p>1.创建画笔，函数原型如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HPEN <span class="title">CreatePen</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>      iStyle,<span class="comment">//画笔的样式</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>      cWidth,<span class="comment">//画笔的粗细</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] COLORREF color<span class="comment">//画笔的颜色</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;<span class="comment">//创建成功画笔句柄</span></span><br></pre></td></tr></table></figure>

<p>PS_SOILD-实心线，可以支持多个像素宽，其它线型只能是一个像素宽。</p>
<p>2.将画笔应用到DC中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HGDIOBJ <span class="title">SelectObject</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] HDC     hdc,<span class="comment">//绘图设备句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] HGDIOBJ h<span class="comment">//GDI绘图对象句柄，(包括)兼容画笔句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;<span class="comment">//返回原来的GDI绘图对象句柄</span></span><br></pre></td></tr></table></figure>

<p>3.绘图</p>
<p>4.取出DC中的画笔</p>
<p>将原来的画笔，使用SelectObject函数，放入到设备DC中，就会将我们创建的画笔取出。</p>
<p>5.释放画笔，函数原型如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">DeleteObject</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] HGDIOBJ ho<span class="comment">//GDI绘图对象句柄，画笔句柄。</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>只能删除不被DC使用的画笔，所以在释放前，必须从将画笔从DC中取出。</p>
<p>大致过程就是，创建-交换-绘画-取出-释放</p>
<p> <strong>示例</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PAINTSTRUCT PS = &#123; &#125;;<span class="comment">//抓到画家</span></span><br><span class="line">HDC hdc = BeginPaint(hwnd, &amp;PS);</span><br><span class="line">HPEN hPen = CreatePen(PS_SOLID,<span class="number">20</span>,RGB(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>));<span class="comment">//创建</span></span><br><span class="line">HGDIOBJ nOldPen = SelectObject(hdc, hPen);<span class="comment">//交换</span></span><br><span class="line">Ellipse(hdc, <span class="number">100</span>, <span class="number">100</span>, <span class="number">300</span>, <span class="number">300</span>);</span><br><span class="line">SelectObject(hdc, nOldPen);<span class="comment">//交换,这里可以不用接收，上面创建时的句柄可以找到这跟笔，让画家松手就行了，我们就能销毁了。</span></span><br><span class="line">DeleteObject(hPen);</span><br><span class="line">EndPaint(hwnd,&amp;PS);</span><br></pre></td></tr></table></figure>

<h3 id="画刷"><a href="#画刷" class="headerlink" title="画刷"></a>画刷</h3><ul>
<li>画刷相关<ul>
<li>画刷-封闭图形的填充颜色、图案</li>
<li>HBRUSH-画刷句柄</li>
<li>画刷的使用套路就跟画笔一样</li>
<li>默认是画刷颜色是白色的</li>
</ul>
</li>
<li>画刷的使用</li>
</ul>
<p>1.创建画刷</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">创建实心画刷</span><br><span class="line"><span class="function">HBRUSH <span class="title">CreateSolidBrush</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] COLORREF color</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;    </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">创建纹理画刷</span><br><span class="line"><span class="function">HBRUSH <span class="title">CreateHatchBrush</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>      iHatch,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] COLORREF color</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>2.将画刷应用到DC中</p>
<p>SelectObject</p>
<p>3.绘图</p>
<p>4.将画刷从DC中取出</p>
<p>SelectObject</p>
<p>5.删除画刷</p>
<p>DeleteObject</p>
<hr>
<ul>
<li>其他</li>
</ul>
<p>可以使用GetStockObject函数获取系统维护的画刷，画笔等。</p>
<p>如果不使用画刷填充，需要使用NULL_BRUSH参数，获取不填充的画刷。</p>
<p>GetStockObject返回的画刷不需要DeleteObject。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向操作系统借一把透明刷子</span></span><br><span class="line">HGDIOBJ hBrush = GetStockObject(NULL_BRUSH);</span><br></pre></td></tr></table></figure>

<h2 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h2><h3 id="位图绘制"><a href="#位图绘制" class="headerlink" title="位图绘制"></a>位图绘制</h3><ul>
<li><p>位图相关</p>
<ul>
<li>光栅图形-记录图像中每一点的颜色等信息</li>
<li>矢量图形-记录图像算法、绘图指令等。</li>
<li>HBITMAP-位图句柄</li>
</ul>
</li>
<li><p>位图的使用</p>
<p>1.在资源中添加位图资源</p>
<p>2.从资源中加载位图——loadBitMap</p>
<p>3.创建一个与当前DC相匹配的DC(内存DC)(在内存的一个虚拟的区域画)</p>
<hr>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HDC <span class="title">CreateCompatibleDC</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] HDC hdc<span class="comment">//当前DC句柄，可以为NULL(使用屏幕DC)</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;<span class="comment">//返回创建好的DC句柄</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>兼具资源的步骤和GDI绘图对象的步骤。</strong></p>
<p>4.将位图放入匹配的DC中SelectObject</p>
<p>5.成像(1:1)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">BitBlt</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] HDC   hdc,<span class="comment">//目的DC</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>   x,<span class="comment">//目的左上X坐标</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>   y,<span class="comment">//目的左上Y坐标</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>   cx,<span class="comment">//目的宽度</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>   cy,<span class="comment">//目的高度</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] HDC   hdcSrc,<span class="comment">//源DC</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>   x1,<span class="comment">//源左上X坐标</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>   y1,<span class="comment">//源左上Y坐标</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] DWORD rop<span class="comment">//成像方法SRCCOPY</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>缩放成像</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">StretchBlt</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] HDC   hdcDest,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>   xDest,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>   yDest,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>   wDest,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>   hDest,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] HDC   hdcSrc,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>   xSrc,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>   ySrc,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>   wSrc,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>   hSrc,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] DWORD rop</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>6.取出位图</p>
<p>SelectObject</p>
<p>7.释放位图</p>
<p>DeleteObject</p>
<p>8.释放匹配的DC</p>
<p>DeleteDC</p>
<p><strong>代码示例</strong>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PAINTSTRUCT ps = &#123; &#125;;</span><br><span class="line">HDC hdc = BeginPaint(hwnd, &amp;ps);</span><br><span class="line">HBITMAP hBmp = LoadBitmap(g_HINSTANCE, (<span class="keyword">char</span>*)IDB_BITMAP1);</span><br><span class="line">HDC hMemdc = CreateCompatibleDC(hdc);<span class="comment">//创建一个内存DC，并构建一个虚拟区域，并且内存DC在虚拟区域中绘图</span></span><br><span class="line">HGDIOBJ nOldBmp = SelectObject(hMemdc,hBmp);<span class="comment">//将位图数据送给内存DC,内存DC在虚拟区域中将位图绘制出来，返回旧位图(原来并没有，这是个假的，只是为了我们将来能够换回来）</span></span><br><span class="line">BitBlt(hdc, <span class="number">100</span>, <span class="number">100</span>, <span class="number">48</span>, <span class="number">48</span>, hMemdc, <span class="number">0</span>, <span class="number">0</span>, SRCCOPY);<span class="comment">//将虚拟区域绘制好的图像成像到窗口中</span></span><br><span class="line">StretchBlt(hdc, <span class="number">200</span>, <span class="number">200</span>, <span class="number">96</span>, <span class="number">96</span>,hMemdc,<span class="number">0</span>,<span class="number">0</span>,<span class="number">48</span>,<span class="number">48</span>,SRCCOPY);<span class="comment">//缩放成像</span></span><br><span class="line"><span class="comment">//开辟的区域比要成像的图像大，就是放大图像。</span></span><br><span class="line"></span><br><span class="line">SelectObject(hMemdc, nOldBmp);<span class="comment">//换回来</span></span><br><span class="line">DeleteObject(hBmp);<span class="comment">//释放画的位图</span></span><br><span class="line">DeleteDC(hMemdc);<span class="comment">//释放内存DC</span></span><br></pre></td></tr></table></figure>

<h2 id="文本绘制"><a href="#文本绘制" class="headerlink" title="文本绘制"></a>文本绘制</h2><h3 id="文字的绘制"><a href="#文字的绘制" class="headerlink" title="文字的绘制"></a>文字的绘制</h3><ul>
<li>TextOut-将文字绘制在指定坐标位置</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">TextOutW</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] HDC     hdc,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>     x,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>     y,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] LPCWSTR lpString,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>     c</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>



<ul>
<li>DrawText</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DrawText</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]      HDC     hdc,<span class="comment">//DC句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in, out] LPCTSTR lpchText,<span class="comment">//字符串</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in]      <span class="keyword">int</span>     cchText,<span class="comment">//字符数量</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in, out] LPRECT  lprc,<span class="comment">//绘制文字的矩形框</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in]      UINT    format<span class="comment">//绘制的方式</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>文字颜色和背景</p>
<ul>
<li>文字颜色:SetTextColor</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">COLORREF <span class="title">SetTextColor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] HDC      hdc,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] COLORREF color</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>



<ul>
<li>文字背景色:SetBkColor——只适用在不透明</li>
<li>文字背景模式:SetBkMode(OPAQUE/TRANSPARENT)(透明(默认)/非透明)</li>
</ul>
</li>
</ul>
<h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><ul>
<li>字体相关:</li>
<li>window常用的字体为TrueType格式的字体文件<ul>
<li>字体名-标识字体类型</li>
<li>HFONT-字体句柄(保存字体的数据信息——外观形状)</li>
</ul>
</li>
<li>字体的使用</li>
</ul>
<p>1.创建字体CreateFont</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HFONT <span class="title">CreateFontA</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>    cHeight,<span class="comment">//字体高度</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>    cWidth,<span class="comment">//字体宽度</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>    cEscapement,<span class="comment">//字符串倾斜角度</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>    cOrientation,<span class="comment">//字体的旋转角度</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>    cWeight,<span class="comment">//字体的粗细</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] DWORD  bItalic,<span class="comment">//斜体</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] DWORD  bUnderline,<span class="comment">//字符下划线</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] DWORD  bStrikeOut,<span class="comment">//删除线</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] DWORD  iCharSet,<span class="comment">//字符集-GB2312_CHARSET</span></span></span></span><br><span class="line"><span class="function"><span class="params">    </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">//下面的4参数全写0即可</span></span></span></span><br><span class="line"><span class="function"><span class="params">    </span></span></span><br><span class="line"><span class="function"><span class="params">  [in] DWORD  iOutPrecision,<span class="comment">//输出精度</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] DWORD  iClipPrecision,<span class="comment">//剪切精度</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] DWORD  iQuality,<span class="comment">//输出质量</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] DWORD  iPitchAndFamily,<span class="comment">//匹配字体</span></span></span></span><br><span class="line"><span class="function"><span class="params">    </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">//这个得写</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] LPCSTR pszFaceName<span class="comment">//字体名称</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>代码示例</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">PAINTSTRUCT ps = &#123; &#125;;</span><br><span class="line">HDC hdc = BeginPaint(hwnd,&amp;ps);</span><br><span class="line"></span><br><span class="line">SetTextColor(hdc, RGB(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">SetBkColor(hdc, RGB(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HFONT hFront = CreateFont(<span class="number">30</span>,<span class="number">0</span>,<span class="number">45</span>,<span class="number">0</span>,<span class="number">900</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>, GB2312_CHARSET,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="string">&quot;黑体&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HGDIOBJ nOldFron = SelectObject(hdc, hFront);<span class="comment">//将创建的字体给它</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* szText = <span class="string">&quot;我是TEXTOUT&quot;</span>;</span><br><span class="line">TextOut(hdc,<span class="number">100</span>,<span class="number">100</span>,szText,<span class="built_in">strlen</span>(szText));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//DrawText在矩形的范围内画，所以首先要确定一个范围</span></span><br><span class="line">RECT rc;</span><br><span class="line">rc.left = <span class="number">100</span>;</span><br><span class="line">rc.top = <span class="number">150</span>;</span><br><span class="line">rc.right = <span class="number">200</span>;</span><br><span class="line">rc.bottom = <span class="number">200</span>;</span><br><span class="line"><span class="comment">//DrawText有矩形作为限制边界(可以打破)</span></span><br><span class="line">DrawText(hdc, szText, <span class="built_in">strlen</span>(szText),&amp;rc,DT_LEFT | DT_TOP);</span><br><span class="line"><span class="comment">//DT_VCENTER和DT_BOTTOM只适用于DT_SINGLELINE和DT_WORDBREAK冲突</span></span><br><span class="line"></span><br><span class="line">SelectObject(hdc, nOldFron);<span class="comment">//让它放开</span></span><br><span class="line">DeleteObject(hFront);<span class="comment">//字体更要记得释放，因为字体占的内存较大</span></span><br><span class="line">EndPaint(hwnd,&amp;ps);</span><br></pre></td></tr></table></figure>

<h2 id="对话框"><a href="#对话框" class="headerlink" title="对话框"></a>对话框</h2><p><strong>处理消息的方式与普通窗口相反</strong>，缺省的函数调用自定义函数。</p>
<h3 id="对话框原理"><a href="#对话框原理" class="headerlink" title="对话框原理"></a>对话框原理</h3><ul>
<li>对话框的分类<ul>
<li>模式对话框-当前对话框显示时，会禁止本进程其它窗口和用户交互操作。</li>
<li>无模式对话框-在对话框显示后，本进程其它窗口仍然可以和用户进行操作。</li>
</ul>
</li>
<li>对话框基本使用 <ol>
<li>对话框窗口处理函数</li>
<li>注册窗口函数(不使用)</li>
<li>创建对话框</li>
<li>对话框的关闭</li>
</ol>
</li>
</ul>
<hr>
<p><strong>谁注册窗口类，窗口处理函数就由谁来实现。</strong></p>
<hr>
<ul>
<li>对话框处理函数(并非真正的对话框处理函数，真正的系统内部。)</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DLGPROC Dlgproc;</span><br><span class="line"></span><br><span class="line"><span class="function">INT_PTR <span class="title">Dlgproc</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HWND unnamedParam1,<span class="comment">//窗口句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  UINT unnamedParam2,<span class="comment">//消息ID</span></span></span></span><br><span class="line"><span class="function"><span class="params">  WPARAM unnamedParam3,<span class="comment">//消息参数</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPARAM unnamedParam4<span class="comment">//消息参数</span></span></span></span><br><span class="line">)；</span><br></pre></td></tr></table></figure>

<p>返回TRUE——缺省处理函数不需要处理。</p>
<p>返回False——交给缺省处理函数处理。不需要调用缺省对话框处理函数。</p>
<h3 id="模式对话框"><a href="#模式对话框" class="headerlink" title="模式对话框"></a>模式对话框</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DialogBoxA</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional]  hInstance,<span class="comment">//当前程序实例句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in]            lpTemplate,<span class="comment">//对话框资源ID</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional]  hWndParent,<span class="comment">//对话框父窗口</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional]  lpDialogFunc<span class="comment">//自定义函数</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>DialogBox是一个阻塞函数，只有当对话框关闭后，才会返回，继续执行后续代码。</p>
<p>返回值是通过EndDialog设置。</p>
<ul>
<li>对话框的关闭</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">EndDialog</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] HWND    hDlg,<span class="comment">//关闭的对话框窗口</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] INT_PTR nResult<span class="comment">//关闭的返回值，能指定返回值就说明能接触阻塞</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>关闭模式对话框，只能使用EndDialog,不能使用DestoryWindow等函数。</p>
<p>nRsult是DiglogBox函数退出时的返回值。</p>
<ul>
<li>对话框的消息</li>
</ul>
<p>WM_INITDIALOG-对话框创建之后在显示之前，通知对话框窗口处理函数，可以完成自己的初始化相关的操作。</p>
<hr>
<p>EndDialog销毁对话框，并且解除阻塞。</p>
<p>而DestroyWindow只能销毁对话框，并不能解除阻塞。</p>
<hr>
<h3 id="无模式对话框"><a href="#无模式对话框" class="headerlink" title="无模式对话框"></a>无模式对话框</h3><ul>
<li>创建对话框</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HWND <span class="title">CreateDialog</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HINSTANCE hInstance,<span class="comment">//应用程序实例句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">        LPCTSTR lpName,<span class="comment">//模板资源ID</span></span></span></span><br><span class="line"><span class="function"><span class="params">        HWND hWndParent hWndParent,<span class="comment">//父窗口</span></span></span></span><br><span class="line"><span class="function"><span class="params">        DLGPROC lpDialogFunc<span class="comment">//自定义函数</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>非阻塞函数，创建成功后返回窗口句柄，需要使用ShowWindow函数显示对话框。</p>
<ul>
<li>对话框关闭</li>
</ul>
<p>关闭时使用DestroyWindow销毁窗口，不能使用EndDiaglog关闭对话框。</p>
<p><strong>代码示例</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HWND noModel = CreateDialog(g_Hinstance, (<span class="keyword">char</span>*)IDD_DIALOG1,hwnd, DlgProc);</span><br><span class="line">ShowWindow(noModel, SW_SHOW);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xxx</span><br><span class="line">DestroyWindow(hwnd);</span><br></pre></td></tr></table></figure>

<h2 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h2><p> Windows上静态库和Linux上的静态库在原理上没有任何区别，都是封装一堆东西等着别人去掉。</p>
<h3 id="静态库的特点"><a href="#静态库的特点" class="headerlink" title="静态库的特点"></a>静态库的特点</h3><ul>
<li>运行不存在。<ul>
<li>没有如何，不能执行，生成的文件无法形成静态影像，无法进内存。</li>
</ul>
</li>
<li>静态库源码被链接到调用程序中。</li>
<li>目标程序的归档。</li>
</ul>
<h3 id="C语言静态库"><a href="#C语言静态库" class="headerlink" title="C语言静态库"></a>C语言静态库</h3><ul>
<li>C静态库的创建<ul>
<li>创建一个静态库程序。</li>
<li>添加库程序，源文件使用C文件。</li>
</ul>
</li>
<li>C静态库的使用<ul>
<li>库路径设置:可以使用#pragma关键字设置<ul>
<li>#pragma comment(lib,”../lib/clib.lib”)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="C-静态库"><a href="#C-静态库" class="headerlink" title="C++静态库"></a>C++静态库</h3><ul>
<li>C++静态库的创建<ul>
<li>创建一个静态库项目</li>
<li>添加库程序，源文件使用CPP文件。</li>
</ul>
</li>
<li>C++静态库的使用<ul>
<li>库路径设置:可以使用pragma关键字设置</li>
<li>#pragma comment(lib,”../xx/xxx.lib”)</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//给编译器看</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CLIB_add</span><span class="params">(<span class="keyword">int</span> add1, <span class="keyword">int</span> add2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CLIB_sub</span><span class="params">(<span class="keyword">int</span> add1, <span class="keyword">int</span> add2)</span></span>;</span><br><span class="line"><span class="comment">//给链接器看</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;../Debug/CPPLIB.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; CLIB_add(<span class="number">5</span>, <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; CLIB_sub(<span class="number">5</span>, <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>C++调库中函数需要在前面声明。告诉编译器到底换不换名。</strong></p>
<p><strong>C++编译器编译时会更改函数名。</strong></p>
<p><strong>解决</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span><span class="string">&quot;C&quot;</span> 函数声明；告诉编译器以C语言方式编译(不要给我改名)。</span><br></pre></td></tr></table></figure>

<h2 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h2><h3 id="动态库的特点"><a href="#动态库的特点" class="headerlink" title="动态库的特点"></a>动态库的特点</h3><ol>
<li>运行时独立存在(依附着其它程序运行起来的之后)</li>
<li>源码不会链接到执行程序</li>
<li>使用时加载(使用动态库必须使动态库执行)</li>
</ol>
<p><strong>与静态库进行比较</strong></p>
<ol>
<li>由于静态库是将代码嵌入到使用程序中，多个程序使用时，会有多分代码，所以代码体积会增大。动态库的代码只需要存一份，其他程序通过函数地址使用，所以代码体积较小。</li>
<li>静态库发生变化后，新的代码需要重新链接嵌入到执行程序中。动态库发生变化后，如果库中函数的定义(或地址)未变化(仅仅是函数的实现发生了变化)，其他使用DLL的程序不需要重新链接。</li>
</ol>
<h3 id="动态库的创建"><a href="#动态库的创建" class="headerlink" title="动态库的创建"></a>动态库的创建</h3><ul>
<li><p>创建动态库项目</p>
</li>
<li><p>添加库程序</p>
</li>
<li><p>库程序导出-提供给使用库者库中的函数等信息。</p>
<ol>
<li><p>声明导出:使用_declspec(dllexport)导出函数。将函数的地址存放在动态库的文件头中。(换名之后的函数)</p>
<p><strong>注意</strong>：动态库编译链接后，也会有LIB文件(与该DLL配套生成的)，是作为动态库函数映射使用，与静态库不完全相同。<strong>LIB中存放每个函数的名字和它对应的标号，还有与它配套的DLL文件名——xxx.dll</strong></p>
</li>
<li><p>模块定义文件.def</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">LIBRARY DLLFunc <span class="comment">//库</span></span><br><span class="line">EXPORTS	<span class="comment">//库导出表</span></span><br><span class="line">DLL_Mul  <span class="comment">//导出的函数</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h3 id="动态库的使用"><a href="#动态库的使用" class="headerlink" title="动态库的使用"></a>动态库的使用</h3><ul>
<li>隐式链接(操作系统负责使动态库执行，系统偷偷的把动态库扔到内存中。)<ol>
<li>头文件和函数原型，在函数原型的声明前，增加_declspec(dllimport)</li>
<li>导入动态库的LIB文件</li>
<li>在程序中使用函数<ol>
<li>隐式的链接的情况，dll文件可以存放的路径(编译器可以找到的位置):</li>
<li>与执行文件中同一个目录下</li>
<li>当前工作目录</li>
<li>Windows目录,(三个window..不建议使用，因为是系统路径， 公共场所，容易出现问题。)</li>
<li>Windows/System32目录</li>
<li>Windows/System</li>
<li>环境变量PATH指定目录</li>
</ol>
</li>
</ol>
</li>
</ul>
<hr>
<ul>
<li>显式链接(程序员自己负责使动态库执行)</li>
</ul>
<p>1.定义函数指针类型 typedef</p>
<p>2.加载动态库</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HMODULE <span class="title">LoadLibrary</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  	LPCTSTR lpFileName<span class="comment">//动态库文件名或全路径  </span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;<span class="comment">//返回DLL的实例局句柄(HINSTANCE)</span></span><br></pre></td></tr></table></figure>

<p>3.获取函数(绝对/真实)地址</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FARPROC  <span class="title">GetProcAddress</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	HMODULE hModule,<span class="comment">//DLL句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">         LPCSTR lpProcName<span class="comment">//函数名称</span></span></span></span><br><span class="line">)；//成功返回函数地址</span><br></pre></td></tr></table></figure>

<p>4.使用函数</p>
<p>5.卸载动态库(释放那块内存，结束动态库执行。)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">FreeLibrary</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	HMODULE hModule<span class="comment">//DLL的实例句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>代码示例</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LIBRARY Dll3</span><br><span class="line">EXPORTS</span><br><span class="line">	Print @1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*PRINT)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HINSTANCE hDll = LoadLibrary(<span class="string">&quot;Dll3.dll&quot;</span>);</span><br><span class="line">	PRINT MYPRINT = (PRINT)GetProcAddress(hDll, <span class="string">&quot;Print&quot;</span>);</span><br><span class="line">	MYPRINT();</span><br><span class="line">	FreeLibrary(hDll);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态库中封装类"><a href="#动态库中封装类" class="headerlink" title="动态库中封装类"></a>动态库中封装类</h3><p>类导出的其实也是函数地址。</p>
<ul>
<li>在类名称前增加_declspec(dllexport)定义，例如:</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">declspec</span>(<span class="title">dllexport</span>)<span class="title">CMath</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通常使用预编译开关切换类的导入导出定义，例如:<br><img src="/images/win32(1).assets/image-20211106214536869.png" alt="image-20211106214536869"></li>
</ul>
<p><strong>代码示例</strong>：</p>
<p>(如果生成错误就改一下代码顺序)</p>
<p>动态库中封装类.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _DLLCLASS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _DLLCLASS_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DLLCLASS_EXPORTS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXT_CLASS _declspec(dllexport)<span class="comment">//导出</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXT_CLASS _declspec(dllimport)<span class="comment">//导入</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EXT_CLASS</span> <span class="title">Print</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">PRINT</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p> 动态库中实现.cpp</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;CLASSDLL.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span>	<span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLLCLASS_EXPORTS</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print::PRINT</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;123&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用该动态库</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;../CLASSDLL/CLASSDLL.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;../Debug/CLASSDLL.lib&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Print p1;</span><br><span class="line">	p1.PRINT();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h3><ul>
<li>Windows的线程是可以执行代码的实例。系统是以线程为单位调度程序。一个程序当中可以有多个线程，实现多任务的处理。</li>
<li>进程开启意味着分内存，线程开辟意味着程序的执行。</li>
<li>Windows线程的特点:<ol>
<li>线程都具有1个ID</li>
<li>每个线程都具有自己的内存栈</li>
<li>同一进程中的线程使用同一个地址空间</li>
</ol>
</li>
<li>线程的调度:</li>
</ul>
<p><strong>操作系统</strong>将CPU的执行时间划分成时间片，依次根据时间片执行不同的线程</p>
<p>线程轮询:线程A-&gt;线程B-&gt;线程A……</p>
<p><strong>在一个时间点上，CPU只能执行一个线程。</strong></p>
<h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><ul>
<li>创建线程</li>
</ul>
<p>函数原型如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateThread</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional]  LPSECURITY_ATTRIBUTES   lpThreadAttributes,<span class="comment">//安全属性</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in]            SIZE_T                  dwStackSize,<span class="comment">//线程栈的大小</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in]            LPTHREAD_START_ROUTINE  lpStartAddress,<span class="comment">//线程处理函数的函数地址</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional]  __drv_aliasesMem LPVOID lpParameter,<span class="comment">//传递给线程处理函数的参数</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in]            DWORD                   dwCreationFlags,<span class="comment">//线程的创建方式</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [out, optional] LPDWORD                 lpThreadId<span class="comment">//创建成功，返回线程的ID</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;<span class="comment">//创建成功，返回线程句柄。</span></span><br></pre></td></tr></table></figure>

<p><strong>只要看到安全属性这个参数就通通置空，这个参数已经被废弃了。</strong></p>
<p><strong>线程栈大小，按照1MB对齐。</strong></p>
<p><strong>看到处理函数，就说明这个函数由我们程序员去定义，由系统调用。</strong></p>
<p><strong>线程的创建方式有两种，立即执行方式，挂起方式。</strong></p>
<p><strong>多线程，宏观上同时开始(并行)，真实是，一个时间点只能执行一个线程(串行)。</strong></p>
<ul>
<li>定义线程处理函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	LPVOID lpParameter<span class="comment">//创建线程时，传递给线程的参数。</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>代码示例</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD CALLBACK <span class="title">TestProc</span><span class="params">(LPVOID pParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; (<span class="keyword">char</span>*)pParam &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		Sleep(<span class="number">1000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">DWORD CALLBACK <span class="title">TestProc1</span><span class="params">(LPVOID pParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; (<span class="keyword">char</span>*)pParam &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		Sleep(<span class="number">1000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DWORD nID = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>* text = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">	HANDLE hTread = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, TestProc, (<span class="keyword">void</span>*)text, <span class="number">0</span>, &amp;nID);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>* text1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">	HANDLE hTread1 = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, TestProc1, (<span class="keyword">void</span>*)text1, <span class="number">0</span>, &amp;nID);</span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="线程挂起-销毁"><a href="#线程挂起-销毁" class="headerlink" title="线程挂起/销毁"></a>线程挂起/销毁</h3><p><strong>挂起</strong>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">SuspendTread</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	HANDLE hThread <span class="comment">//线程句柄	</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>唤醒</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">ResumeTread</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	HANDLE hThread<span class="comment">//线程句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>结束指定线程</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL Terminate <span class="title">Thread</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	HANDLE hThread,<span class="comment">//线程句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">        DWORD dwExitCode<span class="comment">//退出码，没有实际意义</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>结束函数所在的线程</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">ExitThread</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	DWORD dwExitCode<span class="comment">//退出码</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="线程相关操作"><a href="#线程相关操作" class="headerlink" title="线程相关操作"></a>线程相关操作</h3><p><strong>获取当前线程ID</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GetCurrentThreadId();</span><br></pre></td></tr></table></figure>

<p><strong>获取当前线程的句柄</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GetCurrentThread();</span><br></pre></td></tr></table></figure>

<p><strong>等候(可等候)单个句柄有信号</strong>——线程句柄</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">WaitForSingleObject</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	HANDLE handle，<span class="comment">//句柄BUFF的地址</span></span></span></span><br><span class="line"><span class="function"><span class="params">	DOWRD dwMilliseconds<span class="comment">//等候时间INFINITE(无限大)</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>一个可等候的句柄，一定有有信号和无信号的两种状态。</p>
<p>等候的时间已经到了，该句柄还是无信号那就返回了。</p>
<p><strong>同时等候多个句柄有信号</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">WaitForMultipleObjects</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	DOWRD nCount,<span class="comment">//要等候的句柄数量</span></span></span></span><br><span class="line"><span class="function"><span class="params">    CONST HANDLE*lpHandle,<span class="comment">//句柄BUFF的地址</span></span></span></span><br><span class="line"><span class="function"><span class="params">    </span></span></span><br><span class="line"><span class="function"><span class="params">    BOOL bWaitAll,<span class="comment">//等候方式</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">//TRUE-所有事件都有信号才返回</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">//FALSE-有一个事件有信号就返回</span></span></span></span><br><span class="line"><span class="function"><span class="params">    </span></span></span><br><span class="line"><span class="function"><span class="params">    </span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD dwMilliseconds<span class="comment">//等候时间INFINITE</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>bWaitAll-等候方式</p>
<ul>
<li>TRUE-表示所有句柄都有信号，才结束等候。</li>
<li>FALSE-表示句柄中只要1个有信号，就结束等候。</li>
</ul>
<hr>
<p>线程句柄执行的时候无信号，结束的时候有信号。</p>
<hr>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><h3 id="原子锁"><a href="#原子锁" class="headerlink" title="原子锁"></a>原子锁</h3><ul>
<li>相关问题</li>
</ul>
<p>多个线程对同一个数据进行原子操作，会产生结果丢失。比如执行++运算时。</p>
<ul>
<li>错误代码分析</li>
</ul>
<p>当线程A执行g_value++时，如果线程切换时间正好是在线程A再次被切换回来之后，会将原来线程A保存的值保存到g_values上，线程B进行的加法操作被覆盖。(汇编角度)</p>
<blockquote>
<p>当CPU在执行某个线程的时候，一旦时间到了它要离开，它会将这个线程已经执行到的位置保护起来，一般是压栈保护。将位置信息压到本线程的栈中。再来，先弹栈读取，恢复战场。</p>
</blockquote>
<ul>
<li>图示</li>
</ul>
<p><img src="/images/win32(1).assets/image-20211107172354028.png" alt="image-20211107172354028"></p>
<p><strong>解释/错误分析</strong>:</p>
<blockquote>
<p>第一个线程刚要将+1后的值赋给g_value,cpu给它的时间就到了，这时切换到线程2，线程2执行完毕，g_value == 1，切换回线程1，先弹栈恢复，执行完毕得到g_value == 1,这就丢失了一次数据。</p>
</blockquote>
<p><strong>解决</strong>：使用原子锁函数，来++</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD CALLBACK <span class="title">TestProc1</span><span class="params">(LPVOID pParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//g_value++;</span></span><br><span class="line">		InterlockedIncrement(&amp;g_value);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD CALLBACK <span class="title">TestProc2</span><span class="params">(LPVOID pParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//g_value++;</span></span><br><span class="line">		InterlockedIncrement(&amp;g_value);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li> 使用原子锁函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InterlockedIncrement</span><br><span class="line">......</span><br><span class="line">每一个操作符都有对应的一个原子锁函数</span><br></pre></td></tr></table></figure>

<p><strong>原子锁的实现</strong>：直接对数据所在的内存进行操作，并且在任何一个瞬间只能有一个线程访问这块内存。(++并不是直接对内存进行操作，而是对寄存器进行操作，然后再赋值给变量。)</p>
<p><strong>锁的是数据所在的这块内存，并不是CPU。</strong></p>
<p><strong>解释</strong>：</p>
<blockquote>
<p>先执行线程1，进来直接给g_value(内存)上锁，如果这时候CPU给的时间到了，那就压栈保护，然后转去执行线程2，线程2一看已经g_value已经被锁了，不会重复锁，发生阻塞，等到时间的耗尽，又转去执行线程1，弹栈恢复，完成执行完后，给g_value解锁，再去执行线程2，线程2就能给g_value上锁了……重复上述过程。</p>
<p>简单来说就是，上了锁之后可以保证一个线程对该变量，完成一次完整的操作后，另一个线程再进行一次完整的操作。</p>
</blockquote>
<p>使用原子锁之后执行效率变慢，因为这两个线程老是对着睡觉。</p>
<p>重要的是保证结果的正确性，如果保证不了正确性，宁可牺牲效率也要保证结果正确。</p>
<ul>
<li>局限性&amp;优点</li>
</ul>
<p>只能对运算符进行原子锁。而且有大量函数。但是在所有的枷锁机制中，它的效率最高。</p>
<hr>
<h3 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h3><ul>
<li>相关的问题</li>
</ul>
<p>多线程下代码或资源的共享使用</p>
<ul>
<li>互斥的使用</li>
</ul>
<p>一.创建互斥</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateMutex</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	LPSECURITY_ATTRIBUTES lpMutexAttributes,<span class="comment">//安全属性</span></span></span></span><br><span class="line"><span class="function"><span class="params">    BOOL bInitialOwner,<span class="comment">//初识的拥有者TRUE/FALSE</span></span></span></span><br><span class="line"><span class="function"><span class="params">    LPCTSTR lpName<span class="comment">//命名</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;<span class="comment">//创建成功返回互斥句柄</span></span><br></pre></td></tr></table></figure>

<p>互斥不光能对操作符进行枷锁，也能对其它东西进行枷锁，比如说锁定一段或一行代码。</p>
<p>原子锁能解决的问题，互斥都能解决，但是互斥能解决的问题，原子锁不一定能解决。</p>
<p> <strong>互斥句柄也是可等候句柄。</strong></p>
<p><strong>特点</strong>：</p>
<p>1.任何一个时间点上只能有一个线程拥有互斥。其它线程只能等待这个线程把互斥扔掉才能拥有。<strong>独占性和排他性、</strong></p>
<ol start="2">
<li>  当任何一个线程都不拥有互斥，互斥句柄有信号。一旦某个线程有互斥，互斥句柄无信号。</li>
<li>谁先等待互斥，谁先得到互斥。</li>
</ol>
<p>二.等到互斥</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WaitForSingleObject/WaitForMultipleObjects...互斥的等候遵循谁先等候谁先获取</span><br></pre></td></tr></table></figure>

<p>三.释放互斥</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">ReleaseMutex</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	HANDLE hMutex<span class="comment">//互斥句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>四.关闭互斥句柄</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CloseHandle</span><br></pre></td></tr></table></figure>

<p><strong>代码示例</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">HANDLE g_hMutex = <span class="number">0</span>;<span class="comment">//接收互斥句柄</span></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD CALLBACK <span class="title">TestProc</span><span class="params">(LPVOID pParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span>* text = (<span class="keyword">char</span>*)pParam;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		WaitForSingleObject(g_hMutex, INFINITE);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(text); i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; text[i];</span><br><span class="line">			Sleep(<span class="number">333</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		ReleaseMutex(g_hMutex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">DWORD CALLBACK <span class="title">TestProc1</span><span class="params">(LPVOID pParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span>* text = (<span class="keyword">char</span>*)pParam;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		WaitForSingleObject(g_hMutex, INFINITE);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(text); i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; text[i];</span><br><span class="line">			Sleep(<span class="number">333</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		ReleaseMutex(g_hMutex);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//创建互斥的这个主线程也不拥有它，</span></span><br><span class="line">	g_hMutex = CreateMutex(<span class="literal">NULL</span>,FALSE,<span class="literal">NULL</span>);</span><br><span class="line">	DWORD nID = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>* text = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">	HANDLE hTread = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, TestProc, (<span class="keyword">void</span>*)text, <span class="number">0</span>, &amp;nID);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>* text1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">	HANDLE hTread1 = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, TestProc1, (<span class="keyword">void</span>*)text1, <span class="number">0</span>, &amp;nID);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">	CloseHandle(g_hMutex);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <strong>解释</strong>：互斥句柄在主函数中创建出来，设备FALSE，谁都不拥有，<strong>互斥句柄有信号</strong>，等待抢占，假设CPU先执行线程1， 拿到互斥句柄，<strong>互斥句柄变为无信号</strong>，执行打印，到时间后，压栈保存，转去执行线程2，此时WaitForSingObject就无法通过，阻塞，等待时间结束，又执行线程1，恢复现场，假设执行完毕，线程1丢掉互斥，<strong>互斥句再次变为有信号</strong>，线程2WaitForSingObject通过，拿到互斥……。      </p>
<hr>
<p>原子锁和互斥都是枷锁机制，实现的都是多个线程之间有排斥关系。 <strong>多个线程之间去竞争临界资源。</strong></p>
<hr>
<p>下面这两个同步技术，事件和信号量，实现的是线程之间的<strong>协调工作关系</strong>。</p>
<hr>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><ul>
<li>相关问题</li>
</ul>
<p>程序(线程)之间的通知的问题。</p>
<p>两个线程要协调工作，它们两个就得通信。</p>
<ul>
<li>事件的使用</li>
</ul>
<p>1.创建事件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateEvent</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	LPSECURITY_ATTRIBUTES lpEventAttributes,<span class="comment">//安全属性</span></span></span></span><br><span class="line"><span class="function"><span class="params">    BOOL bManualReset,<span class="comment">//事件重置(复位(将事件变为无信号))方式，TRUE手动，FALSE自动</span></span></span></span><br><span class="line"><span class="function"><span class="params">    BOOL bInitialState,<span class="comment">//事件初识状态，TRUE有信号</span></span></span></span><br><span class="line"><span class="function"><span class="params">    LPCTSTR lpName<span class="comment">//事件命名</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;<span class="comment">//创建成功返回事件句柄</span></span><br></pre></td></tr></table></figure>

<p>2.等候事件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WaitForSingleObject/WaitForMultipleObjects</span><br></pre></td></tr></table></figure>

<p>3.触发事件(将事件设置成有信号状态)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">SetEvent</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	HANDLE hEvent <span class="comment">//事件句柄 </span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br></pre></td></tr></table></figure>

<p>4.复位事件(将事件设置成无信号状态)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">ResetEvent</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	HANDLE hEvent<span class="comment">//事件句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>5.关闭事件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CloseHandle</span><br></pre></td></tr></table></figure>

<p> <strong>代码示例</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">HANDLE g_hEvent = <span class="number">0</span>;<span class="comment">//接收事件句柄</span></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD CALLBACK <span class="title">PrintProc</span><span class="params">(LPVOID pParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		WaitForSingleObject(g_hEvent,INFINITE);</span><br><span class="line">		<span class="comment">//ResetEvent(g_hEvent);//将事件设置成无信号</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;*************&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过事件进行通信</span></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD CALLBACK <span class="title">CtrlProc</span><span class="params">(LPVOID pParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Sleep(<span class="number">1000</span>);</span><br><span class="line">		SetEvent(g_hEvent);<span class="comment">//解救线程1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//FALSE为自动复位，当经过WaitForSingleObject函数之后</span></span><br><span class="line">	<span class="comment">//TRUE为手动复位，手动在WaitForSingleObject后ResetEvent</span></span><br><span class="line">	g_hEvent = CreateEvent(<span class="literal">NULL</span>,FALSE,FALSE,<span class="literal">NULL</span>);</span><br><span class="line">	DWORD nID = <span class="number">0</span>;</span><br><span class="line">	HANDLE hThread[<span class="number">2</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	hThread[<span class="number">0</span>] = CreateThread(<span class="literal">NULL</span>,<span class="number">0</span>,PrintProc,<span class="literal">NULL</span>,<span class="number">0</span>,&amp;nID);</span><br><span class="line">	hThread[<span class="number">1</span>] = CreateThread(<span class="literal">NULL</span>,<span class="number">0</span>,CtrlProc,<span class="literal">NULL</span>,<span class="number">0</span>,&amp;nID);</span><br><span class="line">	WaitForMultipleObjects(<span class="number">2</span>,hThread,TRUE,INFINITE);</span><br><span class="line">	 </span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>注意</strong>：<strong>小心事件死锁。</strong></p>
<p><img src="/images/win32(1).assets/image-20211107213811934.png" alt="image-20211107213811934"></p>
<hr>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><ul>
<li>相关的问题</li>
</ul>
<p>类似于事件(不是原理类似时间，是作用类似事件)，解决通知的相关问题。但提供一个<strong>计数器</strong>，<strong>可以设置次数</strong>。</p>
<ul>
<li>信号量的使用</li>
</ul>
<p>1.创建 信号量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateSemaphoreW</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional] LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,<span class="comment">//安全属性</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in]   LONG    lInitialCount,<span class="comment">//初始化信号量数量(初识计数值)</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in]   LONG    lMaximumCount,<span class="comment">//信号量(计数器)的最大值</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional] LPCWSTR   lpName<span class="comment">//命名</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;<span class="comment">//创建成功返回信号量句柄</span></span><br></pre></td></tr></table></figure>

<p><strong>信号量的计数器不为0时，信号量句柄有信号。</strong><br>2.等候信号量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WaitForSingleObject/WaitForMultipleObjects</span><br></pre></td></tr></table></figure>

<p>每等候一次，信号量减1，直到为0阻塞。</p>
<p>3.给信号量指定计数值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">ReleaseSemaphore</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]            HANDLE hSemaphore,<span class="comment">//信号量句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in]            LONG   lReleaseCount,<span class="comment">//释放数量</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [out, optional] LPLONG lpPreviousCount<span class="comment">//释放前原来信号量的数量，可以为NULL</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>4.关闭句柄</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CloseHandle  </span><br></pre></td></tr></table></figure>

<p><strong>代码示例</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">HANDLE h_handle = <span class="number">0</span>;<span class="comment">//信号量句柄</span></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD CALLBACK <span class="title">TestProc</span><span class="params">(LPVOID pParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		WaitForSingleObject(h_handle, INFINITE);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;******&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	h_handle = CreateSemaphore(<span class="literal">NULL</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="literal">NULL</span>);</span><br><span class="line">	DWORD nID = <span class="number">0</span>;</span><br><span class="line">	HANDLE hThread = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, TestProc, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;nID);</span><br><span class="line"></span><br><span class="line">	getchar();<span class="comment">//回车之后信号量数量改为5</span></span><br><span class="line">	ReleaseSemaphore(h_handle, <span class="number">5</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	WaitForSingleObject(hThread, INFINITE);</span><br><span class="line">	CloseHandle(h_handle);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;		</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">快乐的威猛先生</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://doraemon-hub-art.github.io/2021/11/08/%E3%80%90Win32%E3%80%91%E5%88%9D%E8%AF%86Win32%E7%BC%96%E7%A8%8B/">https://doraemon-hub-art.github.io/2021/11/08/%E3%80%90Win32%E3%80%91%E5%88%9D%E8%AF%86Win32%E7%BC%96%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://doraemon-hub-art.github.io" target="_blank">半生瓜のblog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Win32-C/">-Win32 - -C</a></div><div class="post_share"><div class="social-share" data-image="/img/win7.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/11/13/%E3%80%90MFC%E3%80%91MFC%E5%9F%BA%E7%A1%80%E7%AF%87(1)/"><img class="prev-cover" src="/img/mfc.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【MFC】MFC基础篇(1)</div></div></a></div><div class="next-post pull-right"><a href="/2021/10/29/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"><img class="next-cover" src="/img/datas.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【算法】查找算法</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/doraemon2.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">快乐的威猛先生</div><div class="author-info__description">There is no end</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">131</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">55</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://space.bilibili.com/94657270"><i class="iconfont icon-bofangqi-zantingxiaodianshi"></i><span>关注我一下吧</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://imgtu.com/i/4T713Q" target="_blank" title="我的微信公众号"><i class="iconfont icon-weixin"></i></a><a class="social-icon" href="https://github.com/doraemon-hub-art" target="_blank" title="我的Github"><i class="iconfont icon-github"></i></a><a class="social-icon" href="https://blog.csdn.net/qq_51604330?spm=1000.2115.3001.5343" target="_blank" title="我的CSDN"><i class="iconfont icon-csdn"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">我的交流群805814463</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Windows%E7%BC%96%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">Windows编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%88%86%E7%B1%BB"><span class="toc-number">1.1.</span> <span class="toc-text">应用程序分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%AF%B9%E6%AF%94"><span class="toc-number">1.2.</span> <span class="toc-text">应用程序对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7"><span class="toc-number">1.3.</span> <span class="toc-text">编译工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%93%E6%96%87%E4%BB%B6%E5%92%8C%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-number">1.4.</span> <span class="toc-text">库文件和头文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.</span> <span class="toc-text">相关函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B"><span class="toc-number">1.6.</span> <span class="toc-text">程序编译过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-number">1.7.</span> <span class="toc-text">窗口创建过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AAwindows%E7%AA%97%E5%8F%A3"><span class="toc-number">1.8.</span> <span class="toc-text">第一个windows窗口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unit04%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81"><span class="toc-number">1.9.</span> <span class="toc-text">Unit04字符编码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%BD%E5%AD%97%E8%8A%82%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.10.</span> <span class="toc-text">宽字节数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCHAR"><span class="toc-number">1.11.</span> <span class="toc-text">TCHAR</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E5%8D%B0UNICODE%E5%AD%97%E7%AC%A6"><span class="toc-number">1.12.</span> <span class="toc-text">打印UNICODE字符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E7%AA%97%E5%8F%A3%E7%B1%BB"><span class="toc-number">1.13.</span> <span class="toc-text">注册窗口类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E5%88%9B%E5%BB%BA"><span class="toc-number">1.14.</span> <span class="toc-text">窗口创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%9F%BA%E7%A1%80"><span class="toc-number">1.15.</span> <span class="toc-text">消息基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BD%9C%E7%94%A8"><span class="toc-number">1.15.1.</span> <span class="toc-text">消息的概念和作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-number">1.15.2.</span> <span class="toc-text">窗口处理函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%BE%AA%E7%8E%AF%E4%B8%AD%E7%9A%84%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0-%E6%B5%85%E8%B0%88"><span class="toc-number">1.15.3.</span> <span class="toc-text">消息循环中的相关函数(浅谈)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%B6%88%E6%81%AF"><span class="toc-number">1.16.</span> <span class="toc-text">常见消息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#WM-DESTORY"><span class="toc-number">1.16.1.</span> <span class="toc-text">WM_DESTORY</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WM-SYSCOMMAND"><span class="toc-number">1.16.2.</span> <span class="toc-text">WM_SYSCOMMAND</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WM-CREATE"><span class="toc-number">1.16.3.</span> <span class="toc-text">WM_CREATE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WM-SIZE"><span class="toc-number">1.16.4.</span> <span class="toc-text">WM_SIZE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WM-QUIT"><span class="toc-number">1.16.5.</span> <span class="toc-text">WM_QUIT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WM-PAINT"><span class="toc-number">1.16.6.</span> <span class="toc-text">WM_PAINT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7"><span class="toc-number">1.16.7.</span> <span class="toc-text">调试技巧</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.17.</span> <span class="toc-text">消息循环的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%BE%AA%E7%8E%AF%E7%9A%84%E9%98%BB%E5%A1%9E"><span class="toc-number">1.17.1.</span> <span class="toc-text">消息循环的阻塞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="toc-number">1.17.2.</span> <span class="toc-text">发送消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%88%86%E7%B1%BB"><span class="toc-number">1.17.3.</span> <span class="toc-text">消息分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">1.18.</span> <span class="toc-text">消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.18.1.</span> <span class="toc-text">消息队列的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.18.2.</span> <span class="toc-text">消息队列的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%92%8C%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.18.3.</span> <span class="toc-text">消息和消息队列的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GetMessage"><span class="toc-number">1.18.4.</span> <span class="toc-text">GetMessage</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%AE%E7%9B%98%E6%B6%88%E6%81%AF"><span class="toc-number">1.19.</span> <span class="toc-text">键盘消息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%AE%E7%9B%98%E6%B6%88%E6%81%AF%E5%88%86%E7%B1%BB"><span class="toc-number">1.19.1.</span> <span class="toc-text">键盘消息分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%B6%88%E6%81%AF-WM-CHAR"><span class="toc-number">1.19.2.</span> <span class="toc-text">字符消息(WM_CHAR)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BC%A0%E6%A0%87%E6%B6%88%E6%81%AF"><span class="toc-number">1.20.</span> <span class="toc-text">鼠标消息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BC%A0%E6%A0%87%E6%B6%88%E6%81%AF%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.20.1.</span> <span class="toc-text">鼠标消息的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BC%A0%E6%A0%87%E5%9F%BA%E6%9C%AC%E6%B6%88%E6%81%AF"><span class="toc-number">1.20.2.</span> <span class="toc-text">鼠标基本消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BC%A0%E6%A0%87%E5%8F%8C%E5%87%BB%E6%B6%88%E6%81%AF"><span class="toc-number">1.20.3.</span> <span class="toc-text">鼠标双击消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BC%A0%E6%A0%87%E6%BB%9A%E8%BD%AE%E6%B6%88%E6%81%AF"><span class="toc-number">1.20.4.</span> <span class="toc-text">鼠标滚轮消息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E6%B6%88%E6%81%AF"><span class="toc-number">1.21.</span> <span class="toc-text">定时器消息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E6%B6%88%E6%81%AF%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.21.1.</span> <span class="toc-text">定时器消息介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E9%94%80%E6%AF%81%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">1.21.2.</span> <span class="toc-text">创建销毁定时器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8F%9C%E5%8D%95%E8%B5%84%E6%BA%90"><span class="toc-number">1.22.</span> <span class="toc-text">菜单资源</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8F%9C%E5%8D%95%E5%88%86%E7%B1%BB"><span class="toc-number">1.22.1.</span> <span class="toc-text">菜单分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E7%9B%B8%E5%85%B3"><span class="toc-number">1.22.2.</span> <span class="toc-text">资源相关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8F%9C%E5%8D%95%E8%B5%84%E6%BA%90%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.22.3.</span> <span class="toc-text">菜单资源的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%B6%88%E6%81%AF-WM-COMMAND-%E5%A4%84%E7%90%86"><span class="toc-number">1.22.4.</span> <span class="toc-text">命令消息(WM_COMMAND)处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Windows%E8%B5%84%E6%BA%90"><span class="toc-number">1.23.</span> <span class="toc-text">Windows资源</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E6%A0%87%E8%B5%84%E6%BA%90"><span class="toc-number">1.23.1.</span> <span class="toc-text">图标资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%89%E6%A0%87%E8%B5%84%E6%BA%90"><span class="toc-number">1.23.2.</span> <span class="toc-text">光标资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%B5%84%E6%BA%90"><span class="toc-number">1.23.3.</span> <span class="toc-text">字符串资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E9%80%9F%E9%94%AE%E8%B5%84%E6%BA%90"><span class="toc-number">1.23.4.</span> <span class="toc-text">加速键资源</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%98%E5%9B%BE%E7%BC%96%E7%A8%8B"><span class="toc-number">1.24.</span> <span class="toc-text">绘图编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80"><span class="toc-number">1.24.1.</span> <span class="toc-text">绘图基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6"><span class="toc-number">1.24.2.</span> <span class="toc-text">基本图形绘制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GDI%E7%BB%98%E5%9B%BE%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.25.</span> <span class="toc-text">GDI绘图对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%BB%E7%AC%94"><span class="toc-number">1.25.1.</span> <span class="toc-text">画笔</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%BB%E5%88%B7"><span class="toc-number">1.25.2.</span> <span class="toc-text">画刷</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E5%9B%BE"><span class="toc-number">1.26.</span> <span class="toc-text">位图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E5%9B%BE%E7%BB%98%E5%88%B6"><span class="toc-number">1.26.1.</span> <span class="toc-text">位图绘制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E7%BB%98%E5%88%B6"><span class="toc-number">1.27.</span> <span class="toc-text">文本绘制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E5%AD%97%E7%9A%84%E7%BB%98%E5%88%B6"><span class="toc-number">1.27.1.</span> <span class="toc-text">文字的绘制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E4%BD%93"><span class="toc-number">1.27.2.</span> <span class="toc-text">字体</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%AF%9D%E6%A1%86"><span class="toc-number">1.28.</span> <span class="toc-text">对话框</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%AF%9D%E6%A1%86%E5%8E%9F%E7%90%86"><span class="toc-number">1.28.1.</span> <span class="toc-text">对话框原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AF%B9%E8%AF%9D%E6%A1%86"><span class="toc-number">1.28.2.</span> <span class="toc-text">模式对话框</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E6%A8%A1%E5%BC%8F%E5%AF%B9%E8%AF%9D%E6%A1%86"><span class="toc-number">1.28.3.</span> <span class="toc-text">无模式对话框</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%BA%93"><span class="toc-number">1.29.</span> <span class="toc-text">静态库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.29.1.</span> <span class="toc-text">静态库的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80%E9%9D%99%E6%80%81%E5%BA%93"><span class="toc-number">1.29.2.</span> <span class="toc-text">C语言静态库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E9%9D%99%E6%80%81%E5%BA%93"><span class="toc-number">1.29.3.</span> <span class="toc-text">C++静态库</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93"><span class="toc-number">1.30.</span> <span class="toc-text">动态库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.30.1.</span> <span class="toc-text">动态库的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">1.30.2.</span> <span class="toc-text">动态库的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.30.3.</span> <span class="toc-text">动态库的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93%E4%B8%AD%E5%B0%81%E8%A3%85%E7%B1%BB"><span class="toc-number">1.30.4.</span> <span class="toc-text">动态库中封装类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.31.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="toc-number">1.31.1.</span> <span class="toc-text">线程基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.31.2.</span> <span class="toc-text">创建线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%8C%82%E8%B5%B7-%E9%94%80%E6%AF%81"><span class="toc-number">1.31.3.</span> <span class="toc-text">线程挂起&#x2F;销毁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C"><span class="toc-number">1.31.4.</span> <span class="toc-text">线程相关操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">1.32.</span> <span class="toc-text">线程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E9%94%81"><span class="toc-number">1.32.1.</span> <span class="toc-text">原子锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5"><span class="toc-number">1.32.2.</span> <span class="toc-text">互斥</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.32.3.</span> <span class="toc-text">事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">1.32.4.</span> <span class="toc-text">信号量</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/01/13/%E3%80%90QT%E3%80%91QT%E5%AF%B9%E8%B1%A1%E6%A0%91/" title="【QT】QT对象树"><img src="/img/QT.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【QT】QT对象树"/></a><div class="content"><a class="title" href="/2022/01/13/%E3%80%90QT%E3%80%91QT%E5%AF%B9%E8%B1%A1%E6%A0%91/" title="【QT】QT对象树">【QT】QT对象树</a><time datetime="2022-01-13T14:09:50.000Z" title="发表于 2022-01-13 22:09:50">2022-01-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/13/%E3%80%90QT%E3%80%91QT%E5%85%83%E5%AF%B9%E8%B1%A1%E7%B3%BB%E7%BB%9F/" title="【QT】QT元对象系统"><img src="/img/QT.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【QT】QT元对象系统"/></a><div class="content"><a class="title" href="/2022/01/13/%E3%80%90QT%E3%80%91QT%E5%85%83%E5%AF%B9%E8%B1%A1%E7%B3%BB%E7%BB%9F/" title="【QT】QT元对象系统">【QT】QT元对象系统</a><time datetime="2022-01-13T03:24:58.000Z" title="发表于 2022-01-13 11:24:58">2022-01-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/11/%E3%80%90QT%E3%80%91%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AF%E4%BB%B6%E6%89%93%E5%8C%85%E5%8F%91%E5%B8%83/" title="【QT】自定义软件打包发布"><img src="/img/package.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【QT】自定义软件打包发布"/></a><div class="content"><a class="title" href="/2022/01/11/%E3%80%90QT%E3%80%91%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AF%E4%BB%B6%E6%89%93%E5%8C%85%E5%8F%91%E5%B8%83/" title="【QT】自定义软件打包发布">【QT】自定义软件打包发布</a><time datetime="2022-01-11T10:29:34.000Z" title="发表于 2022-01-11 18:29:34">2022-01-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/09/%E3%80%90MFC%E3%80%91MFC%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%92%8C%E6%B3%A8%E5%86%8C%E8%A1%A8%E6%93%8D%E4%BD%9C/" title="【MFC】MFC文件操作和注册表操作"><img src="/img/mfcfile.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【MFC】MFC文件操作和注册表操作"/></a><div class="content"><a class="title" href="/2022/01/09/%E3%80%90MFC%E3%80%91MFC%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%92%8C%E6%B3%A8%E5%86%8C%E8%A1%A8%E6%93%8D%E4%BD%9C/" title="【MFC】MFC文件操作和注册表操作">【MFC】MFC文件操作和注册表操作</a><time datetime="2022-01-09T04:58:44.000Z" title="发表于 2022-01-09 12:58:44">2022-01-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/08/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/" title="【操作系统】动态链接库"><img src="/img/dll.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【操作系统】动态链接库"/></a><div class="content"><a class="title" href="/2022/01/08/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/" title="【操作系统】动态链接库">【操作系统】动态链接库</a><time datetime="2022-01-08T03:05:05.000Z" title="发表于 2022-01-08 11:05:05">2022-01-08</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/win7.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 快乐的威猛先生</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a><br>
<img src="https://z3.ax1x.com/2021/08/28/h3o6iT.png" alt="h3o6iT.png" border="0" />
<a href="https://beian.miit.gov.cn/#/Integrated/recordQuery"  style="color:#f72b07" target="_blank">京ICP备2021006139号</a></div><div class="footer_custom_text">欢迎来访</div><div id="running-time"><script>setInterval(()=>{let create_time=Math.round(new Date('2021-03-08 19:27:17').getTime()/1000);let timestamp=Math.round((new Date().getTime()+8*60*60*1000)/1000);let second=timestamp-create_time;let time=new Array(0,0,0,0,0);if(second>=365*24*3600){time[0]=parseInt(second/(365*24*3600));second%=365*24*3600;}if(second>=24*3600){time[1]=parseInt(second/(24*3600));second%=24*3600;}if(second>=3600){time[2]=parseInt(second/3600);second%=3600;}if(second>=60){time[3]=parseInt(second/60);second%=60;}if(second>0){time[4]=second;}currentTimeHtml='本站已安全运行 '+time[0]+' 年 '+time[1]+' 天 '+time[2]+' 时 '+time[3]+' 分 '+time[4]+' 秒';document.getElementById("running-time").innerHTML=currentTimeHtml;},1000);</script></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script src="/js/nobanner.js"></script><script src="/js/weather.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script>(function(d, w, c) {
    w.ChatraID = '6KqzuZGb38hQrA6f6';
    var s = d.createElement('script');
    w[c] = w[c] || function() {
        (w[c].q = w[c].q || []).push(arguments);
    };
    s.async = true;
    s.src = 'https://call.chatra.io/chatra.js';
    if (d.head) d.head.appendChild(s);
})(document, window, 'Chatra');

if (true) {
  var chatBtnFn = () => {
    var chatBtn = document.getElementById("chat_btn")
    chatBtn.addEventListener("click", function(){
      Chatra('openChat')
    });
  }
  chatBtnFn()
} else {
  if (true) {
    function chatBtnHide () {
      Chatra('hide')
    }
    function chatBtnShow () {
      Chatra('show')
    }
  }
}</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start -->
  <script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/hexo-github-calendar@1.21/hexo_githubcalendar.js"></script>
  <script data-pjax>
        function GithubCalendarConfig(){
            var git_githubapiurl ="https://python-github-calendar-api.vercel.app/api?doraemon-hub-art";
            var git_color =['#ebedf0', '#fdcdec', '#fc9bd9', '#fa6ac5', '#f838b2', '#f5089f', '#c4067e', '#92055e', '#540336', '#48022f', '#30021f'];
            var git_user ="doraemon-hub-art";
            var parent_div_git = document.getElementById('recent-posts');
            var git_div_html = '<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_loading" style="width:10%;height:100%;margin:0 auto;display: block"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>';
            if(parent_div_git && location.pathname =='/'){
                console.log('已挂载github calendar')
                // parent_div_git.innerHTML=git_div_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",git_div_html) // 有报错，但不影响使用(支持pjax跳转)
            };
            GithubCalendar(git_githubapiurl,git_color,git_user)
        }
        if(document.getElementById('recent-posts')){
            GithubCalendarConfig()
        }
    </script>
    <style>#github_container{min-height:280px}@media screen and (max-width:650px) {#github_container{background-image:;min-height:0px}}</style>
    <style></style> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://doraemon-hub-art.github.io/categories/C/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 C++ (19)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://doraemon-hub-art.github.io/categories/C语言/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 C (16)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://doraemon-hub-art.github.io/categories/网络编程/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 网络编程 (7)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://doraemon-hub-art.github.io/categories/hexo/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 Hexo (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://doraemon-hub-art.github.io/categories/system/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 系统 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://doraemon-hub-art.github.io/categories/算法/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 算法 (32)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://doraemon-hub-art.github.io/categories/计算机/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 计算机 (9)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://doraemon-hub-art.github.io/categories/数据结构/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 数据结构 (25)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><a class="magnet_link_more"  href="https://doraemon-hub-art.github.io/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(50% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: RGB(73,177,245)}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
                        function butterfly_swiper_injector_config(){
                          var parent_div_git = document.getElementById('recent-posts');
                          var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2021/08/14/黑马程序员C++课程笔记总结/" alt=""><img width="48" height="48" src="/img/c++.png" alt=""/></a><div class="blog-slider__content"><span class="blog-slider__code">2021-08-14</span><a class="blog-slider__title" href="2021/08/14/黑马程序员C++课程笔记总结/" alt="">黑马程序员C++课程笔记总结</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" href="2021/08/14/黑马程序员C++课程笔记总结/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2021/08/26/【网络编程】基于TCPIP协议的CS模型/" alt=""><img width="48" height="48" src="/img/socket.png" alt=""/></a><div class="blog-slider__content"><span class="blog-slider__code">2021-08-26</span><a class="blog-slider__title" href="2021/08/26/【网络编程】基于TCPIP协议的CS模型/" alt="">【网络编程】基于TCP/IP协议的C/S模型</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" href="2021/08/26/【网络编程】基于TCPIP协议的CS模型/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2021/06/17/Hexo-Butterfly添加天气插件/" alt=""><img width="48" height="48" src="/img/taohua.png" alt=""/></a><div class="blog-slider__content"><span class="blog-slider__code">2021-06-17</span><a class="blog-slider__title" href="2021/06/17/Hexo-Butterfly添加天气插件/" alt="">Hexo-Butterfly添加天气插件</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" href="2021/06/17/Hexo-Butterfly添加天气插件/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2021/07/18/C语言实现学生成绩管理系统(EasyX图形窗口)/" alt=""><img width="48" height="48" src="/img/stuman2.png" alt=""/></a><div class="blog-slider__content"><span class="blog-slider__code">2021-07-18</span><a class="blog-slider__title" href="2021/07/18/C语言实现学生成绩管理系统(EasyX图形窗口)/" alt="">C语言实现学生成绩管理系统(EasyX图形窗口)</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" href="2021/07/18/C语言实现学生成绩管理系统(EasyX图形窗口)/" alt="">详情   </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
                          console.log('已挂载butterfly_swiper')
                          // parent_div_git.innerHTML=item_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                          parent_div_git.insertAdjacentHTML("afterbegin",item_html) // 有报错，但不影响使用(支持pjax跳转)
                          }
                        if( document.getElementById('recent-posts') && (location.pathname ==='all'|| 'all' ==='all')){
                        butterfly_swiper_injector_config()
                        }
                      </script><script defer src="https://cdnjs.cloudflare.com/ajax/libs/Swiper/4.1.6/js/swiper.min.js"></script><script defer data-pjax src="https://cdn.jsdelivr.net/npm/hexo-butterfly-swiper/lib/swiper_init.js"></script><!-- hexo injector body_end end --></body></html>