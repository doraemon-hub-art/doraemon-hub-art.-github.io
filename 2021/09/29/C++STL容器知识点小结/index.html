<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>C++STL容器知识点小结 | 半生瓜のblog</title><meta name="keywords" content="-C++11,-笔记,-C++,-STL"><meta name="author" content="Do2eM0N"><meta name="copyright" content="Do2eM0N"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="STL标准模板库 STL主要分为分为三类：  algorithm（算法） -  对数据进行处理（解决问题) 步骤的有限集合 container（容器） -  用来管理一组数据元素  Iterator (迭代器） -  可遍历STL容器内全部或部分元素”的对象  容器和算法通过迭代器可以进行无缝地连接。在STL中几乎所有的代码都采用了模板类和模板函数的方式，这相比于传统的由函数和类组成的库来说提供了">
<meta property="og:type" content="article">
<meta property="og:title" content="C++STL容器知识点小结">
<meta property="og:url" content="http://doraemon2.xyz/2021/09/29/C++STL%E5%AE%B9%E5%99%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%B0%8F%E7%BB%93/index.html">
<meta property="og:site_name" content="半生瓜のblog">
<meta property="og:description" content="STL标准模板库 STL主要分为分为三类：  algorithm（算法） -  对数据进行处理（解决问题) 步骤的有限集合 container（容器） -  用来管理一组数据元素  Iterator (迭代器） -  可遍历STL容器内全部或部分元素”的对象  容器和算法通过迭代器可以进行无缝地连接。在STL中几乎所有的代码都采用了模板类和模板函数的方式，这相比于传统的由函数和类组成的库来说提供了">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://doraemon2.xyz/img/c++.png">
<meta property="article:published_time" content="2021-09-29T02:16:05.000Z">
<meta property="article:modified_time" content="2021-09-29T11:26:09.293Z">
<meta property="article:author" content="Do2eM0N">
<meta property="article:tag" content="-C++11">
<meta property="article:tag" content="-笔记">
<meta property="article:tag" content="-C++">
<meta property="article:tag" content="-STL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://doraemon2.xyz/img/c++.png"><link rel="shortcut icon" href="/img/doraemon2.png"><link rel="canonical" href="http://doraemon2.xyz/2021/09/29/C++STL%E5%AE%B9%E5%99%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%B0%8F%E7%BB%93/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?4bd5c0d5704ac1dd90d20a471e6a167a";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-09-29 19:26:09'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><link rel="stylesheet" href="/css/xiaotubiao.css"><link rel="stylesheet" href="/footermeihua.css"><link rel="stylesheet" href="/css/hua.css"><link rel="stylesheet" href="/css/background.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Swiper/4.1.6/css/swiper.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-butterfly-swiper/lib/swiperstyle.css"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="半生瓜のblog" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/doraemon2.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">100</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">41</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/artitalk/"><i class="fa-fw fa fa-comments"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 伙伴</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/c++.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">半生瓜のblog</a><div id="tp-weather-widget"></div></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/artitalk/"><i class="fa-fw fa fa-comments"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 伙伴</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C++STL容器知识点小结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-09-29T02:16:05.000Z" title="发表于 2021-09-29 10:16:05">2021-09-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-09-29T11:26:09.293Z" title="更新于 2021-09-29 19:26:09">2021-09-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/">C++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C++STL容器知识点小结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>STL标准模板库</p>
<p>STL主要分为分为三类：</p>
<ul>
<li>algorithm（算法） -  对数据进行处理（解决问题) 步骤的有限集合</li>
<li>container（容器） -  用来管理一组数据元素</li>
<li> Iterator (迭代器） -  可遍历STL容器内全部或部分元素”的对象</li>
</ul>
<p>容器和算法通过迭代器可以进行无缝地连接。在STL中几乎所有的代码都采用了模板类和模板函数的方式，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。</p>
<p>STL 最早源于惠普实验室，早于C++存在，但是C++引入STL概念后，STL就成为C++的一部分，因为它被内建在你的编译器之内，不需要另行安装。</p>
<p>STL被组织为下面的13个头文件:</p>
<table>
<thead>
<tr>
<th>&lt; algorithm &gt;</th>
<th>&lt; memory &gt;</th>
</tr>
</thead>
<tbody><tr>
<td>&lt; deque &gt;</td>
<td>&lt; numeric &gt;</td>
</tr>
<tr>
<td>&lt; functional &gt;</td>
<td>&lt; queue &gt;</td>
</tr>
<tr>
<td>&lt; iterator &gt;</td>
<td>&lt; set &gt;</td>
</tr>
<tr>
<td>&lt; vector &gt;</td>
<td>&lt; stack &gt;</td>
</tr>
<tr>
<td>&lt; list &gt;</td>
<td>&lt; utility &gt;</td>
</tr>
<tr>
<td>&lt; map &gt;</td>
<td></td>
</tr>
</tbody></table>
<hr>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>在实际的开发过程中，数据结构本身的重要性完全不逊于算法的重要性，当程序中存在着对时间要求很高的部分时，数据结构的选择就显得更加重要。</p>
<p>经典的数据结构数量有限，但是在项目实战中，我们常常重复着一些为了存放不同数据类型而实现顺序表、链表等结构而重复编写的代码，这些代码都十分相似，只是为了适应不同数据类型的变化而在细节上有所出入。STL容器就为我们提供了这样的方便，它允许我们重复利用已有的实现构造自己的特定类型下的数据结构，通过设置一些模板，STL容器对最常用的数据结构提供了支持，这些模板的参数允许我们指定容器中元素的数据类型，避免重复编码。</p>
<p>容器部分主要有由&lt; vector &gt;,&lt; list &gt;,&lt; deque &gt;,&lt; set &gt;,&lt; map &gt;,&lt; stack &gt; 和&lt; queue &gt;组成。</p>
<p><img src="/images/C++STL%E5%AE%B9%E5%99%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%B0%8F%E7%BB%93.assets/image-20210927103557400.png" alt="image-20210927103557400"></p>
<p><strong>容器的访问方式:</strong><br>下标访问、迭代器访问(iterator)</p>
<p><strong>容器的存储将原来的数据拷贝一份(存放指针即可解决这个问题)。</strong>给这个类定义一个拷贝构造函数，看是否调用即可验证。</p>
<h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>vector是一个将元素置于动态数组中加以管理的容器。</p>
<p>vector可以随机存取元素，支持索引值直接存取， 用[]操作符或at()方法对元素进行操作。</p>
<p>vector尾部添加或移除元素非常快速。但是在中部或头部插入元素或移除元素<strong>比较费时</strong>。</p>
<p><strong>容量capacity要比真是的数据个数size大1。</strong></p>
<hr>
<p>当使用vector的默认构造函数(vector&lt; int &gt;v1)，不能直接通过下标访问，空间还没开辟。</p>
<h4 id="vector带参构造函数"><a href="#vector带参构造函数" class="headerlink" title="vector带参构造函数"></a>vector带参构造函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt; <span class="keyword">int</span> &gt;v2(存储元素个数，默认存储元素的数值);</span><br><span class="line">例如:</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v2(<span class="number">10</span>);</span><br><span class="line">构造时就分配空间，同时插入默认元素<span class="number">0</span></span><br><span class="line">指定容器中存储的元素个之后，此时该<span class="built_in">vector</span>的容量和大小相等。	</span><br><span class="line">(用默认<span class="built_in">vector</span>的默认构造函数之后再往里面push_back的话，<span class="built_in">vector</span>会自动开辟空间<span class="number">4</span>个<span class="number">4</span>个的扩容。)</span><br></pre></td></tr></table></figure>

<h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v3(v2);</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v4(v3.begin.() + x,v3.end());</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> test[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v4(test, test + <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v2.assign(<span class="number">2</span>,<span class="number">888</span>);<span class="comment">//改变vector中的元素个数和元素值</span></span><br><span class="line">v2.assign(v3.begin(),v3.end());<span class="comment">//使用迭代器赋值</span></span><br><span class="line">v2.assign(test,test+<span class="number">3</span>);<span class="comment">//使用指针赋值 </span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v2 = v3;<span class="comment">//调用赋值运算</span></span><br></pre></td></tr></table></figure>

<h4 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h4><p>vector会自动扩充存储大小。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">v2.resize(<span class="number">4</span>);<span class="comment">//重新调整v2容器大小，多余的被抹除。不够的以0填充。</span></span><br><span class="line"></span><br><span class="line">v2.resize(<span class="number">18</span>,<span class="number">666</span>);<span class="comment">//扩充v2大小，以666填充</span></span><br><span class="line"></span><br><span class="line">如果原来大小就是这么大，则不会发生变化。</span><br></pre></td></tr></table></figure>

<h4 id="尾部的添加和删除"><a href="#尾部的添加和删除" class="headerlink" title="尾部的添加和删除"></a>尾部的添加和删除</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v2.push_back(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">v2.pop_back();</span><br></pre></td></tr></table></figure>

<h4 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">下标访问</span><br><span class="line">    v2[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">at</span><br><span class="line">    v2.at(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">接口返回引用</span><br><span class="line">    v2.front();<span class="comment">//取到第一个元素</span></span><br><span class="line">	v2.end();<span class="comment">//取到最后一个元素</span></span><br></pre></td></tr></table></figure>

<h4 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入单个元素</span></span><br><span class="line">v2.insert(迭代器,插入的数值);</span><br><span class="line"><span class="comment">//插入多个元素</span></span><br><span class="line">v2.insert(v2.begin(),<span class="number">3</span>,<span class="number">888</span>);<span class="comment">//在开始的位置插入三个888</span></span><br><span class="line">v2.insert(v2.begin(),v3.begin(),v3.end());<span class="comment">//将v3的内容从v2开始插入进去。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入单个元素的时候返回值是一个迭代器</span></span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把整个vector干掉</span></span><br><span class="line">v2.clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">//干掉的单个元素</span></span><br><span class="line">v2.erase(v2.begin()+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//干掉多个元素</span></span><br><span class="line">v2.erase(v2.begin(),b2.begin()+<span class="number">1</span>);<span class="comment">//不包括结尾，“左闭右开”</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除单个元素返回值也是个迭代器</span></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p>deque是“double-ended queue”的缩写，和vector一样都是STL的容器，唯一不同的是：</p>
<p><strong>deque是双端数组，而vector是单端的。</strong></p>
<p><strong>Deque 特点</strong>：</p>
<ul>
<li> deque在接口上和vector非常相似，在许多操作的地方可以直接替换。</li>
<li>deque可以随机存取元素（支持索引值直接存取，用[]操作符或at()方法）</li>
<li>deque头部和尾部添加或移除元素都非常快速, 但是在中部安插元素或移除元素比较费时。</li>
</ul>
<p>使用时，包含头文件：#include &lt; deque &gt;  </p>
<p>(deque使用多个数组实现)</p>
<p><strong>对比</strong>：</p>
<p><img src="/images/C++STL%E5%AE%B9%E5%99%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%B0%8F%E7%BB%93.assets/image-20210927155900584.png" alt="image-20210927155900584"></p>
<p>多数操作同vector</p>
<p><strong>deuqe可以快速在头部和尾部进行添加或者移除</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>.push_back(element);	<span class="comment">//容器尾部添加一个数据</span></span><br><span class="line"><span class="built_in">deque</span>.push_front(element);	<span class="comment">//容器头部插入一个数据</span></span><br><span class="line"><span class="built_in">deque</span>.pop_back();    	    <span class="comment">//删除容器最后一个数据</span></span><br><span class="line"><span class="built_in">deque</span>.pop_front();		    <span class="comment">//删除容器第一个数据</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="deque的数据存取"><a href="#deque的数据存取" class="headerlink" title="deque的数据存取"></a>deque的数据存取</h4><ol>
<li><p>使用下标操作 deqIntA[0] = 100;</p>
</li>
<li><p>使用at 方法 如: deqIntA.at(2) = 100;</p>
</li>
<li><p>接口返回的引用 deqIntA.front() 和 deqIntA.back()  </p>
<p>注意：  第一和第二种方式必须注意越界</p>
</li>
</ol>
<hr>
<p><strong>end()返回的是一个指向最后一个元素之后位置的迭代器，就类似于字符串结束符。</strong></p>
<hr>
<h4 id="deque与迭代器"><a href="#deque与迭代器" class="headerlink" title="deque与迭代器"></a>deque与迭代器</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>.begin();  <span class="comment">//返回容器中第一个元素的迭代器。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>.end();  <span class="comment">//返回容器中最后一个元素之后的迭代器。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>.rbegin();  <span class="comment">//返回容器中倒数第一个元素的迭代器。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>.rend();  <span class="comment">//返回容器中倒数最后一个元素之后的迭代器。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>.cbegin();  <span class="comment">//返回容器中第一个元素的常量迭代器。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>.cend();  <span class="comment">//返回容器中最后一个元素之后的常量迭代器。</span></span><br></pre></td></tr></table></figure>

<hr>
<p>常量迭代器只能访问呢元素，不能修改元素。</p>
<hr>
<h4 id="deque的赋值"><a href="#deque的赋值" class="headerlink" title="deque的赋值"></a>deque的赋值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>.assign(beg,end);    <span class="comment">//将[beg, end)区间中的数据拷贝赋值给本身。注意该区间是左闭右开的区间。</span></span><br><span class="line"><span class="built_in">deque</span>.assign(n,elem);  <span class="comment">//将n个elem拷贝赋值给本身。</span></span><br><span class="line"><span class="built_in">deque</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">deque</span> &amp;deq);	<span class="comment">//重载等号操作符 </span></span><br><span class="line"><span class="built_in">deque</span>.swap(deq);  <span class="comment">// 将deque与本身的元素互换</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="deque的大小"><a href="#deque的大小" class="headerlink" title="deque的大小"></a>deque的大小</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>.size();	 		 <span class="comment">//返回容器中元素的个数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>.empty();	  <span class="comment">//判断容器是否为空</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>.resize(num);  	<span class="comment">//重新指定容器的长度为num，若容器变长，则以默认值0填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>.resize(num, elem);  <span class="comment">//重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="deque的插入"><a href="#deque的插入" class="headerlink" title="deque的插入"></a>deque的插入</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>.insert(pos,elem);  <span class="comment">//在pos位置插入一个elem元素的拷贝，返回新数据							的位置。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>.insert(pos,n,elem);  <span class="comment">//在pos位置插入n个elem数据，无返回值。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>.insert(pos,beg,end);  <span class="comment">//在pos位置插入[beg,end)区间的数据，无返回值</span></span><br></pre></td></tr></table></figure>

<h4 id="deque的删除"><a href="#deque的删除" class="headerlink" title="deque的删除"></a>deque的删除</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>.clear();	   <span class="comment">//移除容器的所有数据</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>.erase(beg,end); <span class="comment">//删除[beg,end)区间的数据，返回下一个数据的位置。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>.erase(pos);   <span class="comment">//删除pos位置的数据，返回下一个数据的位置。</span></span><br></pre></td></tr></table></figure>

<p><strong>注意迭代器遍历删除</strong></p>
<p>删除一个元素该位置的元素是会前移的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::iterator it = deqIntA.begin(); it!=deqIntA.end();)&#123;</span><br><span class="line">		<span class="keyword">if</span>(*it == <span class="number">4</span>)&#123;</span><br><span class="line">            <span class="comment">//接收-返回指向下一个位置的迭代器</span></span><br><span class="line">			it = deqIntA.erase(it);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;*it;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">			it++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>list是一个<strong>双向链表容器</strong>，可高效地进行插入删除元素。</p>
<p><strong>List 特点：</strong></p>
<ul>
<li> list不可以随机存取元素，所以不支持at.(position)函数与[]操作符。可以对其迭代器执行++，但是不能这样操作迭代器：it+3。</li>
</ul>
<p>  <strong>即：</strong>list的迭代器不能加数字，但可以通过多次自增达到效果。</p>
<ul>
<li>使用时包含 #include &lt; list &gt;   </li>
</ul>
<h4 id="list对象的默认构造"><a href="#list对象的默认构造" class="headerlink" title="list对象的默认构造"></a>list对象的默认构造</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>同样采用模板类实现,对象的默认构造形式：<span class="built_in">list</span>&lt;T&gt; listT;  如：</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lstInt;       <span class="comment">//定义一个存放int的list容器。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">float</span>&gt; lstFloat;     <span class="comment">//定义一个存放float的list容器。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; lstString;    <span class="comment">//定义一个存放string的list容器。</span></span><br></pre></td></tr></table></figure>

<p>注意：尖括号内还可以设置指针类型或自定义类型。</p>
<hr>
<p>vector的内存空间是预先分配的。</p>
<p>list不存在capacity方法，所以它并没有提前分配空间。</p>
<hr>
<h4 id="list对象的带参数构造"><a href="#list对象的带参数构造" class="headerlink" title="list对象的带参数构造"></a>list对象的带参数构造</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">方式一：<span class="built_in">list</span>(beg,end);   <span class="comment">//将[beg, end)区间中的元素拷贝给本身。</span></span><br><span class="line"></span><br><span class="line">方式二：<span class="built_in">list</span>(n,elem);    <span class="comment">//构造函数将n个elem拷贝给本身。</span></span><br><span class="line"></span><br><span class="line">方式三：<span class="built_in">list</span>(<span class="keyword">const</span> <span class="built_in">list</span> &amp;lst); <span class="comment">//拷贝构造函数。</span></span><br></pre></td></tr></table></figure>



<h4 id="list头尾的添加移除操作"><a href="#list头尾的添加移除操作" class="headerlink" title="list头尾的添加移除操作"></a>list头尾的添加移除操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>.push_back(elem);	  <span class="comment">//在容器尾部加入一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>.pop_back();      <span class="comment">//删除容器中最后一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>.push_front(elem);   <span class="comment">//在容器开头插入一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>.pop_front();      <span class="comment">//从容器开头移除第一个元素</span></span><br></pre></td></tr></table></figure>

<h4 id="list的数据存取"><a href="#list的数据存取" class="headerlink" title="list的数据存取"></a>list的数据存取</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>.front();   <span class="comment">//返回第一个元素。</span></span><br><span class="line"><span class="built_in">list</span>.back();  <span class="comment">//返回最后一个元素。</span></span><br></pre></td></tr></table></figure>

<h4 id="list与迭代器"><a href="#list与迭代器" class="headerlink" title="list与迭代器"></a>list与迭代器</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>.begin();     <span class="comment">//返回容器中第一个元素的迭代器。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>.end();      <span class="comment">//返回容器中最后一个元素之后的迭代器。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>.rbegin();     <span class="comment">//返回容器中倒数第一个元素的迭代器。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>.rend();     <span class="comment">//返回容器中倒数最后一个元素的后面的迭代器。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>.cbegin();  <span class="comment">//返回容器中第一个元素的常量迭代器。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>.cend();  <span class="comment">//返回容器中最后一个元素之后的常量迭代器。</span></span><br></pre></td></tr></table></figure>

<h4 id="list的赋值"><a href="#list的赋值" class="headerlink" title="list的赋值"></a>list的赋值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>.assign(beg,end);   <span class="comment">//将[beg, end)区间中的数据拷贝赋值给本身。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>.assign(n,elem);  <span class="comment">//将n个elem拷贝赋值给本身。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">list</span> &amp;lst);	<span class="comment">//重载等号操作符。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>.swap(lst);  <span class="comment">// 将lst与本身的元素互换。</span></span><br></pre></td></tr></table></figure>

<h4 id="list的大小"><a href="#list的大小" class="headerlink" title="list的大小"></a>list的大小</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ist.size();	  <span class="comment">//返回容器中元素的个数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>.empty();	  <span class="comment">//判断容器是否为空</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>.resize(num);  <span class="comment">//重新指定容器的长度为num，若容器变长，则以默认值0填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>.resize(num, elem);  <span class="comment">//重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</span></span><br></pre></td></tr></table></figure>

<h4 id="list的插入"><a href="#list的插入" class="headerlink" title="list的插入"></a>list的插入</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>.insert(pos,elem);  <span class="comment">//在pos位置插入一个elem元素的拷贝，返回新数据的位置。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>.insert(pos,n,elem);  <span class="comment">//在pos位置插入n个elem数据，无返回值。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>.insert(pos,beg,end);  <span class="comment">//在pos位置插入[beg,end)区间的数据，无返回值。</span></span><br></pre></td></tr></table></figure>

<h4 id="list的删除"><a href="#list的删除" class="headerlink" title="list的删除"></a>list的删除</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>.clear();		<span class="comment">//移除容器的所有数据</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>.erase(beg,end);  <span class="comment">//**删除****[beg,end)**区间的数据，返回下一个数据的位置。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>.erase(pos);   <span class="comment">//删除pos位置的数据，返回下一个数据的位置。</span></span><br><span class="line"></span><br><span class="line">lst.remove(elem);  <span class="comment">//删除容器中所有与elem值匹配的元素。</span></span><br></pre></td></tr></table></figure>

<p><strong>vector和deque中没有remove操作</strong></p>
<h4 id="list的反序排列"><a href="#list的反序排列" class="headerlink" title="list的反序排列"></a>list的反序排列</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">l <span class="built_in">list</span>.reverse();   <span class="comment">//反转链表，比如list包含1, 2, 3, 4, 5五个元素，运行此方法后，list就包含5, 4, 3, 2, 1元素。</span></span><br></pre></td></tr></table></figure>

<h3 id="set-multiset"><a href="#set-multiset" class="headerlink" title="set/multiset"></a>set/multiset</h3><h4 id="set-multiset容器概念"><a href="#set-multiset容器概念" class="headerlink" title="set/multiset容器概念"></a>set/multiset容器概念</h4><p>set和multiset是一个<strong>集合</strong>容器，其中set所包含的元素是唯一的，集合中的元素按一定的顺序排列。set采用<strong>红黑树</strong>变体的数据结构实现，红黑树属于平衡二叉树。在插入操作和删除操作上比vector快。在n个数中查找目标数的效率是 log2 n 。</p>
<hr>
<p>C++11新特性:变参模板、完美转发和empalce——<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_51604330/article/details/120517535?spm=1001.2014.3001.5501">C++11新特性:变参模板、完美转发和emplace</a></p>
<hr>
<h4 id="红黑树定义"><a href="#红黑树定义" class="headerlink" title="红黑树定义"></a>红黑树定义</h4><p>是每个节点都带有颜色属性（颜色为红色或黑色）的自平衡二叉查找树，满足下列性质：</p>
<ol>
<li>节点是红色或黑色</li>
<li>根节点是黑色</li>
<li>所有叶子节点都是黑色节点(NULL)</li>
<li>每个红色节点必须有两个黑色的子节点。(从每个叶子到根的所有路径上不能有两个连续的红色节点。</li>
<li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。</li>
</ol>
<p><img src="/images/C++STL%E5%AE%B9%E5%99%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%B0%8F%E7%BB%93.assets/image-20210928091221639.png" alt="image-20210928091221639"></p>
<h4 id="set-和-multiset-特点"><a href="#set-和-multiset-特点" class="headerlink" title="set 和 multiset 特点"></a>set 和 multiset 特点</h4><ol>
<li>set中元素插入过程是按排序规则插入(自动排序)，所以<strong>不能指定插入位置</strong>。</li>
<li>set不可以直接存取元素。（不可以使用at.(pos)与[]操作符）。</li>
<li>multiset与set的区别：set支持唯一键值，每个元素值只能出现一次；而multiset中<strong>同一值可以出现多次</strong>。</li>
<li>不可以直接修改set或multiset容器中的元素值，因为该类容器是自动排序的。<strong>如果希望修改一个元素值，必须先删除原有的元素，再插入新的元素。</strong></li>
</ol>
<p>头文件 #include &lt; set &gt;  </p>
<h4 id="set-multiset对象的默认构造"><a href="#set-multiset对象的默认构造" class="headerlink" title="set/multiset对象的默认构造"></a>set/multiset对象的默认构造</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; setInt;        <span class="comment">//一个存放int的set容器。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">float</span>&gt; setFloat;      <span class="comment">//一个存放float的set容器。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; setString;     <span class="comment">//一个存放string的set容器。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; mulsetInt;       <span class="comment">//一个存放int的multi set容器。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">float</span>&gt; multisetFloat;    <span class="comment">//一个存放float的multi set容器。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="built_in">string</span>&gt; multisetString;   <span class="comment">//一个存放string的multi set容器。</span></span><br></pre></td></tr></table></figure>

<h4 id="set-multiset-对象的带参构造函数"><a href="#set-multiset-对象的带参构造函数" class="headerlink" title="set/multiset 对象的带参构造函数"></a>set/multiset 对象的带参构造函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>(beg,end);   <span class="comment">//将[beg, end)区间中的元素拷贝给本身。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(<span class="keyword">const</span> <span class="built_in">set</span> &amp;s); <span class="comment">//拷贝构造函数。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">multiset</span>(beg,end);   <span class="comment">//将[beg, end)区间中的元素拷贝给本身。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">multiset</span>(<span class="keyword">const</span> <span class="built_in">multiset</span> &amp;s); <span class="comment">//拷贝构造函数。</span></span><br></pre></td></tr></table></figure>

<h4 id="set对象的拷贝构造与赋值"><a href="#set对象的拷贝构造与赋值" class="headerlink" title="set对象的拷贝构造与赋值"></a>set对象的拷贝构造与赋值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>(<span class="keyword">const</span> <span class="built_in">set</span> &amp;st);		    <span class="comment">//拷贝构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">set</span> &amp;st);	<span class="comment">//重载等号操作符</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>.swap(st);				  <span class="comment">//交换两个集合容器</span></span><br></pre></td></tr></table></figure>

<hr>
<p>仿函数(函数对象)——<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_51604330/article/details/120533423">C++仿函数(函数对象)</a>（STL重点）</p>
<hr>
<h4 id="set的插入和pair的用法"><a href="#set的插入和pair的用法" class="headerlink" title="set的插入和pair的用法"></a>set的插入和pair的用法</h4><p>pair表示一个<strong>对组</strong>，它将两个值视为一个单元，把两个值捆绑在一起。</p>
<p>pair&lt;T1,T2&gt;用来存放的两个值的类型，可以不一样，也可以一样，如T1为int，T2为float。T1,T2也可以是自定义类。</p>
<p>pair.first是pair里面的第一个值，是T1类型。</p>
<p>pair.second是pair里面的第二个值，是T2类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>容器的insert的返回值是一个对组</span><br><span class="line">    <span class="built_in">pair</span>&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator,<span class="keyword">bool</span> &gt;ret = s1.insert(<span class="number">5</span>);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;*(ret.first)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ret.second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">first返回插入元素的迭代器,*它得到的就是这个数值</span><br></pre></td></tr></table></figure>

<h4 id="set与迭代器"><a href="#set与迭代器" class="headerlink" title="set与迭代器"></a><strong>set与迭代器</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>.insert(elem);   <span class="comment">//在容器中插入元素。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>.begin();     <span class="comment">//返回容器中第一个数据的迭代器。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>.end();      <span class="comment">//返回容器中最后一个数据之后的迭代器。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>.rbegin();     <span class="comment">//返回容器中倒数第一个元素的迭代器。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>.rend();     <span class="comment">//返回容器中倒数最后一个元素的后面的迭代器。</span></span><br></pre></td></tr></table></figure>

<p>注意循环遍历删除的时候it++的位置。</p>
<h4 id="set-multiset的大小"><a href="#set-multiset的大小" class="headerlink" title="set/multiset的大小"></a>set/multiset的大小</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>.size();	<span class="comment">//返回容器中元素的数目</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>.empty();<span class="comment">//判断容器是否为空</span></span><br></pre></td></tr></table></figure>

<p>注意事项： 它们没有resize 方法</p>
<h4 id="set-multiset的删除"><a href="#set-multiset的删除" class="headerlink" title="set/multiset的删除"></a>set/multiset的删除</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>.clear();		 <span class="comment">//清除所有元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>.erase(pos);   <span class="comment">//删除pos迭代器所指的元素，返回下一个元素的迭代器。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>.erase(beg,end);	 <span class="comment">//删除区间[beg,end)的所有元素，返回下一个元素的迭代器。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>.erase(elem);   <span class="comment">//删除容器中值为elem的元素,返回删除元素的数量</span></span><br></pre></td></tr></table></figure>

<p><strong>删除区间内的某个或某些元素</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">setInt是用<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;声明的容器，假设它内部现已包含按顺序的<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>元素。</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator itBegin=setInt.begin();</span><br><span class="line"></span><br><span class="line">++ itBegin;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator itEnd=setInt.begin();</span><br><span class="line"></span><br><span class="line">++ itEnd;</span><br><span class="line"></span><br><span class="line">++ itEnd;</span><br><span class="line"></span><br><span class="line">++ itEnd;</span><br><span class="line"></span><br><span class="line">setInt.erase(itBegin,itEnd);</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时容器setInt包含按顺序的1, 4, 5, 6四个元素。</span></span><br></pre></td></tr></table></figure>

<p><strong>删除容器中第一个元素</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setInt.erase(setInt.begin());	</span><br></pre></td></tr></table></figure>

<p><strong>删除容器中值为x的元素</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setInt.erase(<span class="number">5</span>); </span><br></pre></td></tr></table></figure>

<p><strong>删除setInt的所有元素</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setInt.clear();			<span class="comment">//容器为空</span></span><br></pre></td></tr></table></figure>

<h4 id="set-multiset的查找"><a href="#set-multiset的查找" class="headerlink" title="set/multiset的查找"></a>set/multiset的查找</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>.find(elem);  <span class="comment">//查找elem元素，返回指向elem元素的迭代器。</span></span><br><span class="line"><span class="comment">//find是否查找到元素，可以通过返回的迭代器和容器的end()方法进行比较。end()就相当于字符串结束符，返回最后一个元素后面位置的迭代器。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>.count(elem);  <span class="comment">//返回容器中值为elem的元素个数。对set来说，要么是0，要么是1。对multiset来说，值可能大于1。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>.lower_bound(elem);  <span class="comment">//返回第一个&gt;=elem元素的迭代器。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>.upper_bound(elem);	  <span class="comment">//  返回第一个&gt;elem元素的迭代器。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>.equal_range(elem);		<span class="comment">//返回multiset容器中与elem相等的上下限的两个迭代器。上限是闭区间，下限是开区间，如[beg,end)。这个函数返回两个迭代器，而这两个迭代器被封装在pair中。</span></span><br><span class="line"> <span class="comment">//例如 1 2 3 3 3 4 返回的是[3,6);</span></span><br></pre></td></tr></table></figure>

<h3 id="map-multimap"><a href="#map-multimap" class="headerlink" title="map/multimap"></a>map/multimap</h3><p>map是标准的<strong>关联式</strong>容器，一个map里存储的元素是一个键值对序列，叫做(key,value)键值对。它提供基于key快速检索数据的能力。</p>
<ol>
<li><p>map中<strong>key值是唯一的</strong>。集合中的元素按一定的顺序排列。元素插入过程是按排序规则插入，所以不能指定插入位置。</p>
</li>
<li><p>map底层的具体实现是采用红黑树变体的平衡二叉树的数据结构。在插入操作、删除和检索操作上比vector快很多。</p>
</li>
<li><p>map可以直接存取key所对应的value，支持[]操作符，如map[key]=value。</p>
<p>#include <map></p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt;m1;</span><br><span class="line">m1.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt;(<span class="number">18</span>,<span class="string">&quot;xiaohua&quot;</span>));</span><br></pre></td></tr></table></figure>

<p><strong>multimap与map的区别</strong></p>
<p>map支持唯一键值，每个键只能出现一次；而multimap中相同键可以出现多次。multimap不支持[]操作符。</p>
<h4 id="map-multimap对象的默认构造"><a href="#map-multimap对象的默认构造" class="headerlink" title="map/multimap对象的默认构造"></a>map/multimap对象的默认构造</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>/<span class="built_in">multimap</span>采用模板类实现，对象的默认构造形式：</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;T1,T2&gt; mapTT; </span><br><span class="line"></span><br><span class="line"><span class="built_in">multimap</span>&lt;T1,T2&gt;  multimapTT;  </span><br><span class="line"></span><br><span class="line">如：</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt; mapA;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">float</span>&gt; mapB;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其中T1,T2还可以用各种指针类型或自定义类型</span></span><br></pre></td></tr></table></figure>

<h4 id="map和multimap对象的带参数构造"><a href="#map和multimap对象的带参数构造" class="headerlink" title="map和multimap对象的带参数构造"></a>map和multimap对象的带参数构造</h4><p>方式一：map(beg,end);   //将[beg, end)区间中的元素拷贝给本身。</p>
<p>方式二：map(const map &amp;mapObject); //拷贝构造函数。</p>
<h4 id="map的插入与迭代器"><a href="#map的插入与迭代器" class="headerlink" title="map的插入与迭代器"></a>map的插入与迭代器</h4><p>map.insert(…);   //往容器插入元素，返回pair&lt;iterator,bool&gt;</p>
<p><strong>map中插入元素的四种方式</strong>：</p>
<p>假设  map&lt;int, string&gt; mapStu;</p>
<p>方式一、通过pair的方式插入对象</p>
<p>mapStu.insert(  pair&lt;int,string&gt;(1,”张三”)  );</p>
<p><strong>例如:</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; m1;</span><br><span class="line">m1.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">18</span>, <span class="string">&quot;王小花&quot;</span>));</span><br><span class="line"><span class="built_in">pair</span>&lt;<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt;::iterator,<span class="keyword">bool</span>&gt;ret = 		m1.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">18</span>, <span class="string">&quot;李小花&quot;</span>));</span><br><span class="line"><span class="keyword">if</span> (ret.second == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;成功啦&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;失败&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>方式二、通过pair的方式插入对象</p>
<p>mapStu.inset(make_pair(2, “李四”));</p>
<p>方式三、通过value_type的方式插入对象</p>
<p>mapStu.insert(  map&lt;int,string&gt;::value_type(3,”王五”)  );</p>
<p>方式四、通过数组的方式插入值</p>
<p>如果键值对已经存在则覆盖原值。</p>
<p>mapStu[4] = “赵六”;</p>
<p>mapStu[4] = “赵四”;覆盖赵六</p>
<p>mapStu[5] = “小七”；</p>
<p>(没有数值默认初始化)    </p>
<p><strong>注意：</strong> </p>
<p> 前三种方法，采用的是insert()方法，该方法<strong>返回值为pair&lt;iterator,bool&gt;</strong></p>
<p>此三种方式插入重复的键值会插入均会失败。 </p>
<p> 第四种方法非常直观，但碰到相同的键时会进行覆盖操作。比如插入key 为4的键值时，先在mapStu中查找主键为4的项，若不存在，则将一个键为4，值为默认初始化值的对组插入到mapStu中，然后再将值修改成“赵六”。若发现已存在4这个键，则修改这个键对应的value。</p>
<p>string strName = mapStu[8];  //取值操作或插入操作</p>
<p>l只有当mapStu存在8这个键时才是正确的取操作，否则会自动插入一个实例，键为8，值为默认构造时的初始化值。</p>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>.begin();  <span class="comment">//返回容器中第一个数据的迭代器。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>.end();  <span class="comment">//返回容器中最后一个数据之后的迭代器。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>.rbegin();  <span class="comment">//返回容器中倒数第一个元素的迭代器。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>.rend();  <span class="comment">//返回容器中倒数最后一个元素的后面的迭代器。</span></span><br></pre></td></tr></table></figure>

<h4 id="map-multimap-排序"><a href="#map-multimap-排序" class="headerlink" title="map/multimap 排序"></a>map/multimap 排序</h4><p><strong>参数</strong></p>
<p><img src="/images/C++STL%E5%AE%B9%E5%99%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%B0%8F%E7%BB%93.assets/image-20210928201038963.png" alt="image-20210928201038963"></p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;T1,T2,less&lt;T1&gt; &gt;  mapA;  <span class="comment">//该容器是按键的升序方式排列元素。未指定函数对象，默认采用less&lt;T1&gt;函数对象。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;T1,T2,greater&lt;T1&gt;&gt; mapB;  <span class="comment">//该容器是按键的降序方式排列元素。</span></span><br><span class="line"></span><br><span class="line">less&lt;T1&gt;与greater&lt;T1&gt;  可以替换成其它的函数对象functor。</span><br><span class="line"></span><br><span class="line">可编写自定义函数对象以进行自定义类型的比较，使用方法与<span class="built_in">set</span>构造时所用的函数对象一样。</span><br></pre></td></tr></table></figure>

<h4 id="map对象的拷贝构造与赋值"><a href="#map对象的拷贝构造与赋值" class="headerlink" title="map对象的拷贝构造与赋值"></a>map对象的拷贝构造与赋值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>(<span class="keyword">const</span> <span class="built_in">map</span> &amp;mp);		   <span class="comment">//拷贝构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">map</span> &amp;mp);	<span class="comment">//重载等号操作符</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>.swap(mp);				<span class="comment">//交换两个集合容器	</span></span><br></pre></td></tr></table></figure>

<h4 id="map的大小"><a href="#map的大小" class="headerlink" title="map的大小"></a>map的大小</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>.size();	<span class="comment">//返回容器中元素的数目</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>.empty();<span class="comment">//判断容器是否为空</span></span><br></pre></td></tr></table></figure>

<h4 id="map的删除"><a href="#map的删除" class="headerlink" title="map的删除"></a>map的删除</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>.clear();		<span class="comment">//删除所有元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>.erase(pos);	<span class="comment">//删除pos迭代器所指的元素，返回下一个元素的迭代器。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>.erase(beg,end);<span class="comment">//删除区间[beg,end)的所有元素	，返回下一个元素的迭代器。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>.erase(key);   <span class="comment">//删除容器中key为key的对组,返回删除的对组个数，失败返回0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>.erase(key_type *first, key_type *last)  <span class="comment">//删除数组指定的半闭半开的区间中 特定的key对应的所有队组</span></span><br><span class="line">例如:</span><br><span class="line">	<span class="keyword">int</span> range[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="map-multimap的查找"><a href="#map-multimap的查找" class="headerlink" title="map/multimap的查找"></a>map/multimap的查找</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>.find(key);  查找键key是否存在，若存在，返回该键的元素的迭代器；若不存在，返回<span class="built_in">map</span>.end();</span><br><span class="line"><span class="comment">//因为multimap中可以存在重复的键值，所以用循环迭代器查找的时候，可以输入具有相同键值的元素。</span></span><br><span class="line"><span class="comment">//例如</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;m1;</span><br><span class="line">m1.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt;(<span class="number">18</span>, <span class="string">&quot;sb&quot;</span>));</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator it = m1.find(<span class="number">18</span>);</span><br><span class="line"><span class="keyword">if</span> (it != m1.end())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;<span class="comment">//这个比count控制循环更灵活实用性更强</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>.count(key);  <span class="comment">//返回容器中键值为key的对组个数。对map来说，要么是0，要么是1;对multimap来说，值&gt;=0。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>.lower_bound(keyElem);  <span class="comment">//返回第一个key&gt;=keyElem元素的迭代器。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>.upper_bound(keyElem);	  <span class="comment">//  返回第一个key&gt;keyElem元素的迭代器。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>.equal_range(keyElem);		<span class="comment">//返回容器中key与keyElem相等的上下限的两个迭代器。上限是闭区间，下限是开区间，如[beg,end)。（multimap重复元素	）</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">最后一个的代码示例</span><br><span class="line"><span class="built_in">multimap</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mul1;</span><br><span class="line">mul1.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">1</span>, <span class="string">&quot;甲&quot;</span>));</span><br><span class="line">mul1.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">2</span>, <span class="string">&quot;乙&quot;</span>));</span><br><span class="line">mul1.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">2</span>, <span class="string">&quot;丙&quot;</span>));</span><br><span class="line">mul1.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">3</span>, <span class="string">&quot;丁&quot;</span>));</span><br><span class="line">mul1.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">4</span>, <span class="string">&quot;卯&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回的是两个玩意，所以要对组接收</span></span><br><span class="line"><span class="built_in">pair</span>&lt;<span class="built_in">multimap</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator,<span class="built_in">multimap</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator&gt; RecvPari = mul1.equal_range(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (RecvPari.first != mul1.end())<span class="comment">//就相当于对组与对组对比</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//注意对应map的元素存放在对组中</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (*RecvPari.first).second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (RecvPari.second != mul1.end())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//存放value在该对组的第二位</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (*RecvPari.second).second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出乙和丁</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><h4 id="queue简介"><a href="#queue简介" class="headerlink" title="queue简介"></a>queue简介</h4><ol>
<li>queue是队列容器，是一种“先进先出”的容器。</li>
<li>默认情况下<strong>queue是利用deque容器</strong>实现的一种容器。</li>
<li>它只允许在队列的前端（front）进行删除操作，而在队列的后端（back）进行插入操作</li>
<li>#include <queue>  </li>
</ol>
<p>默认用deque容器实现</p>
<p><img src="/images/C++STL%E5%AE%B9%E5%99%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%B0%8F%E7%BB%93.assets/image-20210929092413249.png" alt="image-20210929092413249"></p>
<p>可以显式指定类型来控制用什么容器实现</p>
<p>例如:（注意作为内置容器的容器是否与queue兼容）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>,<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&gt;;</span><br></pre></td></tr></table></figure>



<h4 id="queue对象的默认构造"><a href="#queue对象的默认构造" class="headerlink" title="queue对象的默认构造"></a>queue对象的默认构造</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>采用模板类实现，<span class="built_in">queue</span>对象的默认构造形式：<span class="built_in">queue</span>&lt;T&gt; queT; 如：</span><br><span class="line"> </span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; queueInt;       <span class="comment">//一个存放int的queue容器。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">float</span>&gt; queueFloat;   <span class="comment">//一个存放float的queue容器。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; queueString;   <span class="comment">//一个存放string的queue容器。</span></span><br><span class="line"></span><br><span class="line">...				  </span><br><span class="line">注意： 尖括号内还可以设置指针类型或自定义类型。</span><br></pre></td></tr></table></figure>

<h4 id="queue-对象的带参构造"><a href="#queue-对象的带参构造" class="headerlink" title="queue 对象的带参构造"></a>queue 对象的带参构造</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>, <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&gt; queueList; <span class="comment">//内部使用list 来存储队列元素的queue 容器.</span></span><br><span class="line"></span><br><span class="line">错误: <span class="built_in">queue</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; queueList; <span class="comment">//内部不能使用vector来存储队列元素			</span></span><br></pre></td></tr></table></figure>



<h4 id="queue的push-与pop-方法"><a href="#queue的push-与pop-方法" class="headerlink" title="queue的push()与pop()方法"></a>queue的push()与pop()方法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>.push(elem);  <span class="comment">//往队尾添加元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>.pop();    <span class="comment">//从队头处移除队首元素</span></span><br></pre></td></tr></table></figure>

<h4 id="queue对象的拷贝构造与赋值"><a href="#queue对象的拷贝构造与赋值" class="headerlink" title="queue对象的拷贝构造与赋值"></a>queue对象的拷贝构造与赋值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>(<span class="keyword">const</span> <span class="built_in">queue</span> &amp;que);		   <span class="comment">//拷贝构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">queue</span> &amp;que);	<span class="comment">//重载等号操作符</span></span><br></pre></td></tr></table></figure>

<h4 id="queue的数据存取"><a href="#queue的数据存取" class="headerlink" title="queue的数据存取"></a>queue的数据存取</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>.back();  <span class="comment">//返回最后一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>.front();  <span class="comment">//返回第一个元素</span></span><br><span class="line"></span><br><span class="line">可以通过这两个接口修改容器对应内容，因为返回的是引用</span><br><span class="line"> </span><br><span class="line">存放自定义对象的时候考虑<span class="built_in">queue</span>.emplace</span><br></pre></td></tr></table></figure>

<h4 id="queue的大小"><a href="#queue的大小" class="headerlink" title="queue的大小"></a>queue的大小</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>.empty();  <span class="comment">//判断队列是否为空</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>.size(); 	   <span class="comment">//返回队列的大小</span></span><br></pre></td></tr></table></figure>

<h4 id="优先级队列priority-queue"><a href="#优先级队列priority-queue" class="headerlink" title="优先级队列priority_queue"></a>优先级队列priority_queue</h4><p><strong>优先队列</strong>： 它的入队顺序没有变化，但是出队的顺序是根据优先级的高低来决定的。<strong>优先级高的优先出队。</strong></p>
<p><strong>默认值越大优先级越大。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">priority_queue</span>(<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;);<span class="comment">//值越小优先级越大</span></span><br><span class="line"><span class="built_in">priority_queue</span>(<span class="keyword">int</span>,<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;);<span class="comment">//值越小优先级越大</span></span><br></pre></td></tr></table></figure>

<h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><p>stack是堆栈容器，是一种”先进后出的容器”。</p>
<p>默认基于deque容器实现的容器。</p>
<p>(如果用vector实现，在前面删除元素涉及到元素的移动，效率不如deque，一般情况下不建议使用vector。)</p>
<h4 id="stack对象的默认构造"><a href="#stack对象的默认构造" class="headerlink" title="stack对象的默认构造"></a>stack对象的默认构造</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>采用模板类实现， <span class="built_in">stack</span>对象的默认构造形式： <span class="built_in">stack</span> &lt;T&gt; stkT;  </span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span> &lt;<span class="keyword">int</span>&gt; stkInt;       <span class="comment">//一个存放int的stack容器。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span> &lt;<span class="keyword">float</span>&gt; stkFloat;   <span class="comment">//一个存放float的stack容器。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span> &lt;<span class="built_in">string</span>&gt; stkString;   <span class="comment">//一个存放string的stack容器。		  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//尖括号内还可以设置指针类型或自定义类型。</span></span><br></pre></td></tr></table></figure>





<h4 id="stack的push-与pop-方法"><a href="#stack的push-与pop-方法" class="headerlink" title="stack的push()与pop()方法"></a>stack的push()与pop()方法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>.push(elem);  <span class="comment">//往栈头添加元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>.pop();     <span class="comment">//从栈头移除第一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//例:</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stkInt;  </span><br><span class="line">stkInt.push(<span class="number">1</span>);</span><br><span class="line">stkInt.push(<span class="number">2</span>);</span><br><span class="line">stkInt.pop();  </span><br><span class="line">stkInt.push(<span class="number">3</span>);</span><br><span class="line">此时stkInt存放的元素是<span class="number">1</span>, <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h4 id="stack对象的拷贝构造与赋值"><a href="#stack对象的拷贝构造与赋值" class="headerlink" title="stack对象的拷贝构造与赋值"></a>stack对象的拷贝构造与赋值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>(<span class="keyword">const</span> <span class="built_in">stack</span> &amp;stk);		   <span class="comment">//拷贝构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">stack</span> &amp;stk);	<span class="comment">//重载等号操作符</span></span><br></pre></td></tr></table></figure>



<h4 id="stack的数据存取"><a href="#stack的数据存取" class="headerlink" title="stack的数据存取"></a>stack的数据存取</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>.top();	 <span class="comment">//返回最后一个压入栈元素</span></span><br><span class="line"><span class="comment">//返回的是引用可以修改值</span></span><br></pre></td></tr></table></figure>

<h4 id="stack的大小"><a href="#stack的大小" class="headerlink" title="stack的大小"></a>stack的大小</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>.empty();  <span class="comment">//判断堆栈是否为空</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>.size(); 	   <span class="comment">//返回堆栈的大小</span></span><br></pre></td></tr></table></figure>

<h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><p>C++11新增</p>
<h4 id="array容器概念"><a href="#array容器概念" class="headerlink" title="array容器概念"></a>array容器概念</h4><p>array是将元素置于一个固定数组中加以管理的容器。</p>
<p>array可以随机存取元素,支持索引值直接存取，用[]操作符或at()方法对元素进行操作，也可以使用迭代器访问</p>
<p>不支持动态的新增删除操作</p>
<p>array可以完全替代C语言中的数组，使操作数组元素更加安全！</p>
<h4 id="array对象的构造"><a href="#array对象的构造" class="headerlink" title="array对象的构造"></a>array对象的构造</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">array</span>采用模板类实现，<span class="built_in">array</span>对象的默认构造形式(涉及非类型参数-数值类模板)</span><br><span class="line"></span><br><span class="line"><span class="built_in">array</span>&lt;T，10&gt;  arrT;  <span class="comment">//10 为数值型模板参数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 6&gt; a1;   <span class="comment">//一个存放int的array容器</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">float</span>, 6&gt; a2;  <span class="comment">//一个存放float的array容器</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">array</span>&lt;student, 6&gt; a3; <span class="comment">//一个存放student的array容器</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 6&gt; a1=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;; <span class="comment">//定义时同时初始化</span></span><br></pre></td></tr></table></figure>

<h4 id="array的赋值"><a href="#array的赋值" class="headerlink" title="array的赋值"></a>array的赋值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a2.assign(<span class="number">0</span>);<span class="comment">//改变原来array中的所有元素的值</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 6&gt; a1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 6&gt; a2 ;</span><br></pre></td></tr></table></figure>

<h4 id="array的大小"><a href="#array的大小" class="headerlink" title="array的大小"></a>array的大小</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">array</span>.size();	  <span class="comment">//返回容器中元素的个数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">array</span>.max_size(); <span class="comment">//返回容器中最大的元素个数，与size 等同</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">array</span>.empty();  <span class="comment">//判断容器是否为空</span></span><br></pre></td></tr></table></figure>

<h4 id="array的数据存取"><a href="#array的数据存取" class="headerlink" title="array的数据存取"></a>array的数据存取</h4><ol>
<li>使用下标操作 a1[0] = 100;</li>
<li>使用at 方法 如: a1.at(2) = 100;</li>
<li> 接口返回的引用 a2.front() 和 a2.back()</li>
<li>返回内建数组的指针 a1.data()  </li>
</ol>
<p><strong>注意：  第一和第二种方式必须注意越界</strong></p>
<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p><strong>注意：</strong>任何时候在模板(template)中使用一个嵌套从属类型名称, 需要在前一个位置, 添加关键字。</p>
<p>(写模板的时候注意)</p>
<p>例如:</p>
<p><img src="/images/C++STL%E5%AE%B9%E5%99%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%B0%8F%E7%BB%93.assets/image-20210929112319934.png" alt="image-20210929112319934"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> <span class="built_in">list</span>&lt;T&gt;::const_iterator citor;</span><br></pre></td></tr></table></figure>



</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Do2eM0N</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://doraemon2.xyz/2021/09/29/C++STL%E5%AE%B9%E5%99%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%B0%8F%E7%BB%93/">http://doraemon2.xyz/2021/09/29/C++STL%E5%AE%B9%E5%99%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%B0%8F%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://doraemon2.xyz" target="_blank">半生瓜のblog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-11/">-C++11</a><a class="post-meta__tags" href="/tags/%E7%AC%94%E8%AE%B0/">-笔记</a><a class="post-meta__tags" href="/tags/C/">-C++</a><a class="post-meta__tags" href="/tags/STL/">-STL</a></div><div class="post_share"><div class="social-share" data-image="/img/c++.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/09/30/C++%E4%BD%BF%E7%94%A8%E5%86%85%E7%BD%AE%E5%AE%B9%E5%99%A8%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%B9%E5%99%A8/"><img class="prev-cover" src="/img/c++.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C++使用内置容器实现自定义容器</div></div></a></div><div class="next-post pull-right"><a href="/2021/09/28/C++%E4%BB%BF%E5%87%BD%E6%95%B0(%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1)/"><img class="next-cover" src="/img/c++.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">C++仿函数(函数对象)</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/09/27/C++11新特性-变参模板、完美转发和emplace/" title="C++:explicit关键字、左右值、类型转换"><img class="cover" src="/img/c++.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-27</div><div class="title">C++:explicit关键字、左右值、类型转换</div></div></a></div><div><a href="/2021/10/01/C++补充知识&C++11新特性/" title="C++explicit关键字、类型转换、左右值"><img class="cover" src="/img/c++.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-01</div><div class="title">C++explicit关键字、类型转换、左右值</div></div></a></div><div><a href="/2021/10/01/C++智能指针/" title="C++智能指针"><img class="cover" src="/img/c++.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-01</div><div class="title">C++智能指针</div></div></a></div><div><a href="/2021/10/02/C&C++结构体内存对齐/" title="C&C++结构体内存对齐"><img class="cover" src="/img/c++.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-02</div><div class="title">C&C++结构体内存对齐</div></div></a></div><div><a href="/2021/09/28/C++仿函数(函数对象)/" title="C++仿函数(函数对象)"><img class="cover" src="/img/c++.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-28</div><div class="title">C++仿函数(函数对象)</div></div></a></div><div><a href="/2021/08/11/C++实现演讲比赛流程管理系统/" title="C++实现演讲比赛流程管理系统"><img class="cover" src="/img/c++.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-11</div><div class="title">C++实现演讲比赛流程管理系统</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/doraemon2.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Do2eM0N</div><div class="author-info__description">活着</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">100</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">41</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://space.bilibili.com/94657270"><i class="iconfont icon-bofangqi-zantingxiaodianshi"></i><span>关注我一下吧</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://imgtu.com/i/4T713Q" target="_blank" title="我的微信公众号"><i class="iconfont icon-weixin"></i></a><a class="social-icon" href="https://github.com/doraemon-hub-art" target="_blank" title="我的Github"><i class="iconfont icon-github"></i></a><a class="social-icon" href="https://blog.csdn.net/qq_51604330?spm=1000.2115.3001.5343" target="_blank" title="我的CSDN"><i class="iconfont icon-csdn"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">我的交流群805814463</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8"><span class="toc-number">1.</span> <span class="toc-text">容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vector"><span class="toc-number">1.1.</span> <span class="toc-text">vector</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#vector%E5%B8%A6%E5%8F%82%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.1.</span> <span class="toc-text">vector带参构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC"><span class="toc-number">1.1.2.</span> <span class="toc-text">赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.1.3.</span> <span class="toc-text">大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%BE%E9%83%A8%E7%9A%84%E6%B7%BB%E5%8A%A0%E5%92%8C%E5%88%A0%E9%99%A4"><span class="toc-number">1.1.4.</span> <span class="toc-text">尾部的添加和删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0"><span class="toc-number">1.1.5.</span> <span class="toc-text">访问元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="toc-number">1.1.6.</span> <span class="toc-text">插入和删除</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#deque"><span class="toc-number">1.2.</span> <span class="toc-text">deque</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#deque%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96"><span class="toc-number">1.2.1.</span> <span class="toc-text">deque的数据存取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#deque%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.2.2.</span> <span class="toc-text">deque与迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#deque%E7%9A%84%E8%B5%8B%E5%80%BC"><span class="toc-number">1.2.3.</span> <span class="toc-text">deque的赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#deque%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.2.4.</span> <span class="toc-text">deque的大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#deque%E7%9A%84%E6%8F%92%E5%85%A5"><span class="toc-number">1.2.5.</span> <span class="toc-text">deque的插入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#deque%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-number">1.2.6.</span> <span class="toc-text">deque的删除</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#list"><span class="toc-number">1.3.</span> <span class="toc-text">list</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#list%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0"><span class="toc-number">1.3.1.</span> <span class="toc-text">list对象的默认构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#list%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%A6%E5%8F%82%E6%95%B0%E6%9E%84%E9%80%A0"><span class="toc-number">1.3.2.</span> <span class="toc-text">list对象的带参数构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#list%E5%A4%B4%E5%B0%BE%E7%9A%84%E6%B7%BB%E5%8A%A0%E7%A7%BB%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.3.</span> <span class="toc-text">list头尾的添加移除操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#list%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96"><span class="toc-number">1.3.4.</span> <span class="toc-text">list的数据存取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#list%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.3.5.</span> <span class="toc-text">list与迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#list%E7%9A%84%E8%B5%8B%E5%80%BC"><span class="toc-number">1.3.6.</span> <span class="toc-text">list的赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#list%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.3.7.</span> <span class="toc-text">list的大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#list%E7%9A%84%E6%8F%92%E5%85%A5"><span class="toc-number">1.3.8.</span> <span class="toc-text">list的插入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#list%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-number">1.3.9.</span> <span class="toc-text">list的删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#list%E7%9A%84%E5%8F%8D%E5%BA%8F%E6%8E%92%E5%88%97"><span class="toc-number">1.3.10.</span> <span class="toc-text">list的反序排列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set-multiset"><span class="toc-number">1.4.</span> <span class="toc-text">set&#x2F;multiset</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#set-multiset%E5%AE%B9%E5%99%A8%E6%A6%82%E5%BF%B5"><span class="toc-number">1.4.1.</span> <span class="toc-text">set&#x2F;multiset容器概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E5%AE%9A%E4%B9%89"><span class="toc-number">1.4.2.</span> <span class="toc-text">红黑树定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#set-%E5%92%8C-multiset-%E7%89%B9%E7%82%B9"><span class="toc-number">1.4.3.</span> <span class="toc-text">set 和 multiset 特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#set-multiset%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0"><span class="toc-number">1.4.4.</span> <span class="toc-text">set&#x2F;multiset对象的默认构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#set-multiset-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%A6%E5%8F%82%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.5.</span> <span class="toc-text">set&#x2F;multiset 对象的带参构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#set%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E4%B8%8E%E8%B5%8B%E5%80%BC"><span class="toc-number">1.4.6.</span> <span class="toc-text">set对象的拷贝构造与赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#set%E7%9A%84%E6%8F%92%E5%85%A5%E5%92%8Cpair%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">1.4.7.</span> <span class="toc-text">set的插入和pair的用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#set%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.4.8.</span> <span class="toc-text">set与迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#set-multiset%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.4.9.</span> <span class="toc-text">set&#x2F;multiset的大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#set-multiset%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-number">1.4.10.</span> <span class="toc-text">set&#x2F;multiset的删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#set-multiset%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-number">1.4.11.</span> <span class="toc-text">set&#x2F;multiset的查找</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map-multimap"><span class="toc-number">1.5.</span> <span class="toc-text">map&#x2F;multimap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#map-multimap%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0"><span class="toc-number">1.5.1.</span> <span class="toc-text">map&#x2F;multimap对象的默认构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map%E5%92%8Cmultimap%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%A6%E5%8F%82%E6%95%B0%E6%9E%84%E9%80%A0"><span class="toc-number">1.5.2.</span> <span class="toc-text">map和multimap对象的带参数构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map%E7%9A%84%E6%8F%92%E5%85%A5%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.5.3.</span> <span class="toc-text">map的插入与迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.5.4.</span> <span class="toc-text">迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map-multimap-%E6%8E%92%E5%BA%8F"><span class="toc-number">1.5.5.</span> <span class="toc-text">map&#x2F;multimap 排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E4%B8%8E%E8%B5%8B%E5%80%BC"><span class="toc-number">1.5.6.</span> <span class="toc-text">map对象的拷贝构造与赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.5.7.</span> <span class="toc-text">map的大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-number">1.5.8.</span> <span class="toc-text">map的删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map-multimap%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-number">1.5.9.</span> <span class="toc-text">map&#x2F;multimap的查找</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#queue"><span class="toc-number">1.6.</span> <span class="toc-text">queue</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#queue%E7%AE%80%E4%BB%8B"><span class="toc-number">1.6.1.</span> <span class="toc-text">queue简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#queue%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0"><span class="toc-number">1.6.2.</span> <span class="toc-text">queue对象的默认构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#queue-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%A6%E5%8F%82%E6%9E%84%E9%80%A0"><span class="toc-number">1.6.3.</span> <span class="toc-text">queue 对象的带参构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#queue%E7%9A%84push-%E4%B8%8Epop-%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.4.</span> <span class="toc-text">queue的push()与pop()方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#queue%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E4%B8%8E%E8%B5%8B%E5%80%BC"><span class="toc-number">1.6.5.</span> <span class="toc-text">queue对象的拷贝构造与赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#queue%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96"><span class="toc-number">1.6.6.</span> <span class="toc-text">queue的数据存取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#queue%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.6.7.</span> <span class="toc-text">queue的大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97priority-queue"><span class="toc-number">1.6.8.</span> <span class="toc-text">优先级队列priority_queue</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stack"><span class="toc-number">1.7.</span> <span class="toc-text">stack</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#stack%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0"><span class="toc-number">1.7.1.</span> <span class="toc-text">stack对象的默认构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stack%E7%9A%84push-%E4%B8%8Epop-%E6%96%B9%E6%B3%95"><span class="toc-number">1.7.2.</span> <span class="toc-text">stack的push()与pop()方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stack%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E4%B8%8E%E8%B5%8B%E5%80%BC"><span class="toc-number">1.7.3.</span> <span class="toc-text">stack对象的拷贝构造与赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stack%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96"><span class="toc-number">1.7.4.</span> <span class="toc-text">stack的数据存取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stack%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.7.5.</span> <span class="toc-text">stack的大小</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#array"><span class="toc-number">1.8.</span> <span class="toc-text">array</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#array%E5%AE%B9%E5%99%A8%E6%A6%82%E5%BF%B5"><span class="toc-number">1.8.1.</span> <span class="toc-text">array容器概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#array%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E9%80%A0"><span class="toc-number">1.8.2.</span> <span class="toc-text">array对象的构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#array%E7%9A%84%E8%B5%8B%E5%80%BC"><span class="toc-number">1.8.3.</span> <span class="toc-text">array的赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#array%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.8.4.</span> <span class="toc-text">array的大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#array%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96"><span class="toc-number">1.8.5.</span> <span class="toc-text">array的数据存取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E5%85%85"><span class="toc-number">1.8.6.</span> <span class="toc-text">补充</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/10/19/LeetCode%E5%88%B7%E9%A2%98(19)%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D&amp;&amp;%E4%B8%AD&amp;&amp;%E5%90%8E%E9%81%8D%E5%8E%86(%E9%9D%9E%E9%80%92%E5%BD%92)(C++)/" title="LeetCode刷题(19)【简单】二叉树的前&amp;&amp;中&amp;&amp;后序遍历(C++)"><img src="/img/leetcode.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="LeetCode刷题(19)【简单】二叉树的前&amp;&amp;中&amp;&amp;后序遍历(C++)"/></a><div class="content"><a class="title" href="/2021/10/19/LeetCode%E5%88%B7%E9%A2%98(19)%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D&amp;&amp;%E4%B8%AD&amp;&amp;%E5%90%8E%E9%81%8D%E5%8E%86(%E9%9D%9E%E9%80%92%E5%BD%92)(C++)/" title="LeetCode刷题(19)【简单】二叉树的前&amp;&amp;中&amp;&amp;后序遍历(C++)">LeetCode刷题(19)【简单】二叉树的前&amp;&amp;中&amp;&amp;后序遍历(C++)</a><time datetime="2021-10-19T14:06:22.000Z" title="发表于 2021-10-19 22:06:22">2021-10-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/18/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%93%88%E5%B8%8C%E8%A1%A8(C++)/" title="【数据结构】哈希表(C++)"><img src="/img/datas.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【数据结构】哈希表(C++)"/></a><div class="content"><a class="title" href="/2021/10/18/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%93%88%E5%B8%8C%E8%A1%A8(C++)/" title="【数据结构】哈希表(C++)">【数据结构】哈希表(C++)</a><time datetime="2021-10-18T13:16:34.000Z" title="发表于 2021-10-18 21:16:34">2021-10-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/17/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91(C++)/" title="【数据结构】树——二叉搜索树(C++)"><img src="/img/datas.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【数据结构】树——二叉搜索树(C++)"/></a><div class="content"><a class="title" href="/2021/10/17/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91(C++)/" title="【数据结构】树——二叉搜索树(C++)">【数据结构】树——二叉搜索树(C++)</a><time datetime="2021-10-17T07:42:02.000Z" title="发表于 2021-10-17 15:42:02">2021-10-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/17/%E3%80%90%E6%A0%91%E3%80%91%E7%BA%A2%E9%BB%91%E6%A0%91%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B(%E7%95%A5)/" title="【树】红黑树构建过程(略)"><img src="/img/datas.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【树】红黑树构建过程(略)"/></a><div class="content"><a class="title" href="/2021/10/17/%E3%80%90%E6%A0%91%E3%80%91%E7%BA%A2%E9%BB%91%E6%A0%91%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B(%E7%95%A5)/" title="【树】红黑树构建过程(略)">【树】红黑树构建过程(略)</a><time datetime="2021-10-17T07:02:31.000Z" title="发表于 2021-10-17 15:02:31">2021-10-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/16/C%E8%AF%AD%E8%A8%80%E9%A3%8E%E6%A0%BC%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B3%A8%E6%84%8F%E7%82%B9/" title="C语言风格字符串注意点"><img src="/img/taohua.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C语言风格字符串注意点"/></a><div class="content"><a class="title" href="/2021/10/16/C%E8%AF%AD%E8%A8%80%E9%A3%8E%E6%A0%BC%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B3%A8%E6%84%8F%E7%82%B9/" title="C语言风格字符串注意点">C语言风格字符串注意点</a><time datetime="2021-10-16T11:49:50.000Z" title="发表于 2021-10-16 19:49:50">2021-10-16</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/c++.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Do2eM0N</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a><br>
<img src="https://z3.ax1x.com/2021/08/28/h3o6iT.png" alt="h3o6iT.png" border="0" />
<a href="https://beian.miit.gov.cn/#/Integrated/recordQuery"  style="color:#f72b07" target="_blank">京ICP备2021006139号</a></div><div class="footer_custom_text">欢迎来访</div><div id="running-time"><script>setInterval(()=>{let create_time=Math.round(new Date('2021-03-08 19:27:17').getTime()/1000);let timestamp=Math.round((new Date().getTime()+8*60*60*1000)/1000);let second=timestamp-create_time;let time=new Array(0,0,0,0,0);if(second>=365*24*3600){time[0]=parseInt(second/(365*24*3600));second%=365*24*3600;}if(second>=24*3600){time[1]=parseInt(second/(24*3600));second%=24*3600;}if(second>=3600){time[2]=parseInt(second/3600);second%=3600;}if(second>=60){time[3]=parseInt(second/60);second%=60;}if(second>0){time[4]=second;}currentTimeHtml='本站已安全运行 '+time[0]+' 年 '+time[1]+' 天 '+time[2]+' 时 '+time[3]+' 分 '+time[4]+' 秒';document.getElementById("running-time").innerHTML=currentTimeHtml;},1000);</script></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script src="/js/nobanner.js"></script><script src="/js/weather.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script>(function(d, w, c) {
    w.ChatraID = '6KqzuZGb38hQrA6f6';
    var s = d.createElement('script');
    w[c] = w[c] || function() {
        (w[c].q = w[c].q || []).push(arguments);
    };
    s.async = true;
    s.src = 'https://call.chatra.io/chatra.js';
    if (d.head) d.head.appendChild(s);
})(document, window, 'Chatra');

if (true) {
  var chatBtnFn = () => {
    var chatBtn = document.getElementById("chat_btn")
    chatBtn.addEventListener("click", function(){
      Chatra('openChat')
    });
  }
  chatBtnFn()
} else {
  if (true) {
    function chatBtnHide () {
      Chatra('hide')
    }
    function chatBtnShow () {
      Chatra('show')
    }
  }
}</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="http://doraemon2.xyz/categories/C/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 C++ (17)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://doraemon2.xyz/categories/C语言/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 C (16)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://doraemon2.xyz/categories/网络编程/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 网络编程 (6)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://doraemon2.xyz/categories/hexo/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 Hexo (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://doraemon2.xyz/categories/system/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 系统 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://doraemon2.xyz/categories/算法/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 算法 (17)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://doraemon2.xyz/categories/计算机/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 计算机 (8)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://doraemon2.xyz/categories/数据结构/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 数据结构 (25)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><a class="magnet_link_more"  href="http://doraemon2.xyz/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(50% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: RGB(73,177,245)}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
                        function butterfly_swiper_injector_config(){
                          var parent_div_git = document.getElementById('recent-posts');
                          var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2021/07/18/C语言实现学生成绩管理系统(EasyX图形窗口)/" alt=""><img width="48" height="48" src="/img/stuman2.png" alt=""/></a><div class="blog-slider__content"><span class="blog-slider__code">2021-07-18</span><a class="blog-slider__title" href="2021/07/18/C语言实现学生成绩管理系统(EasyX图形窗口)/" alt="">C语言实现学生成绩管理系统(EasyX图形窗口)</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" href="2021/07/18/C语言实现学生成绩管理系统(EasyX图形窗口)/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2021/08/26/【网络编程】基于TCPIP协议的CS模型/" alt=""><img width="48" height="48" src="/img/socket.png" alt=""/></a><div class="blog-slider__content"><span class="blog-slider__code">2021-08-26</span><a class="blog-slider__title" href="2021/08/26/【网络编程】基于TCPIP协议的CS模型/" alt="">【网络编程】基于TCP/IP协议的C/S模型</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" href="2021/08/26/【网络编程】基于TCPIP协议的CS模型/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2021/08/14/黑马程序员C++课程笔记总结/" alt=""><img width="48" height="48" src="/img/c++.png" alt=""/></a><div class="blog-slider__content"><span class="blog-slider__code">2021-08-14</span><a class="blog-slider__title" href="2021/08/14/黑马程序员C++课程笔记总结/" alt="">黑马程序员C++课程笔记总结</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" href="2021/08/14/黑马程序员C++课程笔记总结/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2021/06/17/Hexo-Butterfly添加天气插件/" alt=""><img width="48" height="48" src="/img/taohua.png" alt=""/></a><div class="blog-slider__content"><span class="blog-slider__code">2021-06-17</span><a class="blog-slider__title" href="2021/06/17/Hexo-Butterfly添加天气插件/" alt="">Hexo-Butterfly添加天气插件</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" href="2021/06/17/Hexo-Butterfly添加天气插件/" alt="">详情   </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
                          console.log('已挂载butterfly_swiper')
                          // parent_div_git.innerHTML=item_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                          parent_div_git.insertAdjacentHTML("afterbegin",item_html) // 有报错，但不影响使用(支持pjax跳转)
                          }
                        if( document.getElementById('recent-posts') && (location.pathname ==='all'|| 'all' ==='all')){
                        butterfly_swiper_injector_config()
                        }
                      </script><script defer src="https://cdnjs.cloudflare.com/ajax/libs/Swiper/4.1.6/js/swiper.min.js"></script><script defer data-pjax src="https://cdn.jsdelivr.net/npm/hexo-butterfly-swiper/lib/swiper_init.js"></script><!-- hexo injector body_end end --></body></html>