<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>半生瓜のblog</title><meta name="author" content="Do2eM0N"><meta name="copyright" content="Do2eM0N"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="活着">
<meta property="og:type" content="website">
<meta property="og:title" content="半生瓜のblog">
<meta property="og:url" content="http://doraemon2.xyz/index.html">
<meta property="og:site_name" content="半生瓜のblog">
<meta property="og:description" content="活着">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://doraemon2.xyz/img/doraemon2.png">
<meta property="article:author" content="Do2eM0N">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://doraemon2.xyz/img/doraemon2.png"><link rel="shortcut icon" href="/img/doraemon2.png"><link rel="canonical" href="http://doraemon2.xyz/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?4bd5c0d5704ac1dd90d20a471e6a167a";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: false,
  isHome: true,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2021-10-24 09:53:26'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><link rel="stylesheet" href="/css/xiaotubiao.css"><link rel="stylesheet" href="/footermeihua.css"><link rel="stylesheet" href="/css/hua.css"><link rel="stylesheet" href="/css/background.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Swiper/4.1.6/css/swiper.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-butterfly-swiper/lib/swiperstyle.css"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="半生瓜のblog" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/doraemon2.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">107</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">42</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/artitalk/"><i class="fa-fw fa fa-comments"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 伙伴</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">半生瓜のblog</a><div id="tp-weather-widget"></div></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/artitalk/"><i class="fa-fw fa fa-comments"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 伙伴</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div class="recent-posts" id="recent-posts"><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2021/10/23/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%88%86%E6%94%AF%E5%AE%9A%E7%95%8C%E7%AE%97%E6%B3%95/" title="【算法】分支定界算法">     <img class="post_bg" src="/img/datas.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【算法】分支定界算法"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/10/23/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%88%86%E6%94%AF%E5%AE%9A%E7%95%8C%E7%AE%97%E6%B3%95/" title="【算法】分支定界算法">【算法】分支定界算法</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-10-23T13:11:39.000Z" title="发表于 2021-10-23 21:11:39">2021-10-23</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="content">分支定界算法概念

分支定界(branch and bound)算法是一种在问题的解空间上搜索问题的解的方法。但与回溯算法不同，分支定界算法采用广度优先或最小耗费优先的方法搜索解空间树。并且，在分支定界算法中，每一个活结点只有一次机会称为扩展结点。

​    利用分支定界算法对问题的解空间树进行搜索，它的搜索策略是：

产生当前扩展结点的所有孩子结点。
在产生的孩子结点中，抛弃那些不可能产生可行解(或)最优解的结点。
将其余的孩子结点加入活结点表。
从活结点表中选择下一个活结点作为新的扩展结点。

如此循环，直到找到问题的可行解(最优解)或活结点表为空。
从活结点表中选择下一个活结点作为新的扩展结点，根据选择的方式不同，分支定界算法通常可以分为两种形式。

FIFO(First In First Out) 分支定界算法：按照先进先出原则选择下一个活结点作为扩展结点，即从活结点表中取出结点的顺序与加入结点的顺序相同。
最小耗费或最大收益分支定界算法：在这种情况下，每个结点都有一个耗费或收益。假如要查找一个具有最小耗费的解，那么要选择的下一个扩展结点就是活结点表中具有最小耗费的活结点，假 ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2021/10/23/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" title="【算法】贪心算法">     <img class="post_bg" src="/img/datas.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【算法】贪心算法"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/10/23/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" title="【算法】贪心算法">【算法】贪心算法</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-10-23T12:27:16.000Z" title="发表于 2021-10-23 20:27:16">2021-10-23</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="content">贪心算法概念解释

贪婪算法(贪心算法)是指在对问题求解的时候，每一步选择都采用最好或者最优(即最有利)的选择，从而希望能够导致结果是最好或者最优的算法。    
贪心算法所得到的结果往往不是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果。
贪心算法并没有固定的解发框架，算法的关键是贪心策略的选择，根据不用问题选择不同的策略。

基本思路

建立数学模型描述问题
把求解的问题分为若干个子问题
对每一个子问题求解，得到子问题的局部最优解
把子问题对应的局部最优解合成原来整个问题的一个近似最优解。

例题：

《钱币找零问题》
假设1元、2元、5元、10元、20元、50元、100元的纸币分别有c0,c1,c2,c3,c4,c5,c6张。现在要用这些钱来支付K元，最少要用多少张纸币？

解题思路：

用贪心算法的思想，每一步都用能用的最大纸币即可。

代码实现:
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#inclu ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2021/10/23/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%9B%9E%E6%BA%AF%E6%B3%95/" title="【算法】回溯法">     <img class="post_bg" src="/img/datas.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【算法】回溯法"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/10/23/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%9B%9E%E6%BA%AF%E6%B3%95/" title="【算法】回溯法">【算法】回溯法</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-10-23T10:01:31.000Z" title="发表于 2021-10-23 18:01:31">2021-10-23</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="content">回溯法 回溯的基本原理

在问题的解空间中，按深度优先遍历策略，从根节点出发搜索解空间树。算法搜索至解空间 的任意一个节点时，先判断该节点是否包含问题的解。如果确定不包含，跳过对以该节点为根的 子树的搜索，逐层向其祖先节点回溯，否则进入该子树，继续深度优先搜索。 


回溯法解问题的所有解时，必须回溯到根节点，且根节点的所有子树都被搜索后才结束。
回溯法解问题的一个解时，只要搜索到问题的一个解就可结束。 

回溯的基本步骤

定义问题的解空间(我理解的解空间就是目标问题的内容，或者说是目标问题解的集合。)
确定易于搜索的解空间结构
以深度优先搜索的策略搜索解空间，并在搜索过程中尽可能避免无效搜索

例题

请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了 矩阵的某一格，那么该路径不能再次进入该格子。例如在下面的 3×4 的矩阵中包含一条字符串 “bfce”的路径（路径中的字母用下划线标出）。但矩阵中不包含字符串“abfb”的路径，因为 字符串的第一个字符 b 占据了矩 ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2021/10/23/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95/" title="【算法】动态规划算法">     <img class="post_bg" src="/img/datas.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【算法】动态规划算法"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/10/23/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95/" title="【算法】动态规划算法">【算法】动态规划算法</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-10-23T02:07:30.000Z" title="发表于 2021-10-23 10:07:30">2021-10-23</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="content">动态规划算法例：

走楼梯，可以一次上一阶，也可以，一次上两阶，根据楼梯的阶数来判断有几种上楼梯的方法。

分析：

f(1) = 1; 1种
f(2) = 2; 2种
f(3) = f(1) + f(2);3种
f(4) = f(3) + f(2) ;5种
…
依次类推

代码如下:
123456789101112131415161718192021222324252627#include&lt;iostream&gt;using namespace std;int WalkCount(int n)&#123;	//可以一次走一阶台阶，也可以一次走两阶台阶	if (n &lt; 0)	&#123;		return  0;	&#125;	if (n == 1)	&#123;		return 1;	&#125;	if (n == 2)	&#123;		return 2;	&#125;	else &#123;		return WalkCount(n-1)+WalkCount(n-2);	&#125;&#125;int main(void)&#123;	cout &lt;&lt; WalkC ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2021/10/22/%E3%80%90%E5%8D%95%E9%93%BE%E8%A1%A8%E3%80%91%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E5%92%8C(C++)/" title="【单链表】一元多项式求和(C++)">     <img class="post_bg" src="/img/taohua.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【单链表】一元多项式求和(C++)"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/10/22/%E3%80%90%E5%8D%95%E9%93%BE%E8%A1%A8%E3%80%91%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E5%92%8C(C++)/" title="【单链表】一元多项式求和(C++)">【单链表】一元多项式求和(C++)</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-10-22T10:53:49.000Z" title="发表于 2021-10-22 18:53:49">2021-10-22</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="content">要求&amp;&amp;实现流程
代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#include&lt;iostream&gt;using namespace std;typedef struct LinkNode&#123;	int cofe;//系数	int  exp;/ ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2021/10/22/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/" title="【算法】分治算法">     <img class="post_bg" src="/img/datas.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【算法】分治算法"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/10/22/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/" title="【算法】分治算法">【算法】分治算法</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-10-22T08:42:18.000Z" title="发表于 2021-10-22 16:42:18">2021-10-22</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="content">分治算法
将一个规模为N的问题分解为k个较小的子问题，这些子问题遵循的处理方式就是互相独立且与原问题相同。

两部分组成：

分(divide):递归解决较小的问题。
治(conquer):然后从子问题的解构建原问题的解。

三个步骤：

分解(divide):将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题。
解决(conquer):若干子问题规模较小而容易被解决则直接解决，否则递归解决各个子问题。
合并(Combine):将各个子问题的解合并为原问题的解。

递归实现二分查找
123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;using namespace std;//递归实现二分查找//找到这个值最后一级一级的传递return回来int BinarySearch(int* arr,int minSub,int maxSub,int num)&#123;    if (minSub &gt; maxSub)//无解    &#123;      ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2021/10/21/%E3%80%90%E5%9B%BE%E3%80%91%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95/" title="【图】最短路径算法">     <img class="post_bg" src="/img/datas.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【图】最短路径算法"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/10/21/%E3%80%90%E5%9B%BE%E3%80%91%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95/" title="【图】最短路径算法">【图】最短路径算法</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-10-21T11:00:05.000Z" title="发表于 2021-10-21 19:00:05">2021-10-21</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="content">图的最短算法
从起点开始访问所有路径，可以到达终点的有多条地址,其中路径权值最小的为最短路径。最短路径算法有深度优先遍历、广度优先遍历、Bellman-Ford算法、弗洛伊德算法、SPFA(Shortest Path Faster Algorithm)算法和迪杰斯特拉算法等。

本代码使用深度优先遍历
主要实现思路：

从起点开始，到达终点有多条分支，这些分支中又有多条分支…选择其实一条分支，走到终点，再选择另一个分支(temp =  temp -&gt;next)走到终点，分支的分支……

大致流程:代码实现:
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116 ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2021/10/19/LeetCode%E5%88%B7%E9%A2%98(19)%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D&amp;&amp;%E4%B8%AD&amp;&amp;%E5%90%8E%E9%81%8D%E5%8E%86(%E9%9D%9E%E9%80%92%E5%BD%92)(C++)/" title="LeetCode刷题(19)【简单】二叉树的前&amp;&amp;中&amp;&amp;后序遍历(C++)">     <img class="post_bg" src="/img/leetcode.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="LeetCode刷题(19)【简单】二叉树的前&amp;&amp;中&amp;&amp;后序遍历(C++)"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/10/19/LeetCode%E5%88%B7%E9%A2%98(19)%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D&amp;&amp;%E4%B8%AD&amp;&amp;%E5%90%8E%E9%81%8D%E5%8E%86(%E9%9D%9E%E9%80%92%E5%BD%92)(C++)/" title="LeetCode刷题(19)【简单】二叉树的前&amp;&amp;中&amp;&amp;后序遍历(C++)">LeetCode刷题(19)【简单】二叉树的前&amp;&amp;中&amp;&amp;后序遍历(C++)</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-10-19T14:06:22.000Z" title="发表于 2021-10-19 22:06:22">2021-10-19</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="content">精华在于进栈和出栈的时机
94.二叉树的中序遍历题目


思路：中序遍历的顺序是，左 - 根 - 右创建一个栈来存储结点，创建一个vector来存储中序遍历的值从根结点开始，只要该结点有左子树，就将该结点压进栈中。直到root为空。取出栈顶元素，栈顶元素出栈，将该结点值存进recv。…剩下的只可意会不可言传了，
感谢这位老哥分享——链接

123456789101112131415161718192021222324252627class Solution &#123;public:    //中序遍历顺序-左-中-右    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt;recv;        stack&lt;TreeNode*&gt; Tstack;              //当前结点不为空或当前栈不为空       while(root || !Tstack.empty())       &#123;           while(root)        ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2021/10/18/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%93%88%E5%B8%8C%E8%A1%A8(C++)/" title="【数据结构】哈希表(C++)">     <img class="post_bg" src="/img/datas.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【数据结构】哈希表(C++)"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/10/18/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%93%88%E5%B8%8C%E8%A1%A8(C++)/" title="【数据结构】哈希表(C++)">【数据结构】哈希表(C++)</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-10-18T13:16:34.000Z" title="发表于 2021-10-18 21:16:34">2021-10-18</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><div class="content">哈希表概念哈希表-散列表， 它是基于快速存储的角度设计的，也是一种典型的“空间换时间”的做法。
(键值(编号)就代表了这个数据。)

链式存储实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#inc ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2021/10/17/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91(C++)/" title="【数据结构】树——二叉搜索树(C++)">     <img class="post_bg" src="/img/datas.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【数据结构】树——二叉搜索树(C++)"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/10/17/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91(C++)/" title="【数据结构】树——二叉搜索树(C++)">【数据结构】树——二叉搜索树(C++)</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-10-17T07:42:02.000Z" title="发表于 2021-10-17 15:42:02">2021-10-17</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><div class="content">树概念
树状图是一种数据结构，它是由 n(n&gt;=1）个有限结点组成一个具有层次关系的集合。把它叫做“树”是因 为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点： 
每个结点有零个或多个子结点；没有父结点的结点称为根结点；每一个非根结点有且只有一个父结点；除 了根结点外，每个子结点可以分为多个不相交的子树。



二叉树
同线性表，一个没有限制条件的线性表就是一个数组，但是加以限制条件就得到了非常有用的栈、队列、优先队列等。

引出二叉树

树也是一样，一个没有限制的树由于太灵活，控制起来比较复杂。如果对普通的树加上一些人为的限制，比如 结点只允许有两个子结点，这就是二叉树。 
二叉树是一个每个结点最多只能有两个分支的树，左边的分支称之为左子树，右边的分支称之为右子树。

如下图所示：

(1).在非空二叉树中，第 i-1 层的结点总数不超过 , i&gt;=1； 
(2).深度为 h-1 的二叉树最多有 2的h次方个结点(h&gt;=1)，最少有 h 个结点； 
(3).对于任意一棵二叉树，如果其叶结点数为 N0，而度数为 2 的结点总数为 N2，则 N ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2021/10/17/%E3%80%90%E6%A0%91%E3%80%91%E7%BA%A2%E9%BB%91%E6%A0%91%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B(%E7%95%A5)/" title="【树】红黑树构建过程(略)">     <img class="post_bg" src="/img/datas.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【树】红黑树构建过程(略)"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/10/17/%E3%80%90%E6%A0%91%E3%80%91%E7%BA%A2%E9%BB%91%E6%A0%91%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B(%E7%95%A5)/" title="【树】红黑树构建过程(略)">【树】红黑树构建过程(略)</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-10-17T07:02:31.000Z" title="发表于 2021-10-17 15:02:31">2021-10-17</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><div class="content">红黑树定义
是每个节点都带有颜色属性（颜色为红色或黑色）的自平衡二叉查找(搜索)树，满足下列性质： 
1）节点是红色或黑色； 
2）根节点是黑色； 
3）所有叶子节点都是黑色节点(NULL)； 
4）每个红色节点必须有两个黑色的子节点。(从每个叶子到根的所有路径上不能有两个连续的红色节点。) 
5）从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点


红黑树可以解决二叉树搜索树出现的长短腿情况

构建过程
红黑树是一种自平衡二叉查找树，从上面红黑树的图可以看到，根结点右子树显然比左子树高，但左子树和右子树的黑结 点的层数是相等的，也即任意一个结点到到每个叶子结点的路径都包含数量相同的黑结点。所以我们叫红黑树这种平衡为黑色完美平衡。

给定如下数组来构建红黑树

1.使用第一个元素创建一个根结点(黑色)。

2.插入13，根据二叉搜索树规则，应该插入到左侧，此时插入红色结点不会破坏红黑树平衡，直接插入即可。

3.插入16，插入红色结点不会破坏平衡，直接插入。

4.插入11，此时插入红色结点会破坏平衡(红色结点下面必须是两个黑色结点)，但插入黑色结点也会破坏平衡(从任一结点 ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2021/10/16/C%E8%AF%AD%E8%A8%80%E9%A3%8E%E6%A0%BC%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B3%A8%E6%84%8F%E7%82%B9/" title="C语言风格字符串注意点">     <img class="post_bg" src="/img/taohua.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C语言风格字符串注意点"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/10/16/C%E8%AF%AD%E8%A8%80%E9%A3%8E%E6%A0%BC%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B3%A8%E6%84%8F%E7%82%B9/" title="C语言风格字符串注意点">C语言风格字符串注意点</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-10-16T11:49:50.000Z" title="发表于 2021-10-16 19:49:50">2021-10-16</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/C%E8%AF%AD%E8%A8%80/">C语言</a></span></div><div class="content">C语言风格字符串注意点注意：

strlen()
sizeof()
/转义字符种类


这种写法编译器会自动在结尾填充\0
char a[] = “aaas3”;
这种写法需要手动填充\0,否则后面会输出多余的内容 char b[] = { ‘a’,’a’,’a’,’s’,’3’};
这种写法也要手动添加\0,否则后面会输出多余的内容
char c[6]; c[0] = ‘a’; c[1] = ‘a’; c[2] = ‘a’; c[3] = ‘s’; c[4] = ‘3’; c[5] = ‘\0’;
这种同第一种
const char* d = “aaas3”;
strlen遇到\0结束，不包括\0
char temp1[] = “abc\0abc”; strlen(temp1);//结果为3 sizeof(temp1);//结果为字符数组的大小，也就是8，默认会在结尾填充一个\0,所以指定字符数组存储元素的个数是你字符个数+1，否则就会报错，或者不指定，就像这样。

12345678例:char temp2[] = &quot;AB\x78\\ab\023&quot;;strlen( ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2021/10/16/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%88(C++)/" title="【数据结构】栈(C++)">     <img class="post_bg" src="/img/datas.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【数据结构】栈(C++)"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/10/16/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%88(C++)/" title="【数据结构】栈(C++)">【数据结构】栈(C++)</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-10-16T01:13:29.000Z" title="发表于 2021-10-16 09:13:29">2021-10-16</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><div class="content">栈只能在一边进出，先进的后出。
进出的一端叫做栈顶，另一端叫做栈底。
栈可以使用顺序存储结构，也能使用链式存储结构。

注意：栈只能在一端进行操作，这是栈的关键特征，也就是说栈不允许在中间进行查找、插入、删除等操作，(但是在实际应用中我们可以打破它)。
这里掌握初始化、入栈、出栈、取栈顶元素操作即可。
顺序存储结构实现栈1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;iostream&gt;using namespace std;#define MAX_SIZE 128typedef int DataType;//栈的结构有多重方式定义，不用局限于这一种/*	例如:		定义两个int型，并且直接开辟好数组空间		定义一个指针，一个int to ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2021/10/15/%E3%80%90%E6%A0%88%E3%80%91%E5%AE%9E%E7%8E%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/" title="【栈】实现表达式求值">     <img class="post_bg" src="/img/datas.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【栈】实现表达式求值"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/10/15/%E3%80%90%E6%A0%88%E3%80%91%E5%AE%9E%E7%8E%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/" title="【栈】实现表达式求值">【栈】实现表达式求值</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-10-15T15:03:52.000Z" title="发表于 2021-10-15 23:03:52">2021-10-15</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="content">【栈】实现表达式求值思路 &amp;&amp; 理解 &amp;&amp; 注意
给定一串表达式，字符串类型，依次遍历从头开始遍历每一个位置的内容。
第一个数字，第一个运算符先直接往栈里面push(两个不同的栈)接着走，遇到数push进来，接着走，遇到运算符，和前面那个已经push进栈的运算符进行优先级比较，如果当前运算符优先级大，那就接着push进来，反之，pop出栈，运算前面的式子之和(之后判断运算符栈中是否还有内容，并且当前运算符的优先级是否小于等于已有的运算符，小于等于就接着运算前面的表达式，完成push当前运算符，反之继续往下遍历push…pop…),直到最后一个元素。
注意;
一直发生变化的是rdata-右操作数,所以每次压完运算符找新的右操作数都会将他置空，准备重新赋值。
没有添加括号优先级运算。

expression.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676 ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2021/10/15/%E3%80%90%E6%A0%88%E3%80%91%E5%AE%9E%E7%8E%B0%E8%BF%B7%E5%AE%AB%E6%B1%82%E8%A7%A3/" title="【栈】实现迷宫求解">     <img class="post_bg" src="/img/datas.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【栈】实现迷宫求解"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/10/15/%E3%80%90%E6%A0%88%E3%80%91%E5%AE%9E%E7%8E%B0%E8%BF%B7%E5%AE%AB%E6%B1%82%E8%A7%A3/" title="【栈】实现迷宫求解">【栈】实现迷宫求解</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-10-15T06:58:35.000Z" title="发表于 2021-10-15 14:58:35">2021-10-15</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="content">迷宫求解从入口进入开始， 向不同方向试探，走到死胡同就退回。

找迷宫通路需要使用回溯法，找迷宫通路是对回溯法的一个很好的应用，实现回溯的过程用到数据结构—栈！


回溯法：
​        对一个包括有很多个结点，每个结点有若干个搜索分支的问题，把原问题分解为若干个子问题求解的 算法；当搜索到某个结点发现无法再继续搜索下去时，就让搜索过程回溯(回退)到该节点的前一个结点，继续 搜索该节点外的其他尚未搜索的分支；如果发现该结点无法再搜索下去，就让搜索过程回溯到这个结点的前一 结点继续这样的搜索过程；这样的搜索过程一直进行到搜索到问题的解或者搜索完了全部可搜索分支没有解存 在为止

思路&amp;解释
二维数组作为地图。
一开始确定一个入口——需要判定入口是否合法。
先将入口位置坐标压入栈，只要栈中不为空，那么每次判断移动方向前都要判断当前位置是不是出口。然后由此坐标开始向四周判断，判断哪有路可以走，是路就开始移动(cur-当前位置),压进栈……,走到死胡同，说明四周都不能走了，开始边popStack边向四周判断，不放过来时路上的任何一个遗漏的可能出口路径，反之，找到出口直接retur ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2021/10/13/LeetCode%E5%88%B7%E9%A2%98(18)%E3%80%90%E4%B8%AD%E7%AD%89%E3%80%91%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC%20N%20%E4%B8%AA%E7%BB%93%E7%82%B9(C++)/" title="LeetCode刷题(18)【中等】删除链表的倒数第 N 个结点(C++)">     <img class="post_bg" src="/img/leetcode.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="LeetCode刷题(18)【中等】删除链表的倒数第 N 个结点(C++)"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/10/13/LeetCode%E5%88%B7%E9%A2%98(18)%E3%80%90%E4%B8%AD%E7%AD%89%E3%80%91%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC%20N%20%E4%B8%AA%E7%BB%93%E7%82%B9(C++)/" title="LeetCode刷题(18)【中等】删除链表的倒数第 N 个结点(C++)">LeetCode刷题(18)【中等】删除链表的倒数第 N 个结点(C++)</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-10-13T13:28:33.000Z" title="发表于 2021-10-13 21:28:33">2021-10-13</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="content">19. 删除链表的倒数第 N 个结点
题目——[链接](19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode） (leetcode-cn.com))
遍历统计方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123;public:    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;        if(!head)//空的直接返回        &#123;            return NULL;        &#125;        int count =  0;//统计个数        ListNode* tempnode = head;        ListNode* temp = NULL;         int prev = 0;        while(tempnode)        &#123;      ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2021/10/13/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%A0%86(C++)/" title="【数据结构】堆(C++)">     <img class="post_bg" src="/img/datas.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【数据结构】堆(C++)"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/10/13/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%A0%86(C++)/" title="【数据结构】堆(C++)">【数据结构】堆(C++)</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-10-13T03:10:03.000Z" title="发表于 2021-10-13 11:10:03">2021-10-13</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><div class="content">堆概念

最大堆:最上面的结点数值最大
特点:1.每个结点最多可以有两个结点
2.根结点的键值是所有结点中最大的，每个结点的值都比孩子的值大。
3.除了根节点没有兄弟结点，最后一个左子结点可以没有兄弟结点，其他结点必须有兄弟结点。(有这个限制，下面的求子结点和父结点的公式才能成立。)


最小堆:最上面的结点数值最小….其他同最大堆


堆是最有个性的树，用数组表示的树。



在数组中快速创建堆左图——》右图


1.找到最后一个结点的父结点，(该父结点)与其子结点进行比较大小，若某个子结点大于父结点，则与该父结点交换位置。(就是从最后一个非叶子结点开始进行调整，(向下调整就是找到该父结结点的子结点，进行调整。))
2.再移动到前一个父结点，进行上述操作。
3……    


补充:static修饰的全局函数

一个普通的全局的静态函数。. 这样的static函数与普通函数的区别是：用static修饰的函数，限定在本源码文件中，不能被本源码文件以外的代码文件调用。

链接——链接

相关接口实现123456789101112131415161718192021222324252627 ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2021/10/12/%E6%8C%89%E7%85%A7%E4%BA%8C%E5%8F%89%E6%A0%91%E6%AF%8F%E8%A1%8C%E7%9A%84%E4%B8%AA%E6%95%B0%E6%89%93%E5%8D%B0%E6%95%B0%E7%BB%84/" title="按照二叉树每行的个数打印数组">     <img class="post_bg" src="/img/datas.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="按照二叉树每行的个数打印数组"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/10/12/%E6%8C%89%E7%85%A7%E4%BA%8C%E5%8F%89%E6%A0%91%E6%AF%8F%E8%A1%8C%E7%9A%84%E4%B8%AA%E6%95%B0%E6%89%93%E5%8D%B0%E6%95%B0%E7%BB%84/" title="按照二叉树每行的个数打印数组">按照二叉树每行的个数打印数组</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-10-12T11:17:40.000Z" title="发表于 2021-10-12 19:17:40">2021-10-12</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="content">

这个b玩意儿耗了我2个小时，怎么tm就写不出来呢。
可能是吃的太饱了吧。
越写不出来一定要越冷静下来。

123456789101112131415161718192021222324252627282930313233343536int num = hp.size;int front = 0;int back = 1;int row = 1;while (num)&#123;	for (int j = front; j &lt; back; j++)	&#123;		cout &lt;&lt; hp.arr[j] &lt;&lt; &quot; &quot;;	&#125;	cout &lt;&lt; endl;	num -= row;//输出完本行还剩的元素个数	//如果减去本行输出的个数小于0	if (num &lt;= 0)	&#123;		break;	&#125;	row *= 2;//下一行要输出的元素个数	front = back;//定位下一行的起点	if (num - row &lt;= 0)//如果当前的元素个数不够输出下一行的，直接定位下一行的back位置	 ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2021/10/11/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E9%98%9F%E5%88%97(C++)/" title="【数据结构】队列(C++)">     <img class="post_bg" src="/img/datas.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【数据结构】队列(C++)"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/10/11/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E9%98%9F%E5%88%97(C++)/" title="【数据结构】队列(C++)">【数据结构】队列(C++)</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-10-11T11:34:30.000Z" title="发表于 2021-10-11 19:34:30">2021-10-11</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><div class="content">队列队列是一种受限的线性表，它允许在一段进行删除操作，在另一端进行插入操作。
可以用数组实现，也可以用链表实现。
数组实现(顺序存储)设立一个队头指针front,一个队尾指针rear，分别指向队头元素和队尾元素，rear-front为元素个数。
(数组实现中，其实就是下标。)
 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#define MAX_SIZE 10typedef int DataType;typedef struct Queue&#123;	DataType queue[MAX_SIZE];	int front;	i ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2021/10/10/Windows%E5%AE%89%E8%A3%85MySQL/" title="Windows安装MySQL">     <img class="post_bg" src="/img/mysql.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Windows安装MySQL"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/10/10/Windows%E5%AE%89%E8%A3%85MySQL/" title="Windows安装MySQL">Windows安装MySQL</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-10-10T12:06:26.000Z" title="发表于 2021-10-10 20:06:26">2021-10-10</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/MySQL/">MySQL</a></span></div><div class="content">Windows下安装MySql安装下载链接——链接
选择第二个下载

点击图片左下角的蓝字直接进行下载。

下载完成，点击安装。
选择第一个，点击next。

点击Execulte

等待…然后点击next。


点击next。

点击next。

选择第一个，然后点next。
设置完密码，点击add user。

设置完成后，点击ok。

点击next。

默认，点击next。

点击Execute。

点击Finish。

点击next。

点击Finish。

点击next。

输入密码点击check测试。

点击next。

点击Execute

点击Finish,再点击next。

再次Finish。
弹出窗口。

启动方式一

方式二
管理员方式打开命令行。
123456停止net stop MySQL80开启net start MySQL80 命令行直接链接服务器mysql -hlocalhost -uroot -p密码

配置相关环境变量
点编辑。
C:\Program Files\MySQL\MySQL Server 8.0\bin
</div></div></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fas fa-chevron-right fa-fw"></i></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/doraemon2.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Do2eM0N</div><div class="author-info__description">活着</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">107</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">42</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://space.bilibili.com/94657270"><i class="iconfont icon-bofangqi-zantingxiaodianshi"></i><span>关注我一下吧</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://imgtu.com/i/4T713Q" target="_blank" title="我的微信公众号"><i class="iconfont icon-weixin"></i></a><a class="social-icon" href="https://github.com/doraemon-hub-art" target="_blank" title="我的Github"><i class="iconfont icon-github"></i></a><a class="social-icon" href="https://blog.csdn.net/qq_51604330?spm=1000.2115.3001.5343" target="_blank" title="我的CSDN"><i class="iconfont icon-csdn"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">我的交流群805814463</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/10/23/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%88%86%E6%94%AF%E5%AE%9A%E7%95%8C%E7%AE%97%E6%B3%95/" title="【算法】分支定界算法"><img src="/img/datas.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【算法】分支定界算法"/></a><div class="content"><a class="title" href="/2021/10/23/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%88%86%E6%94%AF%E5%AE%9A%E7%95%8C%E7%AE%97%E6%B3%95/" title="【算法】分支定界算法">【算法】分支定界算法</a><time datetime="2021-10-23T13:11:39.000Z" title="发表于 2021-10-23 21:11:39">2021-10-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/23/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" title="【算法】贪心算法"><img src="/img/datas.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【算法】贪心算法"/></a><div class="content"><a class="title" href="/2021/10/23/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" title="【算法】贪心算法">【算法】贪心算法</a><time datetime="2021-10-23T12:27:16.000Z" title="发表于 2021-10-23 20:27:16">2021-10-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/23/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%9B%9E%E6%BA%AF%E6%B3%95/" title="【算法】回溯法"><img src="/img/datas.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【算法】回溯法"/></a><div class="content"><a class="title" href="/2021/10/23/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%9B%9E%E6%BA%AF%E6%B3%95/" title="【算法】回溯法">【算法】回溯法</a><time datetime="2021-10-23T10:01:31.000Z" title="发表于 2021-10-23 18:01:31">2021-10-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/23/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95/" title="【算法】动态规划算法"><img src="/img/datas.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【算法】动态规划算法"/></a><div class="content"><a class="title" href="/2021/10/23/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95/" title="【算法】动态规划算法">【算法】动态规划算法</a><time datetime="2021-10-23T02:07:30.000Z" title="发表于 2021-10-23 10:07:30">2021-10-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/22/%E3%80%90%E5%8D%95%E9%93%BE%E8%A1%A8%E3%80%91%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E5%92%8C(C++)/" title="【单链表】一元多项式求和(C++)"><img src="/img/taohua.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【单链表】一元多项式求和(C++)"/></a><div class="content"><a class="title" href="/2021/10/22/%E3%80%90%E5%8D%95%E9%93%BE%E8%A1%A8%E3%80%91%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E5%92%8C(C++)/" title="【单链表】一元多项式求和(C++)">【单链表】一元多项式求和(C++)</a><time datetime="2021-10-22T10:53:49.000Z" title="发表于 2021-10-22 18:53:49">2021-10-22</time></div></div></div></div><!--!=partial('includes/widget/card_categories', {}, {cache: true})--><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size: 1.5em; color: #99a9bf">-C++</a> <a href="/tags/C-11/" style="font-size: 1.19em; color: #999da2">-C++11</a> <a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 1.47em; color: #99a8bc">-C语言</a> <a href="/tags/EasyX/" style="font-size: 1.16em; color: #999b9f">-EasyX</a> <a href="/tags/Hexo/" style="font-size: 1.1em; color: #999">-Hexo</a> <a href="/tags/JAVA/" style="font-size: 1.1em; color: #999">-JAVA</a> <a href="/tags/LeetCode/" style="font-size: 1.35em; color: #99a3b0">-LeetCode</a> <a href="/tags/MySQL/" style="font-size: 1.1em; color: #999">-MySQL</a> <a href="/tags/NowCoder/" style="font-size: 1.1em; color: #999">-NowCoder</a> <a href="/tags/STL/" style="font-size: 1.13em; color: #999a9c">-STL</a> <a href="/tags/c/" style="font-size: 1.1em; color: #999">-c++</a> <a href="/tags/hash/" style="font-size: 1.1em; color: #999">-hash</a> <a href="/tags/hexo/" style="font-size: 1.1em; color: #999">-hexo</a> <a href="/tags/system/" style="font-size: 1.1em; color: #999">-system</a> <a href="/tags/windows/" style="font-size: 1.1em; color: #999">-windows</a> <a href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 1.22em; color: #999ea5">-二叉树</a> <a href="/tags/%E4%BA%8C%E7%BA%A7/" style="font-size: 1.25em; color: #999fa8">-二级</a> <a href="/tags/%E5%86%85%E5%AD%98/" style="font-size: 1.1em; color: #999">-内存</a> <a href="/tags/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/" style="font-size: 1.1em; color: #999">-双向链表</a> <a href="/tags/%E5%9B%BE/" style="font-size: 1.1em; color: #999">-图</a> <a href="/tags/%E5%9B%BE%E5%BD%A2%E7%BC%96%E7%A8%8B/" style="font-size: 1.1em; color: #999">-图形编程</a> <a href="/tags/%E5%A0%86/" style="font-size: 1.13em; color: #999a9c">-堆</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" style="font-size: 1.1em; color: #999">-字符串</a> <a href="/tags/%E6%8C%87%E9%92%88/" style="font-size: 1.16em; color: #999b9f">-指针</a> <a href="/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" style="font-size: 1.1em; color: #999">-排序算法</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 1.1em; color: #999">-数据库</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 1.41em; color: #99a5b6">-数据结构</a> <a href="/tags/%E6%95%B0%E7%BB%84/" style="font-size: 1.1em; color: #999">-数组</a> <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 1.1em; color: #999">-服务器</a> <a href="/tags/%E6%A0%88/" style="font-size: 1.25em; color: #999fa8">-栈</a> <a href="/tags/%E6%A0%91/" style="font-size: 1.28em; color: #99a0ab">-树</a> <a href="/tags/%E6%B3%A8%E6%84%8F/" style="font-size: 1.1em; color: #999">-注意</a> <a href="/tags/%E7%AC%94%E8%AE%B0/" style="font-size: 1.44em; color: #99a7b9">-笔记</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 1.38em; color: #99a4b3">-算法</a> <a href="/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/" style="font-size: 1.1em; color: #999">-红黑树</a> <a href="/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/" style="font-size: 1.16em; color: #999b9f">-线性表</a> <a href="/tags/%E7%BB%8F%E9%AA%8C/" style="font-size: 1.1em; color: #999">-经验</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" style="font-size: 1.22em; color: #999ea5">-网络编程</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" style="font-size: 1.32em; color: #99a2ad">-计算机</a> <a href="/tags/%E8%BF%9B%E5%88%B6/" style="font-size: 1.1em; color: #999">-进制</a></div></div><div class="card-widget card-archives"><div class="item-headline"><i class="fas fa-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/10/"><span class="card-archive-list-date">十月 2021</span><span class="card-archive-list-count">28</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/09/"><span class="card-archive-list-date">九月 2021</span><span class="card-archive-list-count">12</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/08/"><span class="card-archive-list-date">八月 2021</span><span class="card-archive-list-count">11</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/07/"><span class="card-archive-list-date">七月 2021</span><span class="card-archive-list-count">5</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/06/"><span class="card-archive-list-date">六月 2021</span><span class="card-archive-list-count">16</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/05/"><span class="card-archive-list-date">五月 2021</span><span class="card-archive-list-count">13</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/04/"><span class="card-archive-list-date">四月 2021</span><span class="card-archive-list-count">6</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/03/"><span class="card-archive-list-date">三月 2021</span><span class="card-archive-list-count">16</span></a></li></ul></div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站资讯</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">107</div></div><div class="webinfo-item"><div class="item-name">已运行时间 :</div><div class="item-count" id="runtimeshow" data-publishDate="2021-02-23T16:00:00.000Z"></div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"></div></div><div class="webinfo-item"><div class="item-name">本站总访问量 :</div><div class="item-count" id="busuanzi_value_site_pv"></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2021-10-24T01:53:25.706Z"></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Do2eM0N</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a><br>
<img src="https://z3.ax1x.com/2021/08/28/h3o6iT.png" alt="h3o6iT.png" border="0" />
<a href="https://beian.miit.gov.cn/#/Integrated/recordQuery"  style="color:#f72b07" target="_blank">京ICP备2021006139号</a></div><div class="footer_custom_text">欢迎来访</div><div id="running-time"><script>setInterval(()=>{let create_time=Math.round(new Date('2021-03-08 19:27:17').getTime()/1000);let timestamp=Math.round((new Date().getTime()+8*60*60*1000)/1000);let second=timestamp-create_time;let time=new Array(0,0,0,0,0);if(second>=365*24*3600){time[0]=parseInt(second/(365*24*3600));second%=365*24*3600;}if(second>=24*3600){time[1]=parseInt(second/(24*3600));second%=24*3600;}if(second>=3600){time[2]=parseInt(second/3600);second%=3600;}if(second>=60){time[3]=parseInt(second/60);second%=60;}if(second>0){time[4]=second;}currentTimeHtml='本站已安全运行 '+time[0]+' 年 '+time[1]+' 天 '+time[2]+' 时 '+time[3]+' 分 '+time[4]+' 秒';document.getElementById("running-time").innerHTML=currentTimeHtml;},1000);</script></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script src="/js/nobanner.js"></script><script src="/js/weather.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script>(function(d, w, c) {
    w.ChatraID = '6KqzuZGb38hQrA6f6';
    var s = d.createElement('script');
    w[c] = w[c] || function() {
        (w[c].q = w[c].q || []).push(arguments);
    };
    s.async = true;
    s.src = 'https://call.chatra.io/chatra.js';
    if (d.head) d.head.appendChild(s);
})(document, window, 'Chatra');

if (true) {
  var chatBtnFn = () => {
    var chatBtn = document.getElementById("chat_btn")
    chatBtn.addEventListener("click", function(){
      Chatra('openChat')
    });
  }
  chatBtnFn()
} else {
  if (true) {
    function chatBtnHide () {
      Chatra('hide')
    }
    function chatBtnShow () {
      Chatra('show')
    }
  }
}</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="http://doraemon2.xyz/categories/C/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 C++ (17)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://doraemon2.xyz/categories/C语言/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 C (16)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://doraemon2.xyz/categories/网络编程/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 网络编程 (6)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://doraemon2.xyz/categories/hexo/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 Hexo (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://doraemon2.xyz/categories/system/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 系统 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://doraemon2.xyz/categories/算法/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 算法 (24)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://doraemon2.xyz/categories/计算机/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 计算机 (8)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://doraemon2.xyz/categories/数据结构/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 数据结构 (25)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><a class="magnet_link_more"  href="http://doraemon2.xyz/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(50% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: RGB(73,177,245)}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
                        function butterfly_swiper_injector_config(){
                          var parent_div_git = document.getElementById('recent-posts');
                          var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2021/07/18/C语言实现学生成绩管理系统(EasyX图形窗口)/" alt=""><img width="48" height="48" src="/img/stuman2.png" alt=""/></a><div class="blog-slider__content"><span class="blog-slider__code">2021-07-18</span><a class="blog-slider__title" href="2021/07/18/C语言实现学生成绩管理系统(EasyX图形窗口)/" alt="">C语言实现学生成绩管理系统(EasyX图形窗口)</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" href="2021/07/18/C语言实现学生成绩管理系统(EasyX图形窗口)/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2021/08/26/【网络编程】基于TCPIP协议的CS模型/" alt=""><img width="48" height="48" src="/img/socket.png" alt=""/></a><div class="blog-slider__content"><span class="blog-slider__code">2021-08-26</span><a class="blog-slider__title" href="2021/08/26/【网络编程】基于TCPIP协议的CS模型/" alt="">【网络编程】基于TCP/IP协议的C/S模型</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" href="2021/08/26/【网络编程】基于TCPIP协议的CS模型/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2021/08/14/黑马程序员C++课程笔记总结/" alt=""><img width="48" height="48" src="/img/c++.png" alt=""/></a><div class="blog-slider__content"><span class="blog-slider__code">2021-08-14</span><a class="blog-slider__title" href="2021/08/14/黑马程序员C++课程笔记总结/" alt="">黑马程序员C++课程笔记总结</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" href="2021/08/14/黑马程序员C++课程笔记总结/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2021/06/17/Hexo-Butterfly添加天气插件/" alt=""><img width="48" height="48" src="/img/taohua.png" alt=""/></a><div class="blog-slider__content"><span class="blog-slider__code">2021-06-17</span><a class="blog-slider__title" href="2021/06/17/Hexo-Butterfly添加天气插件/" alt="">Hexo-Butterfly添加天气插件</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" href="2021/06/17/Hexo-Butterfly添加天气插件/" alt="">详情   </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
                          console.log('已挂载butterfly_swiper')
                          // parent_div_git.innerHTML=item_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                          parent_div_git.insertAdjacentHTML("afterbegin",item_html) // 有报错，但不影响使用(支持pjax跳转)
                          }
                        if( document.getElementById('recent-posts') && (location.pathname ==='all'|| 'all' ==='all')){
                        butterfly_swiper_injector_config()
                        }
                      </script><script defer src="https://cdnjs.cloudflare.com/ajax/libs/Swiper/4.1.6/js/swiper.min.js"></script><script defer data-pjax src="https://cdn.jsdelivr.net/npm/hexo-butterfly-swiper/lib/swiper_init.js"></script><!-- hexo injector body_end end --></body></html>