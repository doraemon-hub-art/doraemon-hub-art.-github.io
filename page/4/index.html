<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>半生瓜のblog</title><meta name="author" content="快乐的威猛先生"><meta name="copyright" content="快乐的威猛先生"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="There is no end">
<meta property="og:type" content="website">
<meta property="og:title" content="半生瓜のblog">
<meta property="og:url" content="http://blog.zhaoyuxuan.xyz/page/4/index.html">
<meta property="og:site_name" content="半生瓜のblog">
<meta property="og:description" content="There is no end">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://blog.zhaoyuxuan.xyz/img/doraemon2.png">
<meta property="article:author" content="快乐的威猛先生">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://blog.zhaoyuxuan.xyz/img/doraemon2.png"><link rel="shortcut icon" href="/img/doraemon2.png"><link rel="canonical" href="http://blog.zhaoyuxuan.xyz/page/4/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?6a91fe3b68865aca008ac0a703405b4e";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: false,
  isHome: true,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2022-03-02 15:38:11'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><link rel="stylesheet" href="/css/xiaotubiao.css"><link rel="stylesheet" href="/footermeihua.css"><link rel="stylesheet" href="/css/hua.css"><link rel="stylesheet" href="/css/background.css"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="半生瓜のblog" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/doraemon2.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">156</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">65</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">22</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 伙伴</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">半生瓜のblog</a><div id="tp-weather-widget"></div></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 伙伴</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div class="recent-posts" id="recent-posts"><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2021/10/16/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%88(C++)/" title="【数据结构】栈(C++)">     <img class="post_bg" src="/img/datas.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【数据结构】栈(C++)"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/10/16/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%88(C++)/" title="【数据结构】栈(C++)">【数据结构】栈(C++)</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-10-16T01:13:29.000Z" title="发表于 2021-10-16 09:13:29">2021-10-16</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><div class="content">栈只能在一边进出，先进的后出。
进出的一端叫做栈顶，另一端叫做栈底。
栈可以使用顺序存储结构，也能使用链式存储结构。

注意：栈只能在一端进行操作，这是栈的关键特征，也就是说栈不允许在中间进行查找、插入、删除等操作，(但是在实际应用中我们可以打破它)。
这里掌握初始化、入栈、出栈、取栈顶元素操作即可。
顺序存储结构实现栈1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;iostream&gt;using namespace std;#define MAX_SIZE 128typedef int DataType;//栈的结构有多重方式定义，不用局限于这一种/*	例如:		定义两个int型，并且直接开辟好数组空间		定义一个指针，一个int to ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2021/10/15/%E3%80%90%E6%A0%88%E3%80%91%E5%AE%9E%E7%8E%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/" title="【栈】实现表达式求值">     <img class="post_bg" src="/img/datas.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【栈】实现表达式求值"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/10/15/%E3%80%90%E6%A0%88%E3%80%91%E5%AE%9E%E7%8E%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/" title="【栈】实现表达式求值">【栈】实现表达式求值</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-10-15T15:03:52.000Z" title="发表于 2021-10-15 23:03:52">2021-10-15</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="content">【栈】实现表达式求值思路 &amp;&amp; 理解 &amp;&amp; 注意
给定一串表达式，字符串类型，依次遍历从头开始遍历每一个位置的内容。
第一个数字，第一个运算符先直接往栈里面push(两个不同的栈)接着走，遇到数push进来，接着走，遇到运算符，和前面那个已经push进栈的运算符进行优先级比较，如果当前运算符优先级大，那就接着push进来，反之，pop出栈，运算前面的式子之和(之后判断运算符栈中是否还有内容，并且当前运算符的优先级是否小于等于已有的运算符，小于等于就接着运算前面的表达式，完成push当前运算符，反之继续往下遍历push…pop…),直到最后一个元素。
注意;
一直发生变化的是rdata-右操作数,所以每次压完运算符找新的右操作数都会将他置空，准备重新赋值。
没有添加括号优先级运算。

expression.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676 ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2021/10/15/%E3%80%90%E6%A0%88%E3%80%91%E5%AE%9E%E7%8E%B0%E8%BF%B7%E5%AE%AB%E6%B1%82%E8%A7%A3/" title="【栈】实现迷宫求解">     <img class="post_bg" src="/img/datas.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【栈】实现迷宫求解"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/10/15/%E3%80%90%E6%A0%88%E3%80%91%E5%AE%9E%E7%8E%B0%E8%BF%B7%E5%AE%AB%E6%B1%82%E8%A7%A3/" title="【栈】实现迷宫求解">【栈】实现迷宫求解</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-10-15T06:58:35.000Z" title="发表于 2021-10-15 14:58:35">2021-10-15</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="content">迷宫求解从入口进入开始， 向不同方向试探，走到死胡同就退回。

找迷宫通路需要使用回溯法，找迷宫通路是对回溯法的一个很好的应用，实现回溯的过程用到数据结构—栈！


回溯法：
​        对一个包括有很多个结点，每个结点有若干个搜索分支的问题，把原问题分解为若干个子问题求解的 算法；当搜索到某个结点发现无法再继续搜索下去时，就让搜索过程回溯(回退)到该节点的前一个结点，继续 搜索该节点外的其他尚未搜索的分支；如果发现该结点无法再搜索下去，就让搜索过程回溯到这个结点的前一 结点继续这样的搜索过程；这样的搜索过程一直进行到搜索到问题的解或者搜索完了全部可搜索分支没有解存 在为止

思路&amp;解释
二维数组作为地图。
一开始确定一个入口——需要判定入口是否合法。
先将入口位置坐标压入栈，只要栈中不为空，那么每次判断移动方向前都要判断当前位置是不是出口。然后由此坐标开始向四周判断，判断哪有路可以走，是路就开始移动(cur-当前位置),压进栈……,走到死胡同，说明四周都不能走了，开始边popStack边向四周判断，不放过来时路上的任何一个遗漏的可能出口路径，反之，找到出口直接retur ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2021/10/13/LeetCode%E5%88%B7%E9%A2%98(18)%E3%80%90%E4%B8%AD%E7%AD%89%E3%80%91%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC%20N%20%E4%B8%AA%E7%BB%93%E7%82%B9(C++)/" title="LeetCode刷题(18)【中等】删除链表的倒数第 N 个结点(C++)">     <img class="post_bg" src="/img/leetcode.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="LeetCode刷题(18)【中等】删除链表的倒数第 N 个结点(C++)"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/10/13/LeetCode%E5%88%B7%E9%A2%98(18)%E3%80%90%E4%B8%AD%E7%AD%89%E3%80%91%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC%20N%20%E4%B8%AA%E7%BB%93%E7%82%B9(C++)/" title="LeetCode刷题(18)【中等】删除链表的倒数第 N 个结点(C++)">LeetCode刷题(18)【中等】删除链表的倒数第 N 个结点(C++)</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-10-13T13:28:33.000Z" title="发表于 2021-10-13 21:28:33">2021-10-13</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="content">19. 删除链表的倒数第 N 个结点
题目——[链接](19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode） (leetcode-cn.com))
遍历统计方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123;public:    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;        if(!head)//空的直接返回        &#123;            return NULL;        &#125;        int count =  0;//统计个数        ListNode* tempnode = head;        ListNode* temp = NULL;         int prev = 0;        while(tempnode)        &#123;      ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2021/10/13/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%A0%86(C++)/" title="【数据结构】堆(C++)">     <img class="post_bg" src="/img/datas.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【数据结构】堆(C++)"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/10/13/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%A0%86(C++)/" title="【数据结构】堆(C++)">【数据结构】堆(C++)</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-10-13T03:10:03.000Z" title="发表于 2021-10-13 11:10:03">2021-10-13</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><div class="content">堆概念

最大堆:最上面的结点数值最大
特点:1.每个结点最多可以有两个结点
2.根结点的键值是所有结点中最大的，每个结点的值都比孩子的值大。
3.除了根节点没有兄弟结点，最后一个左子结点可以没有兄弟结点，其他结点必须有兄弟结点。(有这个限制，下面的求子结点和父结点的公式才能成立。)


最小堆:最上面的结点数值最小….其他同最大堆


堆是最有个性的树，用数组表示的树。



在数组中快速创建堆左图——》右图


1.找到最后一个结点的父结点，(该父结点)与其子结点进行比较大小，若某个子结点大于父结点，则与该父结点交换位置。(就是从最后一个非叶子结点开始进行调整，(向下调整就是找到该父结结点的子结点，进行调整。))
2.再移动到前一个父结点，进行上述操作。
3……    


补充:static修饰的全局函数

一个普通的全局的静态函数。. 这样的static函数与普通函数的区别是：用static修饰的函数，限定在本源码文件中，不能被本源码文件以外的代码文件调用。

链接——链接

相关接口实现123456789101112131415161718192021222324252627 ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2021/10/12/%E6%8C%89%E7%85%A7%E4%BA%8C%E5%8F%89%E6%A0%91%E6%AF%8F%E8%A1%8C%E7%9A%84%E4%B8%AA%E6%95%B0%E6%89%93%E5%8D%B0%E6%95%B0%E7%BB%84/" title="按照二叉树每行的个数打印数组">     <img class="post_bg" src="/img/datas.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="按照二叉树每行的个数打印数组"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/10/12/%E6%8C%89%E7%85%A7%E4%BA%8C%E5%8F%89%E6%A0%91%E6%AF%8F%E8%A1%8C%E7%9A%84%E4%B8%AA%E6%95%B0%E6%89%93%E5%8D%B0%E6%95%B0%E7%BB%84/" title="按照二叉树每行的个数打印数组">按照二叉树每行的个数打印数组</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-10-12T11:17:40.000Z" title="发表于 2021-10-12 19:17:40">2021-10-12</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="content">

这个b玩意儿耗了我2个小时，怎么tm就写不出来呢。
可能是吃的太饱了吧。
越写不出来一定要越冷静下来。

123456789101112131415161718192021222324252627282930313233343536int num = hp.size;int front = 0;int back = 1;int row = 1;while (num)&#123;	for (int j = front; j &lt; back; j++)	&#123;		cout &lt;&lt; hp.arr[j] &lt;&lt; &quot; &quot;;	&#125;	cout &lt;&lt; endl;	num -= row;//输出完本行还剩的元素个数	//如果减去本行输出的个数小于0	if (num &lt;= 0)	&#123;		break;	&#125;	row *= 2;//下一行要输出的元素个数	front = back;//定位下一行的起点	if (num - row &lt;= 0)//如果当前的元素个数不够输出下一行的，直接定位下一行的back位置	 ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2021/10/11/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E9%98%9F%E5%88%97(C++)/" title="【数据结构】队列(C++)">     <img class="post_bg" src="/img/datas.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【数据结构】队列(C++)"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/10/11/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E9%98%9F%E5%88%97(C++)/" title="【数据结构】队列(C++)">【数据结构】队列(C++)</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-10-11T11:34:30.000Z" title="发表于 2021-10-11 19:34:30">2021-10-11</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><div class="content">队列队列是一种受限的线性表，它允许在一段进行删除操作，在另一端进行插入操作。
可以用数组实现，也可以用链表实现。
数组实现(顺序存储)设立一个队头指针front,一个队尾指针rear，分别指向队头元素和队尾元素，rear-front为元素个数。
(数组实现中，其实就是下标。)
 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#define MAX_SIZE 10typedef int DataType;typedef struct Queue&#123;	DataType queue[MAX_SIZE];	int front;	i ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2021/10/10/%E3%80%90MySQL%E3%80%91Windows%E4%B8%8B%E5%AE%89%E8%A3%85MySQL/" title="【MySQL】Windows下安装MySQL">     <img class="post_bg" src="/img/mysql.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【MySQL】Windows下安装MySQL"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/10/10/%E3%80%90MySQL%E3%80%91Windows%E4%B8%8B%E5%AE%89%E8%A3%85MySQL/" title="【MySQL】Windows下安装MySQL">【MySQL】Windows下安装MySQL</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-10-10T12:06:26.000Z" title="发表于 2021-10-10 20:06:26">2021-10-10</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/MySQL/">MySQL</a></span></div><div class="content">Windows下安装MySql安装下载链接——链接
选择第二个下载
点击图片左下角的蓝字直接进行下载。

下载完成，点击安装。
选择第一个，点击next。

点击Execulte

等待…然后点击next。


点击next。

点击next。

选择第一个，然后点next。
设置完密码，点击add user。

设置完成后，点击ok。

点击next。

默认，点击next。

点击Execute。

点击Finish。

点击next。

点击Finish。

点击next。

输入密码点击check测试。

点击next。

点击Execute

点击Finish,再点击next。

再次Finish。
弹出窗口。

启动方式一

方式二
管理员方式打开命令行。
1234停止net stop MySQL80开启new start MySQL80 

配置相关环境变量
点编辑。
C:\Program Files\MySQL\MySQL Server 8.0\bin
</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2021/10/10/LeetCode%E5%88%B7%E9%A2%98(17)%E3%80%90%E4%B8%AD%E7%AD%89%E3%80%91%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/" title="LeetCode刷题(17)【中等】两数相加(C++)">     <img class="post_bg" src="/img/leetcode.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="LeetCode刷题(17)【中等】两数相加(C++)"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/10/10/LeetCode%E5%88%B7%E9%A2%98(17)%E3%80%90%E4%B8%AD%E7%AD%89%E3%80%91%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/" title="LeetCode刷题(17)【中等】两数相加(C++)">LeetCode刷题(17)【中等】两数相加(C++)</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-10-10T03:45:24.000Z" title="发表于 2021-10-10 11:45:24">2021-10-10</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="content">2.两数相加
题目——链接
这题将两个val分开加到sum中更方便。
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118class Solution &#123;public:    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;        /*            从前往后遍历链表，对应的结点乘以10的n次方            越高位越往后存，所以用尾插                   */        //其中一个为空直接返回另一个        if(!l1)  ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2021/10/09/LeetCode%E5%88%B7%E9%A2%98(16)%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0&amp;&amp;%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8&amp;&amp;%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E7%BB%93%E7%82%B9/" title="LeetCode刷题(16)【简单】移除链表元素&amp;&amp;回文链表&amp;&amp;删除链表中的结点">     <img class="post_bg" src="/img/leetcode.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="LeetCode刷题(16)【简单】移除链表元素&amp;&amp;回文链表&amp;&amp;删除链表中的结点"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/10/09/LeetCode%E5%88%B7%E9%A2%98(16)%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0&amp;&amp;%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8&amp;&amp;%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E7%BB%93%E7%82%B9/" title="LeetCode刷题(16)【简单】移除链表元素&amp;&amp;回文链表&amp;&amp;删除链表中的结点">LeetCode刷题(16)【简单】移除链表元素&amp;&amp;回文链表&amp;&amp;删除链表中的结点</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-10-09T13:15:11.000Z" title="发表于 2021-10-09 21:15:11">2021-10-09</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="content">203.移除链表元素链接——链接

12345678910111213141516171819202122232425262728293031class Solution &#123;public:    ListNode* removeElements(ListNode* head, int val) &#123;        if(!head)        &#123;            return head;        &#125;        //设置一个新的头结点指向head——就能解决        ListNode* Newhead = new ListNode;        Newhead-&gt;next = head;        ListNode* tempnode = Newhead;        while(tempnode-&gt;next)        &#123;            if(tempnode-&gt;next-&gt;val == val)            &#123;                Lis ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2021/10/09/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E9%93%BE%E8%A1%A8(C++)/" title="【数据结构】链表(C++)">     <img class="post_bg" src="/img/datas.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【数据结构】链表(C++)"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/10/09/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E9%93%BE%E8%A1%A8(C++)/" title="【数据结构】链表(C++)">【数据结构】链表(C++)</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-10-09T12:50:46.000Z" title="发表于 2021-10-09 20:50:46">2021-10-09</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><div class="content">链表链表是线性表的链式存储方式，逻辑上相邻的数据在计算机中的内存位置不必须相邻，给每一个元素 加一个指针域，指向下一个元素的位置。
如下图所示:

链表的核心要素：

每个结点由数据域和指针域组成
指针域指向下一个结点的内存地址

单链表链表的结点均单项指向下一个结点，形成一条单项访问的数据链。

相关接口实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015 ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2021/10/05/LeetCode%E5%88%B7%E9%A2%98(15)%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0(C++)/" title="LeetCode刷题(15)【简单】删除链表中重复元素(C++)">     <img class="post_bg" src="/img/leetcode.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="LeetCode刷题(15)【简单】删除链表中重复元素(C++)"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/10/05/LeetCode%E5%88%B7%E9%A2%98(15)%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0(C++)/" title="LeetCode刷题(15)【简单】删除链表中重复元素(C++)">LeetCode刷题(15)【简单】删除链表中重复元素(C++)</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-10-05T11:11:26.000Z" title="发表于 2021-10-05 19:11:26">2021-10-05</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="content">83. 删除排序链表中的重复元素
题目——链接


单指针法1234567891011121314151617181920212223//一个指针往后遍历class Solution &#123;public:    ListNode* deleteDuplicates(ListNode* head) &#123;        if(!head || !head-&gt;next)        &#123;            return head;        &#125;        ListNode* tempnode = head;//这个头结点里面好像有元素        while(tempnode-&gt;next)        &#123;            if(tempnode-&gt;val == tempnode-&gt;next-&gt;val)            &#123;                tempnode-&gt;next = tempnode-&gt;next-&gt;next;            &#125;  ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2021/10/03/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E9%A1%BA%E5%BA%8F%E8%A1%A8(C++)/" title="【数据结构】顺序表(C++)">     <img class="post_bg" src="/img/datas.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【数据结构】顺序表(C++)"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/10/03/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E9%A1%BA%E5%BA%8F%E8%A1%A8(C++)/" title="【数据结构】顺序表(C++)">【数据结构】顺序表(C++)</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-10-03T15:54:35.000Z" title="发表于 2021-10-03 23:54:35">2021-10-03</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><div class="content">顺序表顺序表是简单的一种线性结构，逻辑上相邻的数据在计算机中内的存储位置也是相邻的，可以快速定位第几个元素，中间允许有空值，插入、删除时需要移动大量元素。

顺序表的三个要素


用elems记录存储位置的基地址。
分配一段连续的存储空间size（可以存放的元素个数）。
用length记录实际的元素个数，即顺序表的长度（现在实际存放的元素个数）。

图示
代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#define MAX_SIZE 100typedef int ElemsType;typedef struct _SqList&#123;	ElemsType* elems;	int length;//长度	int size;//容量&#125;SqList;//初始化bo ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2021/10/02/C&amp;C++%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/" title="C&amp;C++结构体内存对齐">     <img class="post_bg" src="/img/c++.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C&amp;C++结构体内存对齐"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/10/02/C&amp;C++%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/" title="C&amp;C++结构体内存对齐">C&amp;C++结构体内存对齐</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-10-02T12:20:29.000Z" title="发表于 2021-10-02 20:20:29">2021-10-02</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/C/">C++</a></span></div><div class="content">结构体内存对齐先来看这几个结构体，并计算它们的大小
123456789101112131415161718struct	A // 8&#123;	char a;	int b;&#125;;struct B // 16&#123;	char c;	int d;	double e;&#125;;struct C // 24&#123;	char f;	int g;	double h;	char i;&#125;;

输出的结果并非是实际成员占用的字节数，这就是结构体内存对齐。
结构体内存对齐的原因
1.平台原因(移植原因)

不是所有硬件平台都能访问任意地址上的任意数据，某些硬件平台只能在某些特定地址处取某些特定的数据，否则就会抛出硬件异常。也就是说计算机在读取内存数据时，只能在规定的地址处读数据，而不是在内存中任意位置都会可以读取的。

2.效率原因

正是由于只能在特定的地址处读取数据，所以在访问一些数据时，对于访问未对齐的内存，处理器需要进行两次访问；而对于对齐的内存，只需要访问一次就可以，其实这是一种以空间换时间的做法，并且这种做法是值得的。
结构体内存对齐规则
第一个成员在结构体 ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2021/10/01/C++%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" title="C++智能指针">     <img class="post_bg" src="/img/c++.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++智能指针"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/10/01/C++%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" title="C++智能指针">C++智能指针</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-10-01T13:39:09.000Z" title="发表于 2021-10-01 21:39:09">2021-10-01</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/C/">C++</a></span></div><div class="content">C++智能指针为什么要使用智能指针？&lt;&lt;C++ Primer&gt;&gt; p400
虽然使用动态内存有时是必要的，但众所周知，正确地管理动态内存是非常棘手的。
为了更容易(同时也更安全的)地使用动态内存，新的标准库提供了两种智能指针，来管理动态对象。智能指针的行为类似于常规指针，重要的区别是它负责自动释放所指向的对象。
shared_ptr允许多个指针指向同一个对象，unique_ptr是“独占”所指向的对象。标准库还定义了一个名为weak_ptr的伴随类，它是一种弱引用，指向shared_ptr所管理的对象。这三种类型都定义在memeory头文件中。
原理:将我们分配的动态内存都交给有生命周期的对象来处理，当对象过期时，让它的析构函数删除指向的内存。

C++98 提供了 auto_ptr模板的解决方案
C++11 增加了 unique_ptr、shared_ptr、weak_ptr

(就是一个类模板，里面有析构函数，能够自动释放这个对象开辟的内存。)
auto_ptrC++98的智能指针模板，其定义了管理指针的对象，可以将new获得(直接或间接获得)的地址赋值给这 ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2021/10/01/C++%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86&amp;C++11%E6%96%B0%E7%89%B9%E6%80%A7/" title="C++explicit关键字、类型转换、左右值">     <img class="post_bg" src="/img/c++.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++explicit关键字、类型转换、左右值"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/10/01/C++%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86&amp;C++11%E6%96%B0%E7%89%B9%E6%80%A7/" title="C++explicit关键字、类型转换、左右值">C++explicit关键字、类型转换、左右值</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-10-01T02:59:25.000Z" title="发表于 2021-10-01 10:59:25">2021-10-01</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/C/">C++</a></span></div><div class="content">C++补充知识&amp;C++11及其特性
explicit关键字加在类构造函数前表明该构造函数是显式的，并非隐式的，不能进行隐式类型转换！
类构造函数默认情况下声明为隐式。
给构造函数加上关键字explicit使得该类创建对象必须显式调用构造。
12345student xiaohua(18);//显式构造student xiaoming = 18;//隐式构造student xiaoli(&quot;小李&quot;，18);//显式构造student xiaomei = (&quot;小美&quot;，18);//隐式构造-C++11之前编译不能过//初始化参数列表C++11新增

看到=要想是赋值呢，还是隐式构造呢。
左值和右值的概念
 按字面意思，通俗的说，以赋值运算符=为界，左边的就是左值，右边的就是右值。
左值(lvalue)——代表一个在内存中占有确定位置的对象(就是有一个地址)。
右值(rvalue)——通过排他性来定义，每个表达式不是左值就是右值，rvalue是不在内存中占有确定位置的表达式，而是在存在寄存器中。
所有的左值(无论是数组，函数或不完全类型)都可以转化 ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2021/09/30/C++%E4%BD%BF%E7%94%A8%E5%86%85%E7%BD%AE%E5%AE%B9%E5%99%A8%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%B9%E5%99%A8/" title="C++使用内置容器实现自定义容器">     <img class="post_bg" src="/img/c++.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++使用内置容器实现自定义容器"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/09/30/C++%E4%BD%BF%E7%94%A8%E5%86%85%E7%BD%AE%E5%AE%B9%E5%99%A8%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%B9%E5%99%A8/" title="C++使用内置容器实现自定义容器">C++使用内置容器实现自定义容器</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-09-30T00:56:24.000Z" title="发表于 2021-09-30 08:56:24">2021-09-30</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/C/">C++</a></span></div><div class="content">MySet容器实现MySet .hpp
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#ifndef _myset#define _myset#include&lt;iostream&gt;#include&lt;set&gt;using namespace std;//基于set容器来实现MySet自定义容器//参数1为 里面存的数据类型    参数2 用哪种容器来实现，并且默认为set容器/** 注:		在模板(t ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2021/09/29/C++STL%E5%AE%B9%E5%99%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%B0%8F%E7%BB%93/" title="C++STL容器知识点小结">     <img class="post_bg" src="/img/c++.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++STL容器知识点小结"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/09/29/C++STL%E5%AE%B9%E5%99%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%B0%8F%E7%BB%93/" title="C++STL容器知识点小结">C++STL容器知识点小结</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-09-29T02:16:05.000Z" title="发表于 2021-09-29 10:16:05">2021-09-29</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/C/">C++</a></span></div><div class="content">STL标准模板库
STL主要分为分为三类：

algorithm（算法） -  对数据进行处理（解决问题) 步骤的有限集合
container（容器） -  用来管理一组数据元素
 Iterator (迭代器） -  可遍历STL容器内全部或部分元素”的对象

容器和算法通过迭代器可以进行无缝地连接。在STL中几乎所有的代码都采用了模板类和模板函数的方式，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。
STL 最早源于惠普实验室，早于C++存在，但是C++引入STL概念后，STL就成为C++的一部分，因为它被内建在你的编译器之内，不需要另行安装。
STL被组织为下面的13个头文件:



&lt; algorithm &gt;
&lt; memory &gt;



&lt; deque &gt;
&lt; numeric &gt;


&lt; functional &gt;
&lt; queue &gt;


&lt; iterator &gt;
&lt; set &gt;


&lt; vector &gt;
&lt; stack &gt;


&lt; list ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2021/09/28/C++%E4%BB%BF%E5%87%BD%E6%95%B0(%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1)/" title="C++仿函数(函数对象)">     <img class="post_bg" src="/img/c++.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++仿函数(函数对象)"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/09/28/C++%E4%BB%BF%E5%87%BD%E6%95%B0(%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1)/" title="C++仿函数(函数对象)">C++仿函数(函数对象)</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-09-28T08:43:10.000Z" title="发表于 2021-09-28 16:43:10">2021-09-28</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/C/">C++</a></span></div><div class="content">仿函数(函数对象)研究set/multiset容器的排序原理。
当我们构造一个存放int类型的set容器时
1set&lt;int&gt; s1;

系统会自动帮我们设定并调用一个函数，自动调用头文件functional中的仿函数(一个类中重载了()实现了对比的操作，从而完成了排序)。
1set&lt;int,less&lt;int&gt;&gt; s1;

less函数对象实现比较，为排序提供依据。（升序）greater（降序）
functional中，如图

手动实现:
123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;set&gt;using namespace std;class Student&#123;public:	Student(int _age):age(_age)	&#123;	&#125;	int getAge()const	&#123;		return age;	&#125;	bool ope ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2021/09/27/C++11%E6%96%B0%E7%89%B9%E6%80%A7-%E5%8F%98%E5%8F%82%E6%A8%A1%E6%9D%BF%E3%80%81%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E5%92%8Cemplace/" title="C++:explicit关键字、左右值、类型转换">     <img class="post_bg" src="/img/c++.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++:explicit关键字、左右值、类型转换"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/09/27/C++11%E6%96%B0%E7%89%B9%E6%80%A7-%E5%8F%98%E5%8F%82%E6%A8%A1%E6%9D%BF%E3%80%81%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E5%92%8Cemplace/" title="C++:explicit关键字、左右值、类型转换">C++:explicit关键字、左右值、类型转换</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-09-27T13:06:35.000Z" title="发表于 2021-09-27 21:06:35">2021-09-27</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/C/">C++</a></span></div><div class="content">C++11新特性：变参模板、完美转发和emplace使得 emplace 可以接受任意参数，这样就可以适用于任意对象的构建。

《C++Primer》:新标准引入了三个是新成员——emplace、emplace_front和emplace_back,这些操作构造而不是拷贝元素。这些操作分别对应着，insert、push_front、push_back，允许我们将元素放置在容器头部、一个指定位置之前或容器尾部。
当我们调用push或insert成员函数时，我们将元素类型的对象传递给它们，这些对象被拷贝到容器中。而当我们调用一个emplace成员函数时，则是将参数传递给元素类型的构造函数。emplace成员使用这些参数在容器管理的内存空间中直接构造元素。

问题代码如下：
123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;list&gt;usin ...</div></div></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/3/"><i class="fas fa-chevron-left fa-fw"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/5/"><i class="fas fa-chevron-right fa-fw"></i></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/doraemon2.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">快乐的威猛先生</div><div class="author-info__description">There is no end</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">156</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">65</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">22</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://space.bilibili.com/94657270"><i class="iconfont icon-bofangqi-zantingxiaodianshi"></i><span>关注我一下吧</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://imgtu.com/i/4T713Q" target="_blank" title="我的微信公众号"><i class="iconfont icon-weixin"></i></a><a class="social-icon" href="https://github.com/doraemon-hub-art" target="_blank" title="我的Github"><i class="iconfont icon-github"></i></a><a class="social-icon" href="https://blog.csdn.net/qq_51604330?spm=1000.2115.3001.5343" target="_blank" title="我的CSDN"><i class="iconfont icon-csdn"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">我的交流群805814463</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/03/01/%E3%80%90QT%E3%80%91QT%E4%B8%AD%E4%BD%BF%E7%94%A8lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/" title="【QT】QT中使用Lambda表达式"><img src="/img/QT.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【QT】QT中使用Lambda表达式"/></a><div class="content"><a class="title" href="/2022/03/01/%E3%80%90QT%E3%80%91QT%E4%B8%AD%E4%BD%BF%E7%94%A8lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/" title="【QT】QT中使用Lambda表达式">【QT】QT中使用Lambda表达式</a><time datetime="2022-03-01T15:13:27.000Z" title="发表于 2022-03-01 23:13:27">2022-03-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/23/%E3%80%90QT%E3%80%91QString%E3%80%81QLatin1String%E3%80%81QStringLiteral/" title="【QT】QString、QLatin1String、QStringLiteral"><img src="/img/QT.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【QT】QString、QLatin1String、QStringLiteral"/></a><div class="content"><a class="title" href="/2022/02/23/%E3%80%90QT%E3%80%91QString%E3%80%81QLatin1String%E3%80%81QStringLiteral/" title="【QT】QString、QLatin1String、QStringLiteral">【QT】QString、QLatin1String、QStringLiteral</a><time datetime="2022-02-23T11:51:45.000Z" title="发表于 2022-02-23 19:51:45">2022-02-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/23/%E3%80%90QT%E3%80%91QT%E5%9F%BA%E6%9C%AC%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/" title="【QT】QT基本图形绘制"><img src="/img/QT.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【QT】QT基本图形绘制"/></a><div class="content"><a class="title" href="/2022/02/23/%E3%80%90QT%E3%80%91QT%E5%9F%BA%E6%9C%AC%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/" title="【QT】QT基本图形绘制">【QT】QT基本图形绘制</a><time datetime="2022-02-23T06:54:45.000Z" title="发表于 2022-02-23 14:54:45">2022-02-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/21/%E3%80%90QT%E3%80%91QT%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/" title="【QT】QT事件处理"><img src="/img/QT.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【QT】QT事件处理"/></a><div class="content"><a class="title" href="/2022/02/21/%E3%80%90QT%E3%80%91QT%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/" title="【QT】QT事件处理">【QT】QT事件处理</a><time datetime="2022-02-21T03:13:41.000Z" title="发表于 2022-02-21 11:13:41">2022-02-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/19/%E3%80%90QT%E3%80%91QT%E8%B0%83%E8%89%B2%E6%9D%BF%E7%B1%BB/" title="【QT】QT调色板类"><img src="/img/QT.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【QT】QT调色板类"/></a><div class="content"><a class="title" href="/2022/02/19/%E3%80%90QT%E3%80%91QT%E8%B0%83%E8%89%B2%E6%9D%BF%E7%B1%BB/" title="【QT】QT调色板类">【QT】QT调色板类</a><time datetime="2022-02-19T13:07:41.000Z" title="发表于 2022-02-19 21:07:41">2022-02-19</time></div></div></div></div><!--!=partial('includes/widget/card_categories', {}, {cache: true})--><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size: 1.1em; color: #999">-C</a> <a href="/tags/C/" style="font-size: 1.5em; color: #99a9bf">-C++</a> <a href="/tags/C-11/" style="font-size: 1.23em; color: #999ea6">-C++11</a> <a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 1.46em; color: #99a7bb">-C语言</a> <a href="/tags/DIY/" style="font-size: 1.1em; color: #999">-DIY</a> <a href="/tags/DLL/" style="font-size: 1.1em; color: #999">-DLL</a> <a href="/tags/EasyX/" style="font-size: 1.19em; color: #999da1">-EasyX</a> <a href="/tags/Gitee/" style="font-size: 1.1em; color: #999">-Gitee</a> <a href="/tags/Hexo/" style="font-size: 1.1em; color: #999">-Hexo</a> <a href="/tags/JAVA/" style="font-size: 1.1em; color: #999">-JAVA</a> <a href="/tags/Lamabda/" style="font-size: 1.1em; color: #999">-Lamabda</a> <a href="/tags/LeetCode/" style="font-size: 1.37em; color: #99a4b2">-LeetCode</a> <a href="/tags/Linux/" style="font-size: 1.1em; color: #999">-Linux</a> <a href="/tags/MFC/" style="font-size: 1.14em; color: #999b9d">-MFC</a> <a href="/tags/MySQL/" style="font-size: 1.19em; color: #999da1">-MySQL</a> <a href="/tags/NowCoder/" style="font-size: 1.1em; color: #999">-NowCoder</a> <a href="/tags/Pic/" style="font-size: 1.1em; color: #999">-Pic</a> <a href="/tags/Python/" style="font-size: 1.14em; color: #999b9d">-Python</a> <a href="/tags/QT/" style="font-size: 1.41em; color: #99a5b7">-QT</a> <a href="/tags/STL/" style="font-size: 1.14em; color: #999b9d">-STL</a> <a href="/tags/TCP/" style="font-size: 1.1em; color: #999">-TCP</a> <a href="/tags/UDP/" style="font-size: 1.1em; color: #999">-UDP</a> <a href="/tags/Win32-C%E8%AF%AD%E8%A8%80/" style="font-size: 1.1em; color: #999">-Win32 - -C语言</a> <a href="/tags/hash/" style="font-size: 1.1em; color: #999">-hash</a> <a href="/tags/hexo/" style="font-size: 1.1em; color: #999">-hexo</a> <a href="/tags/nonebot/" style="font-size: 1.1em; color: #999">-nonebot</a> <a href="/tags/python/" style="font-size: 1.1em; color: #999">-python</a> <a href="/tags/system/" style="font-size: 1.1em; color: #999">-system</a> <a href="/tags/windows/" style="font-size: 1.14em; color: #999b9d">-windows</a> <a href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 1.28em; color: #99a0aa">-二叉树</a> <a href="/tags/%E4%BA%8C%E7%BA%A7/" style="font-size: 1.32em; color: #99a2ae">-二级</a> <a href="/tags/%E5%86%85%E5%AD%98/" style="font-size: 1.1em; color: #999">-内存</a> <a href="/tags/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/" style="font-size: 1.1em; color: #999">-双向链表</a> <a href="/tags/%E5%9B%BE/" style="font-size: 1.1em; color: #999">-图</a> <a href="/tags/%E5%9B%BE%E5%BA%8A/" style="font-size: 1.1em; color: #999">-图床</a> <a href="/tags/%E5%9B%BE%E5%BD%A2%E7%BC%96%E7%A8%8B/" style="font-size: 1.1em; color: #999">-图形编程</a> <a href="/tags/%E5%A0%86/" style="font-size: 1.14em; color: #999b9d">-堆</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 1.1em; color: #999">-多线程</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" style="font-size: 1.1em; color: #999">-字符串</a> <a href="/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" style="font-size: 1.1em; color: #999">-学习记录</a></div></div><div class="card-widget card-archives"><div class="item-headline"><i class="fas fa-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="fas fa-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/03/"><span class="card-archive-list-date">三月 2022</span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/02/"><span class="card-archive-list-date">二月 2022</span><span class="card-archive-list-count">12</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/01/"><span class="card-archive-list-date">一月 2022</span><span class="card-archive-list-count">18</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/12/"><span class="card-archive-list-date">十二月 2021</span><span class="card-archive-list-count">2</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/11/"><span class="card-archive-list-date">十一月 2021</span><span class="card-archive-list-count">6</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/10/"><span class="card-archive-list-date">十月 2021</span><span class="card-archive-list-count">37</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/09/"><span class="card-archive-list-date">九月 2021</span><span class="card-archive-list-count">12</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/08/"><span class="card-archive-list-date">八月 2021</span><span class="card-archive-list-count">11</span></a></li></ul></div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站资讯</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">156</div></div><div class="webinfo-item"><div class="item-name">已运行时间 :</div><div class="item-count" id="runtimeshow" data-publishDate="2021-02-23T16:00:00.000Z"></div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"></div></div><div class="webinfo-item"><div class="item-name">本站总访问量 :</div><div class="item-count" id="busuanzi_value_site_pv"></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2022-03-02T07:38:09.849Z"></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 快乐的威猛先生</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a><br></div><div class="footer_custom_text">欢迎来访</div><div id="running-time"><script>setInterval(()=>{let create_time=Math.round(new Date('2021-03-08 19:27:17').getTime()/1000);let timestamp=Math.round((new Date().getTime()+8*60*60*1000)/1000);let second=timestamp-create_time;let time=new Array(0,0,0,0,0);if(second>=365*24*3600){time[0]=parseInt(second/(365*24*3600));second%=365*24*3600;}if(second>=24*3600){time[1]=parseInt(second/(24*3600));second%=24*3600;}if(second>=3600){time[2]=parseInt(second/3600);second%=3600;}if(second>=60){time[3]=parseInt(second/60);second%=60;}if(second>0){time[4]=second;}currentTimeHtml='本站已安全运行 '+time[0]+' 年 '+time[1]+' 天 '+time[2]+' 时 '+time[3]+' 分 '+time[4]+' 秒';document.getElementById("running-time").innerHTML=currentTimeHtml;},1000);</script></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script src="/js/nobanner.js"></script><script src="/js/weather.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>