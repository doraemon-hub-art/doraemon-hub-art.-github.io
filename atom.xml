<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>半生瓜のblog</title>
  
  
  <link href="http://zhaoyuxuan.xyz/atom.xml" rel="self"/>
  
  <link href="http://zhaoyuxuan.xyz/"/>
  <updated>2021-11-14T06:00:47.107Z</updated>
  <id>http://zhaoyuxuan.xyz/</id>
  
  <author>
    <name>Do2eM0N</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【网络编程】简单的服务端客户端实现</title>
    <link href="http://zhaoyuxuan.xyz/2021/11/14/%E3%80%90%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E3%80%91%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%9E%E7%8E%B0/"/>
    <id>http://zhaoyuxuan.xyz/2021/11/14/%E3%80%90%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E3%80%91%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-11-14T05:57:06.000Z</published>
    <updated>2021-11-14T06:00:47.107Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><hr><p>有些图片来源——<a href="https://blog.csdn.net/TT_love9527">https://blog.csdn.net/TT_love9527</a></p><p>其他图片来源未知，侵删。</p><hr><h2 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h2><p><img src="/images/%E7%BD%91%E7%BB%9C.assets/image-20211113113551491.png" alt=" "></p><p>发送方在一层一层的打包，接受方，一层一层解包，拿到数据。</p><p><img src="/images/%E7%BD%91%E7%BB%9C.assets/image-20211113114043879.png" alt="image-20211113114043879"></p><p>我们要做的只是使用打包好的API函数，传递参数即可。</p><h2 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP/IP模型"></a>TCP/IP模型</h2><p>可以理解为OSI七层模型的简化版本。</p><p><strong>对比</strong>：</p><p><img src="/images/%E7%BD%91%E7%BB%9C.assets/image-20211113114251036.png" alt="image-20211113114251036"></p><hr><p><img src="/images/%E7%BD%91%E7%BB%9C.assets/image-20211113114406218.png" alt="image-20211113114406218"></p><p><strong>收发过程可以想象成收发快递。</strong></p><p><img src="/images/%E7%BD%91%E7%BB%9C.assets/image-20211113114519988.png" alt="image-20211113114519988"></p><p>每层只做它应该做的事，其余的它都不知道。</p><p>上层调用下层服务。</p><p><strong>经典的分层模型。</strong></p><p>双方遵守协议的内容，正确完成通信。</p><h2 id="网络套接字编程"><a href="#网络套接字编程" class="headerlink" title="网络套接字编程"></a>网络套接字编程</h2><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p><img src="/images/%E7%BD%91%E7%BB%9C.assets/image-20211113114946319.png" alt="image-20211113114946319"></p><h3 id="TCP套接字"><a href="#TCP套接字" class="headerlink" title="TCP套接字"></a>TCP套接字</h3><p><img src="/images/%E7%BD%91%E7%BB%9C.assets/image-20211113115130159.png" alt="image-20211113115130159"></p><p><strong>无论客户端还是服务端在发送的时候都多发送1个长度，字符串结束符。</strong></p><h4 id="TCP套接字服务端"><a href="#TCP套接字服务端" class="headerlink" title="TCP套接字服务端"></a>TCP套接字服务端</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化套接字库</span></span><br><span class="line">    WORD wVersion;</span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    wVersion = MAKEWORD(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    err = WSAStartup(wVersion, &amp;wsaData);<span class="comment">//初始化哪个版本的网络库，并且将数据存放到哪里</span></span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (LOBYTE(wsaData.wVersion) != <span class="number">1</span>  || HIBYTE(wsaData.wVersion) != <span class="number">1</span>)<span class="comment">//版本检查</span></span><br><span class="line">    &#123;</span><br><span class="line">        WSACleanup();<span class="comment">//清理套接字库</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建套接字</span></span><br><span class="line">    SOCKET sockServer = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);  <span class="comment">//协议族、协议栈</span></span><br><span class="line">    <span class="comment">//准备绑定的信息</span></span><br><span class="line">    SOCKADDR_IN addrServer;</span><br><span class="line">    addrServer.sin_addr.S_un.S_addr = htonl(INADDR_ANY);<span class="comment">//htonl——</span></span><br><span class="line">    addrServer.sin_family = AF_INET;<span class="comment">//协议栈</span></span><br><span class="line">    addrServer.sin_port = htons(<span class="number">6000</span>);<span class="comment">//端口-1024以下的端口是系统保留的，htons——大小端转换,x86小端，网络传输-大端</span></span><br><span class="line">    <span class="comment">//绑定到本机</span></span><br><span class="line">    bind(sockServer,(SOCKADDR*)&amp;addrServer,<span class="keyword">sizeof</span>(SOCKADDR));</span><br><span class="line">    <span class="comment">//监听</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Server start at port 6000&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    listen(sockServer,<span class="number">10</span>);</span><br><span class="line">    SOCKADDR_IN addrClient;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(SOCKADDR);</span><br><span class="line">    <span class="keyword">char</span> recvBuf[<span class="number">100</span>];<span class="comment">//创建两个缓冲区</span></span><br><span class="line">    <span class="keyword">char</span> sendBuf[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//接收连接请求,返回根据客户端的套接字</span></span><br><span class="line">        SOCKET sockConnect = accept(sockServer,(SOCKADDR*)&amp;addrClient,&amp;len);</span><br><span class="line">        sprintf_s(sendBuf,<span class="number">100</span>,<span class="string">&quot;hello client&quot;</span>);</span><br><span class="line">        <span class="comment">//发</span></span><br><span class="line">        send(sockConnect, sendBuf, <span class="built_in">strlen</span>(sendBuf)+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">         <span class="comment">//收</span></span><br><span class="line">        recv(sockConnect, recvBuf, <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; recvBuf &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        closesocket(sockConnect); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭套接字</span></span><br><span class="line">    closesocket(sockServer);</span><br><span class="line">    <span class="comment">//清理套接字库</span></span><br><span class="line">    WSACleanup();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="TCP套接字客户端"><a href="#TCP套接字客户端" class="headerlink" title="TCP套接字客户端"></a>TCP套接字客户端</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化套接字库</span></span><br><span class="line">    WORD wVersion;</span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    wVersion = MAKEWORD(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    err = WSAStartup(wVersion, &amp;wsaData);<span class="comment">//初始化哪个版本的网络库，并且将数据存放到哪里</span></span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (LOBYTE(wsaData.wVersion) != <span class="number">1</span> || HIBYTE(wsaData.wVersion) != <span class="number">1</span>)<span class="comment">//版本检查</span></span><br><span class="line">    &#123;</span><br><span class="line">        WSACleanup();<span class="comment">//清理套接字库</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建TCP套接字</span></span><br><span class="line">    SOCKET sockClient = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//绑定</span></span><br><span class="line">    SOCKADDR_IN addrSrv;</span><br><span class="line">    addrSrv.sin_addr.S_un.S_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    addrSrv.sin_port = htons(<span class="number">6000</span>);<span class="comment">//与服务器绑定端口保持一致，否则无法连接</span></span><br><span class="line">    addrSrv.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">//连接</span></span><br><span class="line">    connect(sockClient, (SOCKADDR*)&amp;addrSrv, <span class="keyword">sizeof</span>(SOCKADDR));</span><br><span class="line">    <span class="comment">//缓冲区</span></span><br><span class="line">    <span class="keyword">char</span> sendBuf[] = <span class="string">&quot;hello server&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> recvBuf[<span class="number">100</span>];</span><br><span class="line">    <span class="comment">//发送数据到服务器</span></span><br><span class="line">    send(sockClient, sendBuf, <span class="built_in">strlen</span>(sendBuf)+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//接收数据</span></span><br><span class="line">    recv(sockClient, recvBuf, <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; recvBuf &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  </span><br><span class="line">    <span class="comment">//关闭清理</span></span><br><span class="line">    closesocket(sockClient);</span><br><span class="line">    WSACleanup();</span><br><span class="line">   <span class="comment">// system(&quot;pause&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UDP套接字"><a href="#UDP套接字" class="headerlink" title="UDP套接字"></a>UDP套接字</h3><p><img src="/images/%E7%BD%91%E7%BB%9C.assets/image-20211113203130824.png" alt="image-20211113203130824"></p><p><strong>UDP套接字不需要监听、建立链接，绑上网卡和端口，直接发送就可以。</strong></p><h4 id="UDP套接字服务端"><a href="#UDP套接字服务端" class="headerlink" title="UDP套接字服务端"></a>UDP套接字服务端</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//初始化套接字库</span></span><br><span class="line">WORD wVersion;</span><br><span class="line">WSADATA wsaData;</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line">wVersion = MAKEWORD(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">err = WSAStartup(wVersion, &amp;wsaData);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (HIBYTE(wsaData.wVersion) != <span class="number">1</span> || LOBYTE(wsaData.wVersion) != <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">WSACleanup();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建套接字</span></span><br><span class="line">SOCKET sockServer = socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">SOCKADDR_IN addrSrv;</span><br><span class="line">addrSrv.sin_addr.S_un.S_addr = htonl(INADDR_ANY);<span class="comment">//主机上任何一个网卡</span></span><br><span class="line">addrSrv.sin_port = htons(<span class="number">6002</span>);</span><br><span class="line">addrSrv.sin_family = AF_INET;</span><br><span class="line"><span class="comment">//绑定到本机6002端口</span></span><br><span class="line">bind(sockServer,(SOCKADDR*)&amp;addrSrv,<span class="keyword">sizeof</span>(SOCKADDR));</span><br><span class="line"><span class="comment">//接收请求, 处理请求</span></span><br><span class="line">SOCKADDR_IN addrClient;</span><br><span class="line"><span class="keyword">int</span> len = <span class="keyword">sizeof</span>(SOCKADDR);</span><br><span class="line"><span class="keyword">char</span> sendBuf[] = <span class="string">&quot;hello client&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> recvBuf[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Start UDP Server at port 6002&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//接收数据</span></span><br><span class="line">recvfrom(sockServer,recvBuf,<span class="number">100</span>,<span class="number">0</span>,(SOCKADDR*)&amp;addrClient,&amp;len);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;Recv:&quot;</span>&lt;&lt; recvBuf &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//发送数据</span></span><br><span class="line">sendto(sockServer, sendBuf, <span class="built_in">strlen</span>(sendBuf) + <span class="number">1</span>, <span class="number">0</span>, (SOCKADDR*)&amp;addrClient, len);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Send:&quot;</span> &lt;&lt; sendBuf &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="UDP套接字客户端"><a href="#UDP套接字客户端" class="headerlink" title="UDP套接字客户端"></a>UDP套接字客户端</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//初始化套接字库</span></span><br><span class="line">WORD wVersion;</span><br><span class="line">WSADATA wsaData;</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line">wVersion = MAKEWORD(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">err = WSAStartup(wVersion, &amp;wsaData);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (HIBYTE(wsaData.wVersion) != <span class="number">1</span> || LOBYTE(wsaData.wVersion) != <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">WSACleanup();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建UDP套接字</span></span><br><span class="line">SOCKET sockClient = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">SOCKADDR_IN addrSrv;</span><br><span class="line">addrSrv.sin_addr.S_un.S_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">addrSrv.sin_port = htons(<span class="number">6002</span>);</span><br><span class="line">addrSrv.sin_family = AF_INET;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len = <span class="keyword">sizeof</span>(SOCKADDR);</span><br><span class="line"><span class="comment">//缓冲区</span></span><br><span class="line"><span class="keyword">char</span> sendBuf[] = <span class="string">&quot;hello Server :)&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> recvBuf[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;send to Server:&quot;</span> &lt;&lt; sendBuf&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">sendto(sockClient, sendBuf, <span class="built_in">strlen</span>(sendBuf) + <span class="number">1</span>,<span class="number">0</span>,(SOCKADDR*)&amp;addrSrv,len);</span><br><span class="line">recvfrom(sockClient, recvBuf, <span class="number">100</span>, <span class="number">0</span>,(SOCKADDR*)&amp;addrSrv, &amp;len);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;recv from Server:&quot;</span> &lt;&lt; recvBuf &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">closesocket(sockClient);</span><br><span class="line">WSACleanup();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;网络编程&quot;&gt;&lt;a href=&quot;#网络编程&quot; class=&quot;headerlink&quot; title=&quot;网络编程&quot;&gt;&lt;/a&gt;网络编程&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;有些图片来源——&lt;a href=&quot;https://blog.csdn.net/TT_love9527&quot;&gt;https</summary>
      
    
    
    
    <category term="网络编程" scheme="http://zhaoyuxuan.xyz/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="-网络编程" scheme="http://zhaoyuxuan.xyz/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    <category term="-TCP" scheme="http://zhaoyuxuan.xyz/tags/TCP/"/>
    
    <category term="-UDP" scheme="http://zhaoyuxuan.xyz/tags/UDP/"/>
    
  </entry>
  
  <entry>
    <title>【MFC】MFC基础篇(1)</title>
    <link href="http://zhaoyuxuan.xyz/2021/11/13/%E3%80%90MFC%E3%80%91MFC%E5%9F%BA%E7%A1%80%E7%AF%87(1)/"/>
    <id>http://zhaoyuxuan.xyz/2021/11/13/%E3%80%90MFC%E3%80%91MFC%E5%9F%BA%E7%A1%80%E7%AF%87(1)/</id>
    <published>2021-11-13T03:20:46.000Z</published>
    <updated>2021-11-14T05:36:02.778Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MFC基础篇"><a href="#MFC基础篇" class="headerlink" title="MFC基础篇"></a>MFC基础篇</h1><p>以C++类的形式对WINDOWS API进行封装。</p><h2 id="MFC框架理论"><a href="#MFC框架理论" class="headerlink" title="MFC框架理论"></a>MFC框架理论</h2><h3 id="关键类"><a href="#关键类" class="headerlink" title="关键类"></a>关键类</h3><p>CWinApp:MFC应用程序抽象，管理DocumentTemplate。</p><p>CFrameWnd: 框架窗口，负责创建应用主窗口，含标题栏，菜单栏，工具栏，状态栏等 。</p><p>CView: 负责展示应用数据，View其实是一个没有边框的窗口, 客户区 。</p><p>CDocument: 负责存储应用数据 。</p><p>CDocTemplate：DocumentTemplate: 隐藏Boss， 负责管理MainFrame，View和Document。</p><h2 id="窗口与窗口对象"><a href="#窗口与窗口对象" class="headerlink" title="窗口与窗口对象"></a>窗口与窗口对象</h2><p><strong>关系：</strong></p><ol><li>每个窗口对象都包含一个窗口</li><li>窗口对象使用Create方法创建窗口，在Create方法个中将窗口对象与窗口绑定</li><li><strong>窗口对象的与窗口的生命周期不同，并不同生共死。(menu.Detach()将对象与它绑定在窗口的这一块区域分离(分离窗口对象和窗口))</strong></li></ol><h2 id="afx"><a href="#afx" class="headerlink" title="afx"></a>afx</h2><p>微软mfx小组。</p><h2 id="消息映射"><a href="#消息映射" class="headerlink" title="消息映射"></a>消息映射</h2><p>把消息ID和相应函数关联起来。 当这种消息发送出来后，对应的函数就会触发。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BEGIN_MESSAGE_MAP(CMFCApplicationView, CView)</span><br><span class="line">ON_COMMAND(ID_MSG_DRAW_PEN,&amp;CMFCApplicationView::OnPen)</span><br><span class="line">ON_COMMAND(ID_MSG_DRAW_RECT,&amp;CMFCApplicationView::OnRect)</span><br><span class="line">    ......</span><br><span class="line">END_MESSAGE_MAP()</span><br></pre></td></tr></table></figure><h2 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h2><h3 id="元文件"><a href="#元文件" class="headerlink" title="元文件"></a>元文件</h3><p>元文件(Metafile)是记录所有”绘图指令”的集合，拥有录制，重放的功能。</p><p>view文件中的代码示例:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一个Metefile的对象</span></span><br><span class="line">HMETAFILEmetafile;</span><br><span class="line"><span class="comment">//结束录制，保存文件</span></span><br><span class="line">metafile = m_dcMetaFile.Close();</span><br><span class="line"><span class="comment">//重放文件</span></span><br><span class="line">pDC-&gt;PlayMetaFile(metafile);</span><br><span class="line"><span class="comment">//准备一个新的录制</span></span><br><span class="line">m_dcMetaFile.Create();</span><br><span class="line"><span class="comment">//在新的录制中重放旧元文件  </span></span><br><span class="line">m_dcMetaFile.PlayMetaFile(metafile);</span><br><span class="line"><span class="comment">//删除元文件</span></span><br><span class="line">DeleteMetaFile(metafile);</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无效界面-请求重绘</span></span><br><span class="line">Invalidate();</span><br></pre></td></tr></table></figure><h3 id="兼容设备描述表"><a href="#兼容设备描述表" class="headerlink" title="兼容设备描述表"></a>兼容设备描述表</h3><p>兼容设备是一种内存设备，在显示图像的过程中，可以先在内存中准备这些图像，之后可以直接<strong>拷贝</strong>内存数据到真实的设备中，完成图像的显示。</p><p><strong>起到一个二次缓冲的效果</strong></p><h3 id="自定义重绘"><a href="#自定义重绘" class="headerlink" title="自定义重绘"></a>自定义重绘</h3><p>定义一个类，略……。</p><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h3><p><strong>写入文件</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMFCApplicationView::OnFileWirte</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加命令处理程序代码</span></span><br><span class="line">CString hello = _T(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line"><span class="comment">//打开文件对话框</span></span><br><span class="line"><span class="function">CFileDialog <span class="title">fileDlg</span><span class="params">(FALSE)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IDOK==fileDlg.DoModal())</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//获取对话框返回的文件名</span></span><br><span class="line"><span class="comment">//打开文件</span></span><br><span class="line"><span class="comment">//写入文件</span></span><br><span class="line"><span class="comment">//关闭文件</span></span><br><span class="line">CString path = fileDlg.GetPathName();</span><br><span class="line"><span class="function">CFile <span class="title">file</span><span class="params">(path, CFile::modeWrite | CFile::modeCreate)</span></span>;</span><br><span class="line"><span class="keyword">int</span> len = hello.GetLength()* <span class="keyword">sizeof</span>(TCHAR);</span><br><span class="line">file.Write(hello, len); </span><br><span class="line">file.Close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>读取文件</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMFCApplicationView::OnFileRead</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加命令处理程序代码</span></span><br><span class="line"><span class="function">CFileDialog <span class="title">fileDlg</span><span class="params">(TRUE)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (IDOK == fileDlg.DoModal())</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//获取文件名</span></span><br><span class="line">CString path = fileDlg.GetPathName();</span><br><span class="line"><span class="comment">//以读取方式打开文件</span></span><br><span class="line"><span class="function">CFile <span class="title">file</span><span class="params">(path, CFile::modeRead)</span></span>;</span><br><span class="line"><span class="comment">//准备缓冲区</span></span><br><span class="line">TCHAR* pBuf;</span><br><span class="line"><span class="keyword">int</span> cnt = file.GetLength();</span><br><span class="line"><span class="keyword">int</span> chars = cnt / <span class="keyword">sizeof</span>(TCHAR);</span><br><span class="line">pBuf = <span class="keyword">new</span> TCHAR[chars + <span class="number">1</span>];</span><br><span class="line"><span class="comment">//读取文件内容到缓冲区</span></span><br><span class="line">file.Read(pBuf, cnt);</span><br><span class="line"><span class="comment">//设置字符串结束位置</span></span><br><span class="line">pBuf[chars] = <span class="number">0</span>;</span><br><span class="line">MessageBox(pBuf);</span><br><span class="line">file.Close();</span><br><span class="line"><span class="keyword">delete</span>[] pBuf;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类的序列化"><a href="#类的序列化" class="headerlink" title="类的序列化"></a>类的序列化</h3><p>类的序列化是将程序中对象<strong>以一种二进制格式存放到设备中</strong>，如文件/数据库等，以实现”永生”或随意”流动”。</p><ul><li>类要从CObject派生，或是CObject的派生类派生 </li><li>实现Serialize方法 </li><li>在类声明中使用DECLARE_SERIAL宏 </li><li>DECLARE_SERIAL(类名) </li><li>定义不带参数的构造函数 </li><li>在类实现中添加IMPLEMNET_SERIAL宏 </li><li>IMPLEMNET_SERIAL(类名，父类名，版本号) </li></ul><h2 id="常用控件"><a href="#常用控件" class="headerlink" title="常用控件"></a>常用控件</h2><p>与使用者进行交互。</p><ul><li>获得控件</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GetDlgItem(控件ID)获取相应的控件</span><br></pre></td></tr></table></figure><ul><li>通过绑定控件和变量</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用</span><br><span class="line">UpdateData(TRUE|FALSE)同步， </span><br><span class="line">默认为True，将控件内容同步到变量，FALSE，将变量同步回控件</span><br></pre></td></tr></table></figure><h3 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h3><p>Radio Button——单选</p><p>Check Box——多选</p><p>响应事件，如点击按钮时间.</p><p><strong>示例</strong>：多选按钮。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CContrlObjectDlg::OnBnClickedButton1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">UpdateData();<span class="comment">//同步控件与变量</span></span><br><span class="line">CString str;</span><br><span class="line">str.Format(_T(<span class="string">&quot;上衣=%d\n裤子=%d\n鞋子=%d\n&quot;</span>),m_clothes,m_pants,m_shoes);</span><br><span class="line">MessageBox(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>多选按钮</strong>：<br><img src="/images/MFC%E5%9F%BA%E7%A1%80%E7%AF%871.assets/image-20211112181938778.png" alt="image-20211112181938778"></p><h3 id="文本框和列表"><a href="#文本框和列表" class="headerlink" title="文本框和列表"></a>文本框和列表</h3><ul><li>List Box——列表</li><li>Edit Control——文本框</li></ul><p><strong>示例</strong>：将文本框的内容放到列表中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CContrlObjectDlg::OnBnClickedButton2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line"><span class="comment">//获取文本框中的内容</span></span><br><span class="line">CString text;</span><br><span class="line"><span class="comment">//得到文本框对象</span></span><br><span class="line">CEdit* edit = (CEdit*)GetDlgItem(IDC_EDIT1);</span><br><span class="line"><span class="comment">//将文本框中的文字存放到text中</span></span><br><span class="line">edit-&gt;GetWindowText(text);</span><br><span class="line"><span class="comment">//得到列表对象</span></span><br><span class="line">CListBox* <span class="built_in">list</span> = (CListBox*)GetDlgItem(IDC_LIST1);</span><br><span class="line"><span class="comment">//将文本框中的文字添加到列表框中</span></span><br><span class="line"><span class="built_in">list</span>-&gt;AddString(text);</span><br><span class="line"><span class="comment">//清空文本框的输入框</span></span><br><span class="line">edit-&gt;SetWindowText(_T(<span class="string">&quot;&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/images/MFC%E5%9F%BA%E7%A1%80%E7%AF%871.assets/image-20211112185648190.png" alt="image-20211112185648190"></p><p><strong>示例2</strong>：<br>查看在列表中选择了什么</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CContrlObjectDlg::OnBnClickedButton2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line"><span class="comment">//储存获取的内容</span></span><br><span class="line">CString text;</span><br><span class="line">CListBox* <span class="built_in">list</span> = (CListBox*)GetDlgItem(IDC_LIST1);</span><br><span class="line"><span class="comment">//获取当前在列表中的选择，返回一个整型，该选项在列表中的位置 </span></span><br><span class="line"><span class="keyword">int</span> n = <span class="built_in">list</span>-&gt;GetCurSel();</span><br><span class="line"><span class="comment">//返回选项放到text中</span></span><br><span class="line"><span class="built_in">list</span>-&gt;GetText(n,text);</span><br><span class="line">MessageBox(text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="下拉列表"><a href="#下拉列表" class="headerlink" title="下拉列表"></a>下拉列表</h3><ul><li>ComboBox——下拉列表</li></ul><p>类似于ListBox，基本上操作一直，只是ListBox直接展开所有选项，而ComboBox需要点开查看。</p><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CContrlObjectDlg::OnBnClickedButton2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line"><span class="comment">//储存获取的内容</span></span><br><span class="line">CString text;</span><br><span class="line">CComboBox* <span class="built_in">list</span> = (CComboBox*)GetDlgItem(IDC_COMBO1);</span><br><span class="line"><span class="keyword">int</span> n = <span class="built_in">list</span>-&gt;GetCurSel();</span><br><span class="line"><span class="built_in">list</span>-&gt;GetLBText(n,text);</span><br><span class="line">MessageBox(text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="进度条"><a href="#进度条" class="headerlink" title="进度条"></a>进度条</h3><ul><li>Progress Control——进度条</li></ul><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">BOOL CContrlObjectDlg::OnInitDialog()中</span><br><span class="line">    </span><br><span class="line"><span class="comment">//得到进度条控件</span></span><br><span class="line">CProgressCtrl* prog = (CProgressCtrl*)GetDlgItem(IDC_PROGRESS1);</span><br><span class="line"><span class="comment">//设置范围</span></span><br><span class="line">prog-&gt;SetRange(<span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//根据条件进行进度条的变动</span></span><br><span class="line">prog = (CProgressCtrl*)GetDlgItem(IDC_PROGRESS1);</span><br><span class="line">num = prog-&gt;GetPos();</span><br><span class="line">prog-&gt;SetPos(++num);</span><br><span class="line">prog-&gt;GetRange(low, high);</span><br><span class="line"><span class="keyword">if</span> (num&gt;= high)</span><br><span class="line">&#123;</span><br><span class="line">    prog-&gt;SetPos(low);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><ul><li>Picture Control——图片</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BOOL CMFCPicODlg::OnInitDialog()中</span><br><span class="line"></span><br><span class="line"><span class="comment">//例如:加载bitmap，以局部变量的方式</span></span><br><span class="line">BitMap bitmap;    </span><br><span class="line">m_bitmap.LoadBitmap(IDB_BITMAP1);</span><br><span class="line">m_pic.SetBitmap(m_bitmap);</span><br><span class="line">bitmap.Detach();</span><br></pre></td></tr></table></figure><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><ul><li>List Control</li></ul><p><strong>例如</strong>：Windows文件查看</p><p><img src="/images/MFC%E5%9F%BA%E7%A1%80%E7%AF%871.assets/image-20211113082415733.png" alt="image-20211113082415733"></p><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绘制表头</span></span><br><span class="line">m_list.InsertColumn(<span class="number">0</span>, _T(<span class="string">&quot;ADDRESS&quot;</span>), LVCFMT_LEFT, <span class="number">400</span>);</span><br><span class="line">m_list.InsertColumn(<span class="number">0</span>, _T(<span class="string">&quot;AGE&quot;</span>), LVCFMT_LEFT, <span class="number">50</span>);</span><br><span class="line">m_list.InsertColumn(<span class="number">0</span>, _T(<span class="string">&quot;NAME&quot;</span>), LVCFMT_LEFT, <span class="number">100</span>);</span><br><span class="line">m_list.InsertColumn(<span class="number">0</span>, _T(<span class="string">&quot;ID&quot;</span>), LVCFMT_LEFT, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入第一行数据</span></span><br><span class="line"><span class="keyword">int</span> index;</span><br><span class="line">index = m_list.InsertItem(<span class="number">0</span>, _T(<span class="string">&quot;0001&quot;</span>));</span><br><span class="line">m_list.SetItemText(index, <span class="number">1</span>, _T(<span class="string">&quot;kenny&quot;</span>));</span><br><span class="line">m_list.SetItemText(index, <span class="number">2</span>, _T(<span class="string">&quot;26&quot;</span>));</span><br><span class="line">m_list.SetItemText(index, <span class="number">3</span>, _T(<span class="string">&quot;Franch&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入第二行数据</span></span><br><span class="line">index = m_list.InsertItem(<span class="number">1</span>, _T(<span class="string">&quot;0002&quot;</span>));</span><br><span class="line">m_list.SetItemText(index, <span class="number">1</span>, _T(<span class="string">&quot;olofm&quot;</span>));</span><br><span class="line">m_list.SetItemText(index, <span class="number">2</span>, _T(<span class="string">&quot;29&quot;</span>));</span><br><span class="line">m_list.SetItemText(index, <span class="number">3</span>, _T(<span class="string">&quot;Sweden&quot;</span>));</span><br></pre></td></tr></table></figure><p><img src="/images/MFC%E5%9F%BA%E7%A1%80%E7%AF%871.assets/image-20211113093242047.png" alt="image-20211113093242047"></p><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><ul><li>Tree Control</li></ul><p><strong>示例</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">HTREEITEM root;</span><br><span class="line">HTREEITEM first_sub;</span><br><span class="line">HTREEITEM second_sub;</span><br><span class="line">m_tree.ModifyStyle(<span class="number">0</span>, TVS_HASLINES | TVS_HASBUTTONS | TVS_LINESATROOT);</span><br><span class="line">root = m_tree.InsertItem(_T(<span class="string">&quot;Root&quot;</span>));</span><br><span class="line"><span class="comment">//root的子节点</span></span><br><span class="line">first_sub = m_tree.InsertItem(_T(<span class="string">&quot;First_Sub&quot;</span>), root);</span><br><span class="line"><span class="comment">//与first同级的四个</span></span><br><span class="line">m_tree.InsertItem(_T(<span class="string">&quot;1&quot;</span>),root);</span><br><span class="line">m_tree.InsertItem(_T(<span class="string">&quot;2&quot;</span>),root);</span><br><span class="line">m_tree.InsertItem(_T(<span class="string">&quot;3&quot;</span>),root);</span><br><span class="line">m_tree.InsertItem(_T(<span class="string">&quot;4&quot;</span>),root);</span><br><span class="line"><span class="comment">//first的子结点</span></span><br><span class="line">second_sub = m_tree.InsertItem(_T(<span class="string">&quot;Second&quot;</span>),first_sub);</span><br><span class="line"><span class="comment">//second的四个子节点</span></span><br><span class="line">m_tree.InsertItem(_T(<span class="string">&quot;5&quot;</span>), second_sub);</span><br><span class="line">m_tree.InsertItem(_T(<span class="string">&quot;6&quot;</span>), second_sub);</span><br><span class="line">m_tree.InsertItem(_T(<span class="string">&quot;7&quot;</span>), second_sub);</span><br><span class="line">m_tree.InsertItem(_T(<span class="string">&quot;8&quot;</span>), second_sub);</span><br></pre></td></tr></table></figure><p><img src="/images/MFC%E5%9F%BA%E7%A1%80%E7%AF%871.assets/image-20211113104231000.png" alt="image-20211113104231000"></p><p><strong>引入、加载图片</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前2张，还能加4张</span></span><br><span class="line">m_imgList.Create(<span class="number">32</span>, <span class="number">32</span>, ILC_MASK | ILC_COLOR32, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    HICON icon = theApp.LoadIcon(IDI_ICON1+i);</span><br><span class="line">    m_imgList.Add(icon);</span><br><span class="line">&#125;</span><br><span class="line">m_tree.SetImageList(&amp;m_imgList,TVSIL_NORMAL);</span><br><span class="line"><span class="comment">//这两个1分别代表的属性</span></span><br><span class="line"><span class="comment">//分别是:未选中时显示哪张图片，被选中时显示哪在张。</span></span><br><span class="line">m_tree.InsertItem(_T(<span class="string">&quot;1&quot;</span>),<span class="number">1</span>,<span class="number">1</span>,root);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MFC基础篇&quot;&gt;&lt;a href=&quot;#MFC基础篇&quot; class=&quot;headerlink&quot; title=&quot;MFC基础篇&quot;&gt;&lt;/a&gt;MFC基础篇&lt;/h1&gt;&lt;p&gt;以C++类的形式对WINDOWS API进行封装。&lt;/p&gt;
&lt;h2 id=&quot;MFC框架理论&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="MFC" scheme="http://zhaoyuxuan.xyz/categories/MFC/"/>
    
    
    <category term="-C++" scheme="http://zhaoyuxuan.xyz/tags/C/"/>
    
    <category term="-MFC" scheme="http://zhaoyuxuan.xyz/tags/MFC/"/>
    
  </entry>
  
  <entry>
    <title>【Win32】初识Win32编程</title>
    <link href="http://zhaoyuxuan.xyz/2021/11/08/%E3%80%90Win32%E3%80%91%E5%88%9D%E8%AF%86Win32%E7%BC%96%E7%A8%8B/"/>
    <id>http://zhaoyuxuan.xyz/2021/11/08/%E3%80%90Win32%E3%80%91%E5%88%9D%E8%AF%86Win32%E7%BC%96%E7%A8%8B/</id>
    <published>2021-11-08T00:48:10.000Z</published>
    <updated>2021-11-13T03:23:51.151Z</updated>
    
    <content type="html"><![CDATA[<hr><p>相关视频——<a href="https://www.bilibili.com/video/BV1NA411K7aN?p=1">链接</a></p><hr><h1 id="Windows编程"><a href="#Windows编程" class="headerlink" title="Windows编程"></a>Windows编程</h1><h2 id="应用程序分类"><a href="#应用程序分类" class="headerlink" title="应用程序分类"></a>应用程序分类</h2><ul><li>控制台程序Console<ul><li>DOS程序，<strong>本身没有窗口</strong>，通过Windows DOS窗口执行。(DOS是操作系统预留的)</li></ul></li><li>窗口程序<ul><li>拥有自己的窗口，可以与用户交互。</li></ul></li><li>库程序<ul><li>存放代码、数据的程序、执行文件可以从中取出代码执行和获取数据</li><li>静态库程序:扩展名LIB,在编译链接程序时，将代码放入到执行文件中。</li><li>动态库程序：扩展名DLL，在执行文件时从中获取代码 。</li></ul>静态库中的代码是直接嵌入到你的项目中，而动态库中的内容是通过地址来找到。<ul><li><strong>静态库程序无法执行，也就是说它最终生成的文件无法进入内存。</strong></li><li>动态库程序有入口函数，可以执行。<strong>但是它不能独立运行。</strong>谁调动态库里面的东西，它就依附于谁。</li></ul></li></ul><h2 id="应用程序对比"><a href="#应用程序对比" class="headerlink" title="应用程序对比"></a>应用程序对比</h2><ul><li>入口函数<ul><li>控制台程序-main</li><li>窗口程序-WinMain</li><li>动态库程序-DllMain</li><li>静态库程序-无入口函数</li></ul></li><li>文件存在方式<ul><li>控制台程序、窗口程序-EXE文件</li><li>动态库程序-DLL文件</li><li>静态库程序-LIB文件</li></ul></li></ul><h2 id="编译工具"><a href="#编译工具" class="headerlink" title="编译工具"></a>编译工具</h2><ul><li>编译器CL.EXE,将源代码编译成目标代码.obj。</li><li>链接器LINK.EXE,将目标代码、库链接生成最终文件。</li><li>资源编译器RC.EXE,(.rc)将资源编译，最终通过链接器存入最终文件</li></ul><h2 id="库文件和头文件"><a href="#库文件和头文件" class="headerlink" title="库文件和头文件"></a>库文件和头文件</h2><p><strong>库文件</strong></p><ul><li>kernel32.dll-提供核心的API,消息进程，线程，内存管理等。</li><li>user32.dll-提供了窗口、消息等API。</li><li>gdi32.dll-绘图相关的API</li></ul><p><strong>头文件</strong></p><ul><li>windows.h——所有windows头文件的集合</li><li>windef.h——windows数据类型</li><li>winbase.h——kernel32的API</li><li>wingdi.h——user32的API</li><li>winnt.h——UNICODE字符集支持</li></ul><h2 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">wWinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    HINSTANCE hInstance,<span class="comment">//当前程序的实例句柄，找到你当前进程所占据的那块内存</span></span></span></span><br><span class="line"><span class="function"><span class="params">    HINSTANCE hPrevInstance,<span class="comment">//当前程序前一个示例句柄，废弃了</span></span></span></span><br><span class="line"><span class="function"><span class="params">    PWSTR pCmdLine, <span class="comment">//命令行参数字符串</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> nCmdShow<span class="comment">//窗口的显示方式</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>暂时可以将句柄理解成，句柄是用来找到内存的东西，但绝对不是指针。</strong></p><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MessageBox</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional] HWND    hWnd,<span class="comment">//父窗口句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional] LPCTSTR lpText,<span class="comment">//显示在消息框中的文字</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional] LPCTSTR lpCaption,<span class="comment">//显示在标题栏中的文字</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in]           UINT    uType<span class="comment">//消息框中的按钮、图标显示了类型</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;<span class="comment">//返回点击的按钮ID</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>能够将程序暂停在这里，说明它是个阻塞函数。它执行，可能不会立即返回。</p><hr><p><strong>如何理解分析一个阻塞函数</strong>？<br>1.这个函数什么情况下阻塞。</p><p>2.这个函数什么情况下解除阻塞返回。</p><hr><p><strong>看到数据类型以H开头，多半就是个句柄。</strong></p><hr><h2 id="程序编译过程"><a href="#程序编译过程" class="headerlink" title="程序编译过程"></a>程序编译过程</h2><ul><li><p>可以直接用vs集成好的环境。<img src="/images/win32(1).assets/image-20211029171632365.png" alt="image-20211029171632365"></p></li><li><p>编译程序-CL,CL.EXE -C xxx.c，生成obj文件</p></li><li><p>链接程序-LINK，LINK.EXE xxx.obj xxx.lib</p></li><li><p>执行生成的exe文件</p></li></ul><hr><ul><li>编写资源的文件，.rc资源脚本文件</li><li>编译rc文件，RC.EXE</li><li>将资源链接到程序中，LINK.EXE</li></ul><p>.res文件和.obj文件统称为目标文件(中间文件，因为不是最终文件)</p><hr><p> <strong>编译链接过程</strong>：将代码转换为机器语言，将生成的res文件和obj文件加上使用的库链接到一起，整合出一个exe文件，这是用编译器所感受不到的。</p><p><img src="/images/win32(1).assets/image-20211029172712321.png" alt="image-20211029172712321"></p><hr><h2 id="窗口创建过程"><a href="#窗口创建过程" class="headerlink" title="窗口创建过程"></a>窗口创建过程</h2><ul><li>定义WinMain函数</li><li>定义窗口的处理函数(自定义，消息处理)</li><li>注册窗口类(向操作系统中写入一些数据)</li><li>创建窗口(内存中创建窗口)</li><li>显示窗口(绘制窗口的图像)</li><li>消息循环(获取/翻译/派发消息)</li><li>消息处理</li></ul><h2 id="第一个windows窗口"><a href="#第一个windows窗口" class="headerlink" title="第一个windows窗口"></a>第一个windows窗口</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//窗口处理函数（自定义、处理消息）</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hWnd, UINT msgID, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> DefWindowProc(hWnd, msgID, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入口函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> CALLBACK <span class="title">WinMain</span><span class="params">(HINSTANCE hIns, HINSTANCE hPerIns, LPSTR lpCmdLine, <span class="keyword">int</span> nCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//注册窗口类</span></span><br><span class="line">WNDCLASS wc = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">//申请两种不用的缓冲区</span></span><br><span class="line">wc.cbClsExtra = <span class="number">0</span>;</span><br><span class="line">wc.cbWndExtra = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + <span class="number">1</span>);</span><br><span class="line">wc.hCursor = <span class="literal">NULL</span>;</span><br><span class="line">wc.hIcon = <span class="literal">NULL</span>;</span><br><span class="line">wc.hInstance = hIns;</span><br><span class="line">wc.lpfnWndProc = WndProc;</span><br><span class="line">wc.lpszClassName = <span class="string">&quot;myWindow&quot;</span>;</span><br><span class="line">wc.lpszMenuName = <span class="literal">NULL</span>;</span><br><span class="line">wc.style = CS_HREDRAW | CS_VREDRAW;</span><br><span class="line"><span class="comment">//将上面赋的这些值全部写入操作系统</span></span><br><span class="line">RegisterClass(&amp;wc);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在内存中创建窗口</span></span><br><span class="line">HWND hWnd = CreateWindow(<span class="string">&quot;myWindow&quot;</span>, <span class="string">&quot;menu&quot;</span>, WS_OVERLAPPEDWINDOW, <span class="number">100</span>, <span class="number">100</span>, <span class="number">500</span>, <span class="number">500</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, hIns, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//显示窗口</span></span><br><span class="line">ShowWindow(hWnd, SW_SHOW);</span><br><span class="line"><span class="comment">//再画一遍(刷新窗口)</span></span><br><span class="line">UpdateWindow(hWnd);</span><br><span class="line"><span class="comment">//消息循环</span></span><br><span class="line">MSG nMsg = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">while</span> (GetMessage(&amp;nMsg,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">TranslateMessage(&amp;nMsg);</span><br><span class="line">DispatchMessage(&amp;nMsg);<span class="comment">//将消息交给窗口处理函数来处理</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>窗口有无与进程退不退没有关系。</p><h2 id="Unit04字符编码"><a href="#Unit04字符编码" class="headerlink" title="Unit04字符编码"></a>Unit04字符编码</h2><p><strong>编码历史背景</strong></p><ul><li>ASC——7位代表一个字符</li><li>ASCII——8位代表一个字符</li><li>DBCS——<strong>单双字节混合编码</strong>，没有同一标准，存在解析问题。</li><li>UNICODE——字符集，有多种编码方式，一般windows只的是utf-16(所有的字符无论中文汉子还是英文字母，都按两个字符编码。),linux utf-8,有统一标准，不存在解析问题。</li></ul><h2 id="宽字节数据类型"><a href="#宽字节数据类型" class="headerlink" title="宽字节数据类型"></a>宽字节数据类型</h2><p>这个数据类型下的所有字符， 都占2个字节。</p><blockquote><p>wchar_t每个字符占2个字节，wchar_t实际上是unsigned short类型，定义时，需要增加‘L’，通知编译器按照双字节编译字符串，采用UNICODE编码。</p><p>需要使用支持wchar_t函数操作宽字节字符串，例如:<br>wchar_t* s1=  L”123456”;</p><p>wprintf(L”%s\n”,s1);</p></blockquote><hr><p>有操作char类型字符串的函数，肯定就有对应操作宽字节字符串的函数。</p><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">wchar_t</span>* s1 = <span class="string">L&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, wcslen(s1));<span class="comment">//5,有效字符个数</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TCHAR"><a href="#TCHAR" class="headerlink" title="TCHAR"></a>TCHAR</h2><p>如果定义了unicode宏，该字符串为wchar*类型，反之为char *类型。</p><h2 id="打印UNICODE字符"><a href="#打印UNICODE字符" class="headerlink" title="打印UNICODE字符"></a>打印UNICODE字符</h2><p>UNICODE字符打印，wprintf对UNICODE字符打印支持不完善。</p><p>在windows下使用<strong>WriteConsole</strong>打印UNICODE字符。</p><p>GetStdHandle获取标准句柄(标准输入句柄、标准输出句柄、标准错误句柄)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WriteConsole(标准输出句柄，pszText,wcslen(pszText),<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>下面的使用案例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> width = LOWORD(lParam);</span><br><span class="line"><span class="keyword">short</span> height = HIWORD(lParam);</span><br><span class="line"><span class="keyword">char</span> szText[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">sprintf_s(szText, <span class="string">&quot;WM_SIZE:宽度%d，高度：%d\n&quot;</span>, width, height);</span><br><span class="line">WriteConsole(g_HOUTPUT, szText, <span class="built_in">strlen</span>(szText), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><hr><p>创建项目时候为什么要改成多字节字符集?</p><p>如果项目的属性选择是UNICODE字符集，编译器会自动给你增加一个UNICODE的宏定义。反之，则不会。</p><hr><p><strong>系统调用函数的参数类型</strong>：</p><p>(对已有的类型进行重命名)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LPSTR =&gt; <span class="keyword">char</span>*</span><br><span class="line">LPSTR =&gt; <span class="keyword">const</span> <span class="keyword">char</span>*</span><br><span class="line">LPWSTR =&gt; <span class="keyword">wchar_t</span>*</span><br><span class="line">LPCWSTR =&gt; <span class="keyword">const</span> <span class="keyword">wchar_t</span>*</span><br><span class="line">   </span><br><span class="line">用的多的是这两个</span><br><span class="line">LPTSTR =&gt; TCHAR </span><br><span class="line">LPCTSTR =&gt; <span class="keyword">const</span> TCHAR*</span><br></pre></td></tr></table></figure><hr><h2 id="注册窗口类"><a href="#注册窗口类" class="headerlink" title="注册窗口类"></a>注册窗口类</h2><p><strong>窗口类的概念</strong></p><ul><li>窗口类是包含了窗口的各种参数信息的数据结构。 </li><li>每个窗口都具有窗口类，基于窗口类创建窗口。</li><li>每个窗口类都具有一个名称，使用前必须注册到系统。</li></ul><p><strong>在操作系统内核里存着就叫窗口类，在程序里存着就叫窗口类。</strong></p><hr><p><strong>窗口类的分类</strong>：</p><ul><li>系统窗口类<ul><li>系统已经定义好的窗口类，<strong>所有</strong>应用程序都可以直接使用。</li><li>不需要注册，直接使用窗口类即可。系统已经注册好了。</li><li>例如:按钮-BUTTON,编辑框-EDIT</li></ul></li><li>应用程序全局窗口类<ul><li>由用户自己定义，当前应用程序所有模块都可以使用。</li></ul></li><li>应用程序局部窗口类<ul><li>由用户自己定义，当前应用程序中本模块可以直接使用。</li></ul></li></ul><p><strong>全局及局部窗口类</strong> ：</p><p>注册窗口类的函数</p><p>(ATOM——unsigned short)</p><p>ATOM RegisterClass(</p><p>​    CONST WNDCLASS *lpWndClass//窗口类的数据);</p><p>//注册成功后 ，返回一个数字标识。(0失败，非0成功。)</p><p><img src="/images/win32(1).assets/image-20211030091746959.png" alt="image-20211030091746959"></p><hr><p><strong>style窗口类风格</strong></p><p>应用程序全局窗口类的注册，需要在窗口类的风格中添加CS_GLOBALCLASS。</p><p>应用程序局部类窗口类注册，无需添加如上风格。</p><p><strong>不建议使用全局窗口类</strong>——因为局部窗口类能完成全局窗口类的功能，并且全局窗口类可能会产生冗余。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CS_HREDRAW ——当窗口水平变化时，窗口重新绘制</span><br><span class="line">CS_VREDRAW ——当窗口垂直变化时，窗口重新绘制</span><br><span class="line">CS_DBLCLKS ——允许窗口接收鼠标双击</span><br><span class="line">CS_NOCLOSE ——窗口没有关闭按钮</span><br></pre></td></tr></table></figure><h2 id="窗口创建"><a href="#窗口创建" class="headerlink" title="窗口创建"></a>窗口创建</h2><p><strong>窗口创建</strong>：</p><p>CreateWindow / CreateWindowEx</p><p><img src="/images/win32(1).assets/image-20211030092735421.png" alt="image-20211030092735421"></p><p><strong>CreateWindow内部是如何实现的</strong></p><ul><li>系统(CreateWindows函数内部)根据传入的窗口类名称，在应用程序局部窗口类中查找，如果找到执行2 ，没找到执行3。</li><li>比较局部窗口与创建窗口时传入的HINSTANCE变量。如果有发现相等。创建和注册类在同一模块，创建窗口返回。如果不相等，继续执行3。</li><li>在应用程序全局窗口类，如果找到，执行4， 没找到执行5。</li><li>使用找到的窗口类信息，创建窗口返回。</li><li>在系统窗口类中查找，如果找到创建窗口返回，否则创建窗口失败。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//窗口处理函数（自定义、处理消息）</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hWnd, UINT msgID, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (msgID)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">PostQuitMessage(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> DefWindowProc(hWnd, msgID, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入口函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> CALLBACK <span class="title">WinMain</span><span class="params">(HINSTANCE hIns, HINSTANCE hPerIns, LPSTR lpCmdLine, <span class="keyword">int</span> nCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册窗口类</span></span><br><span class="line">WNDCLASS wc = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">//申请两种不用的缓冲区</span></span><br><span class="line">wc.cbClsExtra = <span class="number">0</span>;</span><br><span class="line">wc.cbWndExtra = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + <span class="number">1</span>);</span><br><span class="line">wc.hCursor = <span class="literal">NULL</span>;</span><br><span class="line">wc.hIcon = <span class="literal">NULL</span>;</span><br><span class="line">wc.hInstance = hIns;</span><br><span class="line">wc.lpfnWndProc = WndProc;</span><br><span class="line">wc.lpszClassName = <span class="string">&quot;myWindow&quot;</span>;</span><br><span class="line">wc.lpszMenuName = <span class="literal">NULL</span>;</span><br><span class="line">wc.style = CS_HREDRAW | CS_VREDRAW;</span><br><span class="line"><span class="comment">//将上面赋的这些值全部写入操作系统</span></span><br><span class="line">RegisterClass(&amp;wc);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在内存中创建窗口</span></span><br><span class="line">HWND hWnd = CreateWindow(<span class="string">&quot;myWindow&quot;</span>, <span class="string">&quot;menu&quot;</span>, WS_OVERLAPPEDWINDOW, <span class="number">100</span>, <span class="number">100</span>, <span class="number">500</span>, <span class="number">500</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, hIns, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//显示窗口</span></span><br><span class="line">ShowWindow(hWnd, SW_SHOW);</span><br><span class="line"><span class="comment">//再画一遍(刷新窗口)</span></span><br><span class="line">UpdateWindow(hWnd);</span><br><span class="line"><span class="comment">//消息循环</span></span><br><span class="line">MSG nMsg = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">while</span> (GetMessage(&amp;nMsg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">TranslateMessage(&amp;nMsg);</span><br><span class="line">DispatchMessage(&amp;nMsg);<span class="comment">//将消息交给窗口处理函数来处理</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>子窗口创建过程</strong></p><ul><li>创建时要设置父窗口句柄</li><li>创建风格要增加WS_CHILD | WS_VISBLE</li></ul><p>(<strong>根据注册的窗口类，来创建多个窗口。</strong>)</p><p>(个人理解发现：注册的窗口可以复用(覆盖创建一个新的))。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HWND hChild1 = CreateWindowEx(<span class="number">0</span>, <span class="string">&quot;Child&quot;</span>, <span class="string">&quot;C1&quot;</span>, WS_CHILD | WS_VISIBLE | WS_OVERLAPPEDWINDOW, <span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>, hWnd, <span class="literal">NULL</span>, hIns, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">HWND hChild2 = CreateWindowEx(<span class="number">0</span>, <span class="string">&quot;Child&quot;</span>, <span class="string">&quot;C2&quot;</span>, WS_CHILD | WS_VISIBLE | WS_OVERLAPPEDWINDOW, <span class="number">200</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>, hWnd, <span class="literal">NULL</span>, hIns, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><h2 id="消息基础"><a href="#消息基础" class="headerlink" title="消息基础"></a>消息基础</h2><h3 id="消息的概念和作用"><a href="#消息的概念和作用" class="headerlink" title="消息的概念和作用"></a>消息的概念和作用</h3><ul><li>消息组成(windows平台下)<ul><li>窗口句柄</li><li>消息ID</li><li>消息的两个参数(两个附带信息)</li><li>消息产生的时间</li><li>消息产生时的鼠标位置</li></ul></li><li>消息的作用<ul><li>当系统通知窗口工作时，就采用消息的方式(DispatchMessage)派发给(<strong>调用</strong>)窗口的<strong>窗口处理函数</strong>(将MSG的前四个信息传递给消息处理函数)。</li><li><strong>每一个窗口都有窗口处理函数</strong></li></ul></li></ul><p><strong>MSG结构体接收消息</strong></p><p>结构体定义如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对应解释同上消息组成</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagMSG</span> &#123;</span></span><br><span class="line">    HWND        hwnd;</span><br><span class="line">    UINT        message;</span><br><span class="line">    WPARAM      wParam;</span><br><span class="line">    LPARAM      lParam;</span><br><span class="line">    DWORD       time;</span><br><span class="line">    POINT       pt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _MAC</span></span><br><span class="line">    DWORD       lPrivate;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; MSG, *PMSG, NEAR *NPMSG, FAR *LPMSG;</span><br></pre></td></tr></table></figure><p><strong>DispatchMessage如何找到窗口处理函数</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nMsg.hwnd-&gt;保存窗口数据的内存-&gt;找到对应的窗口处理函数-&gt;WndProc</span><br><span class="line">    </span><br><span class="line">回到你自己定义的消息处理函数-&gt;传递参数-&gt;处理消息</span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hWnd, UINT msgID, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line">    传递这四个参数，不用关系后两个</span><br></pre></td></tr></table></figure><h3 id="窗口处理函数"><a href="#窗口处理函数" class="headerlink" title="窗口处理函数"></a>窗口处理函数</h3><p><strong>每个窗口都必需有窗口处理函数，只要基于窗口类创建窗口，就肯定要有个窗口处理函数。</strong></p><p><strong>窗口处理依照如下结构定义</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProc</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HWND hWnd;<span class="comment">//窗口句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">UINT uMsg;<span class="comment">//消息ID</span></span></span></span><br><span class="line"><span class="function"><span class="params">WPARAM wParam;<span class="comment">//消息参数</span></span></span></span><br><span class="line"><span class="function"><span class="params">LPARAM lParam;<span class="comment">//消息参数</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>当系统通知窗口时，(<strong>DispatchMessage</strong>)会调用窗口处理函数，同时将消息ID和消息参数传递给窗口处理函数。</p><p>在窗口处理函数中，<strong>不处理的消息</strong>，<strong>使用缺省窗口处理函数</strong>。</p><p>例如:**DefWindowProc(可以给各种消息做默认处理)**。</p><hr><h3 id="消息循环中的相关函数-浅谈"><a href="#消息循环中的相关函数-浅谈" class="headerlink" title="消息循环中的相关函数(浅谈)"></a>消息循环中的相关函数(浅谈)</h3><p><strong>GetMessage-到系统的某个地方抓本进程的消息</strong></p><p>函数原型如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">GetMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">LPMSG lpMsg,<span class="comment">//存放获取到消息的BUFF，</span></span></span></span><br><span class="line"><span class="function"><span class="params">    HWND hWndp;<span class="comment">//窗口句柄，要是定为NULL，将会抓取本进程中所有窗口中的消息</span></span></span></span><br><span class="line"><span class="function"><span class="params">    UNIT wMsgFilterMin,<span class="comment">//获取的最小ID</span></span></span></span><br><span class="line"><span class="function"><span class="params">    UNIT wMsgFilterMax<span class="comment">//获取消息的最大ID</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">//最后两个参数都为0，就是不管ID有多大，只要是本进程的消息都抓过来</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>其中后三个参数可以限制抓取消息的范围</strong>，如果设置为NULL,0,0那其实就是没有进行限制，只要是本进程的消息我都把它抓过来。</p><p><strong>GetMessage的返回值</strong></p><p>消息WM_QUIT会使GetMessage返回0，从而中终止消息接收。</p><p>PostQuitMessage(0);会在进程中扔出WM_QUIT这个消息，get后从而使得消息循环终止。</p><hr><p><strong>TranslateMessage-翻译消息</strong>——它可不是什么消息都翻译。</p><p><strong>将按键(可见字符按键，a~z)消息翻译成字符消息。</strong></p><p>所以进入到它的内部， 它所做的第一件事就是检查这个消息是否合法，是否是它要翻译的消息类型。 </p><p><strong>如果不是按键类型消息</strong>，不做任何处理，继续执行。</p><p>函数原型如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOL TranslateMessage</span><br><span class="line">&#123;</span><br><span class="line">    CONST  MSG* lpMsg;<span class="comment">//要翻译的消息地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>DispatchMessage-派发消息(调用对应窗口的消息处理函数)</strong></p><p>函数原型如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT <span class="title">DispatchMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">CONST MSG* lpmsg<span class="comment">//要派发的消息</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="常见消息"><a href="#常见消息" class="headerlink" title="常见消息"></a>常见消息</h2><p><strong>如何学习一个消息</strong></p><p>1.掌握这个消息的<strong>产生时间</strong>。</p><ol start="2"><li>分析每个消息附带的<strong>两个信息</strong>。</li><li> 这个消息可以用来干什么(<strong>一般用法</strong>)。 </li></ol><h3 id="WM-DESTORY"><a href="#WM-DESTORY" class="headerlink" title="WM_DESTORY"></a>WM_DESTORY</h3><ul><li>产生时间:窗口被销毁时产生</li><li>附带信息:wParam:为0，lParam:为0</li><li>一般用法:常用于在窗口被销毁前，做相应的善后处理，例如资源、内存等(<strong>该回收回收，该释放释放。</strong>)。</li></ul><h3 id="WM-SYSCOMMAND"><a href="#WM-SYSCOMMAND" class="headerlink" title="WM_SYSCOMMAND"></a>WM_SYSCOMMAND</h3><ul><li>产生时间：当点击窗口最大化，最小化，关闭等。</li><li>附带信息:<ul><li>wParam:具体点击的位置，例如关闭SC_CLOSE等，</li><li>lParam:鼠标光标的位置(<strong>这个不重要，我们只需要知道点没点就行，具体在哪个位置其实无所谓(具体情况具体使用)</strong>)，LOWORD(lParam);水平位置，HIWORD(lParam)；垂直位置。(<strong>高两字节传纵坐标，低两字节传横坐标。</strong>)</li></ul></li><li>一般用法:常用在窗口关闭时，提示用户处理。</li></ul><hr><h3 id="WM-CREATE"><a href="#WM-CREATE" class="headerlink" title="WM_CREATE"></a>WM_CREATE</h3><ul><li>产生时间:在窗口创建成功但还没显示时。</li><li>附带信息:<ul><li>wParam:为0</li><li>lParam:为CREATESTRUCT类型的指针(<strong>强转成这个类型再用</strong>)，通过这个指针可以获取CreatWindowEx中全部12个参数的信息。</li></ul></li><li>一般用法：常用于初始化窗口函数、资源等等，包括创建子窗口等。</li></ul><hr><h3 id="WM-SIZE"><a href="#WM-SIZE" class="headerlink" title="WM_SIZE"></a>WM_SIZE</h3><ul><li>产生时间:在窗口的大小发生变化后。</li><li>附带信息:<ul><li>wParam:窗口大小变化的原因。</li><li>lParam:窗口变化后的大小<ul><li>LOWORD(lParam)变化后的宽度</li><li>HIWORD(lParam)变化后的高度</li></ul></li></ul></li><li>一般用法:常用于窗口大小发生变化后，调整窗口内各个部分的布局。</li></ul><hr><h3 id="WM-QUIT"><a href="#WM-QUIT" class="headerlink" title="WM_QUIT"></a>WM_QUIT</h3><ul><li>产生时间:程序员发送。</li><li>附带信息:<ul><li>wPram:PostQuitmessage函数传递的参数。</li><li>lParam：0。</li></ul></li><li>一般用法:用于结束消息循环，当GetMessage收到这个消息后，会返回FALSE,结束while处理，退出消息循环。</li></ul><p><strong>这个消息不用我们去处理</strong>,进不去我们定义的窗口处理函数,GetMessage()返回了0，无法进入循环获取消息。</p><hr><h3 id="WM-PAINT"><a href="#WM-PAINT" class="headerlink" title="WM_PAINT"></a>WM_PAINT</h3><ul><li>产生时间:当窗口需要绘制的时候 or( GetMessage没消息可抓的时候，详情请看下面。)</li><li>附带信息:(没用)<ul><li>wParam: 0</li><li>lParam:0</li></ul></li><li>专职用法:就是用于绘图。</li></ul><p>第一个WM_PAINT是系统发送的，当第一次创建窗口。</p><p>也就是说产生WM_SIZE消息的同时肯定回产生WM_PAINT消息，重新绘制。</p><p><strong>相关函数</strong></p><ul><li>窗口无效区域:需要重新绘制的区域。</li><li>调用这个函数，让窗口需要重新绘制，<strong>GetMessAge</strong>会发送WM_PAINT消息，<strong>注意，是谁发送消息</strong>。  (就可以理解说这个函数告诉GetMessage说，这个窗口需要绘制了，GetMessage发送消息到消息队列，然后转发到对应进程的消息队列中，开始执行。)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">InvalidateRect</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] HWND       hWnd,<span class="comment">//窗口句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">const</span> RECT *lpRect,<span class="comment">//区域的矩形坐标，对窗口的哪一部分进行重新绘制</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] BOOL       bErase<span class="comment">//重绘前是否先擦除</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="调试技巧"><a href="#调试技巧" class="headerlink" title="调试技巧"></a>调试技巧</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">设置一个全局变量</span><br><span class="line">    HANDLE g_HOUTPUT = <span class="number">0</span>;<span class="comment">//接收标准输出句柄</span></span><br><span class="line">增加一个dos窗口</span><br><span class="line">AllocConsole();</span><br><span class="line">g_HOUTPUT = GetStdHandle(STD_OUTPUT_HANDLE);</span><br></pre></td></tr></table></figure><p>  <strong>dos窗口只能接收字符串类型</strong></p><p><strong>sprintf转，writeconsole打印</strong></p><hr><h2 id="消息循环的原理"><a href="#消息循环的原理" class="headerlink" title="消息循环的原理"></a>消息循环的原理</h2><h3 id="消息循环的阻塞"><a href="#消息循环的阻塞" class="headerlink" title="消息循环的阻塞"></a>消息循环的阻塞</h3><ul><li>GetMessage-从系统获取消息，将消息从系统中移除，阻塞函数。当系统无消息时，会等候下一条消息。</li></ul><blockquote><p>对人来说消息是一直存在的，但是对于CPU来说(速度接近光速)，消息不是经常有的，所以会经常发生阻塞。这样程序的效率就不高，从而引出下面这个函数。</p></blockquote><ul><li>PeekMessage-以查看的方式从系统中获取消息，可以不将消息从系统出移除，非阻塞函数。当系统无消息时，返回FALSE,继续执行后续代码。</li></ul><p><strong>函数原型如下:</strong></p><p>(前四个参数同GetMessage)</p><p>最后一个参数是，是否赋予它抓取消息的能力，一般是不给它的，也就是填写</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">PeekMessageA</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [out]          LPMSG lpMsg,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional] HWND  hWnd,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]           UINT  wMsgFilterMin,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]           UINT  wMsgFilterMax,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]           UINT  wRemoveMsg</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>也就是说</strong>，更好的流程是，先派PeekMessage去侦查是否有消息，有就告诉GetMessage让它来处 理。没有就不要派Get去了，因为它会一直在那里等着消息的出现。</p><p><strong>例如</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (PeekMessage(&amp;nMsg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, PM_NOREMOVE))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//有消息-判断是否是WM_QUIT</span></span><br><span class="line"><span class="keyword">if</span> (GetMessage(&amp;nMsg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">TranslateMessage(&amp;nMsg);</span><br><span class="line">DispatchMessage(&amp;nMsg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//没有消息——空闲处理</span></span><br><span class="line">WriteConsole(g_HOUTPUT, <span class="string">&quot;空闲ing\n&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;空闲ing&quot;</span>), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><p><strong>Windows平台上的消息，都是它们两个造出来的。</strong></p><ul><li>SendMessage-发送消息，会等候消息处理的结果。</li><li>PostMessage-投递消息，消息发出后立刻返回，不等候消息执行结果。</li></ul><p><strong>函数原型如下</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT <span class="title">SendMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] HWND   hWnd,<span class="comment">//消息发送的目的创建</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] UINT   Msg,<span class="comment">//消息ID</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] WPARAM wParam,<span class="comment">//消息参数</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] LPARAM lParam<span class="comment">//消息参数</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>这四个参数就是一个消息的前四个参数，剩下的两个参数函数内部以某种手段自加来获取。 </p><p>（<strong>其中，</strong>sendmessage的消息扔到哪去，我们不知道，在之后的课程中会补充。postmessage的消息会扔到getmessage能接收到的区域）</p><h3 id="消息分类"><a href="#消息分类" class="headerlink" title="消息分类"></a>消息分类</h3><ul><li>系统消息-ID范围0~0x03FF<ul><li>由系统定义好的消息，可以在程序中直接使用。</li><li>程序员只负责一头，要么发送不用处理，要么处理不用发送。</li></ul></li><li>用户自定义的消息-ID范围0x0400(WM_USER) -  0x7FFF(31743)<ul><li>由用户自己定义，满足用户自己的需求。由用户自己发出消息，并响应处理。</li><li>由程序员，自己定制，自己发送，自己处理。</li><li>自定义消息宏：WM_USER(叫什么都行)</li></ul></li></ul><p><strong>例如</strong>:</p><p>定义消息名称</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WM_MYMESSAGE WM_USER+1001</span></span><br></pre></td></tr></table></figure><p>发送,在哪发都可以,附加消息，你自己的，附加什么都行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PostMessage/SendMessage(hWnd, WM_MYMESSAGE, <span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><h3 id="消息队列的概念"><a href="#消息队列的概念" class="headerlink" title="消息队列的概念"></a>消息队列的概念</h3><ul><li>消息队列是用于存放消息的队列。</li><li>消息在队列中先进先出。</li><li>所有窗口都具有消息队列。</li><li>程序(<strong>GetMessage()</strong>)可以从队列中获取消息。</li></ul><hr><h3 id="消息队列的分类"><a href="#消息队列的分类" class="headerlink" title="消息队列的分类"></a>消息队列的分类</h3><ul><li>系统消息队列——由系统维护的消息队列。存放系统产生的消息，例如鼠标、键盘等。</li><li>程序消息队列——属于每个应用程序的(线程)的消息队列。由应用程序(线程)维护。</li></ul><blockquote><p>每个进程都有一个消息队列，都有GetMessage(),在本进程的消息队列中抓取消息。</p><p>细节解释:<br>所有进程产生的消息都先进系统消息队列，操作系统会每个一段时间，将消息转发到各个进程中去。所以才能在本进程中抓到本进程的消息。</p><p>如何做到正确转发:<br>消息的第一个参数是窗口句柄，保存窗口数据的内存，通过它可以找到当前程序实例句柄，找到本进程对应内存，从而正确转发。</p></blockquote><p>SendMessage既没有扔到系统消息队列里，也没有扔到进程消息队列中。</p><hr><h3 id="消息和消息队列的关系"><a href="#消息和消息队列的关系" class="headerlink" title="消息和消息队列的关系"></a>消息和消息队列的关系</h3><ul><li><p>消息和消息队列的关系</p><ul><li>当鼠标、键盘产生消息时，会将消息存放到消息队列中。</li><li>系统会根据存放的消息，找到对应程序的消息队列。</li><li>将消息投递到程序的消息队列中</li></ul></li><li><p>根据消息和消息队列之间使用关系，将消息分成两类</p><ul><li>队列消息-消息的发送和获取，都是通过消息队列完成。<ul><li>消息发送后，首先放入队列，然后通过消息循环，从队列中获取。</li><li>GetMessage-从消息队列中获取消息</li><li>PostMessage-将消息投递到消息队列</li><li>常见的消息队列:WM_PAINT、键盘、鼠标、定时器</li></ul></li><li>非队列消息-消息的发送和获取，是直接调用消息的窗口处理函数完成。 <ul><li>消息发送时，首先找到消息接收窗口的窗口处理函数，直接调用处理函数，完成消息。<ul><li>SendMessage-<strong>直接将消息发送窗口的处理函数，并等待处理结果</strong>。</li><li>常见消息:WM_CREATE(它是必须不能进队列的，否则就没办法把它抓出来了)、WM_SIZE等。</li></ul></li></ul></li></ul></li></ul><h3 id="GetMessage"><a href="#GetMessage" class="headerlink" title="GetMessage"></a>GetMessage</h3><ul><li>在程序(线程)消息队列查找消息，如果队列有消息，**检查消息是否满足指定条件(HWND,ID范围)**，不满足条件就不会取出消息，否则从队列取出消息返回。</li><li>如果程序(线程)消息队列没有消息，会向系统消息队列获取(<strong>找系统要，发起请求</strong>)属于班本程序的消息(<strong>之前说系统会定时分发属于对应进程的消息，如果这个时间没到，但是有的进程没消息了，会打破这个时间，提前分发。</strong>)。如果系统队列的当前消息属于本程序，系统会将消息转发到程序消息队列中。</li><li><strong>如果系统消息也没有消息(那也不闲着)<strong>，检查当前进程的所有窗口需要重新绘制的区域，如果发现有需要绘制的区域，</strong>产生WM_PAINT消息扔到系统的消息队列</strong>，取得消息返回处理。</li><li><strong>如果没有重新绘制区域</strong>，检查定时器，如果有到时的定时器，产生WM_TIMER，返回处理执行。</li><li>如果没有到时的定时器，整理程序的资源、内存等等。</li><li>GetMessage会继续等候下一条消息。PeekMessage会返回FASLE,交出程序的控制权。</li><li>注意:GetMessage如果获取到的是WM_QUIT，函数会返回FALSE。</li></ul><p><strong>总结</strong>：总结起来就是，GetMessage非常的死心眼，没消息就找系统要，要不来就自己造，造不来就整理下资源(干点打扫卫生的活儿)，还没有消息来，那就阻塞，等待消息的传来，<strong>但是依然不返回</strong>。</p><p>阻塞了，就说明GetMessage已经尽力了。</p><p>PeekMessage也会干上面的事儿，<strong>但是它最后不会傻等</strong>。</p><h2 id="键盘消息"><a href="#键盘消息" class="headerlink" title="键盘消息"></a>键盘消息</h2><h3 id="键盘消息分类"><a href="#键盘消息分类" class="headerlink" title="键盘消息分类"></a>键盘消息分类</h3><ul><li>WM_KEYDOWN-按键被按下时产生</li><li>WM_KEYUP-按键被放开时产生</li><li>WM_SYSKEYDOWN-系统键按下时产生，比如ALT、F10</li><li>WM_SYSKEYUP-系统键放开时产生</li></ul><p>附带信息:<br>.WPARAM-按键的Virtual Key(每个这个对应一个按键-这个虚拟键码值无法区分大小写，所以我们才需要去翻译消息)</p><p>LPARAM-按键的参数，例如按下的次数 </p><h3 id="字符消息-WM-CHAR"><a href="#字符消息-WM-CHAR" class="headerlink" title="字符消息(WM_CHAR)"></a>字符消息(WM_CHAR)</h3><ul><li>TranslateMessage在转换WM_KEYDOWN消息时，对于可见字符可以产生WM_CHAR,不可见字符无此消息。</li><li>附带信息:<ul><li>WMPARAM-<strong>输入的字符的ASCII字符编码值</strong></li><li>LPARAM-按键的相关参数</li></ul></li></ul><p>翻译消息的内部大致流程，如下图所示:</p><p><img src="/images/win32(1).assets/image-20211031160052913.png" alt="image-20211031160052913"></p><p><strong>文字解释</strong>:</p><p>先检查是否有按键被按下， 没有直接return,有则判断是否是可见字符消息（<strong>刚才的按键消息再一次被GET过来时，已经变成了字符消息</strong>，不是按键消息，在这部就直接return了），不是直接return,都通过了，那就判断大写键是否打开，根据大小写发出相应的消息。    </p><h2 id="鼠标消息"><a href="#鼠标消息" class="headerlink" title="鼠标消息"></a>鼠标消息</h2><h3 id="鼠标消息的分类"><a href="#鼠标消息的分类" class="headerlink" title="鼠标消息的分类"></a>鼠标消息的分类</h3><ul><li>基本鼠标消息<ul><li>WM_LBUTTONDOWN-鼠标左键按下</li><li>WM_LBUTTONUP-鼠标左键抬起</li><li>WM_RBUTTONDOWN-鼠标右键按下</li><li>WM_RBUTTONUO-鼠标右键抬起</li><li>WM_MOUSEMOVE-鼠标移动消息</li></ul></li><li>双击消息<ul><li>WM_ LBUTTONDBLCLK-鼠标左键双击</li><li>WM_RBUTTONDBLCLK-鼠标右键双击</li></ul></li><li>滚轮消息<ul><li>WM_MOUSEWHEEL-鼠标滚轮消息</li></ul></li></ul><h3 id="鼠标基本消息"><a href="#鼠标基本消息" class="headerlink" title="鼠标基本消息"></a>鼠标基本消息</h3><ul><li>附带信息<ul><li>WPARAM:其他按键的状态，例如Ctrl/Shift等。<ul><li>LPARAM:鼠标的位置，窗口客户区坐标系。<ul><li>LOWWORD X坐标位置</li><li>HIWORD Y坐标位置</li></ul></li></ul></li></ul></li><li>一般情况鼠标按下/抬起成对出现。在鼠标移动过程中，会根据移动速度产生一系列的WM_ MOUSEMOVE消息。</li></ul><h3 id="鼠标双击消息"><a href="#鼠标双击消息" class="headerlink" title="鼠标双击消息"></a>鼠标双击消息</h3><ul><li>附带消息:<ul><li>WPARAM-其它按键的状态，例如CTRL/SHIFT。</li><li>LPARAM-鼠标的位置，窗口客户区坐标系。<ul><li>LOWORD(lParam)-X坐标位置</li><li>HIWORD(lParam)-Y坐标位置</li></ul></li></ul></li><li>消息产生顺序<ul><li>一左键双击为例:<ul><li>WM_LBUTTONDOWN</li><li>WM_LBUTTONUP</li><li>WM_LBUTTONDBLCLK</li><li>WM_LBUTTONU</li><li>使用时需要在注册窗口类的时候添加CS_DBLCLKS风格。</li></ul></li></ul></li></ul><h3 id="鼠标滚轮消息"><a href="#鼠标滚轮消息" class="headerlink" title="鼠标滚轮消息"></a>鼠标滚轮消息</h3><ul><li>附带消息<ul><li>WPARAM<ul><li>LOWORD-其他按键的状态</li><li>HIWORD-滚轮的偏移量(120的倍数 )，通过正负值表示滚轮的方向</li><li>正-向前滚动，负-向后滚动</li></ul></li><li>LPARAM:鼠标当前的位置，屏幕坐标系<ul><li>LOWORD-X坐标</li><li>HIWORD-Y坐标</li></ul></li></ul></li><li>使用:通过偏移量，获取滚轮的方向和距离</li></ul><h2 id="定时器消息"><a href="#定时器消息" class="headerlink" title="定时器消息"></a>定时器消息</h2><h3 id="定时器消息介绍"><a href="#定时器消息介绍" class="headerlink" title="定时器消息介绍"></a>定时器消息介绍</h3><ul><li>产生时间:<br>在程序中创建定时器，当到达时间间隔时，定时器会向程序发送一个WM_TIMER消息。定时器的精度是毫秒，但是准确度很低。例如时间间隔为1000ms，但是会在非1000毫秒到达消息。</li><li>附带信息:<ul><li>WPARAM:<strong>定时器ID(到时间的)</strong></li><li>LPARAM:定时器处理函数的指针</li></ul></li></ul><p>GetMessage肯定有没事干的时候，所以WM_TIMER消息肯定会产生。</p><p>按照一定周期去执行，时间要求不严格，都可以用这个定时器。</p><h3 id="创建销毁定时器"><a href="#创建销毁定时器" class="headerlink" title="创建销毁定时器"></a>创建销毁定时器</h3><ul><li>创建定时器</li></ul><p>函数原型如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UINT_PTR <span class="title">SetTimer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional] HWND      hWnd,<span class="comment">//定时器窗口句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in]           UINT_PTR  nIDEvent,<span class="comment">//定时器ID</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in]           UINT      uElapse,<span class="comment">//时间间隔(毫秒为单位)</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional] TIMERPROC lpTimerFunc；<span class="comment">//定时器处理函数指针(一般不使用，为NULL)创建成功，返回非0。</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>关闭定时器</li></ul><p>函数原型如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">KillTimer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional] HWND     hWnd,<span class="comment">//窗口句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in]           UINT_PTR uIDEvent<span class="comment">//定时器ID</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="菜单资源"><a href="#菜单资源" class="headerlink" title="菜单资源"></a>菜单资源</h2><h3 id="菜单分类"><a href="#菜单分类" class="headerlink" title="菜单分类"></a>菜单分类</h3><ul><li>窗口的顶层菜单(不需要也不能设置ID,因为它的唯一作用的就是弹出下拉次菜单)</li><li>弹出式菜单</li><li>系统菜单</li></ul><p>HMENU(<strong>菜单句柄</strong>)类型表示菜单，ID表示菜单项。</p><h3 id="资源相关"><a href="#资源相关" class="headerlink" title="资源相关"></a>资源相关</h3><ul><li>资源脚本文件:.rc文件</li><li>编译器:RC.EXE</li></ul><h3 id="菜单资源的使用"><a href="#菜单资源的使用" class="headerlink" title="菜单资源的使用"></a>菜单资源的使用</h3><ul><li>添加菜单资源-添加文件.rc文件</li><li>加载菜单资源<ol><li>注册窗口类时设置菜单<ol><li>(wc.lpszMenuName = (char*)IDR_MENU1;//菜单设置)</li></ol></li><li>创建窗口传参设置菜单<ol><li>CreateWindow的导数第三个参数 </li></ol></li><li>在主窗口WM_CREATE消息中利用SetMenu函数设置菜单</li></ol></li></ul><p>LoadMenuW函数原型:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HMENU <span class="title">LoadMenuW</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional] HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]           LPCWSTR   lpMenuName</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>SetMenu函数原型:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">SetMenu</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]           HWND  hWnd,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional] HMENU hMenu</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="命令消息-WM-COMMAND-处理"><a href="#命令消息-WM-COMMAND-处理" class="headerlink" title="命令消息(WM_COMMAND)处理"></a>命令消息(WM_COMMAND)处理</h3><ul><li>附带消息:<ul><li>WPARAM：<ul><li>HIWORD-对于菜单为0(没用)</li><li>LOWRD-<strong>被鼠标点击的</strong>菜单项的ID</li></ul></li><li>LPARAM<ul><li>对于菜单项为0(没用)</li></ul></li></ul></li></ul><h2 id="Windows资源"><a href="#Windows资源" class="headerlink" title="Windows资源"></a>Windows资源</h2><h3 id="图标资源"><a href="#图标资源" class="headerlink" title="图标资源"></a>图标资源</h3><p><strong>指的就是.ico为后缀的图片</strong></p><ul><li>添加资源<ul><li>注意图标的大小， 一个图标文件中，可以有多个不同大小的图标。</li></ul></li><li>加载</li></ul><p>函数原型如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">到本进程的内存中找图标的数据同loadMenu</span><br><span class="line"><span class="function">HICON <span class="title">LoadIconA</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional] HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]           LPCSTR    lpIconName</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;<span class="comment">//成功返回HICON句柄</span></span><br><span class="line"></span><br><span class="line">例：使用</span><br><span class="line">wc.hIcon = LoadIcon(hIns,(<span class="keyword">char</span>*)IDI_ICON1);</span><br></pre></td></tr></table></figure><ul><li>设置<ul><li>注册窗口类</li></ul></li></ul><h3 id="光标资源"><a href="#光标资源" class="headerlink" title="光标资源"></a>光标资源</h3><ul><li>添加光标的资源<ul><li>光标的大小默认是32X32像素，每个光标有HotSpot,是当前鼠标的热点(点击图标生效的那个点)。</li></ul></li><li>加载资源</li></ul><p>函数原型如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HCURSOR <span class="title">LoadCursorW</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional] HINSTANCE hInstance,<span class="comment">//可以为NULL，获取系统默认的Cursor</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in]           LPCWSTR   lpCursorName</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>设置资源</p><ul><li>在注册窗口时，设置光标。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc.hCursor = LoadCursor(hIns,(<span class="keyword">char</span>*)IDC_CURSOR1);</span><br></pre></td></tr></table></figure><ul><li>使用SetCursor设置光标。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HCURSOR <span class="title">SetCursor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HCURSOR hCursor</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//必须放在处理下面这个消息的时候调用</span></span><br></pre></td></tr></table></figure><ul><li>WM_SETCURSOR消息参数<ul><li>WPARAM-当前使用的光标句柄</li><li>LPARAM-LOWORD-当前区域代码(Hit-Test code)HICLIENT/HTCAPTION…</li><li>HIWORD-当前鼠标消息ID</li></ul></li></ul></li></ul><h3 id="字符串资源"><a href="#字符串资源" class="headerlink" title="字符串资源"></a>字符串资源</h3><ul><li>添加字符串资源<ul><li>添加字符串资源，在表中增加字符串。</li></ul></li><li>字符串资源的使用<ul><li>函数原型如下</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LoadStringW</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional] HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]           UINT      uID,<span class="comment">//字符串ID</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [out]          LPWSTR    lpBuffer,<span class="comment">//存放字符串 </span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in]           <span class="keyword">int</span>       cchBufferMax</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;<span class="comment">//成功返回字符串长度，失败0</span></span><br></pre></td></tr></table></figure><p>使用:例如实现中英文两版的软件。使用这个就非常方便。</p><hr><p><strong>字符串能写就写在这张字符串表中，容易修改。</strong></p><p>用loadstring去读，然后在字符串表中改。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> szTitle[<span class="number">256</span>] = &#123; &#125;;</span><br><span class="line">LoadString(hIns, IDS_WIND, szTitle, <span class="number">256</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/win32(1).assets/image-20211102190831358.png" alt="image-20211102190831358"></p><hr><h3 id="加速键资源"><a href="#加速键资源" class="headerlink" title="加速键资源"></a>加速键资源</h3><p>什么ctrl+c,v之类的，就是快捷键呗。</p><p>能使用加速键(组合键)的功能，在菜单栏中也对应有一个，一般是绑定使用。</p><ul><li>添加,资源添加<strong>加速键表</strong>，增加命令ID对应的加速键。</li><li>使用:</li></ul><p>函数原型如下:</p><p>加载加速键表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HACCEL <span class="title">LoadAcceleratorsA</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional] HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]           LPCSTR    lpTableName<span class="comment">//加速键表资源ID</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;<span class="comment">//返回加速键表句柄</span></span><br></pre></td></tr></table></figure><p>翻译加速键</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TranslateAcceleratorA</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] HWND   hWnd,<span class="comment">//处理消息的句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] HACCEL hAccTable,<span class="comment">//加速键句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] LPMSG  lpMsg<span class="comment">//消息</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;<span class="comment">//如果是加速键，返回非0</span></span><br><span class="line"></span><br><span class="line">位置：一定是放在GetMessage的后面，因为它不抓哪来的消息。</span><br><span class="line">并且放在TranslateMessage的后面，假如我按了ctrl+m，我是想让他区分按的是大M还是小m吗？不是，我为的是实现对应的功能(产生对应的消息WM_COMMAND。)</span><br><span class="line">    </span><br><span class="line">如果按的是加速键，在内部会发送出WM_COMMAND消息。</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p> <strong>代码示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HACCEL hAcc = LoadAccelerators(hIns, (<span class="keyword">char</span>*)IDR_ACCELERATOR1);<span class="comment">//加载加速键表</span></span><br><span class="line"><span class="keyword">while</span> (GetMessage(&amp;nMsg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!TranslateAccelerator(hWnd, hAcc, &amp;nMsg))<span class="comment">//不是加速键</span></span><br><span class="line">&#123;</span><br><span class="line">TranslateMessage(&amp;nMsg);</span><br><span class="line">DispatchMessage(&amp;nMsg);<span class="comment">//将消息交给窗口处理函数来处理</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>注意</strong>：<br>由TranslateAccelerator发出的WM_COMMMAND消息,HIWORD(WPARAM)为1。</p><p>而鼠标点击菜单资源的HIWORD(WPARAM)为0。</p><p>LOWORD(WPARAM)都代表命令ID。</p><p>LPARAM为0。</p><hr><h2 id="绘图编程"><a href="#绘图编程" class="headerlink" title="绘图编程"></a>绘图编程</h2><h3 id="绘图基础"><a href="#绘图基础" class="headerlink" title="绘图基础"></a>绘图基础</h3><ul><li>绘图设备(上下文/描述表)DC(Device Context)绘图上下文/绘图描述表</li><li>HDC - DC句柄，表示绘图设备，<strong>绘图设备句柄</strong>。 </li><li>GDI-Windows graphics device interface(Win32提供的绘图API)</li><li>颜色<ul><li>计算机使用红、绿、蓝(RGB)</li><li>每个点颜色是3个字节24位保存0~2^24 - 1种颜色</li><li>16位：5,5,6</li><li>32位：8,8,8,8绘图或透明度</li></ul></li><li>颜色的使用<ul><li>COLORREF-实际DWORD<ul><li>例如:COLORREF nColor = 0;</li></ul></li><li>赋值使用RGB宏<ul><li>例如:nColor = RGB(0,0,255);</li></ul></li><li>获取RGB值<ul><li>GetRBValue/GetGValue/GetBValue</li><li>例如:BYTE nRed  =GetRValue(nColor);</li></ul></li></ul></li></ul><h3 id="基本图形绘制"><a href="#基本图形绘制" class="headerlink" title="基本图形绘制"></a>基本图形绘制</h3><p><strong>在绘图消息中绘图</strong></p><p><strong>绘制点</strong></p><ul><li>SetPixel设置指定点的颜色</li></ul><p>函数原型如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">COLORREF <span class="title">SetPixel</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] HDC      hdc,<span class="comment">//绘图设备句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>      x,<span class="comment">//X坐标 </span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>      y,<span class="comment">//Y坐标</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] COLORREF color<span class="comment">//设置的颜色</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;<span class="comment">//返回点原来的颜色</span></span><br></pre></td></tr></table></figure><p><strong>例如</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PAINTSTRUCT PS = &#123; &#125;;<span class="comment">//抓到画家</span></span><br><span class="line">HDC hdc = BeginPaint(hwnd, &amp;PS);<span class="comment">//开始绘图</span></span><br><span class="line">SetPixel(hdc,<span class="number">100</span>,<span class="number">100</span>,RGB(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">EndPaint(hwnd,&amp;PS);<span class="comment">//放掉画家</span></span><br></pre></td></tr></table></figure><hr><ul><li><p>线的使用(直线、弧线)</p><ul><li><p>MoveToEx-指名窗口当前点(更改窗口当前点) </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">MoveToEx</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]  HDC     hdc,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]  <span class="keyword">int</span>     x,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]  <span class="keyword">int</span>     y,</span></span></span><br><span class="line"><span class="function"><span class="params">  [out] LPPOINT lppt<span class="comment">//为空则不返回上一个点</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>LineTo-从窗口当前点到指定点绘制一条直线(并且致命窗口当前点我)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">LineTo</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] HDC hdc,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span> x,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span> y</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>当前点：上一次绘图时的最后一点，初始为(0,0)点</li></ul></li></ul></li><li><p>封闭图形:能够使用画刷填充的图形(反之则不是)。</p><ul><li>Rectangle/Ellipse——(圆形/矩形)</li></ul></li></ul><p><img src="/images/win32(1).assets/image-20211103164837584.png" alt="image-20211103164837584"></p><p><img src="/images/win32(1).assets/image-20211103164851493.png" alt="image-20211103164851493"></p><p>内切圆，参数相同。</p><h2 id="GDI绘图对象"><a href="#GDI绘图对象" class="headerlink" title="GDI绘图对象"></a>GDI绘图对象</h2><h3 id="画笔"><a href="#画笔" class="headerlink" title="画笔"></a>画笔</h3><ul><li>画笔的作用<ul><li>线的颜色、线型、线粗。</li><li>HPAN-画笔句柄</li></ul></li><li>画笔的使用</li></ul><p>1.创建画笔，函数原型如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HPEN <span class="title">CreatePen</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>      iStyle,<span class="comment">//画笔的样式</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>      cWidth,<span class="comment">//画笔的粗细</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] COLORREF color<span class="comment">//画笔的颜色</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;<span class="comment">//创建成功画笔句柄</span></span><br></pre></td></tr></table></figure><p>PS_SOILD-实心线，可以支持多个像素宽，其它线型只能是一个像素宽。</p><p>2.将画笔应用到DC中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HGDIOBJ <span class="title">SelectObject</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] HDC     hdc,<span class="comment">//绘图设备句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] HGDIOBJ h<span class="comment">//GDI绘图对象句柄，(包括)兼容画笔句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;<span class="comment">//返回原来的GDI绘图对象句柄</span></span><br></pre></td></tr></table></figure><p>3.绘图</p><p>4.取出DC中的画笔</p><p>将原来的画笔，使用SelectObject函数，放入到设备DC中，就会将我们创建的画笔取出。</p><p>5.释放画笔，函数原型如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">DeleteObject</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] HGDIOBJ ho<span class="comment">//GDI绘图对象句柄，画笔句柄。</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>只能删除不被DC使用的画笔，所以在释放前，必须从将画笔从DC中取出。</p><p>大致过程就是，创建-交换-绘画-取出-释放</p><p> <strong>示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PAINTSTRUCT PS = &#123; &#125;;<span class="comment">//抓到画家</span></span><br><span class="line">HDC hdc = BeginPaint(hwnd, &amp;PS);</span><br><span class="line">HPEN hPen = CreatePen(PS_SOLID,<span class="number">20</span>,RGB(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>));<span class="comment">//创建</span></span><br><span class="line">HGDIOBJ nOldPen = SelectObject(hdc, hPen);<span class="comment">//交换</span></span><br><span class="line">Ellipse(hdc, <span class="number">100</span>, <span class="number">100</span>, <span class="number">300</span>, <span class="number">300</span>);</span><br><span class="line">SelectObject(hdc, nOldPen);<span class="comment">//交换,这里可以不用接收，上面创建时的句柄可以找到这跟笔，让画家松手就行了，我们就能销毁了。</span></span><br><span class="line">DeleteObject(hPen);</span><br><span class="line">EndPaint(hwnd,&amp;PS);</span><br></pre></td></tr></table></figure><h3 id="画刷"><a href="#画刷" class="headerlink" title="画刷"></a>画刷</h3><ul><li>画刷相关<ul><li>画刷-封闭图形的填充颜色、图案</li><li>HBRUSH-画刷句柄</li><li>画刷的使用套路就跟画笔一样</li><li>默认是画刷颜色是白色的</li></ul></li><li>画刷的使用</li></ul><p>1.创建画刷</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">创建实心画刷</span><br><span class="line"><span class="function">HBRUSH <span class="title">CreateSolidBrush</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] COLORREF color</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;    </span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">创建纹理画刷</span><br><span class="line"><span class="function">HBRUSH <span class="title">CreateHatchBrush</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>      iHatch,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] COLORREF color</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>2.将画刷应用到DC中</p><p>SelectObject</p><p>3.绘图</p><p>4.将画刷从DC中取出</p><p>SelectObject</p><p>5.删除画刷</p><p>DeleteObject</p><hr><ul><li>其他</li></ul><p>可以使用GetStockObject函数获取系统维护的画刷，画笔等。</p><p>如果不使用画刷填充，需要使用NULL_BRUSH参数，获取不填充的画刷。</p><p>GetStockObject返回的画刷不需要DeleteObject。</p><p><strong>示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向操作系统借一把透明刷子</span></span><br><span class="line">HGDIOBJ hBrush = GetStockObject(NULL_BRUSH);</span><br></pre></td></tr></table></figure><h2 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h2><h3 id="位图绘制"><a href="#位图绘制" class="headerlink" title="位图绘制"></a>位图绘制</h3><ul><li><p>位图相关</p><ul><li>光栅图形-记录图像中每一点的颜色等信息</li><li>矢量图形-记录图像算法、绘图指令等。</li><li>HBITMAP-位图句柄</li></ul></li><li><p>位图的使用</p><p>1.在资源中添加位图资源</p><p>2.从资源中加载位图——loadBitMap</p><p>3.创建一个与当前DC相匹配的DC(内存DC)(在内存的一个虚拟的区域画)</p><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HDC <span class="title">CreateCompatibleDC</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] HDC hdc<span class="comment">//当前DC句柄，可以为NULL(使用屏幕DC)</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;<span class="comment">//返回创建好的DC句柄</span></span><br></pre></td></tr></table></figure><hr><p><strong>兼具资源的步骤和GDI绘图对象的步骤。</strong></p><p>4.将位图放入匹配的DC中SelectObject</p><p>5.成像(1:1)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">BitBlt</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] HDC   hdc,<span class="comment">//目的DC</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>   x,<span class="comment">//目的左上X坐标</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>   y,<span class="comment">//目的左上Y坐标</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>   cx,<span class="comment">//目的宽度</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>   cy,<span class="comment">//目的高度</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] HDC   hdcSrc,<span class="comment">//源DC</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>   x1,<span class="comment">//源左上X坐标</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>   y1,<span class="comment">//源左上Y坐标</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] DWORD rop<span class="comment">//成像方法SRCCOPY</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>缩放成像</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">StretchBlt</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] HDC   hdcDest,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>   xDest,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>   yDest,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>   wDest,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>   hDest,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] HDC   hdcSrc,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>   xSrc,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>   ySrc,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>   wSrc,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>   hSrc,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] DWORD rop</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><p>6.取出位图</p><p>SelectObject</p><p>7.释放位图</p><p>DeleteObject</p><p>8.释放匹配的DC</p><p>DeleteDC</p><p><strong>代码示例</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PAINTSTRUCT ps = &#123; &#125;;</span><br><span class="line">HDC hdc = BeginPaint(hwnd, &amp;ps);</span><br><span class="line">HBITMAP hBmp = LoadBitmap(g_HINSTANCE, (<span class="keyword">char</span>*)IDB_BITMAP1);</span><br><span class="line">HDC hMemdc = CreateCompatibleDC(hdc);<span class="comment">//创建一个内存DC，并构建一个虚拟区域，并且内存DC在虚拟区域中绘图</span></span><br><span class="line">HGDIOBJ nOldBmp = SelectObject(hMemdc,hBmp);<span class="comment">//将位图数据送给内存DC,内存DC在虚拟区域中将位图绘制出来，返回旧位图(原来并没有，这是个假的，只是为了我们将来能够换回来）</span></span><br><span class="line">BitBlt(hdc, <span class="number">100</span>, <span class="number">100</span>, <span class="number">48</span>, <span class="number">48</span>, hMemdc, <span class="number">0</span>, <span class="number">0</span>, SRCCOPY);<span class="comment">//将虚拟区域绘制好的图像成像到窗口中</span></span><br><span class="line">StretchBlt(hdc, <span class="number">200</span>, <span class="number">200</span>, <span class="number">96</span>, <span class="number">96</span>,hMemdc,<span class="number">0</span>,<span class="number">0</span>,<span class="number">48</span>,<span class="number">48</span>,SRCCOPY);<span class="comment">//缩放成像</span></span><br><span class="line"><span class="comment">//开辟的区域比要成像的图像大，就是放大图像。</span></span><br><span class="line"></span><br><span class="line">SelectObject(hMemdc, nOldBmp);<span class="comment">//换回来</span></span><br><span class="line">DeleteObject(hBmp);<span class="comment">//释放画的位图</span></span><br><span class="line">DeleteDC(hMemdc);<span class="comment">//释放内存DC</span></span><br></pre></td></tr></table></figure><h2 id="文本绘制"><a href="#文本绘制" class="headerlink" title="文本绘制"></a>文本绘制</h2><h3 id="文字的绘制"><a href="#文字的绘制" class="headerlink" title="文字的绘制"></a>文字的绘制</h3><ul><li>TextOut-将文字绘制在指定坐标位置</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">TextOutW</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] HDC     hdc,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>     x,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>     y,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] LPCWSTR lpString,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>     c</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>DrawText</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DrawText</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]      HDC     hdc,<span class="comment">//DC句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in, out] LPCTSTR lpchText,<span class="comment">//字符串</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in]      <span class="keyword">int</span>     cchText,<span class="comment">//字符数量</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in, out] LPRECT  lprc,<span class="comment">//绘制文字的矩形框</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in]      UINT    format<span class="comment">//绘制的方式</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>文字颜色和背景</p><ul><li>文字颜色:SetTextColor</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">COLORREF <span class="title">SetTextColor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] HDC      hdc,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] COLORREF color</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>文字背景色:SetBkColor——只适用在不透明</li><li>文字背景模式:SetBkMode(OPAQUE/TRANSPARENT)(透明(默认)/非透明)</li></ul></li></ul><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><ul><li>字体相关:</li><li>window常用的字体为TrueType格式的字体文件<ul><li>字体名-标识字体类型</li><li>HFONT-字体句柄(保存字体的数据信息——外观形状)</li></ul></li><li>字体的使用</li></ul><p>1.创建字体CreateFont</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HFONT <span class="title">CreateFontA</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>    cHeight,<span class="comment">//字体高度</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>    cWidth,<span class="comment">//字体宽度</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>    cEscapement,<span class="comment">//字符串倾斜角度</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>    cOrientation,<span class="comment">//字体的旋转角度</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>    cWeight,<span class="comment">//字体的粗细</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] DWORD  bItalic,<span class="comment">//斜体</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] DWORD  bUnderline,<span class="comment">//字符下划线</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] DWORD  bStrikeOut,<span class="comment">//删除线</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] DWORD  iCharSet,<span class="comment">//字符集-GB2312_CHARSET</span></span></span></span><br><span class="line"><span class="function"><span class="params">    </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">//下面的4参数全写0即可</span></span></span></span><br><span class="line"><span class="function"><span class="params">    </span></span></span><br><span class="line"><span class="function"><span class="params">  [in] DWORD  iOutPrecision,<span class="comment">//输出精度</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] DWORD  iClipPrecision,<span class="comment">//剪切精度</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] DWORD  iQuality,<span class="comment">//输出质量</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] DWORD  iPitchAndFamily,<span class="comment">//匹配字体</span></span></span></span><br><span class="line"><span class="function"><span class="params">    </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">//这个得写</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] LPCSTR pszFaceName<span class="comment">//字体名称</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>代码示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">PAINTSTRUCT ps = &#123; &#125;;</span><br><span class="line">HDC hdc = BeginPaint(hwnd,&amp;ps);</span><br><span class="line"></span><br><span class="line">SetTextColor(hdc, RGB(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">SetBkColor(hdc, RGB(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HFONT hFront = CreateFont(<span class="number">30</span>,<span class="number">0</span>,<span class="number">45</span>,<span class="number">0</span>,<span class="number">900</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>, GB2312_CHARSET,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="string">&quot;黑体&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HGDIOBJ nOldFron = SelectObject(hdc, hFront);<span class="comment">//将创建的字体给它</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* szText = <span class="string">&quot;我是TEXTOUT&quot;</span>;</span><br><span class="line">TextOut(hdc,<span class="number">100</span>,<span class="number">100</span>,szText,<span class="built_in">strlen</span>(szText));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//DrawText在矩形的范围内画，所以首先要确定一个范围</span></span><br><span class="line">RECT rc;</span><br><span class="line">rc.left = <span class="number">100</span>;</span><br><span class="line">rc.top = <span class="number">150</span>;</span><br><span class="line">rc.right = <span class="number">200</span>;</span><br><span class="line">rc.bottom = <span class="number">200</span>;</span><br><span class="line"><span class="comment">//DrawText有矩形作为限制边界(可以打破)</span></span><br><span class="line">DrawText(hdc, szText, <span class="built_in">strlen</span>(szText),&amp;rc,DT_LEFT | DT_TOP);</span><br><span class="line"><span class="comment">//DT_VCENTER和DT_BOTTOM只适用于DT_SINGLELINE和DT_WORDBREAK冲突</span></span><br><span class="line"></span><br><span class="line">SelectObject(hdc, nOldFron);<span class="comment">//让它放开</span></span><br><span class="line">DeleteObject(hFront);<span class="comment">//字体更要记得释放，因为字体占的内存较大</span></span><br><span class="line">EndPaint(hwnd,&amp;ps);</span><br></pre></td></tr></table></figure><h2 id="对话框"><a href="#对话框" class="headerlink" title="对话框"></a>对话框</h2><p><strong>处理消息的方式与普通窗口相反</strong>，缺省的函数调用自定义函数。</p><h3 id="对话框原理"><a href="#对话框原理" class="headerlink" title="对话框原理"></a>对话框原理</h3><ul><li>对话框的分类<ul><li>模式对话框-当前对话框显示时，会禁止本进程其它窗口和用户交互操作。</li><li>无模式对话框-在对话框显示后，本进程其它窗口仍然可以和用户进行操作。</li></ul></li><li>对话框基本使用 <ol><li>对话框窗口处理函数</li><li>注册窗口函数(不使用)</li><li>创建对话框</li><li>对话框的关闭</li></ol></li></ul><hr><p><strong>谁注册窗口类，窗口处理函数就由谁来实现。</strong></p><hr><ul><li>对话框处理函数(并非真正的对话框处理函数，真正的系统内部。)</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DLGPROC Dlgproc;</span><br><span class="line"></span><br><span class="line"><span class="function">INT_PTR <span class="title">Dlgproc</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HWND unnamedParam1,<span class="comment">//窗口句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  UINT unnamedParam2,<span class="comment">//消息ID</span></span></span></span><br><span class="line"><span class="function"><span class="params">  WPARAM unnamedParam3,<span class="comment">//消息参数</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPARAM unnamedParam4<span class="comment">//消息参数</span></span></span></span><br><span class="line">)；</span><br></pre></td></tr></table></figure><p>返回TRUE——缺省处理函数不需要处理。</p><p>返回False——交给缺省处理函数处理。不需要调用缺省对话框处理函数。</p><h3 id="模式对话框"><a href="#模式对话框" class="headerlink" title="模式对话框"></a>模式对话框</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DialogBoxA</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional]  hInstance,<span class="comment">//当前程序实例句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in]            lpTemplate,<span class="comment">//对话框资源ID</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional]  hWndParent,<span class="comment">//对话框父窗口</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional]  lpDialogFunc<span class="comment">//自定义函数</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>DialogBox是一个阻塞函数，只有当对话框关闭后，才会返回，继续执行后续代码。</p><p>返回值是通过EndDialog设置。</p><ul><li>对话框的关闭</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">EndDialog</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] HWND    hDlg,<span class="comment">//关闭的对话框窗口</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] INT_PTR nResult<span class="comment">//关闭的返回值，能指定返回值就说明能接触阻塞</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>关闭模式对话框，只能使用EndDialog,不能使用DestoryWindow等函数。</p><p>nRsult是DiglogBox函数退出时的返回值。</p><ul><li>对话框的消息</li></ul><p>WM_INITDIALOG-对话框创建之后在显示之前，通知对话框窗口处理函数，可以完成自己的初始化相关的操作。</p><hr><p>EndDialog销毁对话框，并且解除阻塞。</p><p>而DestroyWindow只能销毁对话框，并不能解除阻塞。</p><hr><h3 id="无模式对话框"><a href="#无模式对话框" class="headerlink" title="无模式对话框"></a>无模式对话框</h3><ul><li>创建对话框</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HWND <span class="title">CreateDialog</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HINSTANCE hInstance,<span class="comment">//应用程序实例句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">        LPCTSTR lpName,<span class="comment">//模板资源ID</span></span></span></span><br><span class="line"><span class="function"><span class="params">        HWND hWndParent hWndParent,<span class="comment">//父窗口</span></span></span></span><br><span class="line"><span class="function"><span class="params">        DLGPROC lpDialogFunc<span class="comment">//自定义函数</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>非阻塞函数，创建成功后返回窗口句柄，需要使用ShowWindow函数显示对话框。</p><ul><li>对话框关闭</li></ul><p>关闭时使用DestroyWindow销毁窗口，不能使用EndDiaglog关闭对话框。</p><p><strong>代码示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HWND noModel = CreateDialog(g_Hinstance, (<span class="keyword">char</span>*)IDD_DIALOG1,hwnd, DlgProc);</span><br><span class="line">ShowWindow(noModel, SW_SHOW);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xxx</span><br><span class="line">DestroyWindow(hwnd);</span><br></pre></td></tr></table></figure><h2 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h2><p> Windows上静态库和Linux上的静态库在原理上没有任何区别，都是封装一堆东西等着别人去掉。</p><h3 id="静态库的特点"><a href="#静态库的特点" class="headerlink" title="静态库的特点"></a>静态库的特点</h3><ul><li>运行不存在。<ul><li>没有如何，不能执行，生成的文件无法形成静态影像，无法进内存。</li></ul></li><li>静态库源码被链接到调用程序中。</li><li>目标程序的归档。</li></ul><h3 id="C语言静态库"><a href="#C语言静态库" class="headerlink" title="C语言静态库"></a>C语言静态库</h3><ul><li>C静态库的创建<ul><li>创建一个静态库程序。</li><li>添加库程序，源文件使用C文件。</li></ul></li><li>C静态库的使用<ul><li>库路径设置:可以使用#pragma关键字设置<ul><li>#pragma comment(lib,”../lib/clib.lib”)</li></ul></li></ul></li></ul><h3 id="C-静态库"><a href="#C-静态库" class="headerlink" title="C++静态库"></a>C++静态库</h3><ul><li>C++静态库的创建<ul><li>创建一个静态库项目</li><li>添加库程序，源文件使用CPP文件。</li></ul></li><li>C++静态库的使用<ul><li>库路径设置:可以使用pragma关键字设置</li><li>#pragma comment(lib,”../xx/xxx.lib”)</li></ul></li></ul><p><strong>示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//给编译器看</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CLIB_add</span><span class="params">(<span class="keyword">int</span> add1, <span class="keyword">int</span> add2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CLIB_sub</span><span class="params">(<span class="keyword">int</span> add1, <span class="keyword">int</span> add2)</span></span>;</span><br><span class="line"><span class="comment">//给链接器看</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;../Debug/CPPLIB.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; CLIB_add(<span class="number">5</span>, <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; CLIB_sub(<span class="number">5</span>, <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>C++调库中函数需要在前面声明。告诉编译器到底换不换名。</strong></p><p><strong>C++编译器编译时会更改函数名。</strong></p><p><strong>解决</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span><span class="string">&quot;C&quot;</span> 函数声明；告诉编译器以C语言方式编译(不要给我改名)。</span><br></pre></td></tr></table></figure><h2 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h2><h3 id="动态库的特点"><a href="#动态库的特点" class="headerlink" title="动态库的特点"></a>动态库的特点</h3><ol><li>运行时独立存在(依附着其它程序运行起来的之后)</li><li>源码不会链接到执行程序</li><li>使用时加载(使用动态库必须使动态库执行)</li></ol><p><strong>与静态库进行比较</strong></p><ol><li>由于静态库是将代码嵌入到使用程序中，多个程序使用时，会有多分代码，所以代码体积会增大。动态库的代码只需要存一份，其他程序通过函数地址使用，所以代码体积较小。</li><li>静态库发生变化后，新的代码需要重新链接嵌入到执行程序中。动态库发生变化后，如果库中函数的定义(或地址)未变化(仅仅是函数的实现发生了变化)，其他使用DLL的程序不需要重新链接。</li></ol><h3 id="动态库的创建"><a href="#动态库的创建" class="headerlink" title="动态库的创建"></a>动态库的创建</h3><ul><li><p>创建动态库项目</p></li><li><p>添加库程序</p></li><li><p>库程序导出-提供给使用库者库中的函数等信息。</p><ol><li><p>声明导出:使用_declspec(dllexport)导出函数。将函数的地址存放在动态库的文件头中。(换名之后的函数)</p><p><strong>注意</strong>：动态库编译链接后，也会有LIB文件(与该DLL配套生成的)，是作为动态库函数映射使用，与静态库不完全相同。<strong>LIB中存放每个函数的名字和它对应的标号，还有与它配套的DLL文件名——xxx.dll</strong></p></li><li><p>模块定义文件.def</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">LIBRARY DLLFunc <span class="comment">//库</span></span><br><span class="line">EXPORTS<span class="comment">//库导出表</span></span><br><span class="line">DLL_Mul  <span class="comment">//导出的函数</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="动态库的使用"><a href="#动态库的使用" class="headerlink" title="动态库的使用"></a>动态库的使用</h3><ul><li>隐式链接(操作系统负责使动态库执行，系统偷偷的把动态库扔到内存中。)<ol><li>头文件和函数原型，在函数原型的声明前，增加_declspec(dllimport)</li><li>导入动态库的LIB文件</li><li>在程序中使用函数<ol><li>隐式的链接的情况，dll文件可以存放的路径(编译器可以找到的位置):</li><li>与执行文件中同一个目录下</li><li>当前工作目录</li><li>Windows目录,(三个window..不建议使用，因为是系统路径， 公共场所，容易出现问题。)</li><li>Windows/System32目录</li><li>Windows/System</li><li>环境变量PATH指定目录</li></ol></li></ol></li></ul><hr><ul><li>显式链接(程序员自己负责使动态库执行)</li></ul><p>1.定义函数指针类型 typedef</p><p>2.加载动态库</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HMODULE <span class="title">LoadLibrary</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCTSTR lpFileName<span class="comment">//动态库文件名或全路径  </span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;<span class="comment">//返回DLL的实例局句柄(HINSTANCE)</span></span><br></pre></td></tr></table></figure><p>3.获取函数(绝对/真实)地址</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FARPROC  <span class="title">GetProcAddress</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HMODULE hModule,<span class="comment">//DLL句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">         LPCSTR lpProcName<span class="comment">//函数名称</span></span></span></span><br><span class="line">)；//成功返回函数地址</span><br></pre></td></tr></table></figure><p>4.使用函数</p><p>5.卸载动态库(释放那块内存，结束动态库执行。)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">FreeLibrary</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HMODULE hModule<span class="comment">//DLL的实例句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>代码示例</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LIBRARY Dll3</span><br><span class="line">EXPORTS</span><br><span class="line">Print @1</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*PRINT)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HINSTANCE hDll = LoadLibrary(<span class="string">&quot;Dll3.dll&quot;</span>);</span><br><span class="line">PRINT MYPRINT = (PRINT)GetProcAddress(hDll, <span class="string">&quot;Print&quot;</span>);</span><br><span class="line">MYPRINT();</span><br><span class="line">FreeLibrary(hDll);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态库中封装类"><a href="#动态库中封装类" class="headerlink" title="动态库中封装类"></a>动态库中封装类</h3><p>类导出的其实也是函数地址。</p><ul><li>在类名称前增加_declspec(dllexport)定义，例如:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">declspec</span>(<span class="title">dllexport</span>)<span class="title">CMath</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通常使用预编译开关切换类的导入导出定义，例如:<br><img src="/images/win32(1).assets/image-20211106214536869.png" alt="image-20211106214536869"></li></ul><p><strong>代码示例</strong>：</p><p>(如果生成错误就改一下代码顺序)</p><p>动态库中封装类.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _DLLCLASS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _DLLCLASS_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DLLCLASS_EXPORTS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXT_CLASS _declspec(dllexport)<span class="comment">//导出</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXT_CLASS _declspec(dllimport)<span class="comment">//导入</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EXT_CLASS</span> <span class="title">Print</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PRINT</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p> 动态库中实现.cpp</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;CLASSDLL.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span><span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLLCLASS_EXPORTS</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print::PRINT</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;123&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用该动态库</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;../CLASSDLL/CLASSDLL.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;../Debug/CLASSDLL.lib&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Print p1;</span><br><span class="line">p1.PRINT();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h3><ul><li>Windows的线程是可以执行代码的实例。系统是以线程为单位调度程序。一个程序当中可以有多个线程，实现多任务的处理。</li><li>进程开启意味着分内存，线程开辟意味着程序的执行。</li><li>Windows线程的特点:<ol><li>线程都具有1个ID</li><li>每个线程都具有自己的内存栈</li><li>同一进程中的线程使用同一个地址空间</li></ol></li><li>线程的调度:</li></ul><p><strong>操作系统</strong>将CPU的执行时间划分成时间片，依次根据时间片执行不同的线程</p><p>线程轮询:线程A-&gt;线程B-&gt;线程A……</p><p><strong>在一个时间点上，CPU只能执行一个线程。</strong></p><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><ul><li>创建线程</li></ul><p>函数原型如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateThread</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional]  LPSECURITY_ATTRIBUTES   lpThreadAttributes,<span class="comment">//安全属性</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in]            SIZE_T                  dwStackSize,<span class="comment">//线程栈的大小</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in]            LPTHREAD_START_ROUTINE  lpStartAddress,<span class="comment">//线程处理函数的函数地址</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional]  __drv_aliasesMem LPVOID lpParameter,<span class="comment">//传递给线程处理函数的参数</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in]            DWORD                   dwCreationFlags,<span class="comment">//线程的创建方式</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [out, optional] LPDWORD                 lpThreadId<span class="comment">//创建成功，返回线程的ID</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;<span class="comment">//创建成功，返回线程句柄。</span></span><br></pre></td></tr></table></figure><p><strong>只要看到安全属性这个参数就通通置空，这个参数已经被废弃了。</strong></p><p><strong>线程栈大小，按照1MB对齐。</strong></p><p><strong>看到处理函数，就说明这个函数由我们程序员去定义，由系统调用。</strong></p><p><strong>线程的创建方式有两种，立即执行方式，挂起方式。</strong></p><p><strong>多线程，宏观上同时开始(并行)，真实是，一个时间点只能执行一个线程(串行)。</strong></p><ul><li>定义线程处理函数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">LPVOID lpParameter<span class="comment">//创建线程时，传递给线程的参数。</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>代码示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD CALLBACK <span class="title">TestProc</span><span class="params">(LPVOID pParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">char</span>*)pParam &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">Sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">DWORD CALLBACK <span class="title">TestProc1</span><span class="params">(LPVOID pParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">char</span>*)pParam &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">Sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DWORD nID = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* text = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">HANDLE hTread = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, TestProc, (<span class="keyword">void</span>*)text, <span class="number">0</span>, &amp;nID);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* text1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">HANDLE hTread1 = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, TestProc1, (<span class="keyword">void</span>*)text1, <span class="number">0</span>, &amp;nID);</span><br><span class="line"></span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程挂起-销毁"><a href="#线程挂起-销毁" class="headerlink" title="线程挂起/销毁"></a>线程挂起/销毁</h3><p><strong>挂起</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">SuspendTread</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HANDLE hThread <span class="comment">//线程句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>唤醒</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">ResumeTread</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HANDLE hThread<span class="comment">//线程句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>结束指定线程</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL Terminate <span class="title">Thread</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HANDLE hThread,<span class="comment">//线程句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">        DWORD dwExitCode<span class="comment">//退出码，没有实际意义</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>结束函数所在的线程</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">ExitThread</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">DWORD dwExitCode<span class="comment">//退出码</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="线程相关操作"><a href="#线程相关操作" class="headerlink" title="线程相关操作"></a>线程相关操作</h3><p><strong>获取当前线程ID</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GetCurrentThreadId();</span><br></pre></td></tr></table></figure><p><strong>获取当前线程的句柄</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GetCurrentThread();</span><br></pre></td></tr></table></figure><p><strong>等候(可等候)单个句柄有信号</strong>——线程句柄</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">WaitForSingleObject</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HANDLE handle，<span class="comment">//句柄BUFF的地址</span></span></span></span><br><span class="line"><span class="function"><span class="params">DOWRD dwMilliseconds<span class="comment">//等候时间INFINITE(无限大)</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>一个可等候的句柄，一定有有信号和无信号的两种状态。</p><p>等候的时间已经到了，该句柄还是无信号那就返回了。</p><p><strong>同时等候多个句柄有信号</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">WaitForMultipleObjects</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">DOWRD nCount,<span class="comment">//要等候的句柄数量</span></span></span></span><br><span class="line"><span class="function"><span class="params">    CONST HANDLE*lpHandle,<span class="comment">//句柄BUFF的地址</span></span></span></span><br><span class="line"><span class="function"><span class="params">    </span></span></span><br><span class="line"><span class="function"><span class="params">    BOOL bWaitAll,<span class="comment">//等候方式</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">//TRUE-所有事件都有信号才返回</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">//FALSE-有一个事件有信号就返回</span></span></span></span><br><span class="line"><span class="function"><span class="params">    </span></span></span><br><span class="line"><span class="function"><span class="params">    </span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD dwMilliseconds<span class="comment">//等候时间INFINITE</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>bWaitAll-等候方式</p><ul><li>TRUE-表示所有句柄都有信号，才结束等候。</li><li>FALSE-表示句柄中只要1个有信号，就结束等候。</li></ul><hr><p>线程句柄执行的时候无信号，结束的时候有信号。</p><hr><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><h3 id="原子锁"><a href="#原子锁" class="headerlink" title="原子锁"></a>原子锁</h3><ul><li>相关问题</li></ul><p>多个线程对同一个数据进行原子操作，会产生结果丢失。比如执行++运算时。</p><ul><li>错误代码分析</li></ul><p>当线程A执行g_value++时，如果线程切换时间正好是在线程A再次被切换回来之后，会将原来线程A保存的值保存到g_values上，线程B进行的加法操作被覆盖。(汇编角度)</p><blockquote><p>当CPU在执行某个线程的时候，一旦时间到了它要离开，它会将这个线程已经执行到的位置保护起来，一般是压栈保护。将位置信息压到本线程的栈中。再来，先弹栈读取，恢复战场。</p></blockquote><ul><li>图示</li></ul><p><img src="/images/win32(1).assets/image-20211107172354028.png" alt="image-20211107172354028"></p><p><strong>解释/错误分析</strong>:</p><blockquote><p>第一个线程刚要将+1后的值赋给g_value,cpu给它的时间就到了，这时切换到线程2，线程2执行完毕，g_value == 1，切换回线程1，先弹栈恢复，执行完毕得到g_value == 1,这就丢失了一次数据。</p></blockquote><p><strong>解决</strong>：使用原子锁函数，来++</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD CALLBACK <span class="title">TestProc1</span><span class="params">(LPVOID pParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//g_value++;</span></span><br><span class="line">InterlockedIncrement(&amp;g_value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD CALLBACK <span class="title">TestProc2</span><span class="params">(LPVOID pParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//g_value++;</span></span><br><span class="line">InterlockedIncrement(&amp;g_value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li> 使用原子锁函数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InterlockedIncrement</span><br><span class="line">......</span><br><span class="line">每一个操作符都有对应的一个原子锁函数</span><br></pre></td></tr></table></figure><p><strong>原子锁的实现</strong>：直接对数据所在的内存进行操作，并且在任何一个瞬间只能有一个线程访问这块内存。(++并不是直接对内存进行操作，而是对寄存器进行操作，然后再赋值给变量。)</p><p><strong>锁的是数据所在的这块内存，并不是CPU。</strong></p><p><strong>解释</strong>：</p><blockquote><p>先执行线程1，进来直接给g_value(内存)上锁，如果这时候CPU给的时间到了，那就压栈保护，然后转去执行线程2，线程2一看已经g_value已经被锁了，不会重复锁，发生阻塞，等到时间的耗尽，又转去执行线程1，弹栈恢复，完成执行完后，给g_value解锁，再去执行线程2，线程2就能给g_value上锁了……重复上述过程。</p><p>简单来说就是，上了锁之后可以保证一个线程对该变量，完成一次完整的操作后，另一个线程再进行一次完整的操作。</p></blockquote><p>使用原子锁之后执行效率变慢，因为这两个线程老是对着睡觉。</p><p>重要的是保证结果的正确性，如果保证不了正确性，宁可牺牲效率也要保证结果正确。</p><ul><li>局限性&amp;优点</li></ul><p>只能对运算符进行原子锁。而且有大量函数。但是在所有的枷锁机制中，它的效率最高。</p><hr><h3 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h3><ul><li>相关的问题</li></ul><p>多线程下代码或资源的共享使用</p><ul><li>互斥的使用</li></ul><p>一.创建互斥</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateMutex</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">LPSECURITY_ATTRIBUTES lpMutexAttributes,<span class="comment">//安全属性</span></span></span></span><br><span class="line"><span class="function"><span class="params">    BOOL bInitialOwner,<span class="comment">//初识的拥有者TRUE/FALSE</span></span></span></span><br><span class="line"><span class="function"><span class="params">    LPCTSTR lpName<span class="comment">//命名</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;<span class="comment">//创建成功返回互斥句柄</span></span><br></pre></td></tr></table></figure><p>互斥不光能对操作符进行枷锁，也能对其它东西进行枷锁，比如说锁定一段或一行代码。</p><p>原子锁能解决的问题，互斥都能解决，但是互斥能解决的问题，原子锁不一定能解决。</p><p> <strong>互斥句柄也是可等候句柄。</strong></p><p><strong>特点</strong>：</p><p>1.任何一个时间点上只能有一个线程拥有互斥。其它线程只能等待这个线程把互斥扔掉才能拥有。<strong>独占性和排他性、</strong></p><ol start="2"><li>  当任何一个线程都不拥有互斥，互斥句柄有信号。一旦某个线程有互斥，互斥句柄无信号。</li><li>谁先等待互斥，谁先得到互斥。</li></ol><p>二.等到互斥</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WaitForSingleObject/WaitForMultipleObjects...互斥的等候遵循谁先等候谁先获取</span><br></pre></td></tr></table></figure><p>三.释放互斥</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">ReleaseMutex</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HANDLE hMutex<span class="comment">//互斥句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>四.关闭互斥句柄</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CloseHandle</span><br></pre></td></tr></table></figure><p><strong>代码示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">HANDLE g_hMutex = <span class="number">0</span>;<span class="comment">//接收互斥句柄</span></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD CALLBACK <span class="title">TestProc</span><span class="params">(LPVOID pParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span>* text = (<span class="keyword">char</span>*)pParam;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">WaitForSingleObject(g_hMutex, INFINITE);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(text); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; text[i];</span><br><span class="line">Sleep(<span class="number">333</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">ReleaseMutex(g_hMutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">DWORD CALLBACK <span class="title">TestProc1</span><span class="params">(LPVOID pParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span>* text = (<span class="keyword">char</span>*)pParam;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">WaitForSingleObject(g_hMutex, INFINITE);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(text); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; text[i];</span><br><span class="line">Sleep(<span class="number">333</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">ReleaseMutex(g_hMutex);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建互斥的这个主线程也不拥有它，</span></span><br><span class="line">g_hMutex = CreateMutex(<span class="literal">NULL</span>,FALSE,<span class="literal">NULL</span>);</span><br><span class="line">DWORD nID = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* text = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">HANDLE hTread = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, TestProc, (<span class="keyword">void</span>*)text, <span class="number">0</span>, &amp;nID);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* text1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">HANDLE hTread1 = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, TestProc1, (<span class="keyword">void</span>*)text1, <span class="number">0</span>, &amp;nID);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">getchar();</span><br><span class="line">CloseHandle(g_hMutex);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>解释</strong>：互斥句柄在主函数中创建出来，设备FALSE，谁都不拥有，<strong>互斥句柄有信号</strong>，等待抢占，假设CPU先执行线程1， 拿到互斥句柄，<strong>互斥句柄变为无信号</strong>，执行打印，到时间后，压栈保存，转去执行线程2，此时WaitForSingObject就无法通过，阻塞，等待时间结束，又执行线程1，恢复现场，假设执行完毕，线程1丢掉互斥，<strong>互斥句再次变为有信号</strong>，线程2WaitForSingObject通过，拿到互斥……。      </p><hr><p>原子锁和互斥都是枷锁机制，实现的都是多个线程之间有排斥关系。 <strong>多个线程之间去竞争临界资源。</strong></p><hr><p>下面这两个同步技术，事件和信号量，实现的是线程之间的<strong>协调工作关系</strong>。</p><hr><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><ul><li>相关问题</li></ul><p>程序(线程)之间的通知的问题。</p><p>两个线程要协调工作，它们两个就得通信。</p><ul><li>事件的使用</li></ul><p>1.创建事件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateEvent</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">LPSECURITY_ATTRIBUTES lpEventAttributes,<span class="comment">//安全属性</span></span></span></span><br><span class="line"><span class="function"><span class="params">    BOOL bManualReset,<span class="comment">//事件重置(复位(将事件变为无信号))方式，TRUE手动，FALSE自动</span></span></span></span><br><span class="line"><span class="function"><span class="params">    BOOL bInitialState,<span class="comment">//事件初识状态，TRUE有信号</span></span></span></span><br><span class="line"><span class="function"><span class="params">    LPCTSTR lpName<span class="comment">//事件命名</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;<span class="comment">//创建成功返回事件句柄</span></span><br></pre></td></tr></table></figure><p>2.等候事件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WaitForSingleObject/WaitForMultipleObjects</span><br></pre></td></tr></table></figure><p>3.触发事件(将事件设置成有信号状态)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">SetEvent</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HANDLE hEvent <span class="comment">//事件句柄 </span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br></pre></td></tr></table></figure><p>4.复位事件(将事件设置成无信号状态)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">ResetEvent</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HANDLE hEvent<span class="comment">//事件句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>5.关闭事件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CloseHandle</span><br></pre></td></tr></table></figure><p> <strong>代码示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">HANDLE g_hEvent = <span class="number">0</span>;<span class="comment">//接收事件句柄</span></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD CALLBACK <span class="title">PrintProc</span><span class="params">(LPVOID pParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">WaitForSingleObject(g_hEvent,INFINITE);</span><br><span class="line"><span class="comment">//ResetEvent(g_hEvent);//将事件设置成无信号</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;*************&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过事件进行通信</span></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD CALLBACK <span class="title">CtrlProc</span><span class="params">(LPVOID pParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">Sleep(<span class="number">1000</span>);</span><br><span class="line">SetEvent(g_hEvent);<span class="comment">//解救线程1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//FALSE为自动复位，当经过WaitForSingleObject函数之后</span></span><br><span class="line"><span class="comment">//TRUE为手动复位，手动在WaitForSingleObject后ResetEvent</span></span><br><span class="line">g_hEvent = CreateEvent(<span class="literal">NULL</span>,FALSE,FALSE,<span class="literal">NULL</span>);</span><br><span class="line">DWORD nID = <span class="number">0</span>;</span><br><span class="line">HANDLE hThread[<span class="number">2</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">hThread[<span class="number">0</span>] = CreateThread(<span class="literal">NULL</span>,<span class="number">0</span>,PrintProc,<span class="literal">NULL</span>,<span class="number">0</span>,&amp;nID);</span><br><span class="line">hThread[<span class="number">1</span>] = CreateThread(<span class="literal">NULL</span>,<span class="number">0</span>,CtrlProc,<span class="literal">NULL</span>,<span class="number">0</span>,&amp;nID);</span><br><span class="line">WaitForMultipleObjects(<span class="number">2</span>,hThread,TRUE,INFINITE);</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>注意</strong>：<strong>小心事件死锁。</strong></p><p><img src="/images/win32(1).assets/image-20211107213811934.png" alt="image-20211107213811934"></p><hr><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><ul><li>相关的问题</li></ul><p>类似于事件(不是原理类似时间，是作用类似事件)，解决通知的相关问题。但提供一个<strong>计数器</strong>，<strong>可以设置次数</strong>。</p><ul><li>信号量的使用</li></ul><p>1.创建 信号量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateSemaphoreW</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional] LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,<span class="comment">//安全属性</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in]   LONG    lInitialCount,<span class="comment">//初始化信号量数量(初识计数值)</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in]   LONG    lMaximumCount,<span class="comment">//信号量(计数器)的最大值</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional] LPCWSTR   lpName<span class="comment">//命名</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;<span class="comment">//创建成功返回信号量句柄</span></span><br></pre></td></tr></table></figure><p><strong>信号量的计数器不为0时，信号量句柄有信号。</strong><br>2.等候信号量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WaitForSingleObject/WaitForMultipleObjects</span><br></pre></td></tr></table></figure><p>每等候一次，信号量减1，直到为0阻塞。</p><p>3.给信号量指定计数值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">ReleaseSemaphore</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]            HANDLE hSemaphore,<span class="comment">//信号量句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in]            LONG   lReleaseCount,<span class="comment">//释放数量</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [out, optional] LPLONG lpPreviousCount<span class="comment">//释放前原来信号量的数量，可以为NULL</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>4.关闭句柄</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CloseHandle  </span><br></pre></td></tr></table></figure><p><strong>代码示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">HANDLE h_handle = <span class="number">0</span>;<span class="comment">//信号量句柄</span></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD CALLBACK <span class="title">TestProc</span><span class="params">(LPVOID pParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">WaitForSingleObject(h_handle, INFINITE);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;******&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">h_handle = CreateSemaphore(<span class="literal">NULL</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="literal">NULL</span>);</span><br><span class="line">DWORD nID = <span class="number">0</span>;</span><br><span class="line">HANDLE hThread = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, TestProc, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;nID);</span><br><span class="line"></span><br><span class="line">getchar();<span class="comment">//回车之后信号量数量改为5</span></span><br><span class="line">ReleaseSemaphore(h_handle, <span class="number">5</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">WaitForSingleObject(hThread, INFINITE);</span><br><span class="line">CloseHandle(h_handle);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;相关视频——&lt;a href=&quot;https://www.bilibili.com/video/BV1NA411K7aN?p=1&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;Windows编程&quot;&gt;&lt;a href=&quot;#Windows编程&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="Win32" scheme="http://zhaoyuxuan.xyz/categories/Win32/"/>
    
    
    <category term="-Win32 - -C" scheme="http://zhaoyuxuan.xyz/tags/Win32-C/"/>
    
  </entry>
  
  <entry>
    <title>【算法】查找算法</title>
    <link href="http://zhaoyuxuan.xyz/2021/10/29/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    <id>http://zhaoyuxuan.xyz/2021/10/29/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</id>
    <published>2021-10-29T06:35:47.000Z</published>
    <updated>2021-11-02T10:48:34.048Z</updated>
    
    <content type="html"><![CDATA[<h1 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h1><h2 id="查找的定义"><a href="#查找的定义" class="headerlink" title="查找的定义"></a>查找的定义</h2><blockquote><p>查找:又称检索或查询，是指在查找表中找出满足一定条件的结点或记录对应的操作。</p></blockquote><blockquote><p>查找表:在计算机中，是指被查找的数据对象是由同一个类型的记录构成的集合，如顺序表、链表、二叉树和哈希表等。</p></blockquote><blockquote><p>查找效率:查找算法中的基本运算是通过记录的关键字与给定值进行比较，所以查找的效率通常取决于比较所花的时间，而时间取决于比较的次数。通常以关键字与给定值进行比较的记录个数的平均值来计算。</p></blockquote><p><strong>查找操作及分类</strong></p><p><strong>操作</strong>：</p><ol><li>查找某个“特定的”数据元素是否成存在在查找表里。</li><li>某个“特定的”数据元素的各种属性。</li><li>在查找表中插入一个数据元素。</li><li>从查找表中删除某个数据元素。</li></ol><p><strong>分类</strong>:</p><blockquote><p>若对查找表只进行(1)或(2)两种操作，则称此类查找表为静态查找表。</p><p>若在查找的过程中同时插入查找表中存在的数据元素，或者从查找表中删除已经存在的某个数据元素，则称次类查找表为动态查找表。</p></blockquote><h2 id="数组和索引"><a href="#数组和索引" class="headerlink" title="数组和索引"></a>数组和索引</h2><blockquote><p>索引把线性表分为若干块，每一块中的元素存储顺序是任意的，但是块与块之间必须按关键字大小顺序排列。即前一块中的最大关键字值小于后一块中的最小关键字值。</p></blockquote><blockquote><p>分块以后，为了快速定义块，还需要建立一个索引表，索引表中的一项对应于线性表中的块，索引项由键域和链域组成。键域存放相应关键字的键值，链域存放指向本块第一个节点和最后一个节点的指针，索引表按关键字由小到大的顺序排列！</p></blockquote><p><strong>数组是特殊的块索引（一个块一个元素）</strong>：</p><p><img src="%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95.assets/image-20211028180054162.png" alt="image-20211028180054162"></p><p><strong>哈希表是非常经典的块索引!</strong><br><img src="%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95.assets/image-20211028180620292.png" alt="image-20211028180620292"></p><blockquote><p>分块查找的算法分两步进行，首先确定所查找的节点属于哪一块，即在索引表中查找其所在的块，然后在块内查找待查询的数据。由于索引表是递增有序的，可采用二分查找，而块内元素是无序的，只能采用顺序查找。（块内元素较少，则不会对执行速度有太大的影响）</p></blockquote><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><blockquote><p>二分查找法实质上是不断地将有序数据集进行对半分割，并检查每个分区的中间元素。再重 复根据中间数确定目标范围并递归实行对半分割，直到中间数等于待查找的值或是目标数不在搜 索范围之内！</p></blockquote><p><strong>代码实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(<span class="keyword">int</span>* sorted, <span class="keyword">int</span> len, <span class="keyword">int</span> search)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> middle = <span class="number">0</span>;</span><br><span class="line">left = <span class="number">0</span>;</span><br><span class="line">right = len - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">&#123;</span><br><span class="line">middle = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (sorted[middle] == search)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> middle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sorted[middle] &gt; search)</span><br><span class="line">&#123;</span><br><span class="line">right = middle - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">left = middle + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">16</span>,<span class="number">58</span>,<span class="number">74</span>,<span class="number">169</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> search = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> index = BinarySearch(arr, <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]),search);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; index;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果要实现其他类型的比较查找</strong></p><p>注意用void*类型接收不同类型，根据传进来类型的不同调用对应的比较函数。</p><p><strong>代码实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">int_compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* key1, <span class="keyword">const</span> <span class="keyword">void</span>* key2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* ch1 = (<span class="keyword">const</span> <span class="keyword">int</span>*)key1;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* ch2 = (<span class="keyword">const</span> <span class="keyword">int</span>*)key2;</span><br><span class="line"><span class="keyword">return</span> *ch1 - *ch2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">char_compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* key1, <span class="keyword">const</span> <span class="keyword">void</span>* key2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* ch1 = (<span class="keyword">const</span> <span class="keyword">char</span>*)key1;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* ch2 = (<span class="keyword">const</span> <span class="keyword">char</span>*)key2;</span><br><span class="line"><span class="keyword">return</span> *ch1 - *ch2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(<span class="keyword">void</span>* sorted, <span class="keyword">int</span> len,<span class="keyword">int</span> elemSize,<span class="keyword">void</span> *search, <span class="keyword">int</span>(*compare)(<span class="keyword">const</span> <span class="keyword">void</span>* key1, <span class="keyword">const</span> <span class="keyword">void</span>* key2))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> middle = <span class="number">0</span>;</span><br><span class="line">left = <span class="number">0</span>;  </span><br><span class="line">right = len - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">middle = (left + right) / <span class="number">2</span>;</span><br><span class="line">ret = compare( (<span class="keyword">char</span>*)sorted+(middle * elemSize),search);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> middle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">right = middle - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">left = middle + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">16</span>,<span class="number">58</span>,<span class="number">74</span>,<span class="number">169</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> search = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> index = BinarySearch(arr, <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]),<span class="keyword">sizeof</span>(<span class="keyword">int</span>),&amp;search,int_compare);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; index;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>补充</strong>:<strong>上面代码中为什么要转成char类型指针</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret = compare( (<span class="keyword">char</span>*)sorted+(middle * elemSize),search);</span><br></pre></td></tr></table></figure><p>什么类型的指针，增加偏移量的大小的是不同的。</p><p><strong>例如</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>*指针 +<span class="number">1</span>，内存偏移<span class="number">1</span>字节</span><br><span class="line"><span class="keyword">int</span>* 指针 +<span class="number">1</span>，内存偏移<span class="number">4</span>字节</span><br></pre></td></tr></table></figure><p>因为我们的运算加的是对应数组元素类型的大小*middle,求出偏移的字节个数，所以转成char类型指针，可以保证我们加了几个这个类型的大小等同于与数组第一个元素相距了几个元素，得到对应的地址。</p><p><strong>指针的运算！！！</strong></p><p>如下图所示，+1和+4，指向的是同一个地址。</p><p><img src="%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95.assets/image-20211028203724495.png" alt="image-20211028203724495"></p><hr><h2 id="穷举搜索"><a href="#穷举搜索" class="headerlink" title="穷举搜索"></a>穷举搜索</h2><blockquote><p>有 20 枚硬币，可能包括 4 种类型：1 元、5 角、1 角和 5 分。 </p><p>已知 20 枚硬币的总价值为 10 元，求各种硬币的数量。 </p><p>例如：4、11、5、0 就是一种方案。而 8、2、10、 0 是另一个可能的方案，显然方案并不是 </p><p>唯一的，请编写程序求出类似这样的不同的方案一共有多少种？ </p><p>（1）编程思路。 </p><p>直接对四种类型的硬币的个数进行穷举。其中，1 元最多 10 枚、5 角最多 20 枚、1 角最多 20 枚、5 分最多 20 枚。 </p><p>如果以元为单位，则 5 角、1 角、5 分会化成浮点型数据，容易计算出错。可以将 1 元、5 角、1 角、5 分变成 100 分、50 分、10 分和 5 分，从而全部采用整型数据处理。</p></blockquote><p><strong>代码实现</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a100 = <span class="number">0</span>;<span class="comment">//一元硬币的数量</span></span><br><span class="line"><span class="keyword">int</span> a50 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> a10 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> a5 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//可行方案总数</span></span><br><span class="line">    <span class="comment">//for循环可以进行优化，根据上一个纸币面额所花费钱的多少</span></span><br><span class="line"><span class="keyword">for</span> (a100 = <span class="number">0</span>; a100 &lt;= <span class="number">10</span>; a100++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (a50 = <span class="number">0</span>; a50 &lt;= <span class="number">20</span>; a50++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (a10 = <span class="number">0</span>; a10 &lt;= <span class="number">20</span>; a10++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (a5 = <span class="number">0</span>; a5 &lt;= <span class="number">20</span>; a5++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a100 * <span class="number">100</span> + a50 * <span class="number">50</span> + a10 * <span class="number">10</span> + a5 * <span class="number">5</span> == <span class="number">1000</span> &amp;&amp; (a100 + a50 + a10 + a5 == <span class="number">20</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a100:&quot;</span> &lt;&lt; a100 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="string">&quot;a50:&quot;</span> &lt;&lt; a50 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="string">&quot;a10:&quot;</span> &lt;&lt; a10 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="string">&quot;a5:&quot;</span> &lt;&lt; a5 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;一共有&quot;</span> &lt;&lt; count &lt;&lt; <span class="string">&quot;种可行方案&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>穷举法(枚举法)的基本思想是</strong>:列出所有的可能情况，逐个判断有哪些是符合问题所要求 的条件，从而得到问题的全部解答。</p><p>它利用计算机运算速度快、精确度高的特点，对要解决问题的所有可能情况，一个不漏地进行检查，从中找出符合要求的答案。</p><p><strong>用穷举法解决问题,通常可以从两个方面进行分析:</strong></p><blockquote><p>（1）问题所涉及的情况：问题所涉及的情况有哪些，情况的种数必须可以确定。把它描述出来。应用穷举时对问题所涉及的有限种情形必须一一列举，既不能重复，也不能遗漏。重复列 举直接引发增解，影响解的准确性；而列举的遗漏可能导致问题解的遗漏。 </p><p>（2）答案需要满足的条件：分析出来的这些情况，需要满足什么条件，才成为问题的答案。把这些条件描述出来。 </p></blockquote><h2 id="并行搜索"><a href="#并行搜索" class="headerlink" title="并行搜索"></a>并行搜索</h2><p><strong>并发的基本概念</strong>：<br>所谓并发就是在同一实体上的多个事件同时发生。并发编程是指在同一台计算机上”同时”处理多个任务。</p><p><strong>进程</strong>：</p><p>通常每个进程对应一个在运行中的执行程序，比如，QQ 和微信运行的时候，他们分别是不同的进程。</p><p>任一时刻，单个 CPU 一次只能运行一个进程，此时其他进程处于非运行状态。</p><p><strong>线程</strong>：</p><p>一个进程可以拥有多个线程，每个线程可以可以独立并行执行，多个线程共享同一进程的资源，受进程管理。</p><blockquote><p>要从一个无序数据集中进行搜索，我们可以将数据分成N个块，每块由一个线程来并行搜索。</p></blockquote><p><strong>代码实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST_SIZE (1024*1024*200)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUMBER 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">search</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span>* data;<span class="comment">//搜索的数据集</span></span><br><span class="line"><span class="keyword">size_t</span> start;<span class="comment">//搜索的开始位置</span></span><br><span class="line"><span class="keyword">size_t</span> end;<span class="comment">//搜索的结束位置</span></span><br><span class="line"><span class="keyword">size_t</span> count;<span class="comment">//搜索结果</span></span><br><span class="line">&#125;search;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(<span class="keyword">void</span>* lpParm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">search* s = (search*)lpParm;</span><br><span class="line"><span class="keyword">time_t</span> start, end;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;新的线程开始执行...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">time(&amp;start);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;<span class="number">10</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = s-&gt;start; i &lt;= s-&gt;end; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (s-&gt;data[i] == NUMBER)</span><br><span class="line">&#123;</span><br><span class="line">s-&gt;count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">time(&amp;end);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;进程所用时间:&quot;</span> &lt;&lt; end - start &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>* data = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">search s1, s2;</span><br><span class="line">data = <span class="keyword">new</span> <span class="keyword">int</span>[TEST_SIZE];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;TEST_SIZE; i++)</span><br><span class="line">&#123;</span><br><span class="line">data[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">mid = TEST_SIZE / <span class="number">2</span>;</span><br><span class="line">s1.data = data;</span><br><span class="line">s1.start = <span class="number">0</span>;</span><br><span class="line">s1.end = mid;</span><br><span class="line">s1.count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">s2.data = data;</span><br><span class="line">s2.start = mid + <span class="number">1</span>;</span><br><span class="line">s2.end = TEST_SIZE - <span class="number">1</span>;</span><br><span class="line">s2.count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DWORD threadID1;<span class="comment">//线程1的身份证</span></span><br><span class="line">HANDLE hthread1;<span class="comment">//线程1的句柄</span></span><br><span class="line">DWORD threadID2;<span class="comment">//线程2的身份证</span></span><br><span class="line">HANDLE hthread2;<span class="comment">//线程2的句柄</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建线程</span></span><br><span class="line">hthread1 = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc, &amp;s1, <span class="number">0</span>, &amp;threadID1);</span><br><span class="line">hthread2 = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc, &amp;s2, <span class="number">0</span>, &amp;threadID2);</span><br><span class="line"></span><br><span class="line">WaitForSingleObject(hthread1, INFINITE);</span><br><span class="line">WaitForSingleObject(hthread2, INFINITE);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1.count + s2.count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;查找算法&quot;&gt;&lt;a href=&quot;#查找算法&quot; class=&quot;headerlink&quot; title=&quot;查找算法&quot;&gt;&lt;/a&gt;查找算法&lt;/h1&gt;&lt;h2 id=&quot;查找的定义&quot;&gt;&lt;a href=&quot;#查找的定义&quot; class=&quot;headerlink&quot; title=&quot;查找的定义&quot;&gt;</summary>
      
    
    
    
    <category term="算法" scheme="http://zhaoyuxuan.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="-算法" scheme="http://zhaoyuxuan.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>不同指针的偏移量不同</title>
    <link href="http://zhaoyuxuan.xyz/2021/10/28/%E4%B8%8D%E5%90%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%81%8F%E7%A7%BB%E9%87%8F%E4%B8%8D%E5%90%8C/"/>
    <id>http://zhaoyuxuan.xyz/2021/10/28/%E4%B8%8D%E5%90%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%81%8F%E7%A7%BB%E9%87%8F%E4%B8%8D%E5%90%8C/</id>
    <published>2021-10-28T12:52:24.000Z</published>
    <updated>2021-10-28T12:54:23.166Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/4320f6444cac46528f82b567c60adc79.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARG8yZU0wTg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><strong>这里的偏移量我指的是对应指针+几，地址所偏移的长度。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/4320f6444cac46528f82b567c60adc79.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,sha</summary>
      
    
    
    
    <category term="C++" scheme="http://zhaoyuxuan.xyz/categories/C/"/>
    
    
    <category term="-指针" scheme="http://zhaoyuxuan.xyz/tags/%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>【算法】七大排序算法(汇总)</title>
    <link href="http://zhaoyuxuan.xyz/2021/10/25/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E4%B8%83%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://zhaoyuxuan.xyz/2021/10/25/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E4%B8%83%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2021-10-25T00:07:48.000Z</published>
    <updated>2021-10-25T00:12:24.878Z</updated>
    
    <content type="html"><![CDATA[<ol><li><a href="http://doraemon2.xyz/2021/10/24/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/">选择排序</a></li><li><a href="http://doraemon2.xyz/2021/10/24/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/">冒泡排序</a></li><li><a href="http://doraemon2.xyz/2021/10/24/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/">插入排序</a></li><li><a href="http://doraemon2.xyz/2021/10/24/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/">归并排序</a></li><li><a href="http://doraemon2.xyz/2021/10/24/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/">希尔排序</a></li><li><a href="http://doraemon2.xyz/2021/10/24/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%BF%AB%E9%80%9F%E7%AE%97%E6%B3%95/">快速排序</a></li></ol><hr><p><img src="https://img-blog.csdnimg.cn/fe2e642fff6d43f3b1e64e8594cd8820.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARG8yZU0wTg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://doraemon2.xyz/2021/10/24/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/&quot;&gt;选择排序&lt;/a&gt;&lt;/li&gt;
&lt;</summary>
      
    
    
    
    <category term="算法" scheme="http://zhaoyuxuan.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="-算法" scheme="http://zhaoyuxuan.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【算法】快速排序</title>
    <link href="http://zhaoyuxuan.xyz/2021/10/24/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://zhaoyuxuan.xyz/2021/10/24/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</id>
    <published>2021-10-24T13:40:40.000Z</published>
    <updated>2021-10-25T00:13:29.199Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p><strong>排序流程</strong>：</p><ol><li>每次选区第一个的数为基准数</li><li>然后将大于和小于基准的元素分别置于基准数两边</li><li>继续分别对基准数两侧未排序的数据使用分治法进行细分处理(<strong>分而治之</strong>)，直至整个序列有序。</li></ol><p><strong>如下图所示</strong>：<br><img src="https://img-blog.csdnimg.cn/278696f3f8d14844872ffdc45d328137.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARG8yZU0wTg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/ecc987fb68104b0395999135bda2e38e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARG8yZU0wTg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p><strong>代码实现</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">parttion</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = low;<span class="comment">//从左边开始</span></span><br><span class="line"><span class="keyword">int</span> j = high;<span class="comment">//从右边开始</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> base = arr[low];<span class="comment">//定左边第一个为基准书，拿出来之后，该位置就可以被覆盖了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果low就是最</span></span><br><span class="line"><span class="keyword">if</span> (low &lt; high)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//左找一个，右找一个......</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; j) <span class="comment">//i == j说明已经查找完毕</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= base)<span class="comment">//从右边开始遍历，比基准值大，不做改变，继续遍历，直到碰到比基准值小的</span></span><br><span class="line">&#123;</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i &lt; j)<span class="comment">//右边找到小于基数的数</span></span><br><span class="line">&#123;</span><br><span class="line">arr[i++] = arr[j];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt; base)<span class="comment">//从左边开始遍历，比基准值小，不做改变，继续遍历，直到碰到比基准值大的</span></span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i &lt; j)<span class="comment">//左边已经找到大于基数的数</span></span><br><span class="line">&#123;</span><br><span class="line">arr[j--] = arr[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找完毕</span></span><br><span class="line"><span class="comment">//将基准值放入它应该在的位置</span></span><br><span class="line">arr[i] = base;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回基准值位置</span></span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (low &lt; high)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> index = parttion(arr, low, high);<span class="comment">//寻找基准值，然后开始分而治之</span></span><br><span class="line"><span class="comment">//index这个位置的数已经是它该放的位置</span></span><br><span class="line">QuickSort(arr, low, index - <span class="number">1</span>);</span><br><span class="line">QuickSort(arr, index + <span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> len = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">QuickSort(arr, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">print(arr, len);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;快速排序&quot;&gt;&lt;a href=&quot;#快速排序&quot; class=&quot;headerlink&quot; title=&quot;快速排序&quot;&gt;&lt;/a&gt;快速排序&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;排序流程&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每次选区第一个的数为基准数&lt;/li&gt;
&lt;li&gt;然后将</summary>
      
    
    
    
    <category term="算法" scheme="http://zhaoyuxuan.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="-算法" scheme="http://zhaoyuxuan.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【算法】希尔排序</title>
    <link href="http://zhaoyuxuan.xyz/2021/10/24/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    <id>http://zhaoyuxuan.xyz/2021/10/24/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</id>
    <published>2021-10-24T10:16:03.000Z</published>
    <updated>2021-10-24T10:17:19.896Z</updated>
    
    <content type="html"><![CDATA[<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p><strong>插入排序的缺点</strong></p><blockquote><p>插入排序虽好，但在有些情况下是有很多缺点的，比如：</p><p>14,18,20,36,1,2</p><p>除了最后的两个元素，其他的已经有序了，而这两个几乎要移动前面所有的元素。 </p></blockquote><p><strong>引出希尔排序</strong></p><blockquote><p>希尔排序是希尔(Donald Shell)于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序。它与插入排序的不同之处在于，它会优化比较距离较远的元素。</p></blockquote><blockquote><p>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序，随着增量逐渐减少，每组包含的元素越来越多，当增量减至1时，所有的元素被分成1组，实际上等同于执行一次插入排序，算法终止。</p><p>(就是拆开分组进行排序，排完之后再合并在一起再排序一遍。如下图所示。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/df66993e673c43c5a2e8af0f23f48d01.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARG8yZU0wTg==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><p><strong>希尔排序的基本步骤</strong>：</p><ol><li>选择增量：gap  = length / 2,缩小增量：gap = gap /2 ;</li><li>增加序列：用序列表示增量的选择，{n/2,(n/2)/2,…1}</li><li>先将整个待排序的序列分割成若干子序列分别进行直接插入排序，具体算法描述：</li></ol><blockquote><p>选择一个增量序列t1,t2,……,tk,其中ti&gt;tj,tk = 1;</p><p>按增量序列个数k，对整个序列进行k趟排序。</p><p>每趟排序，根据对应的增量ti,将待排序分割成若若干长度为m的子序列，分别对各子表进行直接插入排序。</p></blockquote><p><strong>仅增量因子为1时，整个序列作为一个整体来处理， 表长度即为整个序列的长度。</strong></p><p><strong>代码实现</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span><span class="comment">//希尔排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> gap = len / <span class="number">2</span>;<span class="comment">//增量</span></span><br><span class="line"><span class="keyword">for</span> (; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> cur = arr[i];</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (j = i - gap; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; cur; j-= gap)</span><br><span class="line">&#123;</span><br><span class="line">arr[j + gap] = arr[j];</span><br><span class="line">&#125;</span><br><span class="line">arr[j+gap] = cur;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;希尔排序&quot;&gt;&lt;a href=&quot;#希尔排序&quot; class=&quot;headerlink&quot; title=&quot;希尔排序&quot;&gt;&lt;/a&gt;希尔排序&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;插入排序的缺点&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;插入排序虽好，但在有些情况下是有很</summary>
      
    
    
    
    <category term="算法" scheme="http://zhaoyuxuan.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="-算法" scheme="http://zhaoyuxuan.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【算法】归并排序</title>
    <link href="http://zhaoyuxuan.xyz/2021/10/24/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://zhaoyuxuan.xyz/2021/10/24/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</id>
    <published>2021-10-24T10:12:19.000Z</published>
    <updated>2021-10-25T00:13:41.654Z</updated>
    
    <content type="html"><![CDATA[<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><blockquote><p>当两组数据已经有序，我们可以通过以下方式让两组数据快速排序。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/6965e361e2c94eea8a854ab1fac2203b.png#pic_center" alt="在这里插入图片描述"></p><blockquote><p>依次从两组数据中取前面最小的元素放到新的数组中，然后再把新数组中有序的数据拷贝到原数组，完成排序。这就是归并思想。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/2372b520d62242fe997044e5059adda6.png#pic_center" alt="在这里插入图片描述"></p><p><strong>代码实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeAdd</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp[<span class="number">64</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> i = left;<span class="comment">//指向左边数组最小的元素位置</span></span><br><span class="line"><span class="keyword">int</span> j = mid;<span class="comment">//指向右边数最小的元素位置</span></span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;<span class="comment">//临时数组下标</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt; mid &amp;&amp; j &lt;= right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i] &lt; arr[j])</span><br><span class="line">&#123;</span><br><span class="line">temp[k++] = arr[i++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">temp[k++] = arr[j++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(i&lt; mid)</span><br><span class="line">&#123;</span><br><span class="line">temp[k++] = arr[i++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (j &lt;= right)</span><br><span class="line">&#123;</span><br><span class="line">temp[k++] = arr[j++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把temp中内容拷贝到</span></span><br><span class="line"><span class="built_in">memcpy</span>(arr + left, temp+left, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (right - left + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> len = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">int</span> mid = len / <span class="number">2</span>;</span><br><span class="line">mergeAdd(arr, <span class="number">0</span>,mid, len - <span class="number">1</span>);</span><br><span class="line">print(arr, len);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>当数据无序的时候，只用归并思想就无法实现排序了。</p><hr><p><strong>依靠这种思想</strong>，<strong>引出归并排序方法</strong>。</p><p>下面是一组待排序的数组。</p><p><img src="https://img-blog.csdnimg.cn/a6bf3fafd63643fda9d4e3064fddc925.png#pic_center" alt="在这里插入图片描述"></p><p>以中间为界，分为两个数组。</p><p><img src="https://img-blog.csdnimg.cn/d9c10c84a6e447b4bac649227d1b58ac.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARG8yZU0wTg==,size_15,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><p>再进行细分</p><p><img src="https://img-blog.csdnimg.cn/b6924faab106472fbca8c10acdccd0bc.png#pic_center" alt="在这里插入图片描述"></p><p>再分<br><img src="https://img-blog.csdnimg.cn/12aba38df6644dd0b1bfe3685d29a571.png#pic_center" alt="在这里插入图片描述"></p><p><strong>利用上面的归并思想将两个数组分别有序</strong></p><p>最后合并到一起。</p><p><strong>代码实现</strong>(分治法+归并思想)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//归并法，将两个有序的数组合并到一起</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeAdd</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right,<span class="keyword">int</span>* temp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = left;<span class="comment">//指向左边数组最小的元素位置</span></span><br><span class="line"><span class="keyword">int</span> j = mid;<span class="comment">//指向右边数最小的元素位置</span></span><br><span class="line"><span class="keyword">int</span> k = left;<span class="comment">//临时数组下标</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt; mid &amp;&amp; j &lt;= right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i] &lt; arr[j])</span><br><span class="line">&#123;</span><br><span class="line">temp[k++] = arr[i++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">temp[k++] = arr[j++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(i&lt; mid)</span><br><span class="line">&#123;</span><br><span class="line">temp[k++] = arr[i++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (j &lt;= right)</span><br><span class="line">&#123;</span><br><span class="line">temp[k++] = arr[j++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//排好序的存到原来的位置——分块排序时，对应位置的元素，分治归并后还放在对应的位置。</span></span><br><span class="line"><span class="built_in">memcpy</span>(arr + left, temp+left, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (right - left + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span>* temp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (left &lt; right)</span><br><span class="line">&#123;</span><br><span class="line">mid = left + (right - left) / <span class="number">2</span>;<span class="comment">//找中间值</span></span><br><span class="line">mergeSort(arr, left, mid, temp);</span><br><span class="line">mergeSort(arr, mid + <span class="number">1</span>, right, temp);</span><br><span class="line">mergeAdd(arr, left,mid+<span class="number">1</span>, right, temp);<span class="comment">//mid在整合的时候算在右边那半</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> len = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">int</span> mid = len / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span>* temp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">mergeSort(arr, <span class="number">0</span>, len - <span class="number">1</span>, temp);</span><br><span class="line">mergeAdd(arr, <span class="number">0</span>,mid, len - <span class="number">1</span>,temp);</span><br><span class="line">print(arr, len);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;归并排序&quot;&gt;&lt;a href=&quot;#归并排序&quot; class=&quot;headerlink&quot; title=&quot;归并排序&quot;&gt;&lt;/a&gt;归并排序&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;当两组数据已经有序，我们可以通过以下方式让两组数据快速排序。&lt;/p&gt;
&lt;/blockquote&gt;
</summary>
      
    
    
    
    <category term="算法" scheme="http://zhaoyuxuan.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="-算法" scheme="http://zhaoyuxuan.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【算法】插入排序</title>
    <link href="http://zhaoyuxuan.xyz/2021/10/24/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>http://zhaoyuxuan.xyz/2021/10/24/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</id>
    <published>2021-10-24T04:18:21.000Z</published>
    <updated>2021-10-24T04:26:39.768Z</updated>
    
    <content type="html"><![CDATA[<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p><strong>实现原理</strong></p><blockquote><p>插入排序的工作原理是通过构建有序序列，对于未排序的数据，在已排序的序列中从后向前扫描，找到相应的位置并插入。插入排序在实现上，通常采用in-place排序(即只需用到O(1)的额外空间的排序)，因而在从后向前扫描的过程中，需要反复把已排序的元素逐步向后挪位，为最新的元素提供插入空间。</p></blockquote><p><strong>排序流程</strong></p><blockquote><p>1.从第一个元素开始，该元素可以认为已经被排序。</p><p>2.取出下一个元素，在已经排序的元素序列中从后向前扫描。</p><p>3.如果该元素(已经排序)大于新元素，该元素移到下一位置。</p><p>重复步骤3，直到找到已排序的元素小于或等于新元素的位置。</p><p>4.将新元素插入到该位置。</p><p>重复2~4。    </p></blockquote><p><strong>类似于玩斗地主时，给你发完牌，理牌的过程。</strong></p><p><strong>代码实现</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;先取出第一个元素，已经有序了，从后面元素开始一个一个往里面插。</span><br><span class="line">void InsertSort(int* arr, int len)</span><br><span class="line">&#123;</span><br><span class="line">    int preIndex &#x3D; 0;&#x2F;&#x2F;前一个结点的下标</span><br><span class="line">    int cur &#x3D; 0;&#x2F;&#x2F;当前结点的值(要往前面插入的值)</span><br><span class="line">    for (int i &#x3D; 1; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        preIndex &#x3D; i - 1;</span><br><span class="line">        cur &#x3D; arr[i];</span><br><span class="line"></span><br><span class="line">        while (preIndex &gt;&#x3D; 0 &amp;&amp; arr[preIndex] &gt; cur)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[preIndex + 1] &#x3D; arr[preIndex];</span><br><span class="line">            preIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;已经找到了cur这个值应该放的位置</span><br><span class="line">        arr[preIndex+1] &#x3D; cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>动画图解</strong>： (实现代码不同，但是意思是相同的)<strong>图片掉了记得提醒我</strong>。</p><p><img src="http://doraemon2.xyz/images/%E6%8E%92%E5%BA%8F.assets/%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92.gif" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;插入排序&quot;&gt;&lt;a href=&quot;#插入排序&quot; class=&quot;headerlink&quot; title=&quot;插入排序&quot;&gt;&lt;/a&gt;插入排序&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;实现原理&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;插入排序的工作原理是通过构建有序序列，对</summary>
      
    
    
    
    <category term="算法" scheme="http://zhaoyuxuan.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="-算法" scheme="http://zhaoyuxuan.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【算法】冒泡排序</title>
    <link href="http://zhaoyuxuan.xyz/2021/10/24/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>http://zhaoyuxuan.xyz/2021/10/24/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</id>
    <published>2021-10-24T03:02:00.000Z</published>
    <updated>2021-10-24T04:29:54.053Z</updated>
    
    <content type="html"><![CDATA[<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p><strong>排序流程</strong></p><blockquote><p>通过重复地遍历排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复的地进行直到没有再需要交换，也就是或该数列已经排序完成。这个算法的名字由来是因为越小(大)的元素会经由交换慢慢的像泡泡一样“浮”到数列的顶端，故而得名。</p></blockquote><p><strong>代码实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PopSort1</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">bool</span> sorted = <span class="number">0</span>;<span class="comment">//判断循环是否进行元素的交换了</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])<span class="comment">//稳定的排序算法，相同值的数，不会进行交换</span></span><br><span class="line">&#123;</span><br><span class="line">sorted = <span class="number">1</span>;</span><br><span class="line">swap(arr[j], arr[j + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!sorted)<span class="comment">//本次循环没进行交换，说明排序已经完成，剩下还没进行的循环就不用进行了。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">print(arr, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PopSort2</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> end = len - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (end)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; end; i++)<span class="comment">//&lt;end,保证每次都能取到第i+1个</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">swap(arr[i], arr[i + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">end--;</span><br><span class="line">&#125;</span><br><span class="line">print(arr, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">266</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">78</span>,<span class="number">9</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> len = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">PopSort1(arr, len);</span><br><span class="line"><span class="comment">//PopSort2(arr, len);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;排序流程&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;通过重复地遍历排序的数列，一次比较两个元</summary>
      
    
    
    
    <category term="算法" scheme="http://zhaoyuxuan.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="-算法" scheme="http://zhaoyuxuan.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【算法】选择排序</title>
    <link href="http://zhaoyuxuan.xyz/2021/10/24/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <id>http://zhaoyuxuan.xyz/2021/10/24/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</id>
    <published>2021-10-24T02:19:14.000Z</published>
    <updated>2021-10-24T02:25:19.702Z</updated>
    
    <content type="html"><![CDATA[<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p><strong>实现流程</strong></p><blockquote><p>一串无序排列的数，选出最大(小)的数，与最后一个数交换位置，再在前面(除去选出的这个最大的数)选出一个最大的数与倒数第二个数交换，重复这个过程。</p></blockquote><p><strong>代码实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort1</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; len - i; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; arr[max])</span><br><span class="line">&#123;</span><br><span class="line">max = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果此时找到的最大的数的下标不是最后一个</span></span><br><span class="line"><span class="keyword">if</span> (max != len - i - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">swap(arr[len - i - <span class="number">1</span>], arr[max]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">print(arr, len);</span><br><span class="line"><span class="comment">//我不喜欢这种选择排序的写法，不够一目了然</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort2</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> end = len - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (end)</span><br><span class="line">&#123;</span><br><span class="line">max = <span class="number">0</span>;<span class="comment">//每次都以为第一个是最大的</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= end; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i] &gt; arr[max])<span class="comment">//大于号改小于号就变成递减了</span></span><br><span class="line">&#123;</span><br><span class="line">max = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (max != end)</span><br><span class="line">&#123;</span><br><span class="line">swap(arr[max], arr[end]);</span><br><span class="line">&#125;</span><br><span class="line">end--;</span><br><span class="line">&#125;</span><br><span class="line">print(arr, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tempArry[] = &#123; <span class="number">10</span>,<span class="number">22</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">87</span>,<span class="number">99</span>,<span class="number">12</span>,<span class="number">333</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> len = <span class="keyword">sizeof</span>(tempArry) / <span class="keyword">sizeof</span>(tempArry[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//SelectSort1(tempArry, len);</span></span><br><span class="line">SelectSort2(tempArry, len);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;选择排序&quot;&gt;&lt;a href=&quot;#选择排序&quot; class=&quot;headerlink&quot; title=&quot;选择排序&quot;&gt;&lt;/a&gt;选择排序&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;实现流程&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一串无序排列的数，选出最大(小)的数，与</summary>
      
    
    
    
    <category term="算法" scheme="http://zhaoyuxuan.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="-算法" scheme="http://zhaoyuxuan.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【算法】分支定界算法</title>
    <link href="http://zhaoyuxuan.xyz/2021/10/23/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%88%86%E6%94%AF%E5%AE%9A%E7%95%8C%E7%AE%97%E6%B3%95/"/>
    <id>http://zhaoyuxuan.xyz/2021/10/23/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%88%86%E6%94%AF%E5%AE%9A%E7%95%8C%E7%AE%97%E6%B3%95/</id>
    <published>2021-10-23T13:11:39.000Z</published>
    <updated>2021-10-23T13:12:34.522Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分支定界算法"><a href="#分支定界算法" class="headerlink" title="分支定界算法"></a>分支定界算法</h1><p><strong>概念</strong></p><blockquote><p>分支定界(branch and bound)算法是一种在问题的解空间上搜索问题的解的方法。但与回溯算法不同，分支定界算法采用广度优先或最小耗费优先的方法搜索解空间树。并且，在分支定界算法中，每一个活结点只有一次机会称为扩展结点。</p></blockquote><p>​    <strong>利用分支定界算法对问题的解空间树进行搜索</strong>，<strong>它的搜索策略是</strong>：</p><ol><li>产生当前扩展结点的所有孩子结点。</li><li>在产生的孩子结点中，抛弃那些不可能产生可行解(或)最优解的结点。</li><li>将其余的孩子结点加入活结点表。</li><li>从活结点表中选择下一个活结点作为新的扩展结点。</li></ol><p>如此循环，直到找到问题的可行解(最优解)或活结点表为空。</p><p>从活结点表中选择下一个活结点作为新的扩展结点，<strong>根据选择的方式不同</strong>，分支定界算法通常可以分为两种形式。</p><ol><li>FIFO(First In First Out) 分支定界算法：按照先进先出原则选择下一个活结点作为扩展结点，即从活结点表中取出结点的顺序与加入结点的顺序相同。</li><li><strong>最小耗费或最大收益分支定界算法</strong>：在这种情况下，每个结点都有一个耗费或收益。假如要查找一个具有最小耗费的解，那么要<strong>选择</strong>的下一个扩展结点就是活结点表中具有最小耗费的活结点，假如要查找一个具有最大收益的解，那么要<strong>选择</strong>的下一个扩展结点就是活结点表中具有最大收益的活结点。</li></ol><hr><p><strong>补充</strong>: A *算法（最小消耗优先法搜索解空间树）(未完待续……)</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分支定界算法&quot;&gt;&lt;a href=&quot;#分支定界算法&quot; class=&quot;headerlink&quot; title=&quot;分支定界算法&quot;&gt;&lt;/a&gt;分支定界算法&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;概念&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;分支定界(branch an</summary>
      
    
    
    
    <category term="算法" scheme="http://zhaoyuxuan.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="-C++" scheme="http://zhaoyuxuan.xyz/tags/C/"/>
    
    <category term="-算法" scheme="http://zhaoyuxuan.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【算法】贪心算法</title>
    <link href="http://zhaoyuxuan.xyz/2021/10/23/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    <id>http://zhaoyuxuan.xyz/2021/10/23/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</id>
    <published>2021-10-23T12:27:16.000Z</published>
    <updated>2021-10-23T13:23:43.475Z</updated>
    
    <content type="html"><![CDATA[<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><p><strong>概念解释</strong></p><blockquote><p>贪婪算法(贪心算法)是指在对问题求解的时候，每一步选择都采用最好或者最优(即最有利)的选择，从而希望能够导致结果是最好或者最优的算法。    </p><p>贪心算法所得到的结果往往不是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果。</p><p>贪心算法并没有固定的解发框架，算法的关键是贪心策略的选择，根据不用问题选择不同的策略。</p></blockquote><p><strong>基本思路</strong></p><ul><li>建立数学模型描述问题</li><li>把求解的问题分为若干个子问题</li><li>对每一个子问题求解，得到子问题的局部最优解</li><li>把子问题对应的局部最优解合成原来整个问题的一个<strong>近似</strong>最优解。</li></ul><p><strong>例题</strong>：</p><blockquote><p>《钱币找零问题》</p><p>假设1元、2元、5元、10元、20元、50元、100元的纸币分别有c0,c1,c2,c3,c4,c5,c6张。现在要用这些钱来支付K元，最少要用多少张纸币？</p></blockquote><p><strong>解题思路</strong>：</p><blockquote><p>用贪心算法的思想，每一步都用能用的最大纸币即可。</p></blockquote><p><strong>代码实现</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 7</span></span><br><span class="line"><span class="comment">//有的零钱面值</span></span><br><span class="line"><span class="keyword">int</span> value[N] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">20</span>,<span class="number">50</span>,<span class="number">100</span> &#125;;</span><br><span class="line"><span class="comment">//对应零钱的张数</span></span><br><span class="line"><span class="keyword">int</span> Vcount[N] = &#123; <span class="number">10</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> money)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> j = money / value[i];<span class="comment">//从最大面值开始，尽可能地用最大面值先支付，看看用几张</span></span><br><span class="line"><span class="keyword">int</span> c = j &gt; Vcount[i]?Vcount[i]:j;<span class="comment">//看看有的张数够不够，够就用j，不够就用有的最大数量Vconut[i]</span></span><br><span class="line"><span class="keyword">if</span> (j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;使用了&quot;</span> &lt;&lt; c &lt;&lt; <span class="string">&quot;张&quot;</span> &lt;&lt; value[i] &lt;&lt; <span class="string">&quot;的&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">money -= c * value[i];</span><br><span class="line">num += c;</span><br><span class="line"><span class="keyword">if</span> (money == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (money &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//说明钱不够</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> money = <span class="number">0</span>;<span class="comment">//钱</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;<span class="comment">//张数</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入要支付的价格&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; money;</span><br><span class="line">num = solve(money);</span><br><span class="line"><span class="keyword">if</span> (num != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;最少要用&quot;</span> &lt;&lt; num &lt;&lt; <span class="string">&quot;张&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;前不够&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>但是</strong>，当我们只有1张50的和3张20的时候，money定位60块钱就会出现问题。 会提示找不开，这种情况下我们使用贪心算法得到的答案就不是最优解，因为我们一直在尝试用最大的纸币来尽可能的使用最少的张数来解决问题。这就不是最优的。</p><p>贪心算法没有固定的框架，关键是看你怎么<strong>选择</strong>。这种情况就需要调整策略，甚至，就不适用贪心算法。</p><p>贪心算法是尽力找到<strong>近似的最优解</strong>，注重的是速度，不是精准度，并不是说一定能找到合适的解,或是一定能找到解 。</p><p><strong>对应问题根据情况不同选择合适的算法解决</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;贪心算法&quot;&gt;&lt;a href=&quot;#贪心算法&quot; class=&quot;headerlink&quot; title=&quot;贪心算法&quot;&gt;&lt;/a&gt;贪心算法&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;概念解释&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;贪婪算法(贪心算法)是指在对问题求解的时</summary>
      
    
    
    
    <category term="算法" scheme="http://zhaoyuxuan.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="-C++" scheme="http://zhaoyuxuan.xyz/tags/C/"/>
    
    <category term="-算法" scheme="http://zhaoyuxuan.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【算法】回溯法</title>
    <link href="http://zhaoyuxuan.xyz/2021/10/23/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    <id>http://zhaoyuxuan.xyz/2021/10/23/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%9B%9E%E6%BA%AF%E6%B3%95/</id>
    <published>2021-10-23T10:01:31.000Z</published>
    <updated>2021-10-23T13:23:31.413Z</updated>
    
    <content type="html"><![CDATA[<h1 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h1><p> <strong>回溯的基本原理</strong></p><blockquote><p>在问题的解空间中，按深度优先遍历策略，从根节点出发搜索解空间树。算法搜索至解空间 的任意一个节点时，先判断该节点是否包含问题的解。如果确定不包含，跳过对以该节点为根的 子树的搜索，逐层向其祖先节点回溯，否则进入该子树，继续深度优先搜索。 </p></blockquote><blockquote><p>回溯法解问题的所有解时，必须回溯到根节点，且根节点的所有子树都被搜索后才结束。</p><p>回溯法解问题的一个解时，只要搜索到问题的一个解就可结束。 </p></blockquote><p><strong>回溯的基本步骤</strong></p><ol><li>定义问题的解空间(我理解的解空间就是目标问题的内容，或者说是目标问题解的集合。)</li><li>确定易于搜索的解空间结构</li><li>以<strong>深度优先搜索</strong>的策略搜索解空间，并在搜索过程中尽可能避免无效搜索</li></ol><p><strong>例题</strong></p><blockquote><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了 矩阵的某一格，那么该路径不能再次进入该格子。例如在下面的 3×4 的矩阵中包含一条字符串 “bfce”的路径（路径中的字母用下划线标出）。但矩阵中不包含字符串“abfb”的路径，因为 字符串的第一个字符 b 占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。 </p><p>A B T G </p><p>C F C S </p><p>J D E H        </p></blockquote><p><strong>代码实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//探测下一个字符是否存在</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasPathCore</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* matirix,<span class="keyword">int</span> rows,<span class="keyword">int</span> cols,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> row,<span class="keyword">int</span> col, <span class="keyword">const</span> <span class="keyword">char</span>* str,<span class="keyword">int</span>&amp; pathLength,<span class="keyword">bool</span>* visited)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//已经到达字符串结束符,说明前面已经判断完成</span></span><br><span class="line"><span class="keyword">if</span> (str[pathLength] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> haspath = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断当前该点是否合法</span></span><br><span class="line"><span class="comment">//在矩阵内 &amp; 是指定内容(内容) &amp; 没被访问过</span></span><br><span class="line"><span class="keyword">if</span> (row &gt;= <span class="number">0</span> &amp;&amp; row &lt; rows &amp;&amp; col &gt;= <span class="number">0</span> </span><br><span class="line">&amp;&amp; col &lt; cols &amp;&amp; matirix[row * cols + col ]== str[pathLength]  </span><br><span class="line">&amp;&amp; !visited[row * cols + col])</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//进入到这里说明当前位置的字符串符合目标str的第几个，判断下一个是否也符合</span></span><br><span class="line"><span class="comment">//str索引++</span></span><br><span class="line">pathLength++;</span><br><span class="line"><span class="comment">//当前结点设置被访问过</span></span><br><span class="line">visited[row * col + col] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//递归实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">就是说，选择了一个点，如果周围的周围的周围.......符合，</span></span><br><span class="line"><span class="comment">也就是说着条路能走通，会一路到return true(str结尾——str[pathLength] == &#x27;\0&#x27;),</span></span><br><span class="line"><span class="comment">然后逐层通过return haspath(1)返回到调用处，</span></span><br><span class="line"><span class="comment">最后再return haspath(1),回到一开始调用该函数的位置，即hasPath中的调用处，</span></span><br><span class="line"><span class="comment">成功找到路径。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//向四周判断</span></span><br><span class="line"><span class="comment">//看有没有符合的点</span></span><br><span class="line">haspath = hasPathCore(matirix, rows, cols, row, col - <span class="number">1</span>, str, pathLength, visited)</span><br><span class="line">|| hasPathCore(matirix, rows, cols, row - <span class="number">1</span>, col, str, pathLength, visited)</span><br><span class="line">|| hasPathCore(matirix, rows, cols, row, col + <span class="number">1</span>, str, pathLength, visited)</span><br><span class="line">|| hasPathCore(matirix, rows, cols, row + <span class="number">1</span>, col, str, pathLength, visited);</span><br><span class="line"><span class="comment">//有一个符合条件即可</span></span><br><span class="line"><span class="keyword">if</span> (!haspath)<span class="comment">//如果一个符合的点都没有</span></span><br><span class="line">&#123;</span><br><span class="line">--pathLength;<span class="comment">//str索引回退，</span></span><br><span class="line">visited[row * cols * +col] = <span class="number">0</span>;<span class="comment">//当前结点周围走不通，标记为未访问，判断其他(方向)的点。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> haspath;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主体实现流程</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* matirix,<span class="keyword">int</span> rows,<span class="keyword">int</span> cols,<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//参数错误</span></span><br><span class="line"><span class="keyword">if</span> (!matirix || rows &lt;= <span class="number">0</span> || cols &lt;= <span class="number">0</span> || !str)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//bool值矩阵，大小同给定的字符矩阵，标记该位置是否走过</span></span><br><span class="line"><span class="keyword">bool</span>* visited = <span class="keyword">new</span> <span class="keyword">bool</span>[cols * rows];</span><br><span class="line"><span class="built_in">memset</span>(visited, <span class="number">0</span>, cols * rows);<span class="comment">//初始化为0，未访问过</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pathLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历矩阵中的每一个点，分别从该点开始出发，判断路径</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; rows; row++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; cols; col++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (hasPathCore(matirix, rows,cols, row, col, str, pathLength, visited))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] visited;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通用单元测试代码(便于多种情况测试)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* TestTitle, <span class="keyword">const</span> <span class="keyword">char</span>* dest,<span class="keyword">const</span> <span class="keyword">char</span>* str,<span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">bool</span> HopeResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;预计结果为&quot;</span> &lt;&lt; HopeResult &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (hasPath(dest, rows, cols, str) == HopeResult)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; TestTitle &lt;&lt; <span class="string">&quot;与预计结果相同&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; TestTitle &lt;&lt; <span class="string">&quot;与预计结果不同&quot;</span> &lt;&lt;  <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&quot;ABTG</span></span><br><span class="line"><span class="comment"> CFCS</span></span><br><span class="line"><span class="comment"> JDEH&quot;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* TestTitle = <span class="string">&quot;测试1&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* dest = <span class="string">&quot;ABTGCFCSJDEH&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* str = <span class="string">&quot;BFCEH&quot;</span>;</span><br><span class="line">Test(TestTitle, dest, str, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>小结</strong></p><blockquote><p>我理解的回溯法就是深度优先搜索的应用，深度优先搜索就是，一个问题的解决路径有多个岔路口，选择其中的一个一直走到底，找到最终解就return true,不行就回退，判断下一个岔路口，直到找到解，否则一直找不到就return了false。</p><p>而广度优先算法就是，同时选择多个岔路口，从一边开始，<strong>逐层判断</strong>，它们是否能够走通(找到解)。</p><p>以起点开始辐射式的开始遍历(逐层)。感谢这位up主的分享——<a href="https://www.bilibili.com/video/BV1CK4y1w7kA?from=search&seid=17169777033220611310&spm_id_from=333.337.0.0">相关视频</a>。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;回溯法&quot;&gt;&lt;a href=&quot;#回溯法&quot; class=&quot;headerlink&quot; title=&quot;回溯法&quot;&gt;&lt;/a&gt;回溯法&lt;/h1&gt;&lt;p&gt; &lt;strong&gt;回溯的基本原理&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在问题的解空间中，按深度优先遍历策略，从</summary>
      
    
    
    
    <category term="算法" scheme="http://zhaoyuxuan.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="-C++" scheme="http://zhaoyuxuan.xyz/tags/C/"/>
    
    <category term="-算法" scheme="http://zhaoyuxuan.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【算法】动态规划算法</title>
    <link href="http://zhaoyuxuan.xyz/2021/10/23/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95/"/>
    <id>http://zhaoyuxuan.xyz/2021/10/23/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95/</id>
    <published>2021-10-23T02:07:30.000Z</published>
    <updated>2021-10-23T13:24:07.130Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态规划算法"><a href="#动态规划算法" class="headerlink" title="动态规划算法"></a>动态规划算法</h1><p><strong>例</strong>：</p><blockquote><p>走楼梯，可以一次上一阶，也可以，一次上两阶，根据楼梯的阶数来判断有几种上楼梯的方法。</p></blockquote><p><strong>分析</strong>：</p><blockquote><p>f(1) = 1; 1种</p><p>f(2) = 2; 2种</p><p>f(3) = f(1) + f(2);3种</p><p>f(4) = f(3) + f(2) ;5种</p><p>…</p><p>依次类推</p></blockquote><p><strong>代码如下</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WalkCount</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//可以一次走一阶台阶，也可以一次走两阶台阶</span></span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> WalkCount(n<span class="number">-1</span>)+WalkCount(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; WalkCount(<span class="number">45</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>我们发现，当楼梯结束过大的时，会因为内存消耗过大而发生栈溢出。</strong></p><p>因为调用了大量重复的函数，将栈消耗光了。</p><hr><p><strong>解决办法</strong>:避免重复计算的部分，将重复计算的值保存下来。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span>  <span class="title">WalkCount</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span>  ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> * value = <span class="keyword">new</span> <span class="keyword">long</span> <span class="keyword">long</span>[n + <span class="number">1</span>];<span class="comment">//索引从0开始</span></span><br><span class="line">value[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">value[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">value[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">value[i] = value[i - <span class="number">1</span>] + value[i - <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = value[n];</span><br><span class="line"><span class="keyword">delete</span> value;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>动态规划算法也是一种分治的思想</strong>。</p><blockquote><p>分治算法是把原问题分解为若干子问题，自顶向下，求解子问题，合并子问题的解从而得到原问题的解。</p><p>动态规划也是自顶向下把原问题分解为若干子问题，<strong>不同的是</strong>，<strong>然后</strong>，自底向上，先求解最小的子问题，把结果存储在表格中，在求解大的子问题时，直接从表格中查询小的子问题的解 ，避免重复计算，从而提高了算法效率。</p><p>（就是定义了一个数组存储之前得到的内容，累加到传进来的对应值。）</p></blockquote><p> <strong>什么时候使用动态规划算法</strong>？</p><blockquote><p>如果要求一个问题的最优解(通常是最大值或者最小值)，而且该问题能能够分解为若干子问题，并且小问题之间也存在 重叠的子问题，则考虑使用动态规划。</p></blockquote><p><strong>怎么使用动态规划</strong>？</p><p>五部曲</p><ol><li>判断题意是否找出一个问题的最优解。</li><li>从上往下分析问题，大问题可以分解为子问题，子问题中还有更小的问题。</li><li>从下网上分析问题，找出这些问题之间的关联(<a href="https://baike.baidu.com/item/%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B/7359039#:~:text=%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B%EF%BC%8C%E6%98%AF%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%AD%E6%9C%AC%E9%98%B6%E6%AE%B5%E7%9A%84%E7%8A%B6%E6%80%81%E5%BE%80%E5%BE%80%E6%98%AF%E4%B8%8A%E4%B8%80%E9%98%B6%E6%AE%B5%E7%8A%B6%E6%80%81%E5%92%8C%E4%B8%8A%E4%B8%80%E9%98%B6%E6%AE%B5%E5%86%B3%E7%AD%96%E7%9A%84%E7%BB%93%E6%9E%9C%E3%80%82%20%E5%A6%82%E6%9E%9C%E7%BB%99%E5%AE%9A%E4%BA%86%E7%AC%ACK%E9%98%B6%E6%AE%B5%E7%9A%84%E7%8A%B6%E6%80%81S%20k%20%E4%BB%A5%E5%8F%8A%E5%86%B3%E7%AD%96u,k%20%28S%20k%29%EF%BC%8C%E5%88%99%E7%AC%ACK%2B1%E9%98%B6%E6%AE%B5%E7%9A%84%E7%8A%B6%E6%80%81S%20k%2B1%20%E4%B9%9F%E5%B0%B1%E5%AE%8C%E5%85%A8%E7%A1%AE%E5%AE%9A%E3%80%82">状态转移方程</a>)。</li><li>讨论底层的边界问题。</li><li>解决问题(通常使用数组进行迭代求出最优解)</li></ol><p><strong>练习</strong></p><blockquote><p>给定一根线段，长为n,分成m段，最大的乘积是多少？</p><p>例如:长为10，最大分为3*4 *2 = 36</p><p>感谢这位老哥分享思路<a href="https://blog.csdn.net/scarificed/article/details/120315147?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0.no_search_link&spm=1001.2101.3001.4242.0">剑指offer–剪绳子（动态规划+贪心算法）详解</a></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传进来的是绳子的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CutRope</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//动态开辟数组</span></span><br><span class="line"><span class="keyword">int</span>* temp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];<span class="comment">//数组索引从0开始</span></span><br><span class="line"><span class="comment">//绳子多长(n多大),对应分割的最大乘积就存在数组对应下标所指向的值temp[n]</span></span><br><span class="line">temp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">temp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">temp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">temp[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我们不需要去考虑到底要分割成多少段求出来的乘积才是最大的，</span></span><br><span class="line"><span class="comment">每次分割成都两段，这两段的乘积最大值已经在之前求出来并且存到了temp中对应的位置上了，</span></span><br><span class="line"><span class="comment">我们只需要对比这几种分割(分成两段的不同情况，这两段最大的乘积都是多少)选出最大的，</span></span><br><span class="line"><span class="comment">放到该长度n，在temp数组中的位置即可。</span></span><br><span class="line"><span class="comment">例： 4 可以分为1 3，2 2 ，3 1 </span></span><br><span class="line"><span class="comment">1、2、3分成的乘积最大值，在之前已经求出来了，最需要分成这两种的乘积即可。</span></span><br><span class="line"><span class="comment">3 4 3 最大为 4 ，存进temp[4] = 4;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> max = <span class="number">0</span>;<span class="comment">//保存当前长度乘积最大的。</span></span><br><span class="line"><span class="comment">//循环计算出最大的</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i / <span class="number">2</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (max &lt; temp[j] * temp[i - j])</span><br><span class="line">&#123;</span><br><span class="line">max = temp[j] * temp[i - j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">temp[n] = max;</span><br><span class="line">&#125;</span><br><span class="line">result = temp[n];</span><br><span class="line"><span class="keyword">delete</span> temp;</span><br><span class="line"><span class="keyword">return</span>  result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;动态规划算法&quot;&gt;&lt;a href=&quot;#动态规划算法&quot; class=&quot;headerlink&quot; title=&quot;动态规划算法&quot;&gt;&lt;/a&gt;动态规划算法&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;例&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;走楼梯，可以一次上一阶，也可</summary>
      
    
    
    
    <category term="算法" scheme="http://zhaoyuxuan.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="-C++" scheme="http://zhaoyuxuan.xyz/tags/C/"/>
    
    <category term="-算法" scheme="http://zhaoyuxuan.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【单链表】一元多项式求和(C++)</title>
    <link href="http://zhaoyuxuan.xyz/2021/10/22/%E3%80%90%E5%8D%95%E9%93%BE%E8%A1%A8%E3%80%91%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E5%92%8C(C++)/"/>
    <id>http://zhaoyuxuan.xyz/2021/10/22/%E3%80%90%E5%8D%95%E9%93%BE%E8%A1%A8%E3%80%91%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E5%92%8C(C++)/</id>
    <published>2021-10-22T10:53:49.000Z</published>
    <updated>2021-10-22T10:59:24.482Z</updated>
    
    <content type="html"><![CDATA[<h1 id="要求-amp-amp-实现流程"><a href="#要求-amp-amp-实现流程" class="headerlink" title="要求&amp;&amp;实现流程"></a>要求&amp;&amp;实现流程</h1><p><img src="https://img-blog.csdnimg.cn/48da2cf0fa54459fbd0c22dfabf67cc0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARG8yZU0wTg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/c92c9508032942d391b3dabd073c73cc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARG8yZU0wTg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/30d5b1e8faa84e4984621d7438546260.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARG8yZU0wTg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/d8e23e4090ed4c20aa387b329215d24e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARG8yZU0wTg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/60d224e997fa4a12a24ab1eddefc8c16.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARG8yZU0wTg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> cofe;<span class="comment">//系数</span></span><br><span class="line"><span class="keyword">int</span>  <span class="built_in">exp</span>;<span class="comment">//次方</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;LinkList,LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initLinkList</span><span class="params">(LinkList*&amp; L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">L = <span class="keyword">new</span> LinkList;</span><br><span class="line">L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//尾插</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkPushBack</span><span class="params">(LinkList* L, <span class="keyword">int</span> _cofe, <span class="keyword">int</span> _exp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LinkNode* node = <span class="keyword">new</span> LinkNode;</span><br><span class="line">node-&gt;cofe = _cofe;</span><br><span class="line">node-&gt;<span class="built_in">exp</span> = _exp;</span><br><span class="line"></span><br><span class="line">LinkNode* temp = L;</span><br><span class="line"><span class="keyword">while</span> (temp-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">temp-&gt;next = node;</span><br><span class="line">node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inputPoly</span><span class="params">(LinkList* L1, LinkList* L2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//系数，次方</span></span><br><span class="line"><span class="keyword">int</span> l1cofe = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> l2cofe = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> l1exp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> l2exp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//几项式</span></span><br><span class="line"><span class="keyword">int</span> l1num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> l2num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;第一个多项式有几项?&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; l1num;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l1num; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入第&quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;项的系数:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; l1cofe;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入第&quot;</span> &lt;&lt; i+<span class="number">1</span> &lt;&lt; <span class="string">&quot;项的次方:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; l1exp;</span><br><span class="line">LinkPushBack(L1, l1cofe, l1exp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;第一个多项式输入完毕!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;第二个多项式有几项?&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; l2num;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l2num; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入第&quot;</span> &lt;&lt; i+<span class="number">1</span>&lt;&lt; <span class="string">&quot;项的系数:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; l2cofe;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入第&quot;</span> &lt;&lt; i+<span class="number">1</span> &lt;&lt; <span class="string">&quot;项的次方:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; l2exp;</span><br><span class="line">LinkPushBack(L2, l2cofe, l2exp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;第二个多项式输入完毕！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;多项式输入完毕!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多项式求和运算</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sumList</span><span class="params">(LinkList* L1, LinkList* L2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LinkNode* p = L1-&gt;next;<span class="comment">//p为结果链表</span></span><br><span class="line">LinkNode* q = L2-&gt;next;</span><br><span class="line">LinkNode* pFront = L1;</span><br><span class="line">LinkNode* qFront = L2;</span><br><span class="line"><span class="comment">//cofe系数</span></span><br><span class="line"><span class="comment">//exp次方</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (q &amp;&amp; p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;<span class="built_in">exp</span> == q-&gt;<span class="built_in">exp</span>)<span class="comment">//是同类项，可以合并，结果合并到p中</span></span><br><span class="line">&#123;</span><br><span class="line">p-&gt;cofe += q-&gt;cofe;</span><br><span class="line">LinkNode* temp = <span class="keyword">new</span> LinkNode;</span><br><span class="line"><span class="comment">//删除q的结点</span></span><br><span class="line">temp = q;</span><br><span class="line">qFront-&gt;next = temp-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> temp;</span><br><span class="line"></span><br><span class="line"><span class="comment">//工作指针后移</span></span><br><span class="line">pFront = p;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line"></span><br><span class="line">q = qFront-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;<span class="built_in">exp</span> &lt; q-&gt;<span class="built_in">exp</span>)<span class="comment">//结果链表对应次方比q链表对应结点次方小，结果链表中工作指针后移</span></span><br><span class="line">&#123;</span><br><span class="line">pFront = p;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;<span class="built_in">exp</span> &gt; q-&gt;<span class="built_in">exp</span>)<span class="comment">//结果链表对应次方比q链表对应结点次方大，q对应结点插过来。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//将这个结点插入到结果结点中</span></span><br><span class="line"></span><br><span class="line">qFront-&gt;next = q-&gt;next;</span><br><span class="line">pFront-&gt;next = q;</span><br><span class="line">q-&gt;next = p;</span><br><span class="line"></span><br><span class="line">q = qFront-&gt;next;<span class="comment">//重新回到对应链表</span></span><br><span class="line"><span class="comment">//结果链表的前指针后移</span></span><br><span class="line">pFront = pFront-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果多项式L2的长度大于L1的，此时结束时，L2还有没遍历到的结点，次方大于L1所有的结点，直接插入到结果链表(L1)尾部</span></span><br><span class="line"><span class="keyword">if</span> (q)<span class="comment">//加个判断条件防止，L1最后一个项，系数大于L2的，也进入下面这个循环</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (q)</span><br><span class="line">&#123;</span><br><span class="line">pFront-&gt;next = q;</span><br><span class="line">pFront = pFront-&gt;next;</span><br><span class="line">q = q-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">pFront-&gt;next = <span class="literal">NULL</span>;<span class="comment">//链接完成后尾结点next域置空</span></span><br><span class="line">&#125;</span><br><span class="line">L2-&gt;next = <span class="literal">NULL</span>;<span class="comment">//到达这里，L2除了head结点之外，后面的就算有内容也不属于它了。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;相加结果为:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">L1 = L1-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (L1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; L1-&gt;cofe &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; L1-&gt;<span class="built_in">exp</span> &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">L1 = L1-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//销毁链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destoryLink</span><span class="params">(LinkNode*&amp; L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LinkNode* tempNode = L;</span><br><span class="line"><span class="keyword">while</span> (tempNode)</span><br><span class="line">&#123;</span><br><span class="line">L = L-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> tempNode;</span><br><span class="line">tempNode = L;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LinkList* L1;</span><br><span class="line">LinkList* L2;</span><br><span class="line">initLinkList(L1);</span><br><span class="line">initLinkList(L2);</span><br><span class="line"></span><br><span class="line">inputPoly(L1, L2);</span><br><span class="line">sumList(L1, L2) ;</span><br><span class="line"></span><br><span class="line">destoryLink(L1);</span><br><span class="line">destoryLink(L2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：<br><img src="https://img-blog.csdnimg.cn/7fa18aa10d1f4428aeeab48bd5c7d85d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARG8yZU0wTg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;要求-amp-amp-实现流程&quot;&gt;&lt;a href=&quot;#要求-amp-amp-实现流程&quot; class=&quot;headerlink&quot; title=&quot;要求&amp;amp;&amp;amp;实现流程&quot;&gt;&lt;/a&gt;要求&amp;amp;&amp;amp;实现流程&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https:</summary>
      
    
    
    
    <category term="算法" scheme="http://zhaoyuxuan.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="-C++" scheme="http://zhaoyuxuan.xyz/tags/C/"/>
    
    <category term="-算法" scheme="http://zhaoyuxuan.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="-数据结构" scheme="http://zhaoyuxuan.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="-链表" scheme="http://zhaoyuxuan.xyz/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>【算法】分治算法</title>
    <link href="http://zhaoyuxuan.xyz/2021/10/22/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/"/>
    <id>http://zhaoyuxuan.xyz/2021/10/22/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/</id>
    <published>2021-10-22T08:42:18.000Z</published>
    <updated>2021-10-23T13:23:10.207Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h1><blockquote><p>将一个规模为N的问题分解为k个较小的子问题，这些子问题遵循的处理方式就是互相独立且与原问题相同。</p></blockquote><p><strong>两部分组成</strong>：</p><ul><li>分(divide):递归解决较小的问题。</li><li>治(conquer):然后从子问题的解构建原问题的解。</li></ul><p><strong>三个步骤</strong>：</p><ol><li>分解(divide):将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题。</li><li>解决(conquer):若干子问题规模较小而容易被解决则直接解决，否则递归解决各个子问题。</li><li>合并(Combine):将各个子问题的解合并为原问题的解。</li></ol><p><strong>递归实现二分查找</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归实现二分查找</span></span><br><span class="line"><span class="comment">//找到这个值最后一级一级的传递return回来</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">int</span> minSub,<span class="keyword">int</span> maxSub,<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minSub &gt; maxSub)<span class="comment">//无解</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (minSub + maxSub) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (num == arr[mid])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(num &lt; arr[mid])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//因为中间数据arr[mid]大于num,所以新的范围从minSub到mid-1</span></span><br><span class="line">        <span class="keyword">return</span> BinarySearch(arr, minSub, mid - <span class="number">1</span>, num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//num &gt; arr[mid]</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//因为num大于中间数据arr[mid],所以新的范围从mid+1到maxSub</span></span><br><span class="line">        <span class="keyword">return</span> BinarySearch(arr, mid + <span class="number">1</span>, maxSub, num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123; <span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">17</span>,<span class="number">23</span>,<span class="number">48</span>,<span class="number">55</span>,<span class="number">64</span> &#125;;</span><br><span class="line">    <span class="comment">//数组-起始位置(数组索引范围)-要查找的值</span></span><br><span class="line">    <span class="keyword">int</span> index = BinarySearch(arr,<span class="number">0</span>,<span class="number">8</span>,<span class="number">64</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; index &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分治算法&quot;&gt;&lt;a href=&quot;#分治算法&quot; class=&quot;headerlink&quot; title=&quot;分治算法&quot;&gt;&lt;/a&gt;分治算法&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;将一个规模为N的问题分解为k个较小的子问题，这些子问题遵循的处理方式就是互相独立且与原问题相同。&lt;</summary>
      
    
    
    
    <category term="算法" scheme="http://zhaoyuxuan.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="-C++" scheme="http://zhaoyuxuan.xyz/tags/C/"/>
    
    <category term="-算法" scheme="http://zhaoyuxuan.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【图】最短路径算法</title>
    <link href="http://zhaoyuxuan.xyz/2021/10/21/%E3%80%90%E5%9B%BE%E3%80%91%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95/"/>
    <id>http://zhaoyuxuan.xyz/2021/10/21/%E3%80%90%E5%9B%BE%E3%80%91%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95/</id>
    <published>2021-10-21T11:00:05.000Z</published>
    <updated>2021-10-21T11:13:46.466Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图的最短算法"><a href="#图的最短算法" class="headerlink" title="图的最短算法"></a>图的最短算法</h1><blockquote><p>从起点开始访问所有路径，可以到达终点的有多条地址,其中路径权值最小的为最短路径。<br>最短路径算法有深度优先遍历、广度优先遍历、Bellman-Ford算法、弗洛伊德算法、SPFA(Shortest Path Faster Algorithm)算法和迪杰斯特拉算法等。</p></blockquote><p><strong>本代码使用深度优先遍历</strong></p><p><strong>主要实现思路</strong>：</p><blockquote><p>从起点开始，到达终点有多条分支，这些分支中又有多条分支…<br>选择其实一条分支，走到终点，再选择另一个分支(temp =  temp -&gt;next)走到终点，分支的分支……</p></blockquote><p><strong>大致流程</strong>:<br><img src="https://img-blog.csdnimg.cn/82539303749b450595dfa1447cc0eb20.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARG8yZU0wTg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><strong>代码实现</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">邻接列表的大致排列类似于哈希表</span></span><br><span class="line"><span class="comment">自己定义出&quot;邻接桶&quot;的概念，类似于“哈希桶”</span></span><br><span class="line"><span class="comment">邻接桶中存着每个顶点</span></span><br><span class="line"><span class="comment">每个顶点的通过EdgeNode——边，来链接着顶点和顶点，</span></span><br><span class="line"><span class="comment">每个顶点都可以作为起始点，指向/被指向。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这个容器就是“邻接桶”</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">***</span></span><br><span class="line"><span class="comment">***************</span></span><br><span class="line"><span class="comment">***</span></span><br><span class="line"><span class="comment">**   *</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">**   *</span></span><br><span class="line"><span class="comment">***</span></span><br><span class="line"><span class="comment">***************</span></span><br><span class="line"><span class="comment">***</span></span><br><span class="line"><span class="comment">**   *</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">**   *</span></span><br><span class="line"><span class="comment">***</span></span><br><span class="line"><span class="comment">***************</span></span><br><span class="line"><span class="comment">***</span></span><br><span class="line"><span class="comment">**   *</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">*顶点*</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Max_Size 1024 </span></span><br><span class="line"><span class="keyword">bool</span> visited[Max_Size];</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">EdgeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> adjvex;</span><br><span class="line"><span class="keyword">int</span> weight;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">EdgeNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;EdgeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">VertexNode</span>//顶点结点，这个就是邻接桶</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> data;<span class="comment">//结点数据</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">EdgeNode</span>* <span class="title">first</span>;</span><span class="comment">//指向邻接第一条边</span></span><br><span class="line">&#125;VertexNode, AdjList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">AdjListGraph</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">AdjList* adjlist;</span><br><span class="line"><span class="keyword">int</span> vex;<span class="comment">//顶点数</span></span><br><span class="line"><span class="keyword">int</span> edge;<span class="comment">//边数</span></span><br><span class="line"></span><br><span class="line">&#125;AdjListGraph;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过顶点对应的字符来寻找顶点在图中的邻接点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Location</span><span class="params">(AdjListGraph&amp; G,<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vex; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (G.adjlist[i].data == c)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//图的初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initGraph</span><span class="params">(AdjListGraph&amp; G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">G.adjlist = <span class="keyword">new</span> AdjList[Max_Size];<span class="comment">//左侧的邻接桶</span></span><br><span class="line">G.edge = <span class="number">0</span>;</span><br><span class="line">G.vex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Max_Size; i++)</span><br><span class="line">&#123;</span><br><span class="line">visited[i] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//图的创建</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createGraph</span><span class="params">(AdjListGraph&amp; G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入该图的顶点数以及边数&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; G.vex &gt;&gt; G.edge;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入顶点data&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vex; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; G.adjlist[i].data;<span class="comment">//输入顶点所存数据</span></span><br><span class="line">G.adjlist[i].first = <span class="literal">NULL</span>;<span class="comment">//边和边的关系，置空，先不与任何边相连。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//确定顶点与顶点之间的关系，两个顶点形成一条边，有几条边，就有几对i1 i2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> v1 = <span class="number">0</span>, v2 = <span class="number">0</span>;<span class="comment">//保存输入的顶点的字符</span></span><br><span class="line"><span class="keyword">int</span> i1 = <span class="number">0</span>, i2 = <span class="number">0</span>;<span class="comment">//保存顶点在数组中的下标</span></span><br><span class="line"><span class="comment">//将i1和i2链接起来</span></span><br><span class="line"><span class="comment">//i1为起点。i2为终点。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//保存边的权重</span></span><br><span class="line"><span class="keyword">int</span> weight = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入想关联边的顶点&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.edge; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; weight;<span class="comment">//以v1为起点，v2为终点的边，权重是weight</span></span><br><span class="line">i1 = Location(G, v1);</span><br><span class="line">i2 = Location(G, v2);</span><br><span class="line"><span class="comment">//说明存在</span></span><br><span class="line"><span class="keyword">if</span> (i1 != <span class="number">-1</span> &amp;&amp; i2 != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">EdgeNode* temp = <span class="keyword">new</span> EdgeNode;</span><br><span class="line">temp-&gt;adjvex = i2;</span><br><span class="line">temp-&gt;next = G.adjlist[i1].first;<span class="comment">//头插法-类似于hashtable中的插入数据</span></span><br><span class="line">temp-&gt;weight = weight;</span><br><span class="line">G.adjlist[i1].first = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//图的最短路径算法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> min_weight = <span class="number">0x7FFFFFFF</span>;<span class="comment">//定义一个最大的方便与之比较。（INT_MAX）</span></span><br><span class="line"><span class="keyword">int</span> steps = <span class="number">0</span>;<span class="comment">//已走过的步数</span></span><br><span class="line"><span class="keyword">int</span> path[Max_Size ] = &#123; <span class="number">0</span> &#125;;<span class="comment">//保存走过的路径</span></span><br><span class="line"><span class="keyword">int</span> shortest_path[Max_Size] = &#123; <span class="number">0</span> &#125;;<span class="comment">//保存最短路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//求图的最短路径——深度优先遍历（前提是连通图）</span></span><br><span class="line"><span class="comment">//                            起点   终点      已走过的权重和   </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(AdjListGraph&amp; G,<span class="keyword">int</span> start ,<span class="keyword">int</span> end,<span class="keyword">int</span> weights)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> cur = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (start == end)<span class="comment">//已经找到终点了，不需要遍历了</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; steps; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; G.adjlist[path[i]].data &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//path中存的是对应结点在邻接桶中的下标，通过这个下标就能找到对应的data,即可找到走过的路径</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;该路径对应的长度是:&quot;</span> &lt;&lt; weights &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//输入对应的路径长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (min_weight &gt; weights)<span class="comment">//取到当前最小路径</span></span><br><span class="line">&#123;</span><br><span class="line">min_weight = weights;</span><br><span class="line"><span class="built_in">memcpy</span>(shortest_path, path, steps * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">visited[start] = <span class="number">1</span>;</span><br><span class="line">EdgeNode* temp = G.adjlist[start].first;<span class="comment">//指向第一条边</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (temp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> weight = temp-&gt;weight;</span><br><span class="line">cur = temp-&gt;adjvex;<span class="comment">//通过这条边的指向，指过来的这个顶点，在邻接桶中的下标</span></span><br><span class="line"><span class="keyword">if</span> (!visited[cur])</span><br><span class="line">&#123;</span><br><span class="line">visited[cur] = <span class="number">1</span>;<span class="comment">//标记已经访问</span></span><br><span class="line">path[steps++] = cur;</span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line">DFS(G, cur, end, weights+weight);</span><br><span class="line"></span><br><span class="line">visited[cur] = <span class="number">0</span>;<span class="comment">//前一步探索完成后，置空cur,（应该是有路线含有重复结点时起到作用）</span></span><br><span class="line">path[--steps] = <span class="number">0</span>;<span class="comment">//路径回退</span></span><br><span class="line">&#125;</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">AdjListGraph G;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">initGraph(G);</span><br><span class="line"><span class="comment">//创建图</span></span><br><span class="line">createGraph(G);</span><br><span class="line"><span class="comment">//深度优先-寻找最短路径</span></span><br><span class="line">DFS(G, Location(G, <span class="string">&#x27;A&#x27;</span>), Location(G, <span class="string">&#x27;D&#x27;</span>), <span class="number">0</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;成功得到最短路径为&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//最短路径</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;起点&quot;</span>;</span><br><span class="line"><span class="keyword">while</span> (shortest_path[i] &gt; <span class="number">0</span> &amp;&amp; i &lt; Max_Size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt; G.adjlist[shortest_path[i]].data ;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>输入示例</strong>：<br><img src="https://img-blog.csdnimg.cn/5279a8ca6ec44afaae5cc9121c692c9f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARG8yZU0wTg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;图的最短算法&quot;&gt;&lt;a href=&quot;#图的最短算法&quot; class=&quot;headerlink&quot; title=&quot;图的最短算法&quot;&gt;&lt;/a&gt;图的最短算法&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;从起点开始访问所有路径，可以到达终点的有多条地址,其中路径权值最小的为最短路径。&lt;</summary>
      
    
    
    
    <category term="算法" scheme="http://zhaoyuxuan.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="-C++" scheme="http://zhaoyuxuan.xyz/tags/C/"/>
    
    <category term="-算法" scheme="http://zhaoyuxuan.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="-数据结构" scheme="http://zhaoyuxuan.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="-图" scheme="http://zhaoyuxuan.xyz/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题(19)【简单】二叉树的前&amp;&amp;中&amp;&amp;后序遍历(C++)</title>
    <link href="http://zhaoyuxuan.xyz/2021/10/19/LeetCode%E5%88%B7%E9%A2%98(19)%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D&amp;&amp;%E4%B8%AD&amp;&amp;%E5%90%8E%E9%81%8D%E5%8E%86(%E9%9D%9E%E9%80%92%E5%BD%92)(C++)/"/>
    <id>http://zhaoyuxuan.xyz/2021/10/19/LeetCode%E5%88%B7%E9%A2%98(19)%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D&amp;&amp;%E4%B8%AD&amp;&amp;%E5%90%8E%E9%81%8D%E5%8E%86(%E9%9D%9E%E9%80%92%E5%BD%92)(C++)/</id>
    <published>2021-10-19T14:06:22.000Z</published>
    <updated>2021-10-19T14:07:38.662Z</updated>
    
    <content type="html"><![CDATA[<p><strong>精华在于进栈和出栈的时机</strong></p><h1 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94.二叉树的中序遍历"></a>94.二叉树的中序遍历</h1><p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">题目</a></p><p><img src="https://img-blog.csdnimg.cn/9d297ef375fb4b468c58ad49d2bfae32.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARG8yZU0wTg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p>思路：<br>中序遍历的顺序是，左 - 根 - 右<br>创建一个栈来存储结点，创建一个vector来存储中序遍历的值<br>从根结点开始，只要该结点有左子树，就将该结点压进栈中。<br>直到root为空。<br>取出栈顶元素，栈顶元素出栈，将该结点值存进recv。<br>…<br>剩下的只可意会不可言传了，</p><p>感谢这位老哥分享——<a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/zhan-c-by-li-kou-it-16d5/">链接</a></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//中序遍历顺序-左-中-右</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;recv;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; Tstack;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//当前结点不为空或当前栈不为空</span></span><br><span class="line">       <span class="keyword">while</span>(root || !Tstack.empty())</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">while</span>(root)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="comment">//只要当前结点不为空就往栈里面压</span></span><br><span class="line">               Tstack.push(root);</span><br><span class="line">               root = root-&gt;left;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//此时栈顶元素为根节点左侧树最左的左子树</span></span><br><span class="line">           <span class="comment">//取到该结点</span></span><br><span class="line">           root = Tstack.top();</span><br><span class="line">           Tstack.pop();</span><br><span class="line">           <span class="comment">//pop出栈，存进recv中</span></span><br><span class="line">           recv.push_back(root-&gt;val);</span><br><span class="line">           root = root-&gt;right;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> recv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>递归方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h1 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144.二叉树的前序遍历"></a>144.二叉树的前序遍历</h1><p><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">题目</a><br><img src="https://img-blog.csdnimg.cn/57f870c20620471f83d7e8b07ea2cd17.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARG8yZU0wTg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>非递归</strong><br>感谢这位老哥分享——<a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/shu-de-qian-xu-bian-li-fei-di-gui-fang-fa-zhan-by-/">链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;recv;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt;Tstack;</span><br><span class="line">    <span class="keyword">while</span>(root || !Tstack.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(root)</span><br><span class="line">        &#123;</span><br><span class="line">            recv.push_back(root-&gt;val);</span><br><span class="line">            Tstack.push(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        root = Tstack.top();</span><br><span class="line">        Tstack.pop();</span><br><span class="line">        root = root-&gt;right;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> recv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145.二叉树的后序遍历"></a>145.二叉树的后序遍历</h1><p><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">题目</a><br><img src="https://img-blog.csdnimg.cn/e6e1e58b4d444317b4dc7673d573d24b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARG8yZU0wTg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p>一直往栈里面往左节点，压到左边最后一个做结点，往回pop,判断当前这个结点是否右结点，有右结点就输出，最后判断自己。</p><p>感谢这位老哥分享思路—<a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/solution/er-cha-shu-hou-xu-fei-di-gui-bian-li-liang-chong-z/">链接</a></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;result;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt;Tstack;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        TreeNode* prev = <span class="literal">nullptr</span>;<span class="comment">//记录cur上一个指向的结点，比cur走慢一步</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!Tstack.empty() || cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//只有cur不为空，就一直往里面压左节点</span></span><br><span class="line">            <span class="keyword">while</span>(cur) </span><br><span class="line">            &#123;</span><br><span class="line">                Tstack.push(cur);</span><br><span class="line">                cur =cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = Tstack.top();</span><br><span class="line">            <span class="comment">//如果当前结点没有右结点 ||  右结点已经访问过了</span></span><br><span class="line">            <span class="keyword">if</span>(!cur-&gt;right || prev == cur-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                Tstack.pop();</span><br><span class="line">                result.push_back(cur-&gt;val);</span><br><span class="line">                prev = cur;</span><br><span class="line">                <span class="comment">//要从栈里面往外面吐结点，所以要将cur置为null</span></span><br><span class="line">                cur = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;   </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>   result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>大致流程感觉<br><img src="https://img-blog.csdnimg.cn/88d1252a9a964302bf56a25c8757cb2c.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARG8yZU0wTg==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/be98cf30ed3240ceabe2540a448efaff.gif#pic_center#pic_center" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;精华在于进栈和出栈的时机&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;94-二叉树的中序遍历&quot;&gt;&lt;a href=&quot;#94-二叉树的中序遍历&quot; class=&quot;headerlink&quot; title=&quot;94.二叉树的中序遍历&quot;&gt;&lt;/a&gt;94.二叉树的中序遍历&lt;/h1&gt;</summary>
      
    
    
    
    <category term="算法" scheme="http://zhaoyuxuan.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="-C++" scheme="http://zhaoyuxuan.xyz/tags/C/"/>
    
    <category term="-LeetCode" scheme="http://zhaoyuxuan.xyz/tags/LeetCode/"/>
    
    <category term="-树" scheme="http://zhaoyuxuan.xyz/tags/%E6%A0%91/"/>
    
    <category term="-二叉树" scheme="http://zhaoyuxuan.xyz/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
</feed>
