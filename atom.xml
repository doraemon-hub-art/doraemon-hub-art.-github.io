<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>半生瓜のblog</title>
  
  
  <link href="https://doraemon-hub-art.github.io/atom.xml" rel="self"/>
  
  <link href="https://doraemon-hub-art.github.io/"/>
  <updated>2022-01-18T08:47:34.087Z</updated>
  <id>https://doraemon-hub-art.github.io/</id>
  
  <author>
    <name>快乐的威猛先生</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【QT】QT容器</title>
    <link href="https://doraemon-hub-art.github.io/2022/01/18/%E3%80%90QT%E3%80%91QT%E5%AE%B9%E5%99%A8/"/>
    <id>https://doraemon-hub-art.github.io/2022/01/18/%E3%80%90QT%E3%80%91QT%E5%AE%B9%E5%99%A8/</id>
    <published>2022-01-18T08:45:02.000Z</published>
    <updated>2022-01-18T08:47:34.087Z</updated>
    
    <content type="html"><![CDATA[<h1 id="QT容器"><a href="#QT容器" class="headerlink" title="QT容器"></a>QT容器</h1><h2 id="QString类"><a href="#QString类" class="headerlink" title="QString类"></a>QString类</h2><p><strong>隐式共享:</strong></p><p>隐式数据共享机制去最大化资源有效利用和最小化复制克隆操作。</p><p>隐式数据共享类当作为函数参数传递的时候，不仅安全而且效率很高，因为传递的时候只是传递了数据的指针，数据本身只当自己被修改的时候才会去复制。简称写时复制。</p><p>数据相同时，执行浅拷贝，仅复制指向数据块的指针，数据不同时则执行深拷贝。</p><p>隐式共享技术可以大大降低对内存的开销以及，CPU资源的消耗，很大程度提高应用程序的运行效率。</p><p>QString类保存了16位的Unicode值(宽字节)，Unicode把所有语言都统一到一套编码里，Unicode提供UTF-8、UTF-16、UTF-32编码方式。</p><p>UTF-8以字节为单位对Unicode进行编码，对不同范围的字体使用不同长度的编码。对于0x00-0x7F之间的字符，UTF-8编码与ASCII编码完全相同。</p><p><strong>代码示例</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">QString s = <span class="string">&quot;Hello&quot;</span>;<span class="comment">//Hello数据块引用计数为1</span></span><br><span class="line">QString s1 = s;<span class="comment">//Hello数据块引用计数为2</span></span><br><span class="line">QString s2 = s;<span class="comment">//Hello数据块引用计数为3</span></span><br><span class="line"><span class="comment">//其中一个进行球盖</span></span><br><span class="line">s2 = <span class="string">&quot;He&quot;</span>;<span class="comment">//不在引用Hello这个数据块，Hello数据块引用-1，He数据块引用计数为1</span></span><br><span class="line">QString s3 = s;<span class="comment">//Hello数据块引用计数为3</span></span><br><span class="line">QString s4 = s2;<span class="comment">//He数据块引用计数为2</span></span><br><span class="line">QString s5 = s2;<span class="comment">//He数据块引用计数为2</span></span><br></pre></td></tr></table></figure><p><strong>初始化</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//const char* 初始化</span></span><br><span class="line">QString s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="function">QString <span class="title">str</span><span class="params">(<span class="string">&quot;test&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">//QChar数组初始化</span></span><br><span class="line">QChar cHi[<span class="number">3</span>] = &#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;i&#x27;</span>&#125;;</span><br><span class="line"><span class="function">QString <span class="title">strHi</span><span class="params">(cHi,<span class="number">2</span>)</span></span>;Z</span><br><span class="line"><span class="comment">//类对象初始化</span></span><br><span class="line">QString s1 = s;</span><br></pre></td></tr></table></figure><p><strong>转换</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//QString转数字</span></span><br><span class="line">  <span class="function">QString <span class="title">strAge</span><span class="params">(<span class="string">&quot;18&quot;</span>)</span></span>;</span><br><span class="line">  <span class="keyword">int</span> nAge = strAge.toInt();<span class="comment">//默认是10进制</span></span><br><span class="line">  <span class="function">QString <span class="title">strRate</span><span class="params">(<span class="string">&quot;3.14&quot;</span>)</span></span>;</span><br><span class="line">  <span class="keyword">float</span> nRate = strRate.toFloat();</span><br><span class="line">  <span class="function">QString <span class="title">strDouble</span><span class="params">(<span class="string">&quot;3.333&quot;</span>)</span></span>;</span><br><span class="line">  <span class="keyword">double</span> strD = strDouble.toDouble();</span><br><span class="line">  <span class="comment">//数字转QString</span></span><br><span class="line">  <span class="keyword">int</span> year = <span class="number">2022</span>;</span><br><span class="line">  <span class="keyword">float</span> height = <span class="number">1.70f</span>;</span><br><span class="line">  QString strYear;</span><br><span class="line">  strYear =  strYear.number(year);</span><br><span class="line">  QString strHeight;</span><br><span class="line">  strHeight = strHeight.number(height);</span><br><span class="line">  QString strTest;</span><br><span class="line">  strTest = strTest.setNum(year);</span><br><span class="line">  <span class="comment">//QString转QByteArray</span></span><br><span class="line">  QString strTom = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">  QByteArray tomArray = strTom.toUtf8();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* cTom = tomArray.data();</span><br><span class="line">  <span class="comment">//QString转QDataTime</span></span><br><span class="line">  QString strTime = <span class="string">&quot;1949-10-01 10:00:00&quot;</span>;</span><br><span class="line">  QDateTime dtTime = QDateTime::fromString(strTime,<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line">  <span class="comment">//QDateTime转QString</span></span><br><span class="line">  QDateTime dtCurrent = QDateTime::currentDateTime();</span><br><span class="line">  QString strCurrent = dtCurrent.toString(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>常用方法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//QString的拼接</span></span><br><span class="line">    QString s = <span class="string">&quot;对不起&quot;</span>;</span><br><span class="line">    s += <span class="string">&quot;我是警察。&quot;</span>;</span><br><span class="line">    s.append(<span class="string">&quot;Sorry。&quot;</span>);<span class="comment">// 结尾添加</span></span><br><span class="line">    <span class="comment">//QString格式化</span></span><br><span class="line">    QString s0;</span><br><span class="line">    s0.<span class="built_in">sprintf</span>(<span class="string">&quot;%s%d%s&quot;</span>,<span class="string">&quot;我&quot;</span>,<span class="number">19</span>,<span class="string">&quot;岁了。&quot;</span>);</span><br><span class="line">    QString s1;</span><br><span class="line">    s1 = QString(<span class="string">&quot;%1%2%3&quot;</span>).arg(<span class="string">&quot;我&quot;</span>).arg(<span class="number">19</span>).arg(<span class="string">&quot;岁了。&quot;</span>);</span><br><span class="line">    <span class="comment">//以索引方式访问</span></span><br><span class="line">    QChar qc1= s1.at(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//插入字符</span></span><br><span class="line">    QString s2= <span class="string">&quot;我岁了。&quot;</span>;</span><br><span class="line">    QString s3 = <span class="string">&quot;19&quot;</span>;</span><br><span class="line">    s2.insert(<span class="number">1</span>,s3.toUtf8());</span><br><span class="line">    <span class="comment">//在字符串起始位置插入</span></span><br><span class="line">    s2.prepend(<span class="string">&quot;今年&quot;</span>);</span><br><span class="line">    <span class="comment">//指定位置进行替换</span></span><br><span class="line">    s2.replace(<span class="number">0</span>,<span class="number">2</span>,<span class="string">&quot;去年&quot;</span>);</span><br><span class="line">    <span class="comment">//去除字符串两端的空格,中间的空格变为一个空格</span></span><br><span class="line">    s2.trimmed();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询字符</span></span><br><span class="line">    QString s4 = <span class="string">&quot;哔哩哔哩关注快乐的威猛先生&quot;</span>;</span><br><span class="line">    <span class="comment">//查询是否以xx开头,BOOL</span></span><br><span class="line">    qDebug()&lt;&lt;s4.startsWith(<span class="string">&quot;哔哩哔哩&quot;</span>);</span><br><span class="line">    QString s5 = <span class="string">&quot;tom&quot;</span>;</span><br><span class="line">    qDebug()&lt;&lt;s5.startsWith(<span class="string">&quot;tom&quot;</span>,Qt::CaseSensitive);<span class="comment">//大小写敏感</span></span><br><span class="line">    <span class="comment">//查询是否以xx结尾</span></span><br><span class="line">    qDebug()&lt;&lt;s5.endsWith(<span class="string">&quot;威猛先生&quot;</span>);<span class="comment">//同样可以表明大小写是否敏感</span></span><br><span class="line">    <span class="comment">//是否包含</span></span><br><span class="line">   qDebug()&lt;&lt;s5.contains(<span class="string">&quot;o&quot;</span>);<span class="comment">//同样可以表明大小写是否敏感</span></span><br><span class="line">   <span class="comment">//比较</span></span><br><span class="line">    qDebug()&lt;&lt;QString::compare(<span class="string">&quot;Tom&quot;</span>,<span class="string">&quot;tom&quot;</span>,Qt::CaseInsensitive);<span class="comment">//判断字符串是否相等，大小写是否敏感</span></span><br><span class="line">    <span class="comment">//分割字符串</span></span><br><span class="line">    QString strTime =  <span class="string">&quot;2022/1/17&quot;</span>;</span><br><span class="line">    QStringList timeList = strTime.split(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    foreach (QString ss,timeList) &#123;<span class="comment">//循环读取容器中的元素，用一个变量来接收读取到的数据</span></span><br><span class="line">       qDebug()&lt;&lt;ss;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//截取字符串</span></span><br><span class="line">    QString sFriends = <span class="string">&quot;EnvyuskenyS&quot;</span>;</span><br><span class="line">    qDebug()&lt;&lt;sFriends.mid(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//判断NULL字符串isNull()，采用默认构造函数，或者用const char*xx =&#x27;\0&#x27;来对QString进行构造</span></span><br><span class="line"><span class="comment">//判断空字符传isEmpty()</span></span><br></pre></td></tr></table></figure><hr><h2 id="QStringList"><a href="#QStringList" class="headerlink" title="QStringList"></a>QStringList</h2><p>QString类型的链表</p><p>常用操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> QStringList weekList;</span><br><span class="line"> weekList&lt;&lt;<span class="string">&quot;星期一&quot;</span>&lt;&lt;<span class="string">&quot;星期二&quot;</span>&lt;&lt;<span class="string">&quot;星期三&quot;</span>&lt;&lt;<span class="string">&quot;星期四&quot;</span>&lt;&lt;<span class="string">&quot;星期五&quot;</span>&lt;&lt;<span class="string">&quot;星期六&quot;</span>;</span><br><span class="line"> weekList.append(<span class="string">&quot;星期天&quot;</span>);<span class="comment">//尾插</span></span><br><span class="line"> qDebug()&lt;&lt;weekList;</span><br><span class="line"> <span class="comment">//for遍历链表</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; weekList.size();i++)</span><br><span class="line"> &#123;</span><br><span class="line">      qDebug()&lt;&lt;weekList.at(i);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//foreach遍历链表</span></span><br><span class="line"> foreach (QString ss, weekList) &#123;</span><br><span class="line">    qDebug()&lt;&lt;ss;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//STL风格迭代器</span></span><br><span class="line"> QStringList::iterator it = weekList.begin();</span><br><span class="line"> <span class="keyword">for</span>(;it !=  weekList.end();it++)</span><br><span class="line"> &#123;</span><br><span class="line">     qDebug()&lt;&lt;*it;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//JAVA风格迭代</span></span><br><span class="line"> QListIterator&lt;QString&gt;itr(weekList);</span><br><span class="line"> <span class="keyword">while</span> (itr.hasNext()) &#123;</span><br><span class="line">     qDebug()&lt;&lt;itr.next();<span class="comment">//java风格的迭代器初识位置在第一个元素的前一个位置</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//查看链表中是否包含某个元素</span></span><br><span class="line"> qDebug()&lt;&lt;weekList.contains(<span class="string">&quot;星期八&quot;</span>);</span><br><span class="line"> <span class="comment">//插入元素</span></span><br><span class="line"> weekList.insert(<span class="number">0</span>,<span class="string">&quot;星期零&quot;</span>);</span><br><span class="line"> weekList.append(<span class="string">&quot;星期八&quot;</span>);</span><br><span class="line"> <span class="comment">//删除元素</span></span><br><span class="line"> weekList.removeFirst();</span><br><span class="line"> weekList.removeLast();</span><br><span class="line"> weekList.removeOne(<span class="string">&quot;星期一&quot;</span>);</span><br><span class="line"> weekList.removeAt(<span class="number">0</span>);</span><br><span class="line"> weekList.clear();</span><br></pre></td></tr></table></figure><hr><h2 id="QList"><a href="#QList" class="headerlink" title="QList"></a>QList</h2><p>QList&lt; T &gt;是最常用的容器类。QList以列表形态存储并管理数据，并能进行基于快速索引的访问，也可以进行快速的数据删除操作。继承自QList类的子类有QItemSelection、QQueue、QStringList、QTestEventList.</p><p>可用运算符&lt;&lt; 、append()、prepend()进行添加元素，insert()进行插入。QList&lt; T &gt;维护了一个指针数组，数组元素指向每一个链表项，因此QList&lt; T &gt; 提供了基于下标的快速访问。</p><p>Java风格迭代器迭代点位置：第一个列表项前、两个列表项中间、最后一个列表项之后。STL风格迭代器迭代点位置：直接指向列表项。</p><p><img src="https://gitee.com/Do2eM0N/blogimg/raw/master/202201181647149.png" alt="image-20220117165954098"></p><p>QString中可以通过[]来访问元素。因为里面放的是指针，通过指针访问元素。</p><p><strong>相关操作示例</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;<span class="keyword">int</span>&gt;<span class="built_in">list</span>;</span><br><span class="line">    <span class="comment">//添加与元素</span></span><br><span class="line">    <span class="built_in">list</span>&lt;&lt;1&lt;&lt;2&lt;&lt;3&lt;&lt;4&lt;&lt;5;</span><br><span class="line">    <span class="built_in">list</span>.append(0);</span><br><span class="line">    <span class="built_in">list</span>.prepend(6);</span><br><span class="line">    <span class="built_in">list</span>.insert(0,99);</span><br><span class="line">    //查找元素</span><br><span class="line">   <span class="built_in">list</span>.at(2);</span><br><span class="line">   <span class="built_in">list</span>[2];</span><br><span class="line">    //查看是否包含</span><br><span class="line">   <span class="built_in">list</span>.contains(8);</span><br><span class="line">    //修改元素</span><br><span class="line">    <span class="built_in">list</span>.replace(1,66);</span><br><span class="line">    <span class="built_in">list</span>[2] = 77;</span><br><span class="line">    //删除元素</span><br><span class="line">    <span class="built_in">list</span>.removeFirst();</span><br><span class="line">    <span class="built_in">list</span>.removeLast();</span><br><span class="line">    //删除指定位置元素</span><br><span class="line">    <span class="built_in">list</span>.removeAt(2);</span><br><span class="line">    //指定元素删除</span><br><span class="line">    <span class="built_in">list</span>.removeOne(66);</span><br><span class="line">    //清空链表</span><br><span class="line">    <span class="built_in">list</span>.clear();</span><br></pre></td></tr></table></figure><p><strong>迭代器</strong></p><p><strong>JAVA风格迭代器</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JAVA风格迭代器</span></span><br><span class="line">   QList&lt;<span class="keyword">int</span>&gt;montList;</span><br><span class="line">   <span class="function">QMutableListIterator&lt;<span class="keyword">int</span>&gt; <span class="title">it_mrw</span><span class="params">(montList)</span></span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;   <span class="number">12</span>; i++)</span><br><span class="line">   &#123;</span><br><span class="line">       it_mrw.insert(i);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//反遍历</span></span><br><span class="line">   <span class="comment">//将迭代器移到结尾，判断前面是否有数据</span></span><br><span class="line">   <span class="keyword">for</span>(it_mrw.toBack();it_mrw.hasPrevious();)</span><br><span class="line">   &#123;</span><br><span class="line">       qDebug()&lt;&lt;it_mrw.previous();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//正遍历</span></span><br><span class="line">   <span class="keyword">for</span>(it_mrw.toFront();it_mrw.hasNext();)</span><br><span class="line">   &#123;</span><br><span class="line">       qDebug()&lt;&lt;it_mrw.next();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//删除、修改</span></span><br><span class="line">   <span class="keyword">for</span>(it_mrw.toFront(); it_mrw.hasNext();)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="keyword">int</span> month = it_mrw.next();</span><br><span class="line">        <span class="keyword">if</span>(month== <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">             it_mrw.remove();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(month == <span class="number">11</span>)</span><br><span class="line">       &#123;</span><br><span class="line">             it_mrw.setValue(<span class="number">12</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   qDebug()&lt;&lt;montList;</span><br><span class="line">   <span class="comment">//只读迭代器</span></span><br><span class="line">   QListIterator&lt;<span class="keyword">int</span>&gt;it_mr(montList);</span><br><span class="line">   <span class="comment">//正遍历</span></span><br><span class="line">   <span class="keyword">for</span>(it_mr.toFront();it_mr.hasNext();)</span><br><span class="line">   &#123;</span><br><span class="line">       qDebug()&lt;&lt;it_mr.next();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//反遍历</span></span><br><span class="line">   <span class="keyword">for</span>(it_mr.toBack();it_mr.hasPrevious();)</span><br><span class="line">   &#123;</span><br><span class="line">       qDebug()&lt;&lt;it_mr.previous();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>STL风格迭代器</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//STL风格迭代器</span></span><br><span class="line">QList&lt;<span class="keyword">int</span>&gt;numList;</span><br><span class="line">numList&lt;&lt;<span class="number">10</span>&lt;&lt;<span class="number">11</span>&lt;&lt;<span class="number">12</span>&lt;&lt;<span class="number">13</span>;</span><br><span class="line"><span class="comment">//读写迭代器</span></span><br><span class="line"> QList&lt;<span class="keyword">int</span>&gt;::iterator it_numRW;</span><br><span class="line"> <span class="keyword">for</span>( it_numRW = numList.begin();it_numRW != numList.end();it_numRW++)</span><br><span class="line"> &#123;</span><br><span class="line">     *it_numRW =*it_numRW *  <span class="number">10</span>;</span><br><span class="line">      qDebug()&lt;&lt;*it_numRW;</span><br><span class="line"> &#125;</span><br><span class="line"> qDebug()&lt;&lt;<span class="string">&quot;---&quot;</span>;</span><br><span class="line"> <span class="comment">//只读迭代器</span></span><br><span class="line"> QList&lt;<span class="keyword">int</span>&gt;::const_iterator it_numR;</span><br><span class="line"> <span class="comment">//constEnd方法返回的迭代器指向最后一个元素之后，是虚拟的。</span></span><br><span class="line"> <span class="keyword">for</span>( it_numR = numList.constBegin();it_numR != numList.constEnd();it_numR++)</span><br><span class="line"> &#123;</span><br><span class="line">         qDebug()&lt;&lt;*it_numR;</span><br><span class="line"> &#125;</span><br><span class="line">   qDebug()&lt;&lt;<span class="string">&quot;---&quot;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="QLinkedList"><a href="#QLinkedList" class="headerlink" title="QLinkedList"></a>QLinkedList</h2><p> 更加高效，大量数据情况下运行速度更快。是一个更加”纯粹”的链表。</p><p>不支持下标访问，不用维护那个指针数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">QLinkedList&lt;QString&gt;weekList;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">8</span> ;j ++ )</span><br><span class="line"> &#123;</span><br><span class="line">      weekList&lt;&lt;QString(<span class="string">&quot;%1%2&quot;</span>).arg(<span class="string">&quot;星期&quot;</span>).arg(j);</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="comment">//JAVA风格只读迭代器</span></span><br><span class="line">  QLinkedListIterator&lt;QString&gt;it_wr(weekList);</span><br><span class="line">  <span class="keyword">for</span>(it_wr.toFront();it_wr.hasNext();)</span><br><span class="line">  &#123;</span><br><span class="line">      qDebug()&lt;&lt;it_wr.next();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//Java风格读写迭代器</span></span><br><span class="line">  QMutableLinkedListIterator&lt;QString&gt;it_wrw(weekList);</span><br><span class="line">  <span class="keyword">for</span>(it_wrw.toFront();it_wrw.hasNext();)</span><br><span class="line">  &#123;</span><br><span class="line">      QString day = it_wrw.next();</span><br><span class="line">      <span class="keyword">if</span>(day == <span class="string">&quot;星期3&quot;</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          it_wrw.setValue(<span class="string">&quot;星期三&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(day == <span class="string">&quot;星期5&quot;</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          it_wrw.setValue(<span class="string">&quot;星期五&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(day == <span class="string">&quot;星期6&quot;</span>)</span><br><span class="line">       &#123;</span><br><span class="line">          it_wrw.insert(<span class="string">&quot;星期六6&quot;</span>);<span class="comment">//插入到当前位置的后面</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>( it_wrw.toFront();it_wrw.hasNext();)</span><br><span class="line">  &#123;</span><br><span class="line">       qDebug()&lt;&lt;it_wrw.next();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//QLinkedList不能支持下标访问</span></span><br></pre></td></tr></table></figure><hr><h2 id="QVector"><a href="#QVector" class="headerlink" title="QVector"></a>QVector</h2><p>QVector在相邻的内存中存储给定数据类型T的一组数据。在QVector前部或中间位置插入操作速度都很慢，因为会导致内存中大量数据的移动。访问数据可使用下标，也可以使用迭代器。继承自QVector类的子类有QPolygon、QPolygonF、QStack。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">QVector&lt;QString&gt;vStarts;</span><br><span class="line">  <span class="comment">//添加元素</span></span><br><span class="line"> vStarts&lt;&lt;<span class="string">&quot;星期1&quot;</span>&lt;&lt;<span class="string">&quot;星期2&quot;</span>&lt;&lt;<span class="string">&quot;星期3&quot;</span>;</span><br><span class="line"> vStarts.append(<span class="string">&quot;星期4&quot;</span>);</span><br><span class="line"> vStarts.prepend(<span class="string">&quot;星期5&quot;</span>);</span><br><span class="line"> vStarts.insert(<span class="number">0</span>,<span class="string">&quot;星期6&quot;</span>);</span><br><span class="line"> <span class="comment">//修改元素</span></span><br><span class="line"> vStarts.replace(<span class="number">0</span>,<span class="string">&quot;星期六&quot;</span>);</span><br><span class="line"> <span class="comment">//删除元素</span></span><br><span class="line"> vStarts.remove(<span class="number">0</span>);</span><br><span class="line"> vStarts.removeFirst();</span><br><span class="line"> vStarts.removeAll(<span class="string">&quot;星期日&quot;</span>);</span><br><span class="line"> <span class="comment">//访问元素</span></span><br><span class="line"> vStarts[<span class="number">2</span>];</span><br><span class="line"> vStarts.at(<span class="number">2</span>);</span><br><span class="line"> vStarts.contains(<span class="string">&quot;星期日&quot;</span>);</span><br><span class="line"> <span class="comment">//JAVA风格只读迭代</span></span><br><span class="line"> QVectorIterator&lt;QString&gt;it_sr(vStarts);</span><br><span class="line"> <span class="keyword">for</span>(it_sr.toFront();it_sr.hasNext();)</span><br><span class="line"> &#123;</span><br><span class="line">     qDebug()&lt;&lt;it_sr.next();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//JAVA风格读写迭代</span></span><br><span class="line"> QMutableVectorIterator&lt;QString&gt;it_srw(vStarts);</span><br><span class="line"> <span class="keyword">for</span>(it_srw.toFront();it_srw.hasNext();)</span><br><span class="line"> &#123;</span><br><span class="line">     QString s = it_srw.next();</span><br><span class="line">     <span class="keyword">if</span>(!QString::compare(s,<span class="string">&quot;星期1&quot;</span>))</span><br><span class="line">      &#123;</span><br><span class="line">         it_srw.setValue(<span class="string">&quot;星期一&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> qDebug()&lt;&lt;vStarts;</span><br></pre></td></tr></table></figure><hr><h2 id="QMap"><a href="#QMap" class="headerlink" title="QMap"></a>QMap</h2><p>QMap与QHash差别：</p><ul><li>QHash比QMap查找速度更快。</li><li>QHash以任意顺序存储，QMap以key顺序存储数据。</li><li>QHash的key必须提供operator==()及一个全局的qHash(key)函数，而QMap必须提供operator&lt;()函数。</li></ul><p>存储一键多值数据时可使用QMultiMap&lt; key,T&gt;容器或QMultiHash&lt; key, T&gt;容器</p><p><strong>默认从小到大排序。</strong></p><p><img src="https://gitee.com/Do2eM0N/blogimg/raw/master/202201181103021.png" alt="image-20220118110333932"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">QMap&lt;QString,QString&gt;infoMap;</span><br><span class="line"> infoMap.insert(<span class="string">&quot;哈哈哈哈&quot;</span>,<span class="string">&quot;鸡汤来喽&quot;</span>);</span><br><span class="line"> infoMap.insert(<span class="string">&quot;芜湖&quot;</span>,<span class="string">&quot;起飞&quot;</span>);</span><br><span class="line"> infoMap[<span class="string">&quot;哔哩哔哩&quot;</span>]=<span class="string">&quot;快乐的威猛先生&quot;</span>;</span><br><span class="line"> infoMap[<span class="string">&quot;CSDN&quot;</span>]=<span class="string">&quot;半生瓜のblog&quot;</span>;</span><br><span class="line"> <span class="comment">//通过key查找value</span></span><br><span class="line"> qDebug()&lt;&lt;infoMap[<span class="string">&quot;哔哩哔哩&quot;</span>];</span><br><span class="line"> <span class="comment">//通过value找key</span></span><br><span class="line"> qDebug()&lt;&lt;infoMap.key(<span class="string">&quot;快乐的威猛先生&quot;</span>);</span><br><span class="line"> <span class="comment">//JAVA风格只读迭代器</span></span><br><span class="line"> QMapIterator&lt;QString,QString&gt;it_r(infoMap);</span><br><span class="line"> <span class="keyword">for</span>(it_r.toFront();it_r.hasNext();)</span><br><span class="line"> &#123;</span><br><span class="line">     it_r.next();</span><br><span class="line">     qDebug()&lt;&lt;it_r.key()&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;it_r.value();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//JAVA风格读写迭代器</span></span><br><span class="line"> QMutableMapIterator&lt;QString,QString&gt;it_rw(infoMap);</span><br><span class="line"> <span class="keyword">for</span>(it_rw.toFront();it_rw.hasNext();)</span><br><span class="line"> &#123;</span><br><span class="line">     it_rw.next();</span><br><span class="line">     <span class="keyword">if</span>(it_rw.key()==<span class="string">&quot;哔哩哔哩&quot;</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         it_rw.setValue(<span class="string">&quot;关注快乐的威猛先生&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//STL风格只读迭代器</span></span><br><span class="line"> QMap&lt;QString,QString&gt;::const_iterator i_r;</span><br><span class="line"> i_r = infoMap.constBegin();</span><br><span class="line"> <span class="keyword">for</span>(;i_r != infoMap.constEnd();i_r++)</span><br><span class="line"> &#123;</span><br><span class="line">     qDebug()&lt;&lt;i_r.key()&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;i_r.value();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//STL风格读写迭代器</span></span><br><span class="line"> QMap&lt;QString,QString&gt;::iterator i_rw;</span><br><span class="line"> <span class="keyword">for</span>(i_rw = infoMap.begin();i_rw != infoMap.end();i_rw++)</span><br><span class="line"> &#123;</span><br><span class="line">        <span class="keyword">if</span>(i_rw.key() == <span class="string">&quot;哔哩哔哩&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            i_rw.value() = <span class="string">&quot;快关注威猛先生&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> i_rw = infoMap.find(<span class="string">&quot;哔哩哔哩&quot;</span>);</span><br><span class="line"> i_rw.value() =<span class="string">&quot;bilibili&quot;</span>;</span><br><span class="line"> <span class="keyword">for</span>(i_rw = infoMap.begin();i_rw != infoMap.end();i_rw++)</span><br><span class="line"> &#123;</span><br><span class="line">     qDebug()&lt;&lt;*i_rw;<span class="comment">//value</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//一个键对应多个值</span></span><br><span class="line"> QMultiMap&lt;QString,QString&gt;wMap1;<span class="comment">//一个key对应多个value</span></span><br><span class="line"> wMap1.insert(<span class="string">&quot;spring1&quot;</span>,<span class="string">&quot;5°C&quot;</span>);</span><br><span class="line"> wMap1.insert(<span class="string">&quot;spring2&quot;</span>,<span class="string">&quot;15°C&quot;</span>);</span><br><span class="line"> wMap1.insert(<span class="string">&quot;spring2&quot;</span>,<span class="string">&quot;16°C&quot;</span>);</span><br><span class="line"> wMap1.insert(<span class="string">&quot;spring2&quot;</span>,<span class="string">&quot;17°C&quot;</span>);</span><br><span class="line"> wMap1.insert(<span class="string">&quot;spring3&quot;</span>,<span class="string">&quot;25°C&quot;</span>);</span><br><span class="line"> wMap1.insert(<span class="string">&quot;spring4&quot;</span>,<span class="string">&quot;35°C&quot;</span>);</span><br><span class="line"> wMap1.insert(<span class="string">&quot;spring4&quot;</span>,<span class="string">&quot;36°C&quot;</span>);</span><br><span class="line"> wMap1.insert(<span class="string">&quot;spring4&quot;</span>,<span class="string">&quot;37°C&quot;</span>);</span><br><span class="line"> <span class="comment">//指定元素删除</span></span><br><span class="line"> wMap1.remove(<span class="string">&quot;spring1&quot;</span>,<span class="string">&quot;5°C&quot;</span>);</span><br><span class="line"> <span class="comment">//查询指定value</span></span><br><span class="line"> wMap1.values(<span class="string">&quot;spring2&quot;</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//JAVA风格只读迭代</span></span><br><span class="line"> QMapIterator&lt;QString,QString&gt;it_r1(wMap1);</span><br><span class="line"> <span class="keyword">for</span>(it_r1.toFront();it_r1.hasNext();)</span><br><span class="line"> &#123;</span><br><span class="line">     qDebug()&lt;&lt;it_r1.key()&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;it_r1.next().value(); <span class="comment">//这个迭代器看起来比较变扭，先拿key,然后通过下一个迭代点拿value</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> qDebug()&lt;&lt;wMap1;</span><br></pre></td></tr></table></figure><hr><h2 id="QHash"><a href="#QHash" class="headerlink" title="QHash"></a>QHash</h2><p><strong>无序。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//QHash类</span></span><br><span class="line">  QHash&lt;<span class="keyword">int</span>,QString&gt;moneyHash;</span><br><span class="line">  moneyHash.insert(<span class="number">1</span>,<span class="string">&quot;一块钱&quot;</span>);</span><br><span class="line">  moneyHash.insert(<span class="number">10</span>,<span class="string">&quot;十块钱&quot;</span>);</span><br><span class="line">  moneyHash.insert(<span class="number">20</span>,<span class="string">&quot;二十块钱&quot;</span>);</span><br><span class="line">  moneyHash.insert(<span class="number">50</span>,<span class="string">&quot;五十块钱&quot;</span>);</span><br><span class="line">  moneyHash[<span class="number">50</span>]  = <span class="string">&quot;50&quot;</span>;</span><br><span class="line">  moneyHash.insertMulti(<span class="number">50</span>,<span class="string">&quot;50块钱&quot;</span>);<span class="comment">//插入多个value</span></span><br><span class="line">  qDebug()&lt;&lt;moneyHash;</span><br><span class="line">  <span class="comment">//JAVA风格只读迭代器</span></span><br><span class="line">  QHashIterator&lt;<span class="keyword">int</span>,QString&gt;it_mr(moneyHash);</span><br><span class="line">  <span class="keyword">for</span>(it_mr.toFront();it_mr.hasNext();)</span><br><span class="line">  &#123;</span><br><span class="line">      qDebug()&lt;&lt;it_mr.key()&lt;&lt;it_mr.next().value();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//JAVA风格读写迭代器</span></span><br><span class="line">  QMutableHashIterator&lt;<span class="keyword">int</span>,QString&gt;it_mrw(moneyHash);</span><br><span class="line">  <span class="comment">//修改数据</span></span><br><span class="line">  <span class="keyword">if</span>(  it_mrw.findNext(<span class="string">&quot;十块钱&quot;</span>))</span><br><span class="line">  &#123;</span><br><span class="line">      it_mrw.setValue(<span class="string">&quot;10元&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(it_mrw.toFront();it_mrw.hasNext();)</span><br><span class="line">  &#123;</span><br><span class="line">      qDebug()&lt;&lt;it_mrw.key()&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;it_mrw.next().value();</span><br><span class="line">  &#125;</span><br><span class="line">  qDebug()&lt;&lt;moneyHash;</span><br></pre></td></tr></table></figure><hr><h2 id="QVariant类"><a href="#QVariant类" class="headerlink" title="QVariant类"></a>QVariant类</h2><p>QVariant类能保存很多Qt类型的值，包括QColor,QBrush,QFont,QRect,QString及QSize等等，而且能存放Qt的容器类型值。</p><p>可采用toT()将QVariant对象转换为T类型数据并获取其值。如toInt()，toFloat(),toString(),可用type方法获取数据类型。对于GUI模块中定义的数据类型没有相应的转换函数，即没有toColor(),没有toImage()这样的函数提供，可通过value()方法实现转换，判断两种类型是否可以转换可通过用type方法获取数据类型，判断方法的返回值判断。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QVariant <span class="title">vNum</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">qDebug()&lt;&lt;vNum.toInt();</span><br><span class="line"><span class="function">QVariant <span class="title">vPi</span><span class="params">(<span class="number">3.1415f</span>)</span></span>;</span><br><span class="line">qDebug()&lt;&lt; vPi.toFloat();</span><br><span class="line"><span class="function">QVariant <span class="title">vStr</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line">qDebug()&lt;&lt;vStr.toString();</span><br><span class="line"><span class="function">QVariant <span class="title">vb</span><span class="params">(<span class="literal">true</span>)</span></span>;</span><br><span class="line">qDebug()&lt;&lt;vb.toBool();</span><br><span class="line"></span><br><span class="line">QColor c = QColor(Qt::red);</span><br><span class="line">QVariant VC = c;</span><br><span class="line">qDebug()&lt;&lt;VC.type();</span><br><span class="line">qDebug()&lt;&lt;VC.value&lt;QColor&gt;();</span><br><span class="line"></span><br><span class="line">QVariant vss = vStr;</span><br><span class="line">qDebug()&lt;&lt;vss.canConvert(QVariant::Int);<span class="comment">//返回数据类型转换能力，QVariant的转换能力</span></span><br><span class="line">qDebug()&lt;&lt;vss.convert(QVariant::Int);<span class="comment">//false,转换失败，数据清空</span></span><br><span class="line"><span class="comment">//转换成功的条件:有转换能力，且数据类型匹配。</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;QT容器&quot;&gt;&lt;a href=&quot;#QT容器&quot; class=&quot;headerlink&quot; title=&quot;QT容器&quot;&gt;&lt;/a&gt;QT容器&lt;/h1&gt;&lt;h2 id=&quot;QString类&quot;&gt;&lt;a href=&quot;#QString类&quot; class=&quot;headerlink&quot; title=&quot;Q</summary>
      
    
    
    
    <category term="QT" scheme="https://doraemon-hub-art.github.io/categories/QT/"/>
    
    
    <category term="-QT" scheme="https://doraemon-hub-art.github.io/tags/QT/"/>
    
  </entry>
  
  <entry>
    <title>【QT】布局管理器</title>
    <link href="https://doraemon-hub-art.github.io/2022/01/16/%E3%80%90QT%E3%80%91%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86%E5%99%A8/"/>
    <id>https://doraemon-hub-art.github.io/2022/01/16/%E3%80%90QT%E3%80%91%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86%E5%99%A8/</id>
    <published>2022-01-16T13:57:29.000Z</published>
    <updated>2022-01-16T13:57:57.259Z</updated>
    
    <content type="html"><![CDATA[<h1 id="布局管理器"><a href="#布局管理器" class="headerlink" title="布局管理器"></a>布局管理器</h1><p><img src="https://gitee.com/Do2eM0N/blogimg/raw/master/202201162157302.png" alt="image-20220116123759846"></p><p><strong>设计模式实现布局</strong></p><p>详情见工具栏</p><p><img src="https://gitee.com/Do2eM0N/blogimg/raw/master/202201161308818.png" alt="image-20220116130800777"></p><p>垂直布局，水平布局，打破布局。</p><p><strong>代码实现布局</strong></p><p><strong>main.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;testlayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QLineEdit&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QFormLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QRadioButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QSpacerItem&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    TestLayout w;</span><br><span class="line">   <span class="comment">//添加部件并且布局</span></span><br><span class="line">    <span class="comment">//添加标签</span></span><br><span class="line">    QLabel* nameLabel = <span class="keyword">new</span>  QLabel(<span class="string">&quot;姓名:(&amp;N)&quot;</span>);</span><br><span class="line">    QLabel* ageLabel = <span class="keyword">new</span>  QLabel(<span class="string">&quot;年龄:(&amp;A)&quot;</span>);</span><br><span class="line">    QLabel* emailLabel = <span class="keyword">new</span>  QLabel(<span class="string">&quot;邮箱:(&amp;E)&quot;</span>);</span><br><span class="line">    QLabel* doorLabel = <span class="keyword">new</span> QLabel(<span class="string">&quot;门牌号码:&quot;</span>);</span><br><span class="line">     <span class="comment">// 添加文本框</span></span><br><span class="line">     QLineEdit* nameLineEdit = <span class="keyword">new</span> QLineEdit;</span><br><span class="line">     QLineEdit* ageLineEdit = <span class="keyword">new</span> QLineEdit;</span><br><span class="line">     QLineEdit* emailLineEdit = <span class="keyword">new</span> QLineEdit;</span><br><span class="line">     QLineEdit* doorNumLineEdit = <span class="keyword">new</span> QLineEdit;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置伙伴关系——绑定快捷键</span></span><br><span class="line">    nameLabel-&gt;setBuddy(nameLineEdit);</span><br><span class="line">    ageLabel-&gt;setBuddy(ageLineEdit);</span><br><span class="line">    emailLabel-&gt;setBuddy(emailLineEdit);</span><br><span class="line">    <span class="comment">//添加布局</span></span><br><span class="line">    <span class="comment">//QFormLayout常用语表单布局</span></span><br><span class="line">    QFormLayout* headerLayout = <span class="keyword">new</span> QFormLayout;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将部件添加到布局管理器中</span></span><br><span class="line">     headerLayout-&gt;addRow(nameLabel,nameLineEdit);</span><br><span class="line">     headerLayout-&gt;addRow(ageLabel,ageLineEdit);</span><br><span class="line">     headerLayout-&gt;addRow(emailLabel,emailLineEdit);</span><br><span class="line">     headerLayout-&gt;addRow(doorLabel,doorNumLineEdit);</span><br><span class="line">     <span class="comment">//性别标签</span></span><br><span class="line">     QLabel* sexLabel = <span class="keyword">new</span> QLabel(<span class="string">&quot;性别:&quot;</span>);</span><br><span class="line">     <span class="comment">//添加单选按钮</span></span><br><span class="line">    QRadioButton* mBtn = <span class="keyword">new</span> QRadioButton;</span><br><span class="line">    QRadioButton* wBtn = <span class="keyword">new</span> QRadioButton;</span><br><span class="line">    mBtn-&gt;setText(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">    wBtn-&gt;setText(<span class="string">&quot;女&quot;</span>);</span><br><span class="line">    <span class="comment">//添加水平布局管理器</span></span><br><span class="line">    QHBoxLayout* sexLayout = <span class="keyword">new</span> QHBoxLayout;</span><br><span class="line">    sexLayout-&gt;addWidget(sexLabel);</span><br><span class="line">    sexLayout-&gt;addWidget(mBtn);</span><br><span class="line">    sexLayout-&gt;addWidget(wBtn);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加垂直布局管理器</span></span><br><span class="line">    <span class="comment">//将两个布局管理器添加到一起</span></span><br><span class="line">    QVBoxLayout* mainLayout = <span class="keyword">new</span> QVBoxLayout(&amp;w);<span class="comment">//参数-指定父窗体</span></span><br><span class="line">    mainLayout-&gt;addLayout(headerLayout);<span class="comment">//添加布局</span></span><br><span class="line">    mainLayout-&gt;addLayout(sexLayout);</span><br><span class="line">    <span class="comment">//在性别选项下添加空白</span></span><br><span class="line">    QSpacerItem* spacer = <span class="keyword">new</span> QSpacerItem(<span class="number">30</span>,<span class="number">30</span>);</span><br><span class="line">    mainLayout-&gt;addItem(spacer);<span class="comment">//添加空隙对象</span></span><br><span class="line">    <span class="comment">//添加一个按钮</span></span><br><span class="line">    QPushButton* okBtn = <span class="keyword">new</span> QPushButton(<span class="string">&quot;确定&quot;</span>);</span><br><span class="line">    <span class="comment">//将按钮添加到布局管理器中</span></span><br><span class="line">    mainLayout-&gt;addWidget(okBtn);<span class="comment">//添加部件</span></span><br><span class="line">    mainLayout-&gt;setMargin(<span class="number">10</span>);<span class="comment">//与窗口的间隙</span></span><br><span class="line">    mainLayout-&gt;setSpacing(<span class="number">20</span>);<span class="comment">//设置控件间的间隙</span></span><br><span class="line">    <span class="comment">//设置窗口布局管理器</span></span><br><span class="line">    w.setLayout(mainLayout);</span><br><span class="line">    w.show();</span><br><span class="line">    <span class="keyword">return</span> a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Do2eM0N/blogimg/raw/master/202201162157284.png" alt="image-20220116215432704"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;布局管理器&quot;&gt;&lt;a href=&quot;#布局管理器&quot; class=&quot;headerlink&quot; title=&quot;布局管理器&quot;&gt;&lt;/a&gt;布局管理器&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/Do2eM0N/blogimg/raw/master/202</summary>
      
    
    
    
    <category term="QT" scheme="https://doraemon-hub-art.github.io/categories/QT/"/>
    
    
    <category term="-QT" scheme="https://doraemon-hub-art.github.io/tags/QT/"/>
    
  </entry>
  
  <entry>
    <title>【QT】QT窗口部件</title>
    <link href="https://doraemon-hub-art.github.io/2022/01/16/%E3%80%90QT%E3%80%91QT%E7%AA%97%E5%8F%A3%E9%83%A8%E4%BB%B6/"/>
    <id>https://doraemon-hub-art.github.io/2022/01/16/%E3%80%90QT%E3%80%91QT%E7%AA%97%E5%8F%A3%E9%83%A8%E4%BB%B6/</id>
    <published>2022-01-16T04:26:40.000Z</published>
    <updated>2022-01-16T04:28:59.538Z</updated>
    
    <content type="html"><![CDATA[<h1 id="QT窗口部件"><a href="#QT窗口部件" class="headerlink" title="QT窗口部件"></a>QT窗口部件</h1><h2 id="默认部件基类"><a href="#默认部件基类" class="headerlink" title="默认部件基类"></a>默认部件基类</h2><p>QT提供的默认部件基类包括QMainWindow、QWidget、和QDialog，这三个部件基类也是用的最多的。</p><p>QMainWindow是带有菜单栏、工具栏、状态栏的主窗口类，它有自己单独的布局。布局有一个中心区域，通常是标准的QT部件，也可以是定制的部件，且必须有一个中心小部件。setCentralWidget()方法可设置中心部件。</p><p>QWidget类是所有部件对象的基类，被称为基础窗口部件。</p><p>QWidget提供自我绘制和处理用户输入等基本功能，如接收鼠标、键盘和其他事件，并且在屏幕上绘制自己的表现。每一个窗口部件都是矩形的，并且它们是按照**Z轴(由屏幕里到屏幕外)**顺序排列的。一个窗口部件可以被它的父窗口部件或者它前面的窗口部件盖住一部分。一个没有父窗口部件的窗口部件一直是顶级窗口部件。非顶级窗口部件时父窗口的子部件。</p><p>QWidget构造函数有两个参数:QWidget*parent = 0,QT:WindowFlages f = 0。</p><p>parent即父窗口，默认为0，即没有父窗口，是顶级窗口，如果指定parent值，则当前窗体将会是一个子部件。QT:WindowFlags是QT:WindowType，枚举值的组合，用来设置窗口的属性，f=0表示默认为QT:Widget风格，setWindowState()可设置窗体的状态，参数由QT:WindowStates枚举值指定。</p><p><strong>QWidget类关系表</strong></p><p><img src="https://gitee.com/Do2eM0N/blogimg/raw/master/202201161228351.png" alt="image-20220115102847426"></p><p><strong>窗体状态</strong></p><p><img src="https://gitee.com/Do2eM0N/blogimg/raw/master/202201151029912.png" alt="image-20220115102920884"></p><p><strong>模态</strong></p><p>窗口间的阻塞情况，是否必须先关闭某一窗口之后，才能对另一个窗口进行操作。</p><p>被设置为模态窗口的窗口关闭之后才能对其他窗口进行操作。</p><hr><p>QDialog是各种对话框的基类，其继承自QWidget，对话框有两种表现形态:形态对话框、非模态对话框。模态对话框就是一个阻塞同一应用程序中其它可视窗口的输入对话框。用户必须完成当前对话框中的交互操作并且关闭窗口后才能操作当前音乐程序中的其它窗口。模式对话框有它们自己的本地事件循环。exec()方法可使窗口以模态方式运行。当用户关闭这个对话框，exec()将提供一个可用的返回值并且这时流程控制继续从调用exec()的地方进行。</p><p>通常，我们链接默认按钮，例如”OK”到accpet()槽并且把”Cancel”链接到reject()槽，来使对话框关闭并且返回适当的值。另外，我们也可以连接done()槽，传递给它Accepted或Rejected。</p><p><strong>模态窗口运行</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）调用exec()方法，如</span><br><span class="line">QDialog dlg;</span><br><span class="line">dlg.exec();</span><br><span class="line">（<span class="number">2</span>）调用setModal()方法设置模态，如</span><br><span class="line">QDialog dlg;</span><br><span class="line">dlg.setModal(<span class="literal">true</span>);</span><br><span class="line">dlg.show();</span><br><span class="line">（<span class="number">3</span>）QWidget widget;</span><br><span class="line">widget.setWindowModality(Qt::ApplicationModal);</span><br><span class="line">widget.show();</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Do2eM0N/blogimg/raw/master/202201161228218.png" alt="image-20220115175915707"></p><hr><h2 id="其他部件"><a href="#其他部件" class="headerlink" title="其他部件"></a>其他部件</h2><p><strong>QLabel</strong></p><p>常用来显示文本、文字、图片、gif动图。</p><p>可与其他部件设置伙伴关系，此时标签起到快捷键作用。</p><p><strong>QLineEdit</strong></p><p>接收用户输入。</p><p>可以增加限制条件，例如只能让用户输入什么。</p><p>掩码字符</p><p><img src="https://gitee.com/Do2eM0N/blogimg/raw/master/202201161136600.png" alt="image-20220116113648534"></p><p><strong>QPushButton</strong></p><p>按钮类，常用显示文字图标。</p><p><strong>QRadioButton</strong></p><p>单选按钮类，只能选一个，将单选框按钮加入一个分组框中时，加入的按钮是一个分组，分组中只能选中一个，具有排他性。</p><p><strong>QCheckBox</strong></p><p>多选按钮类，可多选。</p><p>略….</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;QT窗口部件&quot;&gt;&lt;a href=&quot;#QT窗口部件&quot; class=&quot;headerlink&quot; title=&quot;QT窗口部件&quot;&gt;&lt;/a&gt;QT窗口部件&lt;/h1&gt;&lt;h2 id=&quot;默认部件基类&quot;&gt;&lt;a href=&quot;#默认部件基类&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="QT" scheme="https://doraemon-hub-art.github.io/categories/QT/"/>
    
    
    <category term="-QT" scheme="https://doraemon-hub-art.github.io/tags/QT/"/>
    
  </entry>
  
  <entry>
    <title>【QT】QT对象树</title>
    <link href="https://doraemon-hub-art.github.io/2022/01/13/%E3%80%90QT%E3%80%91QT%E5%AF%B9%E8%B1%A1%E6%A0%91/"/>
    <id>https://doraemon-hub-art.github.io/2022/01/13/%E3%80%90QT%E3%80%91QT%E5%AF%B9%E8%B1%A1%E6%A0%91/</id>
    <published>2022-01-13T14:09:50.000Z</published>
    <updated>2022-01-13T14:10:59.123Z</updated>
    
    <content type="html"><![CDATA[<h1 id="QT对象树"><a href="#QT对象树" class="headerlink" title="QT对象树"></a>QT对象树</h1><p>QT提供了对象树机制，能够<strong>自动</strong>、有效的组织和管理继承自QObject的对象。</p><p>每个继承自QObject类的对象通过它的对象链表(QObjectList)来管理子类对象，当用户创建一个子对象时，其对象链表相应更新子类对象的信息，对象链表可通过children()获取。</p><p>当父类对象析构的时候，其对象链表中的所有(子类)对象也会被析构，父对象会自动，将其从父对象列表中删除，QT保证没有对象会被delete两次。开发中手动回收资源时建议使用deleteLater代替delete,因为deleteLater多次是安全的。</p><p><img src="https://gitee.com/Do2eM0N/blogimg/raw/master/202201131239311.png" alt="image-20220113123903219"></p><hr><p>派生于QObject的类，申请资源的时候，我们可以不用过分的去关注资源回收情况，因为当该基类销毁回收时，子类也会一起销毁回收。</p><hr><p><strong>当某一个子类进行销毁的时候，如果它也有子类，对应的子类也会销毁回收。</strong></p><hr><p><img src="https://gitee.com/Do2eM0N/blogimg/raw/master/202201132152345.png" alt="image-20220113215247296"></p><p><img src="https://gitee.com/Do2eM0N/blogimg/raw/master/202201132153248.png" alt="image-20220113215301204"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;QT对象树&quot;&gt;&lt;a href=&quot;#QT对象树&quot; class=&quot;headerlink&quot; title=&quot;QT对象树&quot;&gt;&lt;/a&gt;QT对象树&lt;/h1&gt;&lt;p&gt;QT提供了对象树机制，能够&lt;strong&gt;自动&lt;/strong&gt;、有效的组织和管理继承自QObject的对象。&lt;/p</summary>
      
    
    
    
    <category term="QT" scheme="https://doraemon-hub-art.github.io/categories/QT/"/>
    
    
    <category term="-QT" scheme="https://doraemon-hub-art.github.io/tags/QT/"/>
    
  </entry>
  
  <entry>
    <title>【QT】QT元对象系统</title>
    <link href="https://doraemon-hub-art.github.io/2022/01/13/%E3%80%90QT%E3%80%91QT%E5%85%83%E5%AF%B9%E8%B1%A1%E7%B3%BB%E7%BB%9F/"/>
    <id>https://doraemon-hub-art.github.io/2022/01/13/%E3%80%90QT%E3%80%91QT%E5%85%83%E5%AF%B9%E8%B1%A1%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-01-13T03:24:58.000Z</published>
    <updated>2022-01-13T03:46:16.773Z</updated>
    
    <content type="html"><![CDATA[<h1 id="QT元对象系统-Meta-Object-System"><a href="#QT元对象系统-Meta-Object-System" class="headerlink" title="QT元对象系统(Meta-Object-System)"></a>QT元对象系统(Meta-Object-System)</h1><h2 id="元对象系统"><a href="#元对象系统" class="headerlink" title="元对象系统"></a>元对象系统</h2><p>元对象系统是一个基于标准C++的扩展，为QT提供了信号与槽机制、实时类型信息、动态属性系统。</p><p>元对象系统的三个基本条件:类必须继承自QObject、类声明Q_OBJECT宏(默认私有)、元对象编译器moc。</p><p><strong>信号与槽机制是QT的核心机制</strong>，信号与槽是一种高级接口，应用于对象之间的通信。信号和槽是QT自行定义的一种通信机制，它独立于标准的C/C++语言，要正确的处理信号和槽，必须借助一个称为moc(Meta-Object-Compiler)，也就是”元对象编译器”。</p><p>它为高层次的事件处理自动生成所需要的必要代码。QT程序在交由标准编译器编译之前，先要使用moc分析C++源文件。如果moc发现在一个类头文件中包含了函Q_OBJECT，则会生成以moc_className.cpp(自定义类名)的.cpp文件。这个源文件中包含了Q_OBJECT宏的实现代码。新的文件同样将进入编译系统，与源文件一起参与编译。构建生成的.o文件包含与moc生成的.cpp文件中。</p><hr><h2 id="信号与槽"><a href="#信号与槽" class="headerlink" title="信号与槽"></a>信号与槽</h2><p><strong>产生的历史背景</strong>:</p><p>GUI用户界面中，当用户操作一个窗口部件时，需要其他窗口部件响应，传统方式经常使用callback(回调机制)来实现。所谓回调即事先将函数指针作为一个参数传递给另一个函数，然后在函数处理过程中适当地方调用函数。</p><p>回调机制有两个缺陷:类型不安全，不能保证调用过程中使用正确的参数,强耦合，处理函数必须知道调用哪个回调函数。</p><p><strong>QT的信号与槽机制:</strong></p><p>QT的信号与槽机制是类型安全的，<strong>松耦合</strong>，更灵活，更方便。</p><p>信号与槽(Signal &amp; Slot)是QT编程的基础，也是QT的一大创新。因为有了信号与槽机制的编程，在QT中处理界面的各个组件的交互操作时变得更加直观个简单。</p><p>**信号(Signal)**就是在特定情况下被发射的事件，例如PushButton最常见的信号就是鼠标单击时发射的clicked()信号。发生信号使用QT的emit关键字。QT的signals关键字指出进入了信号的声明区，随后即可声明自己的信号。</p><p>**槽(Slot)**就是对信号响应的函数。槽就是一个函数，与一般的C++函数是一样的,可以声明在类的任何部分(public、private or protected)，可以具有任何参数，也可以被直接调用。</p><p>槽函数与一般的函数不同的是:槽函数可以与一个信号关联(connect)，当信号被发射时， 关联的槽函数被自动执行。</p><p><strong>信号与槽链接方式</strong></p><p><img src="https://gitee.com/Do2eM0N/blogimg/raw/master/202201121318703.png" alt="image-20220112131738342"></p><h3 id="信号与槽链接-一对一"><a href="#信号与槽链接-一对一" class="headerlink" title="信号与槽链接( 一对一)"></a>信号与槽链接( 一对一)</h3><p><strong>mainwindow.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainWindow</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainWindow</span> :</span> <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MainWindow</span><span class="params">(QWidget *parent = <span class="number">0</span>)</span></span>;</span><br><span class="line">    ~MainWindow();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义信号</span></span><br><span class="line">    <span class="comment">//信号的声明</span></span><br><span class="line">    <span class="comment">//信号不用实现也不能实现</span></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Comeon</span><span class="params">(QString&amp; str)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="comment">//同样可以手动添加槽方法-或者在设计模式中添加槽方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">on_WorldBtn_clicked</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">on_CNBtn_clicked</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">on_BJBtn_clicked</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">startSend</span><span class="params">(QString&amp; str)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>mainwindow.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;qdebug.h&gt;</span></span></span><br><span class="line">MainWindow::MainWindow(QWidget *parent) :</span><br><span class="line">    QMainWindow(parent),</span><br><span class="line">    ui(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//链接信号与槽</span></span><br><span class="line">    <span class="comment">//默认是自动关联</span></span><br><span class="line">    <span class="comment">//将信号和处理这个信号的槽方法相连接起来，connect只负责将它们两个链接在一起</span></span><br><span class="line">    <span class="comment">//至于谁发的，就无所谓了。</span></span><br><span class="line">    connect(<span class="keyword">this</span>,SIGNAL(Comeon(QString&amp;)),<span class="keyword">this</span>,SLOT(startSend(QString&amp;)));</span><br><span class="line"> <span class="comment">//或者 //connect(this,&amp;MainWindow::Comeon,this,&amp;MainWindow::startSend);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~MainWindow()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::on_WorldBtn_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//发射信号</span></span><br><span class="line">    QString str = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    <span class="function">emit <span class="title">Comeon</span><span class="params">(str)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::on_CNBtn_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString str = <span class="string">&quot;Hello China!&quot;</span>;</span><br><span class="line">    <span class="function">emit <span class="title">Comeon</span><span class="params">(str)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::on_BJBtn_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString str = <span class="string">&quot;Hello BeiJing!&quot;</span>;</span><br><span class="line">    <span class="function">emit <span class="title">Comeon</span><span class="params">(str)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::startSend</span><span class="params">(QString &amp;str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//打印调试信息</span></span><br><span class="line">     qDebug()&lt;&lt;str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="信号与槽链接-一对多"><a href="#信号与槽链接-一对多" class="headerlink" title="信号与槽链接(一对多)"></a>信号与槽链接(一对多)</h3><p>一个信号对应多个槽方法。可以多个槽响应一个信号。</p><p><strong>示例:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">connect(<span class="keyword">this</span>,SIGNAL(Comeon(QString&amp;)),<span class="keyword">this</span>,SLOT(startSend(QString&amp;)));</span><br><span class="line">connect(<span class="keyword">this</span>,SIGNAL(Comeon(QString&amp;)),<span class="keyword">this</span>,SLOT(HelloCN()));</span><br><span class="line">connect(<span class="keyword">this</span>,SIGNAL(Comeon(QString&amp;)),<span class="keyword">this</span>,SLOT(HelloCHP()));</span><br></pre></td></tr></table></figure><p><strong>注意:<strong>一般情况下多个槽方法的参数个数保持一致，</strong>但是，</strong>有的时候，可以不使用信号传过来的这个参数，所以槽方法的参数个数可以比信号传递的参数个数少，但是，不能比信号传递过来的参数数量多。</p><p> <strong>错误示范:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect(<span class="keyword">this</span>,SIGNAL(Comeon(QString&amp;)),<span class="keyword">this</span>,SLOT(HelloCN(QString&amp;,<span class="keyword">int</span>)));</span><br></pre></td></tr></table></figure><p><strong>链接失败。</strong></p><hr><h3 id="信号与槽链接-多对一"><a href="#信号与槽链接-多对一" class="headerlink" title="信号与槽链接(多对一)"></a>信号与槽链接(多对一)</h3><p> 多个信号链接一个槽方法。进一步反应了信号与槽机制的灵活性。</p><p><strong>示例:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">connect(<span class="keyword">this</span>,SIGNAL(Comeon(QString&amp;)),<span class="keyword">this</span>,SLOT(HelloCHP()));</span><br><span class="line">connect(<span class="keyword">this</span>,SIGNAL(Comeon2()),<span class="keyword">this</span>,SLOT(HelloCHP()));</span><br><span class="line">connect(<span class="keyword">this</span>,SIGNAL(Comeon3()),<span class="keyword">this</span>,SLOT(HelloCHP()));</span><br><span class="line">connect(<span class="keyword">this</span>,SIGNAL(Comeon4()),<span class="keyword">this</span>,SLOT(HelloCHP()));</span><br></pre></td></tr></table></figure><p>参数设置见上《信号与槽链接(一对多)》。</p><hr><h3 id="信号与信号-一对一"><a href="#信号与信号-一对一" class="headerlink" title="信号与信号(一对一)"></a>信号与信号(一对一)</h3><p>当一个信号发射时，发射另一个信号。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect(<span class="keyword">this</span>,SIGNAL(Comeon4()),<span class="keyword">this</span>,SIGNAL(Comeon3())); </span><br></pre></td></tr></table></figure><hr><h3 id="断开信号与槽链接"><a href="#断开信号与槽链接" class="headerlink" title="断开信号与槽链接"></a>断开信号与槽链接</h3><p><strong>断开一个信号和一个与它相链接的槽方法。</strong></p><p>disconnect,参数同connect</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disconnect(<span class="keyword">this</span>,SIGNAL(Comeon(QString&amp;)),<span class="keyword">this</span>,SLOT(startSend(QString&amp;)));</span><br></pre></td></tr></table></figure><p><strong>断开所有与该信号相连接的槽方法。</strong></p><p>与上面不同的是，后两个参数置为0，所有的对象，和所有的槽方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disconnect(<span class="keyword">this</span>,SIGNAL(Comeon(QString&amp;)),<span class="number">0</span>,<span class="number">0</span>),;</span><br></pre></td></tr></table></figure><hr><p><strong>断开指定对象的所有信号与的指定对象的所有槽方法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">qDebug()&lt;&lt;<span class="string">&quot;断开this所有信号与this的所有槽方法的链接&quot;</span>;</span><br><span class="line">disconnect(<span class="keyword">this</span>,<span class="number">0</span>,<span class="keyword">this</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">disconnect(<span class="keyword">this</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);<span class="comment">//断开this所有相关的对象的槽方法的链接</span></span><br></pre></td></tr></table></figure><hr><p><strong>也可以通过connect函数的返回值来断开某个链接。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取返回值</span></span><br><span class="line">......</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">QMetaObject::Connection m_res;<span class="comment">//返回值类型</span></span><br><span class="line">......</span><br><span class="line">       m_res = connect(<span class="keyword">this</span>,SIGNAL(Comeon(QString&amp;)),<span class="keyword">this</span>,SLOT(startSend(QString&amp;)));<span class="comment">//获取返回值</span></span><br><span class="line">......</span><br><span class="line">    disconnect(m_res);<span class="comment">//断开链接</span></span><br></pre></td></tr></table></figure><hr><p><strong>总结-信号与槽机制的优越性:</strong></p><ol><li>信号与槽机制是类型安全的，相关联的信号与槽参数必需匹配(详细解释在上，相关联的槽方法的参数只能少不能多)</li><li>信号与槽是松耦合的，信号发送者不知道也不需要知道接受者的信息。</li><li>信号与槽可以使用任意类型的任意数量的参数。、</li></ol><hr><h2 id="动态属性系统"><a href="#动态属性系统" class="headerlink" title="动态属性系统"></a>动态属性系统</h2><p>在标准C++中，为了保证封装性，我们经常声明一个私有变量，然后声明两个共有函数例如set,get来对这个变量进行操作。</p><p>同理，在QT中我们可以使用宏**Q_PROPERTY()**来实现这些，函数可以使用QObject::property()和QObject::setProperty()。</p><p>在使用的时候，我们不用知道变量的所在类的任何细节，只需要知道名字即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Q_PROPERTY(type name</span><br><span class="line">             (READ getFunction [WRITE setFunction] |</span><br><span class="line">              MEMBER memberName [(READ getFunction | WRITE setFunction)])</span><br><span class="line">             [RESET resetFunction]</span><br><span class="line">             [NOTIFY notifySignal]</span><br><span class="line">             [REVISION <span class="keyword">int</span>]</span><br><span class="line">             [DESIGNABLE <span class="keyword">bool</span>]</span><br><span class="line">             [SCRIPTABLE <span class="keyword">bool</span>]</span><br><span class="line">             [STORED <span class="keyword">bool</span>]</span><br><span class="line">             [USER <span class="keyword">bool</span>]</span><br><span class="line">             [CONSTANT]</span><br><span class="line">             [FINAL])</span><br></pre></td></tr></table></figure><p>  <strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">    Q_PROPERTY(QString mask READ mask WRITE setMask NOTIFY maskChanged)</span><br><span class="line">......</span><br><span class="line">    QObject* obj  = myPc;</span><br><span class="line">    qDebug()&lt;&lt;obj-&gt;property(<span class="string">&quot;mask&quot;</span>).toString();</span><br><span class="line">    qDebug()&lt;&lt;obj-&gt;property(<span class="string">&quot;mask&quot;</span>).toString();</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;QT元对象系统-Meta-Object-System&quot;&gt;&lt;a href=&quot;#QT元对象系统-Meta-Object-System&quot; class=&quot;headerlink&quot; title=&quot;QT元对象系统(Meta-Object-System)&quot;&gt;&lt;/a&gt;QT元对象系统</summary>
      
    
    
    
    <category term="QT" scheme="https://doraemon-hub-art.github.io/categories/QT/"/>
    
    
    <category term="-QT" scheme="https://doraemon-hub-art.github.io/tags/QT/"/>
    
  </entry>
  
  <entry>
    <title>【QT】自定义软件打包发布</title>
    <link href="https://doraemon-hub-art.github.io/2022/01/11/%E3%80%90QT%E3%80%91%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AF%E4%BB%B6%E6%89%93%E5%8C%85%E5%8F%91%E5%B8%83/"/>
    <id>https://doraemon-hub-art.github.io/2022/01/11/%E3%80%90QT%E3%80%91%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AF%E4%BB%B6%E6%89%93%E5%8C%85%E5%8F%91%E5%B8%83/</id>
    <published>2022-01-11T10:29:34.000Z</published>
    <updated>2022-01-11T10:30:47.162Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自定义软件打包发布"><a href="#自定义软件打包发布" class="headerlink" title="自定义软件打包发布"></a>自定义软件打包发布</h1><ul><li>安装nisi和nisedit。</li></ul><p><img src="https://gitee.com/Do2eM0N/blogimg/raw/master/202201111830396.png" alt="image-20220111172214216"></p><ul><li>打开nisedit。</li></ul><p><img src="https://gitee.com/Do2eM0N/blogimg/raw/master/202201111726717.png"></p><ul><li>点击——文件——新建脚本：向导。</li></ul><p><img src="https://gitee.com/Do2eM0N/blogimg/raw/master/202201111729295.png" alt="image-20220111172905248"></p><ul><li>设置名称等信息，点击下一步。</li></ul><p><img src="https://gitee.com/Do2eM0N/blogimg/raw/master/202201111830469.png"></p><ul><li>选择安装图标——设置安装语言，点击下一步。</li></ul><p><img src="https://gitee.com/Do2eM0N/blogimg/raw/master/202201111731748.png"></p><ul><li>选择授权文件(License.txt,里面的内容自定义。)点击下一步。</li></ul><p><img src="https://gitee.com/Do2eM0N/blogimg/raw/master/202201111830536.png" alt="image-20220111173423517"></p><ul><li>选择你的程序相关文件，删掉默认的两个。</li></ul><p><img src="https://gitee.com/Do2eM0N/blogimg/raw/master/202201111830195.png" alt="image-20220111173708350"></p><ul><li>点击添加文件，注意其中部分文件的路径。</li></ul><p><img src="https://gitee.com/Do2eM0N/blogimg/raw/master/202201111830512.png" alt="image-20220111173816372"></p><ul><li>其中要注意的路径，就是带有文件夹的，如下图所示。</li></ul><p><img src="https://gitee.com/Do2eM0N/blogimg/raw/master/202201111830658.png" alt="image-20220111174520365"></p><p><img src="https://gitee.com/Do2eM0N/blogimg/raw/master/202201111830635.png" alt="image-20220111174539381"></p><ul><li>添加完成，选中.exe文件，点击下一步。</li></ul><p><img src="https://gitee.com/Do2eM0N/blogimg/raw/master/202201111747350.png" alt="image-20220111174756306"></p><ul><li>默认，点击下一步。</li></ul><p><img src="https://gitee.com/Do2eM0N/blogimg/raw/master/202201111746544.png" alt="image-20220111174654495"></p><ul><li>选择自述文件，点击下一步。</li></ul><p><img src="https://gitee.com/Do2eM0N/blogimg/raw/master/202201111830098.png" alt="image-20220111174809257"></p><ul><li>设置相关文字消息提示，以及图标。点击下一步。</li></ul><p><img src="https://gitee.com/Do2eM0N/blogimg/raw/master/202201111803351.png" alt="image-20220111180304300"></p><ul><li>将三个选项都勾上，点击完成。</li></ul><p><img src="https://gitee.com/Do2eM0N/blogimg/raw/master/202201111830698.png" alt="image-20220111180406001"></p><ul><li>保存文件，打包完成。</li></ul><p><img src="https://gitee.com/Do2eM0N/blogimg/raw/master/202201111830687.png" alt="image-20220111180457048"></p><p><img src="https://gitee.com/Do2eM0N/blogimg/raw/master/202201111830547.png" alt="image-20220111180522390"></p><hr><h1 id="补充-windeployqt补全相关库"><a href="#补充-windeployqt补全相关库" class="headerlink" title="补充:windeployqt补全相关库"></a>补充:windeployqt补全相关库</h1><p>有可能补的不全，需要手动补充。</p><p>windeployqt ExamSys.exe</p><p>找不到命令添加环境变量。D:\QT5.9.6\5.9.6\mingw53_32\bin</p><p><img src="https://gitee.com/Do2eM0N/blogimg/raw/master/202201111811360.png" alt="image-20220111181158287"></p><p>完成。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;自定义软件打包发布&quot;&gt;&lt;a href=&quot;#自定义软件打包发布&quot; class=&quot;headerlink&quot; title=&quot;自定义软件打包发布&quot;&gt;&lt;/a&gt;自定义软件打包发布&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;安装nisi和nisedit。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img s</summary>
      
    
    
    
    <category term="QT" scheme="https://doraemon-hub-art.github.io/categories/QT/"/>
    
    
    <category term="-QT" scheme="https://doraemon-hub-art.github.io/tags/QT/"/>
    
  </entry>
  
  <entry>
    <title>【MFC】MFC文件操作和注册表操作</title>
    <link href="https://doraemon-hub-art.github.io/2022/01/09/%E3%80%90MFC%E3%80%91MFC%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%92%8C%E6%B3%A8%E5%86%8C%E8%A1%A8%E6%93%8D%E4%BD%9C/"/>
    <id>https://doraemon-hub-art.github.io/2022/01/09/%E3%80%90MFC%E3%80%91MFC%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%92%8C%E6%B3%A8%E5%86%8C%E8%A1%A8%E6%93%8D%E4%BD%9C/</id>
    <published>2022-01-09T04:58:44.000Z</published>
    <updated>2022-01-09T05:24:49.803Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MFC文件和注册表的操作"><a href="#MFC文件和注册表的操作" class="headerlink" title="MFC文件和注册表的操作"></a>MFC文件和注册表的操作</h1><p>日志、操作配置文件、ini文件、注册表、音视频的文件存储。</p><p>Linux下一切皆文件。</p><h2 id="C-C-文件操作"><a href="#C-C-文件操作" class="headerlink" title="C/C++文件操作"></a>C/C++文件操作</h2><h3 id="常量指针和指针常量"><a href="#常量指针和指针常量" class="headerlink" title="常量指针和指针常量"></a>常量指针和指针常量</h3><p>const char*  p == char const *p 常量指针，表示指向的内容为常量，指针的指向可以修改，指针指向的内容不能修改。</p><p>char* const p  指针常量，表示地址是常量，指向不能改变，指向的内容可以改变。 </p><h3 id="C语言文件操作"><a href="#C语言文件操作" class="headerlink" title="C语言文件操作"></a>C语言文件操作</h3><p><strong>文件打开的模式</strong></p><p><img src="https://gitee.com/Do2eM0N/blogimg/raw/master/202201091305850.png" alt="image-20220108164525100"></p><p><strong>示例:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMFCFileView::OnFileWrite</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FILE* pFile = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//打开文件</span></span><br><span class="line"><span class="keyword">errno_t</span> err = _wfopen_s(&amp;pFile,_T(<span class="string">&quot;1.txt&quot;</span>),_T(<span class="string">&quot;w&quot;</span>));</span><br><span class="line"><span class="keyword">if</span> (!err)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">TRACE(<span class="string">&quot;Open Fail ErrorCode = %d&quot;</span>,GetLastError());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">fwrite(_T(<span class="string">&quot;ohguradianbyebye&quot;</span>), <span class="number">2</span>, wcslen(_T(<span class="string">&quot;ohguradianbyebye&quot;</span>))+<span class="number">1</span>, pFile); <span class="comment">//wcslen求宽字符串的长度</span></span><br><span class="line">fclose(pFile);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMFCFileView::OnFileRead</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FILE* pFile = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//打开文件</span></span><br><span class="line"><span class="keyword">errno_t</span> err = _wfopen_s(&amp;pFile, _T(<span class="string">&quot;1.txt&quot;</span>), _T(<span class="string">&quot;r&quot;</span>));</span><br><span class="line"><span class="keyword">if</span> (!err)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">TRACE(<span class="string">&quot;Open Fail ErrorCode = %d&quot;</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">fseek(pFile, <span class="number">0</span>, SEEK_END);<span class="comment">//偏移到结尾位置</span></span><br><span class="line"><span class="keyword">int</span> len = ftell(pFile);<span class="comment">//得到文件指针的当前位置，也就是文件长度。</span></span><br><span class="line">WCHAR *pBuf=<span class="keyword">new</span> WCHAR[len+<span class="number">1</span>];</span><br><span class="line">fseek(pFile,<span class="number">0</span>,SEEK_SET);<span class="comment">//文件指针回到开头位置</span></span><br><span class="line">    <span class="comment">//等同于rewind(pFile);</span></span><br><span class="line">fread(pBuf,<span class="number">2</span>,len,pFile);<span class="comment">//这里是宽字节所以是2</span></span><br><span class="line">pBuf[len] = <span class="number">0</span>;<span class="comment">//确保数组最后一个元素为&#x27;\0&#x27;</span></span><br><span class="line">MessageBox(pBuf);</span><br><span class="line">fclose(pFile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-文件操作"><a href="#C-文件操作" class="headerlink" title="C++文件操作"></a>C++文件操作</h3><p> <strong>ofstream类</strong></p><p><img src="https://gitee.com/Do2eM0N/blogimg/raw/master/202201081815893.png" alt="image-20220108181527795"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMFCFileView::OnFileWrite</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;2.txt&quot;</span>)</span></span>;</span><br><span class="line">ofs.write(<span class="string">&quot;doraemon&quot;</span>,<span class="built_in">strlen</span>(<span class="string">&quot;droaemon&quot;</span>));</span><br><span class="line">ofs. close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMFCFileView::OnFileRead</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;2.txt&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">char</span> pBuf[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">ifs.read(pBuf,<span class="number">100</span>);</span><br><span class="line">USES_CONVERSION;</span><br><span class="line">CString strBuf = A2W(pBuf);</span><br><span class="line">MessageBox(strBuf);</span><br><span class="line">ifs.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Win32-API-MFC文件操作"><a href="#Win32-API-MFC文件操作" class="headerlink" title="Win32 API/MFC文件操作"></a>Win32 API/MFC文件操作</h2><h3 id="Win32-API文件操作"><a href="#Win32-API文件操作" class="headerlink" title="Win32 API文件操作"></a>Win32 API文件操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateFileA</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">//创建或打开的对象的名称</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in]           LPCSTR                lpFileName,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">//访问方式,读、读写，写、查询</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in]           DWORD                 dwDesiredAccess,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">//共享方式</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in]           DWORD                 dwShareMode,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="comment">//NULL不能被子进程继承 </span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional] LPSECURITY_ATTRIBUTES lpSecurityAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">//如何创建文件</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in]           DWORD                dwCreationDisposition,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">//设置文件的属性和标志</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in]           DWORD                 dwFlagsAndAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">//NULL</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional] HANDLE                hTemplateFile</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">WriteFile(</span><br><span class="line">    _In_ HANDLE hFile,</span><br><span class="line">    _In_reads_bytes_opt_(nNumberOfBytesToWrite) LPCVOID lpBuffer,</span><br><span class="line">    <span class="comment">//要写入的字节数</span></span><br><span class="line">    _In_ DWORD nNumberOfBytesToWrite,</span><br><span class="line">    <span class="comment">//用来接收实际写入到文件的字节数</span></span><br><span class="line">    _Out_opt_ LPDWORD lpNumberOfBytesWritten,</span><br><span class="line">    _Inout_opt_ LPOVERLAPPED lpOverlapped</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMFCFileView::OnFileWrite</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HANDLE  hFile;</span><br><span class="line">hFile = CreateFile(_T(<span class="string">&quot;3.txt&quot;</span>),GENERIC_WRITE,<span class="number">0</span>,<span class="literal">NULL</span>,CREATE_NEW,FILE_ATTRIBUTE_NORMAL,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line">TRACE(<span class="string">&quot;%d&quot;</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">DWORD dwwrites;</span><br><span class="line">WriteFile(hFile,<span class="string">&quot;Doraemon&quot;</span>,<span class="built_in">strlen</span>(<span class="string">&quot;Doraemon&quot;</span>),&amp;dwwrites,<span class="literal">NULL</span>);</span><br><span class="line">CloseHandle(hFile);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMFCFileView::OnFileRead</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HANDLE hFile;</span><br><span class="line">hFile = CreateFile(_T(<span class="string">&quot;3.txt&quot;</span>),GENERIC_READ,<span class="number">0</span>,<span class="literal">NULL</span>,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">char</span> pBuf[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">DWORD dwreads;</span><br><span class="line">ReadFile(hFile,pBuf,<span class="number">100</span>,&amp;dwreads,<span class="literal">NULL</span>);</span><br><span class="line">USES_CONVERSION;</span><br><span class="line">CString strBuf = A2W(pBuf);</span><br><span class="line">MessageBox(strBuf);</span><br><span class="line">CloseHandle(hFile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MFC文件操作"><a href="#MFC文件操作" class="headerlink" title="MFC文件操作"></a>MFC文件操作</h3><p><strong>示例:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMFCFileView::OnFileWrite</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">CFile <span class="title">file</span><span class="params">(<span class="string">L&quot;4.txt&quot;</span>,CFile::modeCreate | CFile::modeWrite)</span></span>;</span><br><span class="line">file.Write(<span class="string">&quot;doraemon&quot;</span>,<span class="built_in">strlen</span>(<span class="string">&quot;doraemon&quot;</span>));</span><br><span class="line">file.Close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMFCFileView::OnFileRead</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">CFile <span class="title">file</span><span class="params">(<span class="string">L&quot;4.txt&quot;</span>,CFile::modeRead)</span></span>;</span><br><span class="line"><span class="keyword">char</span>* pBuf;</span><br><span class="line">DWORD dwFileLen = file.GetLength();</span><br><span class="line">pBuf = <span class="keyword">new</span> <span class="keyword">char</span>[dwFileLen + <span class="number">1</span>];</span><br><span class="line">pBuf[dwFileLen] = <span class="number">0</span>;</span><br><span class="line">file.Read(pBuf, dwFileLen);</span><br><span class="line">USES_CONVERSION;</span><br><span class="line">CString strBuf = A2W(pBuf);</span><br><span class="line">MessageBox(strBuf);</span><br><span class="line">file.Close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CFileDialog(</span><br><span class="line">    <span class="comment">//TRUE构建一个打开的对话框，FLASE构建一个保存对话框</span></span><br><span class="line">    BOOL bOpenFileDialog,</span><br><span class="line">    <span class="comment">//指定默认的文件扩展名</span></span><br><span class="line">    LPCTSTR lpszDefExt = <span class="literal">NULL</span>,</span><br><span class="line">    <span class="comment">//初始化文件名NULL默认没有初始文件名</span></span><br><span class="line">    LPCTSTR lpszFileName = <span class="literal">NULL</span>,</span><br><span class="line">    DWORD dwFlags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,</span><br><span class="line">    <span class="comment">//用来指定一个或一组文件的过滤器</span></span><br><span class="line">    LPCTSTR lpszFilter = <span class="literal">NULL</span>,</span><br><span class="line">    <span class="comment">//用来指定文件对话框的父窗口或拥有窗口</span></span><br><span class="line">    CWnd* pParentWnd = <span class="literal">NULL</span>,</span><br><span class="line">    DWORD dwSize = <span class="number">0</span>,</span><br><span class="line">    BOOL bVistaStyle = TRUE);</span><br></pre></td></tr></table></figure><p><strong>例如:创建一个默认保存对话框</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CFileDialog <span class="title">fileDlg</span><span class="params">(FALSE)</span></span>;</span><br><span class="line">fileDlg.DoModal();</span><br></pre></td></tr></table></figure><p><strong>文件夹方式保存读取文件</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMFCFileView::OnFileWrite</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">CFileDialog <span class="title">fileDlg</span><span class="params">(FALSE)</span></span>;</span><br><span class="line">fileDlg.m_ofn.lpstrTitle = <span class="string">L&quot;doraemon&quot;</span>;</span><br><span class="line">fileDlg.m_ofn.lpstrFilter = _T(<span class="string">&quot;Text Files(*.txt)\0*.txt\0All Files(*.*)\0*.*\0\0&quot;</span>);</span><br><span class="line">fileDlg.m_ofn.lpstrDefExt = <span class="string">L&quot;txt&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (fileDlg.DoModal() == IDOK)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">CFile <span class="title">file</span><span class="params">(fileDlg.GetFileName(), CFile::modeCreate | CFile::modeWrite)</span></span>;</span><br><span class="line">USES_CONVERSION;</span><br><span class="line"><span class="keyword">char</span>* szBuf = T2A(fileDlg.GetFileName());</span><br><span class="line">TRACE(<span class="string">&quot;fileDlg.GetFileName()= %s&quot;</span>, szBuf);</span><br><span class="line">file.Write(<span class="string">&quot;ZYXXX&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;ZYXXX&quot;</span>));</span><br><span class="line">file.Close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMFCFileView::OnFileRead</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">CFileDialog <span class="title">fileDlg</span><span class="params">(TRUE)</span></span>;</span><br><span class="line">fileDlg.m_ofn.lpstrTitle = <span class="string">L&quot;doraemon&quot;</span>;</span><br><span class="line">fileDlg.m_ofn.lpstrFilter = _T(<span class="string">&quot;Text Files(*.txt)\0*.txt\0All Files(*.*)\0*.*\0\0&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fileDlg.DoModal() == IDOK)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">CFile <span class="title">file</span><span class="params">(fileDlg.GetFileName(), CFile::modeRead)</span></span>;</span><br><span class="line"><span class="keyword">char</span>* pBuf;</span><br><span class="line">DWORD dwFileLen = file.GetLength();</span><br><span class="line">pBuf = <span class="keyword">new</span> <span class="keyword">char</span>[dwFileLen + <span class="number">1</span>];</span><br><span class="line">pBuf[dwFileLen] = <span class="number">0</span>;</span><br><span class="line">file.Read(pBuf, dwFileLen);</span><br><span class="line">file.Close();</span><br><span class="line">USES_CONVERSION;</span><br><span class="line">CString strBuf = A2W(pBuf );</span><br><span class="line">MessageBox(strBuf);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Do2eM0N/blogimg/raw/master/202201091305759.png" alt="image-20220109101517226"></p><h2 id="配置文件的访问与读写"><a href="#配置文件的访问与读写" class="headerlink" title="配置文件的访问与读写"></a>配置文件的访问与读写</h2><p> <strong>示例:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写配置文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMFCFileView::OnWirteConfig</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//获取当前路径</span></span><br><span class="line">WCHAR strPath[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">GetCurrentDirectoryW(MAX_PATH,strPath);</span><br><span class="line">CString strFilePath;</span><br><span class="line">strFilePath.Format(<span class="string">L&quot;%ls//Test.ini&quot;</span>,strPath);</span><br><span class="line">WritePrivateProfileStringW(<span class="string">L&quot;metadata&quot;</span>,<span class="string">L&quot;title&quot;</span>,<span class="string">L&quot;搜狗双拼&quot;</span>,strFilePath);</span><br><span class="line">WritePrivateProfileStringW(<span class="string">L&quot;声母&quot;</span>,<span class="string">L&quot;ch&quot;</span>,<span class="string">L&quot;I&quot;</span>,strFilePath);</span><br><span class="line">WritePrivateProfileStringW(<span class="string">L&quot;声母&quot;</span>,<span class="string">L&quot;sh&quot;</span>,<span class="string">L&quot;U&quot;</span>,strFilePath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读配置文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMFCFileView::OnReadConfig</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">WCHAR strPath[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">WCHAR strTitle[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">WCHAR strCh[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">WCHAR strSh[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">GetCurrentDirectoryW(MAX_PATH, strPath);</span><br><span class="line">CString strFilePath;</span><br><span class="line">strFilePath.Format(<span class="string">L&quot;%ls//Test.ini&quot;</span>, strPath);</span><br><span class="line">DWORD dwNum1 = GetPrivateProfileStringW(<span class="string">L&quot;metadata&quot;</span>,<span class="string">L&quot;title&quot;</span>,<span class="literal">NULL</span>,strTitle,MAX_PATH,strFilePath);</span><br><span class="line">DWORD dwNum2 = GetPrivateProfileStringW(<span class="string">L&quot;声母&quot;</span>,<span class="string">L&quot;ch&quot;</span>,<span class="literal">NULL</span>,strTitle,MAX_PATH,strFilePath);</span><br><span class="line">DWORD dwNum3 = GetPrivateProfileStringW(<span class="string">L&quot;声母&quot;</span>,<span class="string">L&quot;sh&quot;</span>,<span class="literal">NULL</span>,strTitle,MAX_PATH,strFilePath);</span><br><span class="line">USES_CONVERSION;</span><br><span class="line"><span class="keyword">char</span>* szTitle = W2A(strTitle);</span><br><span class="line"><span class="keyword">char</span>*  szSh = W2A(strSh);</span><br><span class="line"><span class="keyword">char</span>* szCh = W2A(strCh);</span><br><span class="line">TRACE(<span class="string">&quot;strTitle = %s . strCh = %s, strSh = %s&quot;</span>,szTitle,szCh,szSh);<span class="comment">//没读取出来-_-</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="注册表编程"><a href="#注册表编程" class="headerlink" title="注册表编程"></a>注册表编程</h2><p>注册表存储在二进制文件里面，win32 API提供了大量的函数操作注册表。</p><p><strong>创建注册表</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RegCreateKeyW (</span><br><span class="line">    <span class="comment">//打开的当前项句柄,实际上就是那几个分支选项</span></span><br><span class="line">    _In_ HKEY hKey,</span><br><span class="line">    <span class="comment">//打开或创建的表项的名称</span></span><br><span class="line">    _In_opt_ LPCWSTR lpSubKey,</span><br><span class="line">    <span class="comment">//用来接收创建或者打开表项的句柄</span></span><br><span class="line">    _Out_ PHKEY phkResult</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p><strong>打开注册表</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RegOpenKeyW (</span><br><span class="line">    _In_ HKEY hKey,</span><br><span class="line">    _In_opt_ LPCWSTR lpSubKey,</span><br><span class="line">    _Out_ PHKEY phkResult</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p><strong>写入注册表</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RegSetValueW (</span><br><span class="line">   <span class="comment">//打开的当前项句柄,实际上就是那几个分支选项</span></span><br><span class="line">    _In_ HKEY hKey,</span><br><span class="line">    <span class="comment">//打开或者创建的表项的名称</span></span><br><span class="line">    _In_opt_ LPCWSTR lpSubKey,</span><br><span class="line">    <span class="comment">//指示被存储信息的类型REG_SZ类型</span></span><br><span class="line">    _In_ DWORD dwType,</span><br><span class="line">    <span class="comment">//要存放到注册表里面的数据</span></span><br><span class="line">    _In_reads_bytes_opt_(cbData) LPCWSTR lpData,</span><br><span class="line">    <span class="comment">//要存放的字符串数据的大小、长度</span></span><br><span class="line">    _In_ DWORD cbData</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p><strong>扩展——设置注册表项下指定值的数据和类型</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RegSetValueExW(</span><br><span class="line">    <span class="comment">//打开的当前项的句柄，</span></span><br><span class="line">    _In_ HKEY hKey,</span><br><span class="line">    <span class="comment">//指向一个字符串的指针，包含了将要设置值的名称</span></span><br><span class="line">    _In_opt_ LPCWSTR lpValueName,</span><br><span class="line">    <span class="comment">//保留参数 0 </span></span><br><span class="line">    _Reserved_ DWORD Reserved,</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    _In_ DWORD dwType,</span><br><span class="line">    _In_reads_bytes_opt_(cbData) CONST BYTE* lpData,</span><br><span class="line">    _In_ DWORD cbData</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p><strong>从注册表中读取数据</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RegQueryValueW (</span><br><span class="line">    _In_ HKEY hKey,</span><br><span class="line">    _In_opt_ LPCWSTR lpSubKey,</span><br><span class="line">    <span class="comment">//读取的缓存</span></span><br><span class="line">    _Out_writes_bytes_to_opt_(*lpcbData, *lpcbData) __out_data_source(REGISTRY) LPWSTR lpData,</span><br><span class="line">    <span class="comment">//缓存大小</span></span><br><span class="line">    _Inout_opt_ PLONG lpcbData</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p><strong>示例:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写注册表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMFCFileView::OnWriteReg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HKEY hKey;</span><br><span class="line">DWORD dwAge = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//创建注册表项 </span></span><br><span class="line"><span class="keyword">int</span> ret = ::RegCreateKeyW(HKEY_LOCAL_MACHINE, <span class="string">L&quot;SOFTWARE\\Doraemon\\admin&quot;</span>, &amp;hKey);<span class="comment">//创建失败，以管理员方式运行。</span></span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">&#123;</span><br><span class="line">TRACE(<span class="string">&quot;RegCreateKeyW Failed,ErrorCode = %d&quot;</span>, GetLastError());</span><br><span class="line">MessageBox(<span class="string">L&quot;创建注册表失败&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//写注册表</span></span><br><span class="line">ret = ::RegSetValueEx(hKey, <span class="string">L&quot;age&quot;</span>, <span class="number">0</span>, REG_DWORD, (CONST BYTE*) &amp; dwAge, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">if</span> (ret != ERROR_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">TRACE(<span class="string">&quot;RegCreateKeyW Failed,ErrorCode = %d&quot;</span>, GetLastError());</span><br><span class="line">MessageBox(<span class="string">L&quot;写注册表失败&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">::RegCloseKey(hKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读注册表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMFCFileView::OnReadReg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">HKEY hKey;</span><br><span class="line">DWORD dwAge;</span><br><span class="line"><span class="comment">//打开注册表项 </span></span><br><span class="line"><span class="keyword">int</span> ret = ::RegCreateKeyW(HKEY_LOCAL_MACHINE, <span class="string">L&quot;SOFTWARE\\Doraemon\\admin&quot;</span>, &amp;hKey);<span class="comment">//创建失败，以管理员方式运行。</span></span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">&#123;</span><br><span class="line">TRACE(<span class="string">&quot;RegOpenKeyW Failed,ErrorCode = %d&quot;</span>, GetLastError());</span><br><span class="line">MessageBox(<span class="string">L&quot;打开注册表失败&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读注册表</span></span><br><span class="line">DWORD dwType;</span><br><span class="line">DWORD dwValue;</span><br><span class="line"></span><br><span class="line">ret = ::RegQueryValueEx(hKey, <span class="string">L&quot;age&quot;</span>, <span class="number">0</span>, &amp;dwType, (LPBYTE) &amp; dwAge, &amp;dwValue);</span><br><span class="line"><span class="keyword">if</span> (ret != ERROR_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">TRACE(<span class="string">&quot;RegQueryValueEx Failed,ErrorCode = %d&quot;</span>, GetLastError());</span><br><span class="line">MessageBox(<span class="string">L&quot;读注册表失败&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">TRACE(<span class="string">&quot;dwType = %d,dwValue = %d,dwAge = %d&quot;</span>,dwType,dwValue,dwAge);</span><br><span class="line">::RegCloseKey(hKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="文件操作的实际应用"><a href="#文件操作的实际应用" class="headerlink" title="文件操作的实际应用"></a>文件操作的实际应用</h2><ol><li>调试日志debugview,文件日志:警告日志、错误日志。</li><li>视频存储</li><li>文件传输CFile和socket结合使用</li><li>C语言和MFC的文件操作用途广泛，Win32 API、ifstream,ofstream用的少。</li><li>配置文件windows</li><li>注册表操作-病毒-逆向</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MFC文件和注册表的操作&quot;&gt;&lt;a href=&quot;#MFC文件和注册表的操作&quot; class=&quot;headerlink&quot; title=&quot;MFC文件和注册表的操作&quot;&gt;&lt;/a&gt;MFC文件和注册表的操作&lt;/h1&gt;&lt;p&gt;日志、操作配置文件、ini文件、注册表、音视频的文件存储。&lt;</summary>
      
    
    
    
    <category term="MFC" scheme="https://doraemon-hub-art.github.io/categories/MFC/"/>
    
    
    <category term="-MFC" scheme="https://doraemon-hub-art.github.io/tags/MFC/"/>
    
    <category term="-文件操作" scheme="https://doraemon-hub-art.github.io/tags/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>【操作系统】动态链接库</title>
    <link href="https://doraemon-hub-art.github.io/2022/01/08/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/"/>
    <id>https://doraemon-hub-art.github.io/2022/01/08/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/</id>
    <published>2022-01-08T03:05:05.000Z</published>
    <updated>2022-01-08T05:25:32.274Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态链接库"><a href="#动态链接库" class="headerlink" title="动态链接库"></a>动态链接库</h1><p>DLL就是整个windows操作系统的基础。动态链接库不能直接运行，也不能接收消息。他们就是一些独立的文件。</p><p>Windows API中的所有函数都包含在DLL中。</p><p><strong>其中三个最重要的DLL</strong></p><ul><li>Kernel32.dll——它包含用于管理内存、进程和线程的各个函数:CreateThread</li><li>User32.dll——它包含用于指定用户界面任务(如窗口的创建和消息的传送)的各个函数</li><li>GDI32.dll——它包含用于画图和显示文本的各个函数</li></ul><h2 id="静态库和动态库"><a href="#静态库和动态库" class="headerlink" title="静态库和动态库"></a>静态库和动态库</h2><p><strong>静态库:</strong><br>函数和数据被编译进一个二进制文件(通常扩展名为.LIB)。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其他模块组合起来创建最终的可执行文件(.EXE文件)。</p><p><strong>动态库:</strong><br>在使用动态库的时候，往往提供提供两个文件：一个引入库(静态库)(LIB)和一个DLL。引入库包含被DLL导出的函数和变量的符号名,DLL包含实际的函数和数据。<strong>在编译链接</strong>可执行文件时，<strong>只</strong>需要链接引入库，DLL中的函数代码和数据并不复制到可执行文件中，而是在运行时候，再去加载DLL，访问DLL中导出的函数。</p><p><strong>使用动态链接库的好处:</strong></p><ol><li>增强产品的功能(更换界面的DLL)</li><li>提供二次开发的平台(SDK基础版本)</li><li>简化项目管理(串行开发，以多个DLL的方式获取)</li><li>可以节省磁盘空间和内存</li><li>有助于资源的共享(对话框模块，字符串，图标)</li><li>有助于实现应用程序的本地化(多语言版本)</li><li>可以采用多种语言来编写</li></ol><h2 id="使用动态链接库"><a href="#使用动态链接库" class="headerlink" title="使用动态链接库"></a>使用动态链接库</h2><h3 id="创建DLL"><a href="#创建DLL" class="headerlink" title="创建DLL"></a>创建DLL</h3><p> <strong>dumpbin命令</strong></p><p>通过使用这个命令来知道库中导出的都是什么函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//提供给用户用的函数</span></span><br><span class="line"><span class="comment">//应用程序如果要访问某个DLL中的函数，那么函数必须是被导出的函数。</span></span><br><span class="line"><span class="comment">//为了让DLL导出一些函数，需要在每个将要被导出的函数前面加上_declspec(dllexport)</span></span><br><span class="line">_declspec(dllexport)<span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_declspec(dllexport)<span class="function"><span class="keyword">int</span> <span class="title">substract</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Do2eM0N/blogimg/raw/master/202201081325222.png" alt="image-20220107121301863"></p><p><img src="https://gitee.com/Do2eM0N/blogimg/raw/master/202201081325123.png"></p><p>名字改变===名字粉碎，区分不同的函数。</p><h3 id="隐式链接"><a href="#隐式链接" class="headerlink" title="隐式链接"></a>隐式链接</h3><p>lib文件直接复制到当前文件路径下，对应的dll文件也要复制过去。</p><p> 将静态库文件.lib添加到项目属性的链接器-输入-附加依赖项中。</p><p><img src="https://gitee.com/Do2eM0N/blogimg/raw/master/202201071301313.png" alt="image-20220107130111252"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">substract</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDLLMFCTestDlg::OnBnClickedButton1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CString str;</span><br><span class="line">str.Format(<span class="string">L&quot;4+3 = %d&quot;</span>,add(<span class="number">4</span>,<span class="number">3</span>));</span><br><span class="line">MessageBox(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDLLMFCTestDlg::OnBnClickedButton2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CString str;</span><br><span class="line">str.Format(<span class="string">L&quot;4-3 = %d&quot;</span>,substract (<span class="number">4</span>, <span class="number">3</span>));</span><br><span class="line">MessageBox(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用dumpbin -imports XXX.exe查看可执行文件导入了哪些DLL。</p><p>在.exe文件运行的时候，系统将为exe分配一个4GB的地址空间，然后加载模块会分析该应用程序的输入信息，从中找到该程序将要访问的动态链接库信息。然后在用户的机器上搜索这些动态链接库。</p><hr><p>_ declspec(dllexport)与_declspec(dllimport)</p><p>与使用extern关键字这种方式对比，使用_declspec(dllimport)的标识符，它将告诉编译器是从<strong>动态链接库</strong>引入的。</p><p>extern表示函数是外部的全局函数。</p><p>_declspec(dllexport)是在类、函数以及数据的声明的时候使用。把DLL里面的相关代码暴露出来给其他应用程序使用。<strong>提供给别的应用程序使用。</strong>表示提供者。供DLL内部使用。</p><p>_declspec(dllimport)是在外部程序需要使用DLL内相关内容时使用的标识符。<strong>是把DLL中的相关代码插入到应用程序中去。</strong>表示使用者。不是DLL内部使用。</p><p>通常情况下，DLL的实现者和使用者不是同一个人，DLL+头文件方式。</p><p>具体：略……</p><p>头文件建议使用条件指令编译。是使得程序的可读性增强，灵活性增强。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果定义了DLL1_API，则什么也不干，如果没听已，则</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DLL1_API </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL1_API _declspec(dllimport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>   </span></span><br><span class="line"></span><br><span class="line"><span class="function">DLL1_API <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function">DLL1_API <span class="keyword">int</span> <span class="title">substract</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure><hr><h3 id="从DLL中导出C-类"><a href="#从DLL中导出C-类" class="headerlink" title="从DLL中导出C++类"></a>从DLL中导出C++类</h3><p>动态链接库导出整个类和仅导出该类的某些成员函数在实现方式的区别:如果在声明该类时，指定了导出标志，那么该类中所有的函数都被导出，否则只有那些声明时指定了导出标志的类成员才会被导出。</p><hr><h3 id="解决名字改编问题"><a href="#解决名字改编问题" class="headerlink" title="解决名字改编问题"></a>解决名字改编问题</h3><p>编译器在生成DLL时，会对函数名进行改编。</p><p>我们可以使用如下代码防止名字改编:<br>extern “C”</p><p>#define DLL_API extern “c” _declspec(dllexport)</p><p>这样编译器就不会做改变，一个用C语言编写的客户端程序可以调用C++编写的DLL，其缺点就是不能导出一个类的成员函数，只能用于导出全局函数这种情况。</p><p>_stdcall标准的调用约定 C/C++ MFC</p><p>Delphi 用pacal 是从左至右的压栈方式。</p><p>.def文件</p><p>LIBRARY DLLNAME</p><p>EXPORTS //即使调用_stdcall约定，也不会发生改编，而智慧调用这里显示的</p><p>add //字符串</p><p>substract</p><p>EXPORTS语句引入了一个由一个多个definitions(导出的函数或数据)组成的节。每个定义必须在单独一行上。EXPORTS关键字可以在第一个定义所在的同一行上或在前一行上。.def文件可以包含一个或多个EXPORTS语句。</p><p><strong>当DLL中导出函数采用的是标准调用约定时，访问该dll的客户端程序也应该采用该调用约定类型来访问相应的导出函数。</strong></p><h3 id="显式链接-动态方式加载DLL"><a href="#显式链接-动态方式加载DLL" class="headerlink" title="显式链接(动态方式加载DLL)"></a>显式链接(动态方式加载DLL)</h3><p>不需要lib文件。</p><p><strong>LoadLibrary</strong></p><p><strong>注意名字是否被改编，调用的是哪个函数。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDLLMFCTestDlg::OnBnClickedButton1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//动态加载DLL</span></span><br><span class="line">HINSTANCE hInst = LoadLibrary(<span class="string">L&quot;ZYXTDLL.dll&quot;</span>);</span><br><span class="line"><span class="comment">//声明要加载的函数</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*ADDPROC)</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="comment">//从DLL获取函数地址，A通过导出函数的实际函数名</span></span><br><span class="line">ADDPROC Add = (ADDPROC)GetProcAddress(hInst,<span class="string">&quot;?add@@YAHHH@Z&quot;</span>); </span><br><span class="line">    <span class="comment">//或者</span></span><br><span class="line">    ADDPROC Add = (ADDPROC)GetProcAddress(hInst,MAKEINTRESOURCEA(<span class="number">1</span>)); </span><br><span class="line"><span class="keyword">if</span> (!Add)</span><br><span class="line">&#123;</span><br><span class="line">MessageBox(<span class="string">L&quot;获取函数地址失败&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">CString str;</span><br><span class="line">str.Format(<span class="string">L&quot;4+3 = %d&quot;</span>,Add(<span class="number">4</span>,<span class="number">3</span>));</span><br><span class="line">MessageBox(str);</span><br><span class="line">FreeLibrary(hInst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为调用LoadLibrary时动态加载动态链接库，所以不需要头文件和.lib文件。</p><p>如果我们在动态链接库中使用标准调用约定_stdcall，而在可执行程序中使用动态加载DLL，会发生名字重编，如果知道DLL中函数的序号，这时可以使用宏MAKEINTRESOURCE把序号转变成名字。</p><h3 id="DLLMAIN函数"><a href="#DLLMAIN函数" class="headerlink" title="DLLMAIN函数"></a>DLLMAIN函数</h3><p>对可执行模块来说，入口函数是winmain。</p><p>对DLL文件来说，入口函数是DLLMAIN。</p><p>在编写DLL文件时，可以写DLLMAIN也可以不写。</p><p><strong>函数原型</strong></p><p>// 表示动态链接可以的模块句柄，当DLL初次被加载时，句柄可以通过这个参数传递进来。如果某些函数需要使用到当前DLL模块的句柄，那么就可以为该DLL提供DILLMAIN函数，然后通过参数，保存在一个全局变量中，以供其他函数使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">DllMain</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    HINSTANCE hinstDLL,  </span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD fdwReason,     <span class="comment">// reason for calling function</span></span></span></span><br><span class="line"><span class="function"><span class="params">    LPVOID lpReserved )</span>  <span class="comment">// reserved</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Perform actions based on the reason for calling.</span></span><br><span class="line">    <span class="keyword">switch</span>( fdwReason ) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_ATTACH:<span class="comment">//当进程第一次加载DLL并调用DLLMAIN函数</span></span><br><span class="line">         <span class="comment">// Initialize once for each new process.</span></span><br><span class="line">         <span class="comment">// Return FALSE to fail DLL load.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> DLL_THREAD_ATTACH:<span class="comment">//当前进程正在创建一个新线程</span></span><br><span class="line">         <span class="comment">// Do thread-specific initialization.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> DLL_THREAD_DETACH:<span class="comment">//线程结束</span></span><br><span class="line">         <span class="comment">// Do thread-specific cleanup.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_DETACH:<span class="comment">//进程结束</span></span><br><span class="line">         <span class="comment">// Perform any necessary cleanup.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;  <span class="comment">// Successful DLL_PROCESS_ATTACH.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;动态链接库&quot;&gt;&lt;a href=&quot;#动态链接库&quot; class=&quot;headerlink&quot; title=&quot;动态链接库&quot;&gt;&lt;/a&gt;动态链接库&lt;/h1&gt;&lt;p&gt;DLL就是整个windows操作系统的基础。动态链接库不能直接运行，也不能接收消息。他们就是一些独立的文件。&lt;/p&gt;</summary>
      
    
    
    
    <category term="操作系统" scheme="https://doraemon-hub-art.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="-操作系统" scheme="https://doraemon-hub-art.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="-DLL" scheme="https://doraemon-hub-art.github.io/tags/DLL/"/>
    
  </entry>
  
  <entry>
    <title>【操作系统】进程间的通信</title>
    <link href="https://doraemon-hub-art.github.io/2022/01/05/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/"/>
    <id>https://doraemon-hub-art.github.io/2022/01/05/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/</id>
    <published>2022-01-05T10:09:50.000Z</published>
    <updated>2022-01-05T10:14:04.784Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p><strong>程序</strong>是计算机<strong>指令的集合</strong>，它以文件的形式存储在磁盘上。</p><p><strong>进程</strong>通常上被定义为一个正在运行的程序的实例，是一个程序在其自身的地址空间中的一次执行活动，一个程序可以对应多个进程。</p><p>进程是资源申请，高度和独立运行的单位，因此，它使用系统中的运行资源，而程序不能申请使用系统资源，不能被系统高度也不能作为独立运行的单位，因此它不占系统运行资源。</p><h2 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a>进程的组成</h2><ul><li><strong>操作系统用来管理进行的内核对象</strong></li></ul><p>内核对象也是系统用来存放关于进程的统计信息的地方，内核对象是操作系统内部分配的一个内在块，该内存块是一种数据结构，其成员负责维护该对象的各种信息。</p><ul><li><strong>地址空间</strong></li></ul><p>它包含所有可执行模块或DLL模块的代码和数据，另外，它也包含动态内存分配的地址空间，例如线程的栈和堆分配空间。</p><ul><li><strong>进程从来不执行任何东西，它只是纯粹的容器，或说是线程的执行环境。</strong></li></ul><p>若要使它完成某项操作，它必须拥有一个在它环境中运行的的线程，次线程负责执行包含在进程的地址空间中的代码，也就是，真正完成代码执行的线程。</p><h2 id="子进程"><a href="#子进程" class="headerlink" title="子进程"></a>子进程</h2><p>子进程还是一个进程，指的是由另一个进程(对应称之为父进程)所创建的进程。</p><p>单任务的同步机制——线程、子进程都可以实现。</p><p>需要保护地址空间。</p><p>子进程的线程既可以在父进程终止之后执行代码，也可以在父进程运行的过程中执行代码。</p><h2 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h2><p> <strong>CreateProcessW</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">CreateProcess函数</span><br><span class="line">CreateProcessW(</span><br><span class="line">    _In_opt_ LPCWSTR lpApplicationName,<span class="comment">// 该字符串可以指定要执行的模块的完整路径和文件名</span></span><br><span class="line">_Inout_opt_ LPWSTR lpCommandLine,  <span class="comment">//命令行</span></span><br><span class="line"></span><br><span class="line">_In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,</span><br><span class="line"><span class="comment">//该 结构确定子进程是否可以继承返回到新进程对象的句柄。如果//lpProcessAttributes为NULL，则不能继承该句柄</span></span><br><span class="line">_In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,</span><br><span class="line"><span class="comment">//该结构确定子进程是否可以继承返回到新线程对象的句柄。如果//lpThreadAttributes为NULL，则不能继承该句柄</span></span><br><span class="line">_In_ BOOL bInheritHandles,</span><br><span class="line"><span class="comment">//如果此参数为TRUE，则新进程将继承调用进程中的每个可继承句柄。如果参//数为FALSE，则不会继承句柄。请注意，继承的句柄与原始句柄具有相同的值和//访问权限</span></span><br><span class="line">    _In_ DWORD dwCreationFlags,<span class="comment">// 控制优先级类别和流程创建的标志 CREATE_NEW_CONSOLE</span></span><br><span class="line">_In_opt_ LPVOID lpEnvironment,<span class="comment">// 指向新进程的环境块的指针。如果此参数为//NULL，则新进程将使用调用进程的环境</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">    _In_opt_ LPCWSTR lpCurrentDirectory,<span class="comment">// 进程当前目录的完整路径</span></span><br><span class="line">    _In_ LPSTARTUPINFOW lpStartupInfo, <span class="comment">//设置扩展属性</span></span><br><span class="line">    _Out_ LPPROCESS_INFORMATION lpProcessInformation <span class="comment">// 该结构接收有关新进程的标识//信息</span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p> <strong>示例</strong>:创建一个用firefox打开bing的进程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RunExe</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//TCHAR szApplicationName[] = _T(&quot;D:\\Mozilla Firefox\\firefox.exe&quot;);</span></span><br><span class="line">TCHAR szlpCommandLine[] = _T(<span class="string">&quot;\&quot;D:\\Mozilla Firefox\\firefox.exe\&quot;https://cn.bing.com/&quot;</span>);</span><br><span class="line">STARTUPINFO strStartupInfo;</span><br><span class="line"><span class="built_in">memset</span>(&amp;strStartupInfo,<span class="number">0</span>,<span class="keyword">sizeof</span>(strStartupInfo));</span><br><span class="line">strStartupInfo.cb = <span class="keyword">sizeof</span>(strStartupInfo);</span><br><span class="line">PROCESS_INFORMATION szProcessInformation;</span><br><span class="line"><span class="built_in">memset</span>(&amp;szProcessInformation,<span class="number">0</span>,<span class="keyword">sizeof</span>(szProcessInformation));</span><br><span class="line"><span class="keyword">int</span> iRet = CreateProcess(<span class="literal">NULL</span>, szlpCommandLine, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">false</span>,CREATE_NEW_CONSOLE,<span class="literal">NULL</span>,<span class="literal">NULL</span>,&amp;strStartupInfo,&amp;szProcessInformation);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (iRet)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//创建成功</span></span><br><span class="line">WaitForSingleObject(szProcessInformation.hProcess,<span class="number">3000</span>);</span><br><span class="line">CloseHandle(szProcessInformation.hProcess);</span><br><span class="line">CloseHandle(szProcessInformation.hThread);</span><br><span class="line">szProcessInformation.dwProcessId = <span class="number">0</span>;</span><br><span class="line">szProcessInformation.dwThreadId = <span class="number">0</span>;</span><br><span class="line">szProcessInformation.hThread = <span class="number">0</span>;</span><br><span class="line">szProcessInformation.hProcess = <span class="number">0</span>;</span><br><span class="line">printf_s(<span class="string">&quot;Success iRet = %d\n&quot;</span>,iRet);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">printf_s(<span class="string">&quot;Create Failed iRet = %d,errorcode =%d\n&quot;</span>,iRet,GetLastError());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;test\n&quot;</span>);</span><br><span class="line">RunExe();</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h2><ol><li>socket编程——IP和端口</li><li>剪贴板——剪贴板的内核对象</li><li>邮槽——邮槽的内核对象</li><li>匿名管道——内核对象</li><li>命名管道——内核对象</li><li>Copy_data findwindows wm_copydata——消息sendmessage</li></ol><h3 id="剪贴板"><a href="#剪贴板" class="headerlink" title="剪贴板"></a>剪贴板</h3><p>系统维护管理的一块<strong>内存</strong>区域。</p><p><strong>原理</strong>:当一个进程在复制数据时，是将数据放到内存区域中，当另一个进程在粘贴数据时，从该内存区域取出数据，显示到窗口上面。</p><p><strong>示例:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CClipboardDlg::OnBnClickedButton2</span><span class="params">()</span><span class="comment">//发送</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 1 打开剪切板</span></span><br><span class="line"><span class="keyword">if</span> (OpenClipboard())</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//2 清空剪切板</span></span><br><span class="line">EmptyClipboard();</span><br><span class="line"><span class="keyword">char</span>* szSendBuf;</span><br><span class="line"><span class="comment">//3 获取编辑框的内容</span></span><br><span class="line">CStringW strSendW;</span><br><span class="line">GetDlgItemText(IDC_EDIT_SEND, strSendW);</span><br><span class="line"></span><br><span class="line">CStringA strSend = (CStringA)strSendW;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4 分配一个内存对象，内存对象的句柄就是hClip</span></span><br><span class="line">HANDLE hClip = GlobalAlloc(GMEM_MOVEABLE, strSend.GetLength() + <span class="number">1</span>);</span><br><span class="line"><span class="comment">//5 将剪切板句柄加锁</span></span><br><span class="line">szSendBuf = (<span class="keyword">char</span>*)GlobalLock(hClip);</span><br><span class="line"><span class="built_in">strcpy</span>(szSendBuf, strSend);</span><br><span class="line">TRACE(<span class="string">&quot;szSendBuf = %s&quot;</span>, szSendBuf);</span><br><span class="line">GlobalUnlock(hClip);</span><br><span class="line"><span class="comment">//6 将数据放入剪切板</span></span><br><span class="line">SetClipboardData(CF_TEXT, hClip);</span><br><span class="line"><span class="comment">//关闭剪切板</span></span><br><span class="line">CloseClipboard();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CClipboardDlg::OnBnClickedButton3</span><span class="params">()</span><span class="comment">//接收</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (OpenClipboard())</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//确认剪切板是否可用</span></span><br><span class="line"><span class="keyword">if</span> (IsClipboardFormatAvailable(CF_TEXT))</span><br><span class="line">&#123;</span><br><span class="line">HANDLE hClip;</span><br><span class="line"><span class="keyword">char</span>* pBuf;</span><br><span class="line"><span class="comment">//向剪切板要数据</span></span><br><span class="line">hClip = GetClipboardData(CF_TEXT);</span><br><span class="line">pBuf = (<span class="keyword">char</span>*)GlobalLock(hClip);</span><br><span class="line">USES_CONVERSION;</span><br><span class="line">LPCWSTR strBuf = A2W(pBuf);</span><br><span class="line">GlobalUnlock(hClip);</span><br><span class="line">SetDlgItemText(IDC_EDIT_RECV, strBuf);</span><br><span class="line">&#125;</span><br><span class="line">CloseClipboard();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Do2eM0N/blogimg/raw/master/202201051810854.png" alt="image-20220103195035740"></p><h3 id="邮槽"><a href="#邮槽" class="headerlink" title="邮槽"></a>邮槽</h3><p>使用邮槽通信的进程分为服务端和客户端。邮槽有服务端创建，在创建时需要指定邮槽名，创建之后服务端得到邮槽的句柄 。在邮槽创建后，客户端可以通过邮槽名的打开邮槽，在获得句柄后可以向邮槽写入消息。</p><p>邮槽通信是单向的，只有服务端才能从邮槽中读取消息，客户端只能写入消息。消息是先入先出的。客户端先写入的消息在服务端先被读取。</p><p>通过邮槽通信的数据可以是任意格式的，但是一条消息不能大于424字节。</p><p>邮槽除了在本机内进程进程间通信外，在主机间也可以通信。在主机间进程邮槽通信时，数据通过网络传播时使用的是数据包协议(UDP),所以是一种不可靠通信。通过网络进程邮槽通信时，客户端必须知道服务端的主机名或域名。</p><hr><p><strong>示例:</strong></p><p>服务端</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CChildView::OnSlot</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    &quot;\\\\.\\mailslot\\Mymailslot    \\.\mailslot\Mymailslot </span></span><br><span class="line"><span class="comment">//  1  创建一个邮槽</span></span><br><span class="line">LPCTSTR szSlotName = TEXT(<span class="string">&quot;\\\\.\\mailslot\\Mymailslot&quot;</span>);</span><br><span class="line">HANDLE hSlot = CreateMailslot(szSlotName,</span><br><span class="line"><span class="number">0</span>,                             <span class="comment">// no maximum message size </span></span><br><span class="line">MAILSLOT_WAIT_FOREVER,         <span class="comment">// no time-out for operations </span></span><br><span class="line"><span class="literal">NULL</span>); <span class="comment">// default security</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hSlot == INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line">TRACE(<span class="string">&quot;CreateMailslot failed with %d\n&quot;</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 读取数据</span></span><br><span class="line"><span class="keyword">char</span> szBuf[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">DWORD dwRead;</span><br><span class="line">TRACE(<span class="string">&quot;Begin ReadFile&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!ReadFile(hSlot, szBuf, <span class="number">100</span>, &amp;dwRead, <span class="literal">NULL</span>))</span><br><span class="line">&#123;</span><br><span class="line">MessageBox(_T(<span class="string">&quot;读取数据失败&quot;</span>));</span><br><span class="line">CloseHandle(hSlot);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">TRACE(<span class="string">&quot;End ReadFile&quot;</span>);</span><br><span class="line">MessageBox((CStringW)szBuf);</span><br><span class="line">CloseHandle(hSlot);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CChildView::OnSend</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建一个文件句柄</span></span><br><span class="line">LPCTSTR szSlotName = TEXT(<span class="string">&quot;\\\\.\\mailslot\\Mymailslot&quot;</span>);</span><br><span class="line">HANDLEhMailSlot = CreateFile(szSlotName,FILE_GENERIC_WRITE,FILE_SHARE_READ,<span class="literal">NULL</span>,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (hMailSlot == INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line">TRACE(<span class="string">&quot;CreateMail fail with %d\n&quot;</span>,GetLastError());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//写入数据</span></span><br><span class="line"><span class="keyword">char</span> szBuf[] = <span class="string">&quot;ZYX is handsome&quot;</span>;</span><br><span class="line">DWORD dwWrite;</span><br><span class="line"><span class="keyword">if</span> (!WriteFile(hMailSlot,szBuf,<span class="built_in">strlen</span>(szBuf)+<span class="number">1</span>,&amp;dwWrite,<span class="literal">NULL</span>))</span><br><span class="line">&#123;</span><br><span class="line">MessageBox(_T(<span class="string">&quot;写入数据失败&quot;</span>));</span><br><span class="line">CloseHandle(hMailSlot);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">CloseHandle(hMailSlot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h3><p>匿名管道是一个没有命名的单向管道，本质上就是一个共享的内存，抽象成是管道。</p><p>通常用来在父进程和子进程之间通信。只能实现本地两个进程之间的通信。不能实现网络通信。</p><p><strong>优点是效率高，原理本质上就是共享内存。</strong></p><p><strong>CreatePipe</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CreatePipe(</span><br><span class="line">    _Out_ PHANDLE hReadPipe,  <span class="comment">//该变量接收管道的读取句柄</span></span><br><span class="line">    _Out_ PHANDLE hWritePipe,<span class="comment">// 该变量接收管道的写句柄</span></span><br><span class="line">    _In_opt_ LPSECURITY_ATTRIBUTES lpPipeAttributes,<span class="comment">//安全属性NULL-句柄是否能被子进程继承</span></span><br><span class="line">    _In_ DWORD nSize  <span class="comment">//管道缓冲区的大小 0 :默认缓冲区大小</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="命名管道"><a href="#命名管道" class="headerlink" title="命名管道"></a>命名管道</h3><p>与Socket相似，支持网络之间进程的通信。</p><p><strong>CreateNamePipe</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateNamedPipeA</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCSTR                lpName,  <span class="comment">// \.\pipe&lt;i&gt;pipename</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD                 dwOpenMode,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD                 dwPipeMode,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD                 nMaxInstances,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD                 nOutBufferSize,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD                 nInBufferSize,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD                 nDefaultTimeOut,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPSECURITY_ATTRIBUTES lpSecurityAttributes</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>ConnectNamePipe</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">ConnectNamedPipe</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE       hNamedPipe,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPOVERLAPPED lpOverlapped</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p> <strong>示例:</strong><br>服务端</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CChildView::OnCreateNamePipe</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1创建一个命名管道</span></span><br><span class="line">LPCTSTR szhPipeName = TEXT(<span class="string">&quot;\\\\.\\pipe\\mypipe&quot;</span>);</span><br><span class="line">hNamedPipe = CreateNamedPipe(szhPipeName, PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED, PIPE_TYPE_BYTE, <span class="number">1</span>, <span class="number">1024</span>, <span class="number">1024</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (hNamedPipe == INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line">TRACE(<span class="string">&quot;CreateNamedPipe failed with %d\n&quot;</span>, GetLastError());</span><br><span class="line">MessageBox(_T(<span class="string">&quot;创建命名管道失败&quot;</span>));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2等待客户端的连接</span></span><br><span class="line">HANDLE hEvent = CreateEvent(<span class="literal">NULL</span>,TRUE,FALSE,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (hEvent == <span class="literal">NULL</span>)</span><br><span class="line">&#123; </span><br><span class="line">MessageBox(_T(<span class="string">&quot;创建事件失败&quot;</span>));</span><br><span class="line">CloseHandle(hNamedPipe);</span><br><span class="line">hNamedPipe = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">OVERLAPPED ovlap;</span><br><span class="line">ZeroMemory(&amp;ovlap,<span class="keyword">sizeof</span>(OVERLAPPED));</span><br><span class="line">ovlap.hEvent = hEvent;</span><br><span class="line"><span class="keyword">if</span> (!ConnectNamedPipe(hNamedPipe, &amp;ovlap))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(GetLastError() != ERROR_IO_PENDING)</span><br><span class="line">&#123;</span><br><span class="line">MessageBox(_T(<span class="string">&quot;等待客户端连接失败&quot;</span>));</span><br><span class="line">CloseHandle(hNamedPipe);</span><br><span class="line">CloseHandle(hEvent);</span><br><span class="line">hNamedPipe = <span class="literal">NULL</span>;</span><br><span class="line">hEvent = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (WaitForSingleObject(hEvent, INFINITE) == WAIT_FAILED)</span><br><span class="line">&#123;</span><br><span class="line">MessageBox(_T(<span class="string">&quot;等待对象失败&quot;</span>));</span><br><span class="line">CloseHandle(hNamedPipe);</span><br><span class="line">CloseHandle(hEvent);</span><br><span class="line">hNamedPipe = <span class="literal">NULL</span>;</span><br><span class="line">hEvent = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CChildView::OnSreadNamePipe</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//读取数据</span></span><br><span class="line"><span class="keyword">char</span> szBuf[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">DWORD dwRead;</span><br><span class="line"><span class="keyword">if</span> (!ReadFile(hNamedPipe, szBuf, <span class="number">100</span>, &amp;dwRead, <span class="literal">NULL</span>))</span><br><span class="line">&#123;</span><br><span class="line">MessageBox(_T(<span class="string">&quot;读取数据失败&quot;</span>));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">MessageBox((CStringW)szBuf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CChildView::OnSwriteNamePipe</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//写入数据</span></span><br><span class="line"><span class="keyword">char</span> szBuf[] = <span class="string">&quot;ZYX is handsome Server&quot;</span>;</span><br><span class="line">DWORD dwWrite;</span><br><span class="line"><span class="keyword">if</span> (!WriteFile(hNamedPipe, szBuf, <span class="built_in">strlen</span>(szBuf) + <span class="number">1</span>, &amp;dwWrite, <span class="literal">NULL</span>))</span><br><span class="line">&#123;</span><br><span class="line">MessageBox(_T(<span class="string">&quot;写入数据失败&quot;</span>));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CChildView::OnConNamePipe</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LPCTSTR szNamePipeName = TEXT(<span class="string">&quot;\\\\.\\pipe\\mypipe&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (WaitNamedPipe(szNamePipeName, NMPWAIT_WAIT_FOREVER) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">MessageBox(_T(<span class="string">&quot;当前没有可以利用的管道&quot;</span>));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">hNamedPipe = CreateFile(szNamePipeName,GENERIC_READ | GENERIC_WRITE,<span class="number">0</span>,<span class="literal">NULL</span>,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (hNamedPipe == INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line">MessageBox(_T(<span class="string">&quot;打开命名管道失败!&quot;</span>));</span><br><span class="line">hNamedPipe = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CChildView::OnReadNamePipe</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//读取数据</span></span><br><span class="line"><span class="keyword">char</span> szBuf[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">DWORD dwRead;</span><br><span class="line"><span class="keyword">if</span> (!ReadFile(hNamedPipe, szBuf, <span class="number">100</span>, &amp;dwRead, <span class="literal">NULL</span>))</span><br><span class="line">&#123;</span><br><span class="line">MessageBox(_T(<span class="string">&quot;读取数据失败&quot;</span>));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">MessageBox((CStringW)szBuf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CChildView::OnWriteNamePipe</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加命令处理程序代码</span></span><br><span class="line"><span class="comment">//写入数据</span></span><br><span class="line"><span class="keyword">char</span> szBuf[] = <span class="string">&quot;ZYX is handsome Client&quot;</span>;</span><br><span class="line">DWORD dwWrite;</span><br><span class="line"><span class="keyword">if</span> (!WriteFile(hNamedPipe, szBuf, <span class="built_in">strlen</span>(szBuf) + <span class="number">1</span>, &amp;dwWrite, <span class="literal">NULL</span>))</span><br><span class="line">&#123;</span><br><span class="line">MessageBox(_T(<span class="string">&quot;写入数据失败&quot;</span>));</span><br><span class="line">CloseHandle(hNamedPipe);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">CloseHandle(hNamedPipe);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="WM-COPYDATA"><a href="#WM-COPYDATA" class="headerlink" title="WM_COPYDATA"></a>WM_COPYDATA</h3><p>利用WM_COPYDATA这个消息进行通信。</p><p><strong>是最常用、最灵活的进程间通信方式。</strong></p><p>一个应用程序发送WM_COPYDATA消息以将数据传递给另一个应用程序。</p><p><strong>SPY++专门够用来查找窗口句柄。</strong></p><p>要给进程发送数据，首先要拿到该窗口的句柄，也就是要拿到标题(因为句柄有可能会发生变化)。</p><hr><p>发送端:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CWMCOPYDATASENDDlg::OnBnClickedSend</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//必须要知道接收端的标题 句柄 spy工具</span></span><br><span class="line">CString strWindowTitle = _T(<span class="string">&quot;MFCRecv&quot;</span>);</span><br><span class="line">CString strDataToSend = _T(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="comment">//获取句柄</span></span><br><span class="line">HWND hRecvWnd = ::FindWindow(<span class="literal">NULL</span>, strWindowTitle.GetBuffer(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">if</span> (hRecvWnd != <span class="literal">NULL</span> &amp;&amp; ::IsWindow(hRecvWnd))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//数据的封装</span></span><br><span class="line">COPYDATASTRUCT cpd;</span><br><span class="line">cpd.dwData = <span class="number">0</span>;</span><br><span class="line">cpd.cbData = strDataToSend.GetLength()*<span class="keyword">sizeof</span>(TCHAR);</span><br><span class="line">cpd.lpData = (PVOID)strDataToSend.GetBuffer(<span class="number">0</span>);</span><br><span class="line">::SendMessage(hRecvWnd,WM_COPYDATA,(WPARAM)(AfxGetApp()-&gt;m_pMainWnd),(LPARAM)&amp;cpd);</span><br><span class="line">&#125;</span><br><span class="line">strDataToSend.ReleaseBuffer();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接收端：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CWMCOPYDATADlg::OnCopyData</span><span class="params">(CWnd* pWnd, COPYDATASTRUCT* pCopyDataStruct)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//消息响应函数</span></span><br><span class="line"><span class="comment">//解析数据</span></span><br><span class="line">LPCTSTR szText = (LPCTSTR)(pCopyDataStruct-&gt;lpData);</span><br><span class="line">DWORD dwLength = pCopyDataStruct-&gt;cbData;</span><br><span class="line">TCHAR szRecvText[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">memcpy</span>(szRecvText,szText,dwLength);</span><br><span class="line">MessageBox(szRecvText, _T(<span class="string">&quot;Bingo&quot;</span>), MB_OK);</span><br><span class="line"><span class="keyword">return</span> CDialogEx::OnCopyData(pWnd, pCopyDataStruct);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="比较-amp-总结"><a href="#比较-amp-总结" class="headerlink" title="比较&amp;总结"></a>比较&amp;总结</h3><ul><li>剪贴板比较简单，剪贴板和匿名管道只能实现同一机器的两个进程通信。而不能实现网络进程之间的通信。</li><li>邮槽是基于广播的，可以一对多发送。但只能一个发送，一个接收(单向)。</li><li>命名管道和邮槽可以进程网络通信。命名管道只能是点对点的单一通信。</li><li>邮槽的缺点就是传输的数据量很小，424字节以下。</li><li>WM_COPYDATA封装数据非常方便，如果数据量较大，建议使用命名管道。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;headerlink&quot; title=&quot;进程&quot;&gt;&lt;/a&gt;进程&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;程序&lt;/strong&gt;是计算机&lt;strong&gt;指令的集合&lt;/strong&gt;，它以文件的形式存储在磁盘上。&lt;/p&gt;
&lt;p&gt;&lt;s</summary>
      
    
    
    
    <category term="操作系统" scheme="https://doraemon-hub-art.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="-操作系统" scheme="https://doraemon-hub-art.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="-进程" scheme="https://doraemon-hub-art.github.io/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>【操作系统】多线程之线程同步</title>
    <link href="https://doraemon-hub-art.github.io/2022/01/01/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    <id>https://doraemon-hub-art.github.io/2022/01/01/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</id>
    <published>2022-01-01T03:41:31.000Z</published>
    <updated>2022-01-01T03:53:16.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>线程是CPU调度和分派的基本单位。</li><li>进程<ul><li>是分配资源的基本单位。</li><li>等同于正在运行的程序以及它所管理的资源。</li></ul></li></ul><p><img src="https://gitee.com/Do2eM0N/blogimg/raw/master/imges/202201011145151.png" alt="image-20211226150432077"></p><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><ul><li>CreateThread——Windows中创建线程API</li><li>baginthreadex——底层实现是CreateThread</li></ul><p><strong>示例1</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;windows.h&gt;</span><br><span class="line">#include&lt;process.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">unsigned int __stdcall thread_main_dog(void* cnt)</span><br><span class="line">&#123;</span><br><span class="line">    int i &#x3D; *((int*)cnt);</span><br><span class="line">    for (int j &#x3D; 0; j &lt; i; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;www\n&quot;);</span><br><span class="line">        Sleep(1000);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">unsigned int __stdcall thread_main_cat(void* cnt)</span><br><span class="line">&#123;</span><br><span class="line">    int i &#x3D; *((int*)cnt);</span><br><span class="line">    for (int j &#x3D; 0; j &lt; i; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;mmm\n&quot;);</span><br><span class="line">        Sleep(2000);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">unsigned int __stdcall thread_main_bird(void* cnt)</span><br><span class="line">&#123;</span><br><span class="line">    int i &#x3D; *((int*)cnt);</span><br><span class="line">    for (int j &#x3D; 0; j &lt; i; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;jjj\n&quot;);</span><br><span class="line">        Sleep(3000);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;安全属性——线程堆的大小默认为0——线程函数——线程函数的参数——线程的初识状态0表示立即执行——用来接收线程ID</span><br><span class="line">    unsigned int dog_id &#x3D; 0; </span><br><span class="line">    unsigned int cat_id &#x3D; 0; </span><br><span class="line">    unsigned int bird_id &#x3D; 0; </span><br><span class="line">    int count &#x3D; 10;</span><br><span class="line">    _beginthreadex(NULL, 0, thread_main_dog, (void*)&amp;count,0,&amp;dog_id);</span><br><span class="line">    _beginthreadex(NULL, 0, thread_main_cat, (void*)&amp;count,0,&amp;cat_id);</span><br><span class="line">    _beginthreadex(NULL, 0, thread_main_bird, (void*)&amp;count,0,&amp;bird_id);</span><br><span class="line"></span><br><span class="line">    printf(&quot;%d %d %d\n&quot;, dog_id, cat_id, bird_id);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;system(&quot;pause&quot;);</span><br><span class="line">    Sleep(1000000);</span><br><span class="line">    return 0;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>示例2</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;windows.h&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;process.h&gt;</span><br><span class="line"></span><br><span class="line">DWORD WINAPI ThreadFun(LPVOID p)</span><br><span class="line">&#123;</span><br><span class="line">    int temp &#x3D; *((int*)p);</span><br><span class="line">    printf(&quot;我是子线程，PID&#x3D;%d,temp &#x3D; %d\n&quot;, GetCurrentThreadId(),temp);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;我是主线程\n&quot;);</span><br><span class="line">    HANDLE hThread;</span><br><span class="line">    DWORD dwThreadID;</span><br><span class="line">    &#x2F;*</span><br><span class="line">    安全属性，一般填NULL</span><br><span class="line">    线程栈空间大小，0为默认大小1MB</span><br><span class="line">    线程函数地址</span><br><span class="line">    传给线程函数的参数</span><br><span class="line">    指定额外的标志来控制线程的创建*&#x2F;</span><br><span class="line">     int m &#x3D; 10;</span><br><span class="line">    hThread &#x3D; CreateThread(NULL,0,ThreadFun,&amp;m,0,&amp;dwThreadID);</span><br><span class="line">    Sleep(10000);</span><br><span class="line">    &#x2F;&#x2F;关闭线程</span><br><span class="line">    CloseHandle(hThread);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内核对象"><a href="#内核对象" class="headerlink" title="内核对象"></a>内核对象</h2><ul><li>理解内核对象</li></ul><p><strong>定义</strong>：内核对象通过API来创建，每个内核对象是一个数据结构，它对应一块内存， 由操作系统内核分配，并且只能由操作系统内核访问。在此数据结构中少数成员如安全描述符和使用计数是所有对应都有的，但其他大多数成员都是不用类型的对象特有的。内核对象的数据结构只能由操作系统提供的API访问，应用程序在内存中不能访问。调用创建内核对象的函数后，<strong>该函数会返回一个句柄，它标识了所创建的对象</strong>。它可以由进程的任何线程使用。</p><p>**常见的内核对象:**进程、线程、文件、存取符号对象、事件对象、文件对象、作业对象、互斥对象、管道对象、等待计时器对象、邮件槽对象，信号对象。(创建时会产生内核对象。)</p><p>CreateProcess </p><p>CreateThread</p><p>CreateFile</p><p>Job</p><p>Mutex</p><p>……</p><p><strong>内核对象:为了管理线程/文件等资源而由操作系统创建的数据块。</strong></p><p><strong>其创建的所有者肯定是操作系统。</strong></p><p><strong>带create的都是内核对象的创建。</strong></p><h2 id="主线程和子线程的结束时间"><a href="#主线程和子线程的结束时间" class="headerlink" title="主线程和子线程的结束时间"></a>主线程和子线程的结束时间</h2><p>main函数返回后，整个进程终止，同时终止其包含的所有线程。</p><p><strong>示例</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;windows.h&gt;</span><br><span class="line">#include&lt;process.h&gt;</span><br><span class="line"></span><br><span class="line">unsigned   int __stdcall ThreadFunc(LPVOID p)</span><br><span class="line">&#123;</span><br><span class="line">    int cnt &#x3D; *((int*)p);</span><br><span class="line">    for (int i &#x3D; 0; i &lt; cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Sleep(1000);</span><br><span class="line">        printf(&quot;runing thread\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;main begin\n&quot;);</span><br><span class="line">    int iPrarm &#x3D; 5;</span><br><span class="line">    unsigned int dwThreadID;</span><br><span class="line">    HANDLE hThread &#x3D; (HANDLE)_beginthreadex(NULL, 0, ThreadFunc, (void*)&amp;iPrarm, 0, &amp;dwThreadID);</span><br><span class="line">    &#x2F;&#x2F;Sleep(20000);</span><br><span class="line">    printf(&quot;main end\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用WaitForSingleObject来等待一个内核对象变为已通知状态。  </p><h2 id="为什么使用多线程"><a href="#为什么使用多线程" class="headerlink" title="为什么使用多线程"></a>为什么使用多线程</h2><ul><li>避免阻塞</li></ul><p>单个进程只有一个主线程，当主线程阻塞的时候，整个进程也就阻塞了，无法再做其它的有一些功能了。</p><ul><li>避免CPU空转</li></ul><p>应用程序经常会涉及到RPC，数据库访问，磁盘IO等操作，这些操作的速度比CPU慢很多，而在等待这些响应时，CPU却不能去处理新的请求，导致这种单线程的应用程序性能很差。</p><ul><li>提升效率</li></ul><p>一个进程要独立拥有4GB的虚拟地址空间，而多线程可以共享同一地址空间，线程的切换比进程的切换要快得多。</p><p><strong>上下文切换</strong></p><p>分时使用CPU需要进行上下文切换。</p><p><img src="https://gitee.com/Do2eM0N/blogimg/raw/master/imges/202201011143767.png" alt="image-20211228182457603"></p><p><strong>多线程可以理解成一个轻量级的多进程。</strong> </p><p><strong>解释</strong>：每个进程开始执行 时，需要各个区域读到内存中，下一个进程开始执行时，需要将上一个进程的东西读出来放到硬盘中，再将进程B的各个区域读到内存中，这就是上下文切换。而线程间不用，这些区域资源都是共享的，所以线程间要快于进程间通信。</p><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>CPU是抢占式的。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;windows.h&gt;</span><br><span class="line">#include&lt;process.h&gt;</span><br><span class="line">unsigned WINAPI threadDes(void* arg);</span><br><span class="line">unsigned WINAPI threadInc(void* arg);</span><br><span class="line"></span><br><span class="line">#define NUM_THREAD 50</span><br><span class="line">long long num &#x3D; 0;</span><br><span class="line">&#x2F;&#x2F;变量放在内存中，计算机的时候从内存中拿出来在CPU中运算，运算完成的变量放回去</span><br><span class="line">&#x2F;*</span><br><span class="line">  在此案例中，上一次的进程对变量进行操作，还没有来得及将计算后的结果放回内存中(替换原来的变量值)，下一个线程就开始(切换到了)了(下一个进程拿到的变量值还没有改变)，进行相应的操作。</span><br><span class="line">*&#x2F;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    HANDLE tHandles[NUM_THREAD];</span><br><span class="line">    int i;</span><br><span class="line">    printf(&quot;size of long long: %d \n&quot;,sizeof(long long));</span><br><span class="line">    for (i &#x3D; 0; i &lt; NUM_THREAD; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (i % 2)</span><br><span class="line">        &#123;</span><br><span class="line">            tHandles[i] &#x3D; (HANDLE)_beginthreadex(NULL,0,threadInc,NULL,0,NULL);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            tHandles[i] &#x3D; (HANDLE)_beginthreadex(NULL, 0,threadDes,NULL,0,NULL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WaitForMultipleObjects(NUM_THREAD,tHandles,TRUE,INFINITE);&#x2F;&#x2F;等待多个线程结束</span><br><span class="line">    printf(&quot;%d&quot;, num);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unsigned WINAPI threadInc(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 500000; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        num +&#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">unsigned WINAPI threadDes(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for (i &#x3D; 0; i &lt; 500000; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        num -&#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>解决办法</strong>——上一个锁，告诉CPU当前线程正在用这个变量，后面的先别进来。</p><h3 id="线程同步之互斥对象"><a href="#线程同步之互斥对象" class="headerlink" title="线程同步之互斥对象"></a>线程同步之互斥对象</h3><p>CreateMutex——创建互斥对象。</p><p><strong>用互斥体解决上面的这个问题。</strong></p><p><strong>避免产生资源竞争。</strong></p><p>互斥对象属于内核对象，它能够确保线程拥有对当个资源的互斥访问权。</p><p>互斥对象包含一个使用数量，一个线程ID和一个计数器。其线程ID用于标识系统中的哪个线程当前拥有互斥对象，计数器用于指明该线程拥有互斥对象的次数。</p><p>创建互斥对象 :调用CreateMutex，调用成功，该函数返回所创建的互斥对象的句柄。</p><p>请求互斥对象所有权：调用WaitForSingleObject函数。线程必须主动请求共享独享的所有权才能获得所有权。</p><p>释放指定互斥对象的所有权：调用ReleaseMutex函数。线程访问共享资源结束之后，要主动释放对互斥对象的所有权，使该对象处于已通知状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"> #include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;windows.h&gt;</span><br><span class="line">#include&lt;process.h&gt;</span><br><span class="line">unsigned WINAPI threadDes(void* arg);</span><br><span class="line">unsigned WINAPI threadInc(void* arg);</span><br><span class="line"></span><br><span class="line">#define NUM_THREAD 50</span><br><span class="line">long long num &#x3D; 0;</span><br><span class="line">HANDLE hMutex;&#x2F;&#x2F;定义一个互斥体的句柄</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    HANDLE tHandles[NUM_THREAD];</span><br><span class="line">    int i;</span><br><span class="line">    hMutex &#x3D; CreateMutex(NULL, FALSE, NULL);</span><br><span class="line">    &#x2F;&#x2F;临界区——不是一个变量，是一段代码，就是可能会存在前程之间产生资源抢占的代码。</span><br><span class="line">    for (i &#x3D; 0; i &lt; NUM_THREAD; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (i % 2)</span><br><span class="line">        &#123;</span><br><span class="line">            tHandles[i] &#x3D; (HANDLE)_beginthreadex(NULL,0,threadInc,NULL,0,NULL);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            tHandles[i] &#x3D; (HANDLE)_beginthreadex(NULL, 0,threadDes,NULL,0,NULL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WaitForMultipleObjects(NUM_THREAD,tHandles,TRUE,INFINITE);&#x2F;&#x2F;等待多个线程结束</span><br><span class="line">    CloseHandle(hMutex);</span><br><span class="line">    printf(&quot;%d&quot;, num);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unsigned WINAPI threadInc(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">    int i &#x3D; 0; </span><br><span class="line">    WaitForSingleObject(hMutex, INFINITE);</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 500000; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        num +&#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;运行完上面的循环，之后realease之后，下面的线程才能执行。</span><br><span class="line">    ReleaseMutex(hMutex);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">unsigned WINAPI threadDes(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    &#x2F;&#x2F;如果当CPU切换到下一个线程，由于上个线程还没Release，下面的线程只能等待。</span><br><span class="line">    WaitForSingleObject(hMutex, INFINITE);</span><br><span class="line">    for (i &#x3D; 0; i &lt; 500000; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        num -&#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    ReleaseMutex(hMutex);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><p>多线程+SOCKET实现群聊服务器</p><p>服务端</p><ol><li>每来一个连接，服务端起一个线程(安排一个工人维护)</li><li>将收到的消息转发给所有的客户端</li><li>某个连接断开，需要处理断开的连接</li></ol><p>客户端</p><ol><li>连接服务器</li><li>与服务器进行通信</li></ol><p><strong>服务端</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;多线程+socket编程的联合使用</span><br><span class="line">&#x2F;&#x2F;用互斥体进行线程同步</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include&lt;WinSock2.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include&lt;windows.h&gt;</span><br><span class="line">#include&lt;process.h&gt;</span><br><span class="line">#pragma comment(lib,&quot;ws2_32.lib&quot;)</span><br><span class="line"></span><br><span class="line">#define MAX_CLNT 256</span><br><span class="line">#define MAX_BUF_SIZE</span><br><span class="line">&#x2F;&#x2F;SOCKET数组</span><br><span class="line">SOCKET clntSocks[MAX_CLNT];</span><br><span class="line">int clntCnt &#x3D; 0;&#x2F;&#x2F;当前连接上的socket的数量</span><br><span class="line"></span><br><span class="line">HANDLE hMutex;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;发送给所有的客户端</span><br><span class="line">void SendMsg(char* szMsg, int iLen)</span><br><span class="line">&#123;</span><br><span class="line">    WaitForSingleObject(hMutex, INFINITE);</span><br><span class="line">    for (int i &#x3D; 0; i &lt; clntCnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        send(clntSocks[i],szMsg,iLen,0);</span><br><span class="line">    &#125;</span><br><span class="line">    ReleaseMutex(hMutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;处理客户端链接的函数</span><br><span class="line">unsigned WINAPI HandleCln(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">     &#x2F;&#x2F;接收传过来的参数</span><br><span class="line">    SOCKET hClntSock &#x3D; *((SOCKET*)arg);</span><br><span class="line">    int iLen &#x3D; 0;</span><br><span class="line">    char szMsg[MAX_BUF_SIZE] &#x3D; &#123; 0 &#125;;</span><br><span class="line">    &#x2F;&#x2F;进行数据的收发</span><br><span class="line">    &#x2F;&#x2F;while (iLen &#x3D; recv(hClntSock,szMsg,sizeof(szMsg),0) !&#x3D; 0)</span><br><span class="line">    &#x2F;&#x2F;&#123;</span><br><span class="line">    &#x2F;&#x2F;    &#x2F;&#x2F;将收到的信息发送给当前在线的所有客户端——达到群聊的效果</span><br><span class="line">    &#x2F;&#x2F;    SendMsg(szMsg,iLen);</span><br><span class="line">    &#x2F;&#x2F;&#125; </span><br><span class="line"></span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        iLen &#x3D; recv(hClntSock, szMsg, sizeof(szMsg), 0);</span><br><span class="line">       &#x2F;&#x2F; printf(&quot;recv mag &#x3D; %s iLen &#x3D; %d \n&quot;, szMsg, iLen);</span><br><span class="line">        if (iLen &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            SendMsg(szMsg, iLen);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    WaitForSingleObject(hMutex,INFINITE);</span><br><span class="line">    &#x2F;&#x2F;处理客户端断开链接的情况</span><br><span class="line">    for (int j &#x3D;  0; j &lt; clntCnt; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (hClntSock &#x3D;&#x3D; clntSocks[j])</span><br><span class="line">        &#123;</span><br><span class="line">            while (j++ &lt; clntCnt)</span><br><span class="line">            &#123;</span><br><span class="line">                clntSocks[j] &#x3D; clntSocks[j + 1];</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    clntCnt--;</span><br><span class="line">    printf(&quot;此时连接个数:%d\n&quot;, clntCnt);</span><br><span class="line">    ReleaseMutex(hMutex);</span><br><span class="line">    closesocket(hClntSock);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;初始化套接字库</span><br><span class="line">    WORD wVersion;</span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    int err;</span><br><span class="line"></span><br><span class="line">    HANDLE hThread;</span><br><span class="line"></span><br><span class="line">    wVersion &#x3D; MAKEWORD(1, 1);</span><br><span class="line">    err &#x3D; WSAStartup(wVersion, &amp;wsaData);&#x2F;&#x2F;初始化哪个版本的网络库，并且将数据存放到哪里</span><br><span class="line">    if (err)</span><br><span class="line">    &#123;</span><br><span class="line">        return err;</span><br><span class="line">    &#125;</span><br><span class="line">    if (LOBYTE(wsaData.wVersion) !&#x3D; 1 || HIBYTE(wsaData.wVersion) !&#x3D; 1)&#x2F;&#x2F;版本检查</span><br><span class="line">    &#123;</span><br><span class="line">        WSACleanup();&#x2F;&#x2F;清理套接字库</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;创建一个互斥对象</span><br><span class="line">    hMutex &#x3D; CreateMutex(NULL,FALSE,NULL);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建套接字</span><br><span class="line">    SOCKET sockServer &#x3D; socket(AF_INET, SOCK_STREAM, 0);  &#x2F;&#x2F;协议族、协议栈</span><br><span class="line">    &#x2F;&#x2F;准备绑定的信息</span><br><span class="line">    SOCKADDR_IN addrServer;</span><br><span class="line">    addrServer.sin_addr.S_un.S_addr &#x3D; htonl(INADDR_ANY);&#x2F;&#x2F;htonl——</span><br><span class="line">    addrServer.sin_family &#x3D; AF_INET;&#x2F;&#x2F;协议栈</span><br><span class="line">    addrServer.sin_port &#x3D; htons(6000);&#x2F;&#x2F;端口-1024以下的端口是系统保留的，htons——大小端转换,x86小端，网络传输-大端</span><br><span class="line">    &#x2F;&#x2F;绑定到本机</span><br><span class="line">    if (bind(sockServer, (SOCKADDR*)&amp;addrServer, sizeof(SOCKADDR)) &#x3D;&#x3D; SOCKET_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;bing error:%d&quot;,GetLastError());</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;监听</span><br><span class="line">    std::cout &lt;&lt; &quot;Server start at port 6000&quot; &lt;&lt; std::endl;</span><br><span class="line">    if (listen(sockServer, 10) &#x3D;&#x3D; SOCKET_ERROR)&#x2F;&#x2F;第二个参数是最大排队连接的个数</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;listen errornum &#x3D; %d\n&quot;,GetLastError());</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;  </span><br><span class="line">    SOCKADDR_IN addrClient;</span><br><span class="line">    int len &#x3D; sizeof(SOCKADDR);</span><br><span class="line">    printf(&quot;start listen\n&quot;);</span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;此时来的客户端链接</span><br><span class="line">        &#x2F;&#x2F;接收连接请求,返回根据客户端的套接字</span><br><span class="line">        SOCKET sockConnect &#x3D; accept(sockServer, (SOCKADDR*)&amp;addrClient, &amp;len);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;每来一个链接，就起一个线程</span><br><span class="line">        &#x2F;&#x2F;没来一个连接，全局数组+1个成员，最大连接数+1  </span><br><span class="line"></span><br><span class="line">        WaitForSingleObject(hMutex,INFINITE);</span><br><span class="line"></span><br><span class="line">        clntSocks[clntCnt++] &#x3D; sockConnect;&#x2F;&#x2F;当发生客户端链接的时候，这里有可能发生全局变量的竞争，所以加锁</span><br><span class="line">        printf(&quot;有人下机了，此时连接数目%d\n&quot;,clntCnt);</span><br><span class="line">        ReleaseMutex(hMutex);</span><br><span class="line"></span><br><span class="line">        hThread &#x3D; (HANDLE)_beginthreadex(NULL, 0, HandleCln, (void*)&amp;sockConnect, 0, NULL);</span><br><span class="line">        </span><br><span class="line">        printf(&quot;Connect client IP is :%s \n&quot;,inet_ntoa(addrClient.sin_addr));</span><br><span class="line">        printf(&quot;Connect client NUM is :%d \n&quot;,clntCnt);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;关闭套接字</span><br><span class="line">    closesocket(sockServer);</span><br><span class="line">    &#x2F;&#x2F;清理套接字库</span><br><span class="line">    WSACleanup();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>客户端</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;客户端要干什么</span><br><span class="line">&#x2F;*</span><br><span class="line">* 接收服务端的消息——起一个线程用来接收消息</span><br><span class="line">* 发送消息个服务端——起一个线程用来发送消息</span><br><span class="line">* 退出机制 </span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include&lt;WinSock2.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include&lt;windows.h&gt;</span><br><span class="line">#include&lt;process.h&gt;</span><br><span class="line"></span><br><span class="line">#pragma comment(lib,&quot;ws2_32.lib&quot;)</span><br><span class="line"></span><br><span class="line">#define  BUF_SIZE 256 </span><br><span class="line">#define NAME_SIZE 20</span><br><span class="line">char szName[NAME_SIZE] &#x3D; &quot;[DEFAULT]&quot;;</span><br><span class="line">char szMsg[BUF_SIZE];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;接收消息</span><br><span class="line">unsigned WINAPI RecvMsg(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">    SOCKET hClntSock &#x3D; *((SOCKET*)arg);</span><br><span class="line">    char szNameMsg[NAME_SIZE + BUF_SIZE];</span><br><span class="line">    int iLen &#x3D; 0;</span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        iLen &#x3D; recv(hClntSock, szNameMsg, NAME_SIZE + BUF_SIZE - 1, 0);</span><br><span class="line">        &#x2F;&#x2F;服务端断开</span><br><span class="line">        if (iLen &#x3D;&#x3D; -1)</span><br><span class="line">        &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        szNameMsg[iLen] &#x3D; 0;</span><br><span class="line">        fputs(szNameMsg,stdout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;发送消息</span><br><span class="line">unsigned WINAPI SendMsg(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">    SOCKET hClntSock &#x3D; *((SOCKET*)arg);</span><br><span class="line">    char szNameMsg[NAME_SIZE + BUF_SIZE];&#x2F;&#x2F;名字+消息</span><br><span class="line">    &#x2F;&#x2F;循环接收来自于控制台的消息 </span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        fgets(szMsg,BUF_SIZE,stdin);&#x2F;&#x2F;从控制台中获取消息——会发生阻塞</span><br><span class="line">        &#x2F;&#x2F;退出机制——当收到Q or q 就退出</span><br><span class="line">        if (!strcmp(szMsg,&quot;Q\n&quot;) || !strcmp(szMsg,&quot;q\n&quot;))</span><br><span class="line">        &#123;</span><br><span class="line">            closesocket(hClntSock);</span><br><span class="line">            exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">        sprintf(szNameMsg, &quot;%s %s&quot;, szName, szMsg);&#x2F;&#x2F;字符串拼接</span><br><span class="line">        send(hClntSock,szNameMsg,strlen(szNameMsg),0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;带参数的main函数，用命令行启动</span><br><span class="line">int main(int argc,char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;初始化套接字库</span><br><span class="line">    WORD wVersion;</span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    int err;</span><br><span class="line">    SOCKET hSock;</span><br><span class="line">    SOCKADDR_IN servAdr;</span><br><span class="line"></span><br><span class="line">    HANDLE hSThread;</span><br><span class="line">    HANDLE hRThread;</span><br><span class="line">   </span><br><span class="line">    wVersion &#x3D; MAKEWORD(1, 1);</span><br><span class="line">    err &#x3D; WSAStartup(wVersion, &amp;wsaData);&#x2F;&#x2F;初始化哪个版本的网络库，并且将数据存放到哪里</span><br><span class="line">    if (err)</span><br><span class="line">    &#123;</span><br><span class="line">        return err;</span><br><span class="line">    &#125;</span><br><span class="line">    if (LOBYTE(wsaData.wVersion) !&#x3D; 1 || HIBYTE(wsaData.wVersion) !&#x3D; 1)&#x2F;&#x2F;版本检查</span><br><span class="line">    &#123;</span><br><span class="line">        WSACleanup();&#x2F;&#x2F;清理套接字库</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    sprintf(szName,&quot;[%s]&quot;,argv[1]);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;建立Socket</span><br><span class="line">    hSock &#x3D; socket(PF_INET,SOCK_STREAM,0);</span><br><span class="line">    &#x2F;&#x2F;配置端口和地址</span><br><span class="line">    memset(&amp;servAdr,0,sizeof(servAdr));</span><br><span class="line">    servAdr.sin_addr.S_un.S_addr &#x3D; inet_addr(&quot;127.0.0.1&quot;);</span><br><span class="line">    servAdr.sin_family &#x3D; AF_INET;</span><br><span class="line">    servAdr.sin_port &#x3D; htons(6000);</span><br><span class="line">    &#x2F;&#x2F;连接服务器</span><br><span class="line">    if (connect(hSock, (SOCKADDR*)&amp;servAdr, sizeof(servAdr)) &#x3D;&#x3D; SOCKET_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;connect error is %d\n&quot;,GetLastError());</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    &#x2F;&#x2F;起一个用来收消息</span><br><span class="line">    </span><br><span class="line">    hRThread &#x3D; (HANDLE)_beginthreadex(NULL,0,RecvMsg,(void*)&amp;hSock,0,NULL);</span><br><span class="line">      </span><br><span class="line">    &#x2F;&#x2F;起一个线程用来发消息</span><br><span class="line"></span><br><span class="line">    hSThread &#x3D; (HANDLE)_beginthreadex(NULL, 0, SendMsg, (void*)&amp;hSock, 0, NULL);</span><br><span class="line">    </span><br><span class="line">    WaitForSingleObject(hSThread,INFINITE);</span><br><span class="line">    WaitForSingleObject(hRThread,INFINITE);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;关闭套接字</span><br><span class="line">    closesocket(hSock);</span><br><span class="line">    WSACleanup();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="线程同步之事件对象"><a href="#线程同步之事件对象" class="headerlink" title="线程同步之事件对象"></a>线程同步之事件对象</h3><p>事件对象也属于内核对象，它包含以下三个成员:</p><ul><li>使用计数</li><li>用于指明该事件是一个自动重置的事件还是一个人工重置的时间的布尔值；</li><li>用于指明改时间处于已通知状态还是未通知状态的布尔值。</li></ul><p>事件对象有两种类型:人工重置的事件对象和自动重置的事件对象。这两种的区别在于,当人工重置的事件对象得到通知时，等待该事件对象的所有线程均变为可调度线程；而当一个自动重置的事件对象得到通知时，等待该事件对象的线程中只有一个线程变为可调度线程。</p><p>1.创建事件对象</p><p>调用CreateEvent函数创建或打开一个命名的或匿名的事件对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HANDLE CreateEvent( 　　</span><br><span class="line">LPSECURITY_ATTRIBUTES lpEventAttributes, &#x2F;&#x2F; 安全属性 　　</span><br><span class="line">BOOL bManualReset, 　　&#x2F;&#x2F; 复位方式　　TRUE 必须用ResetEvent手动复原  FALSE 自动还原为无信号状态</span><br><span class="line">BOOL bInitialState, 　 &#x2F;&#x2F; 初始状态 　　TRUE 初始状态为有信号状态  FALSE 无信号状态</span><br><span class="line">LPCTSTR lpName 　　　　&#x2F;&#x2F;对象名称 　NULL  无名的事件对象　</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>2.设置事件对象状态</p><p>调用SetEvent函数把指定的事件对象设置为有信号状态。</p><p>3.重置事件对象状态</p><p>调用ResetEvent函数把指定的事件对象设置为无信号状态。</p><p>4.请求事件对象</p><p>线程通过调用WaitForSingleObject函数请求事件对象。</p><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;windows.h&gt;</span><br><span class="line">#include&lt;process.h&gt;</span><br><span class="line">#define STR_LEN 100</span><br><span class="line"></span><br><span class="line">static  char str[STR_LEN];</span><br><span class="line">static HANDLE hEvent;</span><br><span class="line"></span><br><span class="line">unsigned WINAPI  NumberOfA(void* arg)</span><br><span class="line">&#123;   </span><br><span class="line">    int i, cnt &#x3D; 0;</span><br><span class="line">    WaitForSingleObject(hEvent,INFINITE);&#x2F;&#x2F;没有执行,在本个例子中，Num of others肯定会先进行打印， 因为当前行代码正在等待事件的相应</span><br><span class="line">    for ( i &#x3D; 0; str[i] !&#x3D; &#39;\0&#39;; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (str[i] &#x3D;&#x3D; &#39;A&#39;)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;Num of A: %d\n&quot;,cnt);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unsigned WINAPI NumberOfOthers(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">    int i, cnt &#x3D; 0;</span><br><span class="line">    for ( i &#x3D; 0; str[i]!&#x3D; &#39;\0&#39;; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (str[i] !&#x3D; &#39;A&#39;)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;Num of others: %d\n&quot;, cnt-1);&#x2F;&#x2F;减一是减去&#x2F;n这个换行符</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    SetEvent(hEvent);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc,char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    HANDLE hThread1, hThread2;</span><br><span class="line">    fputs(&quot;input string:\n&quot;,stdout);</span><br><span class="line">    fgets(str,STR_LEN,stdin);</span><br><span class="line">    &#x2F;&#x2F;默认安全符-手动-初识状态为无信号状态</span><br><span class="line">    hEvent &#x3D; CreateEvent(NULL, TRUE, FALSE, NULL);</span><br><span class="line">    hThread1 &#x3D; (HANDLE)_beginthreadex(NULL,0,NumberOfA,NULL,0,NULL);</span><br><span class="line">    hThread2 &#x3D; (HANDLE)_beginthreadex(NULL,0,NumberOfOthers,NULL,0,NULL);</span><br><span class="line">    WaitForSingleObject(hThread1, INFINITE);</span><br><span class="line">    WaitForSingleObject(hThread2, INFINITE);</span><br><span class="line">    &#x2F;&#x2F;直到两个线程执行完毕之后，再把事件设置为无信号状态</span><br><span class="line">    ResetEvent(hEvent);</span><br><span class="line">    CloseHandle(hEvent);</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>示例2：AB同时卖票</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;windows.h&gt;</span><br><span class="line">#include&lt;process.h&gt;</span><br><span class="line"></span><br><span class="line">int iTickets &#x3D; 100;</span><br><span class="line">HANDLE g_hEvent;</span><br><span class="line"></span><br><span class="line">DWORD WINAPI SellTicketA(void* lpParam)</span><br><span class="line">&#123;</span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        WaitForSingleObject(g_hEvent,INFINITE);</span><br><span class="line">        if (iTickets &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            Sleep(1);</span><br><span class="line">            iTickets--;</span><br><span class="line">            printf(&quot;A remain %d\n&quot;,iTickets);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        SetEvent(g_hEvent);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DWORD WINAPI SellTicketB(void* lpParam)</span><br><span class="line">&#123;</span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        WaitForSingleObject(g_hEvent, INFINITE);</span><br><span class="line">        if (iTickets &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            Sleep(1);</span><br><span class="line">            iTickets--;</span><br><span class="line">            printf(&quot;B remain %d\n&quot;, iTickets);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        SetEvent(g_hEvent);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    HANDLE hThreadA;</span><br><span class="line">    HANDLE hThreadB;</span><br><span class="line">    hThreadA &#x3D; CreateThread(NULL,0,SellTicketA,NULL,0,0);</span><br><span class="line">    hThreadB &#x3D; CreateThread(NULL,0,SellTicketB,NULL,0,0);</span><br><span class="line">      </span><br><span class="line">    CloseHandle(hThreadA);</span><br><span class="line">    CloseHandle(hThreadB);</span><br><span class="line">    </span><br><span class="line">    g_hEvent &#x3D; CreateEvent(NULL,FALSE,FALSE,NULL);&#x2F;&#x2F;自动还原成无信号状态</span><br><span class="line">    SetEvent(g_hEvent);</span><br><span class="line">    Sleep(4000);</span><br><span class="line">    CloseHandle(g_hEvent);</span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="深入理解Windows内核对象与句柄"><a href="#深入理解Windows内核对象与句柄" class="headerlink" title="深入理解Windows内核对象与句柄"></a>深入理解Windows内核对象与句柄</h3><h4 id="内核对象-1"><a href="#内核对象-1" class="headerlink" title="内核对象"></a>内核对象</h4><p>Windows中每个内核对象都只是一个内存块，它由操作系统内核分配，并只能由操作系统内核进行访问，应用程序不能再内存中定位这些数据结构并直接更改其内容。这个内存块是一个数据结构，其成员维护着与对象相关的信息。<strong>少数成员(安全描述符和使用计数)是所有内核对象都有的，但大多数成员都是不同类型对象持有的。</strong>               </p><h4 id="内核对象的使用计数与声明周期"><a href="#内核对象的使用计数与声明周期" class="headerlink" title="内核对象的使用计数与声明周期"></a>内核对象的使用计数与声明周期</h4><p><strong>内核对象的所有者是操作系统，而非进程。</strong></p><p> 就是说，当进程退出，内核对象不一定会销毁。操作系统内核通过内核对象的使用计数，知道当前有多少个进程正在使用一个特定的内核对象。初次创建内核对象，使用计数为1。当另一个进程获得该内核对象的访问权之后，使用计数加1。</p><p><strong>如果内核对象的使用计数递减为0，操作系统内核就会销毁该内核对象。</strong></p><p>也就是说内核对象在当前进程中创建，但是当前进程退出时，内核对象有可能被另外一个进程访问。这时，<strong>进程退出只会减少当前进程对引用的所有内核对象的使用计数，而不会减少其他进程对内核的使用计数(即使该内核对象由当前进程创建)。</strong>那么内核对象的使用计数未递减为0，操作系统内核不会销毁该内核对象。</p><p><strong>如下图所示</strong>： <img src="https://gitee.com/Do2eM0N/blogimg/raw/master/imges/202112291720195.png" alt="image-20211229172046095"></p><ol><li>进程1退出，2不退出时。内核对象A，B的引用计数减为0，被操作系统内核销毁，而进程1只减少自身对CD的引用计数，不会影响进程2对C、D的引用计数，此时C、D的引用计数不为0，不会被销毁。</li><li>进程2退出，1不退出时。进程2减少自身对C、D的引用次数，不会影响进程1，故A,B,C,D都不会被销毁</li><li>进程1,2均退出时，只要 ABCD不被其它进程使用，内核推向ABCD的引用计数均递减为0，被内核销毁。</li><li>进程1和2均为退出时，内核对象ABCD的引用计数只要有一个递减为0，那么递减为0的内核对象便被内核销毁。</li></ol><h4 id="操作内核对象"><a href="#操作内核对象" class="headerlink" title="操作内核对象"></a>操作内核对象</h4><p>Windows提供了一组函数进行操作内核对象。成功调用一个创建内核对象的函数后，会返回一个句柄，它表示了所创建的内核对象，可由进程中的任何线程使用。在32位进程中，句柄是一个32位值，在64位进程中句柄是一个64位的值。<strong>我们可使用唯一标识内核对象的句柄，调用内核操作函数对内核对象进行操作。</strong></p><h4 id="内核对象与其他类型的对象"><a href="#内核对象与其他类型的对象" class="headerlink" title="内核对象与其他类型的对象"></a>内核对象与其他类型的对象</h4><p>Windows进程中除了内核对象外还有其他类型的对象，比如窗口，菜单，字体等，这些属于用户对象和GDI对象。要区分内核对象与非内核对象，最简单的方法就是查看创建这个对象的函数，几乎所有创建内核对象的函数都有一个允许我们指定<strong>安全属性</strong>的参数。</p><p><strong>注意:</strong></p><ol><li><strong>一个对象是不是内核对象，通常可以看创建此对象API的参数中是否需要PSECURITY_ATTRIBUTES 类型的参数。</strong></li><li>内核对象只是一个内存块，这块内存位与操作系统内核的地址空间，内存块中存放一个数据结构 (此数据结构的成员有如:安全描述符、计数器等)。</li><li>每个进程中有一个句柄表，这个句柄表(handle table) 仅供内核对象使用。</li></ol><p><img src="https://gitee.com/Do2eM0N/blogimg/raw/master/imges/202201011143539.png" alt="image-20211229194401299"></p><p>4.调用创建内核对象的函数后，其实就是相当于操作系统多了一个内存块，这个内存块就是内核对象。 </p><p>5.调用API CreateThread的时候，比仅仅是创建了一个内核对象，引用计数+1，(创建线程的这个函数)还打开(访问)了内核对象，引用计数+1，所以引用计数就变为2了。(<strong>也就是说实际上创建一个内核对象之后，真是的引用计数其实是2</strong>)</p><p>6.当调用CloseHandle(hThread)时 ，系统通过hThread计算出此句柄在句柄表中的索引，然后把那一项标注为空闲可用的项，内核对象的引用计数-1,即此时此内核对象的引用计数为1，之后这个线程句柄与创建的内核对象已经没有任何关系了。</p><p> <strong>就是说你close之后，该句柄已经和内核对象(内存块)没关系了。</strong></p><p>只有当内核对象的引用计数为0的时候，内核对象才会被销毁。</p><p><strong>但是</strong>，我们已经关闭了线程句柄，也就是这个线程句柄已经和这个内核对象已经没有瓜葛了，那么那个内核对象是怎么又可以和此线程联系起来了呢？<strong>——通过创建线程时产生的那个线程ID。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;访问上面已经调用close的线程1的内核对象，线程ID从创建线程1时获取。</span><br><span class="line">headle2 &#x3D; OpenThread(THREAD_QUERY_INFORMATION, FALSE, threadId);</span><br></pre></td></tr></table></figure><h3 id="线程同步之信号量"><a href="#线程同步之信号量" class="headerlink" title="线程同步之信号量"></a>线程同步之信号量</h3><ul><li><p>信号量可以起到类似于限流参观的作用，一个博物馆只能进这么些人同时参观，后来的人需要在后面排队，<strong>信号量就是把门的，满了拦着人不让进，有位置就往里面放人。</strong>每个人就相当于线程。<strong>信号量限制线程。</strong>这个限制的条件(例如:几个人能同时从参观。)是由程序员来决定的。<strong>信号量限制可活动的线程数。</strong></p></li><li><p>信号量类似于事件对象，同样有两个状态：</p><ul><li>触发状态(有信号状态)，表示有可用资源。</li><li>未触发状态(无信号状态)，表示没有可用资源。</li></ul></li><li><p>信号量的组成</p><ul><li>计数器：该内核对象被使用的次数</li><li>最大资源数量: 标识信号量可以控制的最大资源数量(带符号的32位 )</li><li>当前资源数量:  标识当前可用资源的数量(带符号的32位)。即表示<strong>当前开放的资源个数(注意不是剩下资源的个数)， 只有开放的资源才能被线程所申请</strong>。但这些开放的资源不一定被线程占 用完。例如:当前开放5个资源，只有3个线程申请，则还有2个资源可被申请，但如果这时总共是7个线程要使用信号量，显然开放的5个资源是不够的。这时还可以再开放两个，直到达到最大资源数量。</li></ul><p><strong>信号量的规则如下</strong>：</p><ol><li>如果当前资源计数大于0，那么信号量处于触发状态(有信号状态)，表示有可用资源。</li><li>如果当前资源技术等于0，那么信号量属于未触发状态(无信号状态)，表示没有可用资源。</li><li>系统绝对不会让当前资源计数变为负数。</li><li>当前资源计数绝对不会大于最大资源计数。</li></ol></li></ul><p><img src="https://gitee.com/Do2eM0N/blogimg/raw/master/imges/202201011143607.png" alt="image-20211230183831748"></p><p><strong>信号量与互斥量不用的地方在于，信号量允许多个线程再同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。</strong></p><p>信号量对象对线程的同步方式与前面几种方法不同，信号允许多个线程同时使用共享资源。</p><p><strong>类比理解:</strong> 信号量就是停车场保安，线程就是车辆，例如当前停车场已满(所有资源都被占用)，开走一个资源+1(有空车位)，进来一个车-1。(<strong>资源可以理解为“变量——临界区的内容”</strong>)</p><p><strong>创建信号量</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HANDLE</span><br><span class="line">WINAPI</span><br><span class="line">CreateSemaphoreW(</span><br><span class="line">    _In_opt_ LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,  &#x2F;&#x2F; Null 安全属性</span><br><span class="line">_In_ LONG lInitialCount,  &#x2F;&#x2F;初始化时，共有多少个资源是可以用的。 0：未触发状&#x2F;&#x2F;态（无信号状态），表示没有可用资源</span><br><span class="line"></span><br><span class="line">    _In_ LONG lMaximumCount,  &#x2F;&#x2F;能够处理的最大的资源数量   3</span><br><span class="line">    _In_opt_ LPCWSTR lpName   &#x2F;&#x2F;NULL 信号量的名称</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>增加信号量</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WINAPI</span><br><span class="line">ReleaseSemaphore(</span><br><span class="line">    _In_ HANDLE hSemaphore,   &#x2F;&#x2F;信号量的句柄</span><br><span class="line">    _In_ LONG lReleaseCount,   &#x2F;&#x2F;将lReleaseCount值加到信号量的当前资源计数上面 0-&gt; 1</span><br><span class="line">    _Out_opt_ LPLONG lpPreviousCount  &#x2F;&#x2F;当前资源计数的原始值</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p> <strong>关闭句柄</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CloseHandle(</span><br><span class="line">    _In_ _Post_ptr_invalid_ HANDLE hObject</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p><strong>示例</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;process.h&gt;</span><br><span class="line">#include&lt;windows.h&gt;</span><br><span class="line"></span><br><span class="line">static HANDLE semOne;</span><br><span class="line">static HANDLE semTwo;</span><br><span class="line">static int num;</span><br><span class="line"></span><br><span class="line">unsigned WINAPI Read(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i &#x3D; 0;i&lt;5;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        fputs(&quot;Input num:\n&quot;,stdout);</span><br><span class="line">        printf(&quot;begin read\n&quot;);</span><br><span class="line">        WaitForSingleObject(semTwo,INFINITE);&#x2F;&#x2F;等待内核对象semTwo的信号，如果有信号，就继续执行，如果没信号就等待。</span><br><span class="line">        printf(&quot;beginning read\n&quot;);</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;num);</span><br><span class="line">        ReleaseSemaphore(semOne,1,NULL);&#x2F;&#x2F;释放and给semOne一个信号</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">unsigned WINAPI Accu(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">    int sum &#x3D; 0;</span><br><span class="line">    for (int  i &#x3D; 0; i &lt; 5; i++)</span><br><span class="line">    &#123; </span><br><span class="line">        printf(&quot;begin Accu\n&quot;);</span><br><span class="line">        WaitForSingleObject(semOne,INFINITE);&#x2F;&#x2F;等待内核对象semoOne的信号，无信号，等待ing</span><br><span class="line">        printf(&quot;beginning Accu\n&quot;);</span><br><span class="line">        sum +&#x3D; num;</span><br><span class="line">        printf(&quot;sum &#x3D; %d\n&quot;,sum);</span><br><span class="line">        ReleaseSemaphore(semTwo,1,NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;Result: %d\n&quot;,sum);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc,char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    HANDLE hThread1, hThread2;</span><br><span class="line">    semOne &#x3D; CreateSemaphore(NULL, 0, 1, NULL);&#x2F;&#x2F;初始化时没有可用资源，无信号状态最大信号量是1</span><br><span class="line">    semTwo &#x3D; CreateSemaphore(NULL, 1, 1, NULL);&#x2F;&#x2F;有可用资源，有信号状态</span><br><span class="line">    hThread1 &#x3D; (HANDLE)_beginthreadex(NULL,0,Read,NULL,0,NULL); </span><br><span class="line">    hThread2 &#x3D; (HANDLE)_beginthreadex(NULL,0,Accu,NULL,0,NULL);</span><br><span class="line">  </span><br><span class="line">    CloseHandle(semOne);</span><br><span class="line">    CloseHandle(semTwo);</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> ReleaseSemaphore当等待函数返回时，它会将信号量的计数减一。当线程完成使用资源时，它调用 ReleaseSemaphore 将信号量的计数增加一。（<a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-releasesemaphore">链接</a>）</p><h3 id="线程同步之代码段"><a href="#线程同步之代码段" class="headerlink" title="线程同步之代码段"></a>线程同步之代码段</h3><p>关键代码段，也称为临界区，工作在用户方式下。它是指一个<strong>小代码段</strong>，在代码块能够执行前，它必须独占对某些资源的访问权。通常把多线程中访问同一种资源的那部分代码当做关键代码块。</p><p><strong>初始化关键代码段</strong></p><p>调用InitializeCriticalSection函数初始化一个关键代码段。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InitializeCriticalSection(</span><br><span class="line">    _Out_ LPCRITICAL_SECTION lpCriticalSection</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p>该函数只有一个指向CRITICAL_SECTION结构体的指针。</p><p><strong>进入关键代码段</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">VOID</span><br><span class="line">WINAPI</span><br><span class="line">EnterCriticalSection(</span><br><span class="line">    _Inout_ LPCRITICAL_SECTION lpCriticalSection</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p>调用此函数之前，已获得指定的临界区对象的所有权，该函数等待指定的临界区对象的所有权，如果该所有权赋予了调用线程，则该函数就返回；否则该函数会一直等待，从而导致线程等待。</p><p><strong>退出关键代码段</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VOID</span><br><span class="line">WINAPI</span><br><span class="line">LeaveCriticalSection(</span><br><span class="line">    _Inout_ LPCRITICAL_SECTION lpCriticalSection);</span><br></pre></td></tr></table></figure><p>线程使用完临界区所保护的资源之后，需要调用此函数，<strong>释放指定的临界对象的所有权</strong>。</p><p>之后，<strong>其它想要获得该临界区所有权的线程就可以获得该所有权，从而进入关键代码段，访问保护的资源</strong>。</p><p><strong>删除临界区</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WINBASEAPI</span><br><span class="line">VOID</span><br><span class="line">WINAPI</span><br><span class="line">DeleteCriticalSection(</span><br><span class="line">    _Inout_ LPCRITICAL_SECTION lpCriticalSection</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p>当临界区不再需要时，可以调用此函数释放掉该对象，该函数将释放一个没有任何线程所拥有的临界区对象的所有资源。</p><p><strong>当一个代码段调用LeaveCriticalSection之前，其他代码段是无法操作这块代码的。</strong></p><p><strong>示例</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;程序启动，两个线程开启，只有当一个代码块中调用LeaveCriticalSection另一个代码块才能操作临界区对象，这就会使操作这个临界区对象的只有一个。</span><br><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;process.h&gt;</span><br><span class="line">#include&lt;windows.h&gt;</span><br><span class="line"></span><br><span class="line">int iTickets &#x3D; 100;</span><br><span class="line">CRITICAL_SECTION g_cs;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;A B 两个买票窗口</span><br><span class="line"></span><br><span class="line">DWORD  WINAPI SellTicketA(void* lpParrm)</span><br><span class="line">&#123;</span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        EnterCriticalSection(&amp;g_cs);&#x2F;&#x2F;进入临界区(关键代码段)</span><br><span class="line">        if (iTickets &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            Sleep(1);</span><br><span class="line">            iTickets--;</span><br><span class="line">            printf(&quot;A remain %d\n&quot;,iTickets);</span><br><span class="line">            LeaveCriticalSection(&amp;g_cs);&#x2F;&#x2F;进入临界区</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            LeaveCriticalSection(&amp;g_cs);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DWORD  WINAPI SellTicketB(void* lpParrm)</span><br><span class="line">&#123;</span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        EnterCriticalSection(&amp;g_cs);</span><br><span class="line">        if (iTickets &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            Sleep(1);</span><br><span class="line">            iTickets--;</span><br><span class="line">            printf(&quot;B remain %d\n&quot;,iTickets);</span><br><span class="line">            LeaveCriticalSection(&amp;g_cs);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            LeaveCriticalSection(&amp;g_cs);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    HANDLE hThreadA, hThreadB;</span><br><span class="line">    hThreadA &#x3D; CreateThread(NULL,0,SellTicketA,NULL,0,NULL);</span><br><span class="line">    hThreadB &#x3D; CreateThread(NULL,0,SellTicketB,NULL,0,NULL);</span><br><span class="line"></span><br><span class="line">    CloseHandle(hThreadA);</span><br><span class="line">    CloseHandle(hThreadB);</span><br><span class="line">    &#x2F;&#x2F;初始化关键代码块</span><br><span class="line">    InitializeCriticalSection(&amp;g_cs);</span><br><span class="line">    Sleep(4000);</span><br><span class="line">    DeleteCriticalSection(&amp;g_cs);&#x2F;&#x2F;删除临界区(关键代码段)</span><br><span class="line">    </span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程同步之线程死锁"><a href="#线程同步之线程死锁" class="headerlink" title="线程同步之线程死锁"></a>线程同步之线程死锁</h3><p>死锁是指多个线程因竞争资源而造成的一种僵局(互相等待)，若无外力作用，这些进程都将无法向前推进。 </p><p>Enter和Leave要成对出现。</p><p><strong>只有用户态下，发生线程死锁，内核对象是没有死锁的。</strong></p><p>**示例:**死锁情况。</p><p>开启程序，开启线程，线程1进入A代码段，睡1s,切换线程2，进入B代码段，睡1s,此时两个线程相互等待，发生死锁。(<strong>这里用切换，是因为本质上，同一时间CPU只能执行一个任务，显式的多线程是CPU在多个任务之间来回切换，因为速度及快，所以我们理解为多个任务同时进行,也就是多线程。</strong>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &lt;process.h&gt; </span><br><span class="line"></span><br><span class="line">int iTickets &#x3D; 5000;</span><br><span class="line">CRITICAL_SECTION g_csA;</span><br><span class="line">CRITICAL_SECTION g_csB;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; A窗口     B窗口</span><br><span class="line"></span><br><span class="line">DWORD WINAPI SellTicketA(void* lpParam)</span><br><span class="line">&#123;</span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        EnterCriticalSection(&amp;g_csA);&#x2F;&#x2F;进入临界区A</span><br><span class="line">        &#x2F;&#x2F;Sleep(1);</span><br><span class="line">        EnterCriticalSection(&amp;g_csB);&#x2F;&#x2F;进入临界区B</span><br><span class="line">        if (iTickets &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            Sleep(1);</span><br><span class="line">            iTickets--;</span><br><span class="line">            printf(&quot;A remain %d\n&quot;, iTickets);</span><br><span class="line">            LeaveCriticalSection(&amp;g_csB);&#x2F;&#x2F;离开临界区B</span><br><span class="line">            LeaveCriticalSection(&amp;g_csA);&#x2F;&#x2F;离开临界区A</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            LeaveCriticalSection(&amp;g_csB);&#x2F;&#x2F;离开临界区B</span><br><span class="line">            LeaveCriticalSection(&amp;g_csA);&#x2F;&#x2F;离开临界区A</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DWORD WINAPI SellTicketB(void* lpParam)</span><br><span class="line">&#123;</span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        EnterCriticalSection(&amp;g_csB);&#x2F;&#x2F;进入临界区B</span><br><span class="line">        Sleep(1);</span><br><span class="line">        EnterCriticalSection(&amp;g_csA);&#x2F;&#x2F;进入临界区A</span><br><span class="line">        if (iTickets &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            Sleep(1);</span><br><span class="line">            iTickets--;</span><br><span class="line">            printf(&quot;B remain %d\n&quot;, iTickets);</span><br><span class="line">            LeaveCriticalSection(&amp;g_csA);&#x2F;&#x2F;离开临界区A</span><br><span class="line">            LeaveCriticalSection(&amp;g_csB);&#x2F;&#x2F;离开临界区B</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            LeaveCriticalSection(&amp;g_csA);&#x2F;&#x2F;离开临界区A</span><br><span class="line">            LeaveCriticalSection(&amp;g_csB);&#x2F;&#x2F;离开临界区B</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    HANDLE hThreadA, hThreadB;</span><br><span class="line">    hThreadA &#x3D; CreateThread(NULL, 0, SellTicketA, NULL, 0, NULL);  &#x2F;&#x2F;2</span><br><span class="line">    hThreadB &#x3D; CreateThread(NULL, 0, SellTicketB, NULL, 0, NULL);  &#x2F;&#x2F;2</span><br><span class="line">    CloseHandle(hThreadA); &#x2F;&#x2F;1</span><br><span class="line">    CloseHandle(hThreadB); &#x2F;&#x2F;1</span><br><span class="line">    InitializeCriticalSection(&amp;g_csA); &#x2F;&#x2F;初始化关键代码段A</span><br><span class="line">    InitializeCriticalSection(&amp;g_csB); &#x2F;&#x2F;初始化关键代码段B</span><br><span class="line">    Sleep(40000);</span><br><span class="line">    DeleteCriticalSection(&amp;g_csA);&#x2F;&#x2F;删除临界区</span><br><span class="line">    DeleteCriticalSection(&amp;g_csB);&#x2F;&#x2F;删除临界区</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程同步比较"><a href="#线程同步比较" class="headerlink" title="线程同步比较"></a>线程同步比较</h3><p><strong>Windows线程同步的方式主要有四种:</strong></p><ul><li>互斥对象</li><li>事件对象</li><li>信号量</li><li>关键代码块</li></ul><p><strong>区别:</strong></p><ul><li>互斥对象和事件对象以及信号量都属于<strong>内核对象</strong>，利用内核对象进行线程同步时，<strong>速度较慢</strong>，但利用互斥对象和事件对象这样的内核对象，<strong>可以在多个进程中个各个线程间进行同步</strong>。</li><li>关键代码块工作在<strong>用户方式</strong>下，同步速度较快，但在使用关键底代码块时，很容易进入死锁状态，因为在等待进入关键代码段时无法设定超时值。</li></ul><p>用户级别的:关键代码段，只能本进程中。</p><p>内核级别的:互斥量/事件/信号量，可以跨进程。</p><p><strong>通常，在编写多线程程序并需要实现线程同步时，首先关键代码块，因为它的使用比较简单。</strong></p><p>如果是在MFC中使用的话，可以在类的构造函数initxxx中调用InitializeCriticalSection函数，在该类的析构函数中调用DeleteCriticalSection函数，在所需要保护的代码前调通用EnterCriticalSection函数，在访问完所需保护的资源后，调用LeaveCriticalSection函数。</p><p><strong>需要注意的是:</strong> A在调用了EnterCriticalSection后，要相应的调用LeaveCriticalSection函数，否则其他等待该临界区对象所有权的线程将无法执行。</p><p>B如果访问关键代码段时，使用了多个临界区对象，就要注意防止线程死锁的发生。</p><p><strong>另外</strong>，如果需要在多个进程间的各个线程间实现同步的话，可以使用互斥对象和事件对象或者信号量。</p><p><strong>总结图:</strong> <img src="https://gitee.com/Do2eM0N/blogimg/raw/master/imges/202201011107236.png" alt="image-20220101110746152"></p><p><strong>什么是线程安全？</strong> 假如你的代码在多线程执行和单线程执行永远是完全一样的结果，那么你的代码是线程安全的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;多线程&quot;&gt;&lt;a href=&quot;#多线程&quot; class=&quot;headerlink&quot; title=&quot;多线程&quot;&gt;&lt;/a&gt;多线程&lt;/h1&gt;&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概</summary>
      
    
    
    
    <category term="操作系统" scheme="https://doraemon-hub-art.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="-操作系统" scheme="https://doraemon-hub-art.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="-多线程" scheme="https://doraemon-hub-art.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>宏碁暗影骑士擎安装双系统踩坑记录</title>
    <link href="https://doraemon-hub-art.github.io/2021/12/26/%E5%AE%8F%E7%A2%81%E6%9A%97%E5%BD%B1%E9%AA%91%E5%A3%AB%E6%93%8E%E5%AE%89%E8%A3%85%E5%8F%8C%E7%B3%BB%E7%BB%9F%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <id>https://doraemon-hub-art.github.io/2021/12/26/%E5%AE%8F%E7%A2%81%E6%9A%97%E5%BD%B1%E9%AA%91%E5%A3%AB%E6%93%8E%E5%AE%89%E8%A3%85%E5%8F%8C%E7%B3%BB%E7%BB%9F%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</id>
    <published>2021-12-26T13:59:23.000Z</published>
    <updated>2022-01-01T04:04:57.269Z</updated>
    
    <content type="html"><![CDATA[<p><strong>宏碁暗影骑士擎安装Ubuntu 20.04.3 + Windows10</strong></p><p>本文用来记录笔者前两天安装双系统所遇到的问题，解决的困难只局限于宏碁暗影骑士擎，其它电脑没准不适用。</p><ul><li>安装视频推荐——<a href="https://www.bilibili.com/video/BV1554y1n7zv?from=search&seid=5406529348841572890&spm_id_from=333.337.0.0">Windows 和 Ubuntu 双系统安装指南</a>,这个up主讲的很详细，跟着视频一步一步做就可以。</li><li>我的U盘用<strong>Win32DiskImager</strong>写入镜像之后提示需要格式化才能打开，所以我用的是<strong>rufus</strong>，这个问题该视频评论下面有人提到。</li><li>安装Unbuntu时提示，<strong>turn off rst</strong>,开机猛按F2进入bios设置，在main界面按<strong>ctrl+s</strong>,进入bios高级设置，将sata mode 修改为<strong>ahci</strong>,即可完成正常安装。</li><li>安装完成之后发现无法正常进入win10，因为修改了sata mode,解决办法参考这个博主的文章，完美解决问题——<a href="https://blog.csdn.net/weixin_45658858/article/details/107307523">双系统之下更改Windows硬盘启动方式为AHCI（不用重装系统）</a>。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;宏碁暗影骑士擎安装Ubuntu 20.04.3 + Windows10&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文用来记录笔者前两天安装双系统所遇到的问题，解决的困难只局限于宏碁暗影骑士擎，其它电脑没准不适用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安装视频推荐——&lt;a hr</summary>
      
    
    
    
    <category term="计算机" scheme="https://doraemon-hub-art.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
    <category term="-Linux" scheme="https://doraemon-hub-art.github.io/tags/Linux/"/>
    
    <category term="-windows" scheme="https://doraemon-hub-art.github.io/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>【C++】C++日常积累(没啥用).md</title>
    <link href="https://doraemon-hub-art.github.io/2021/12/10/%E3%80%90C++%E3%80%91C++%E6%97%A5%E5%B8%B8%E7%A7%AF%E7%B4%AF(%E6%B2%A1%E5%95%A5%E7%94%A8)/"/>
    <id>https://doraemon-hub-art.github.io/2021/12/10/%E3%80%90C++%E3%80%91C++%E6%97%A5%E5%B8%B8%E7%A7%AF%E7%B4%AF(%E6%B2%A1%E5%95%A5%E7%94%A8)/</id>
    <published>2021-12-10T08:14:18.000Z</published>
    <updated>2021-12-10T08:19:12.995Z</updated>
    
    <content type="html"><![CDATA[<hr><p><strong>前言</strong>:</p><p>本篇文章用来记录我想到或者没注意过的小概念or知识等。</p><hr><p>2021.12.10</p><ul><li>重写是对于继承关系来说的，并不是必须加virtual,直接在子类中实现不同的定义即可 。</li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;本篇文章用来记录我想到或者没注意过的小概念or知识等。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;2021.12.10&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重写是对于继承关系来说的，并不是必须加virtual,直接在子类中实现不同的定义</summary>
      
    
    
    
    <category term="C++" scheme="https://doraemon-hub-art.github.io/categories/C/"/>
    
    
    <category term="-C++" scheme="https://doraemon-hub-art.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【MySQL】MySQL基础知识总结</title>
    <link href="https://doraemon-hub-art.github.io/2021/11/26/%E3%80%90MySQL%E3%80%91MySQL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%20/"/>
    <id>https://doraemon-hub-art.github.io/2021/11/26/%E3%80%90MySQL%E3%80%91MySQL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%20/</id>
    <published>2021-11-26T12:17:10.000Z</published>
    <updated>2021-11-27T05:39:34.332Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="数据库概念"><a href="#数据库概念" class="headerlink" title="数据库概念"></a>数据库概念</h3><blockquote><p>数据库就是按照数据结构来组织、存储和管理数据，建立在计算存储设备上的仓库。可以看成是电子化的文件柜，也就是存储电子 文件的处所，用户可以对文件中的数据进行进行新增、查询、更新、删除等操作。</p></blockquote><h3 id="为什么要使用数据库？"><a href="#为什么要使用数据库？" class="headerlink" title="为什么要使用数据库？"></a>为什么要使用数据库？</h3><p>随着，应用程序的功能越来越复杂，数据量越来越大，如何管理这些数据就成了一个 大问题。</p><ul><li>读写文件的并解析出数据需要大量重复代码</li><li>从成千上万的数据中快速查询出指定数据需要复杂的逻辑</li><li>数据缺乏安全感</li></ul><p>如果每个应用程序都各自写自己的读写数据代码，一方面效率低，容易出错，另一方面，每个应用程序访问数据的接口都不同，数据难以复用。</p><p><strong>所以</strong></p><blockquote><p>数据库作为一种转门管理数据的软件就出现了。应用程序不需要自己管理数据，而是通过数据库软件提供的接口来读写数据。至于数据本身如何存储到文件，那是数据库软件的事情， 应用程序自己并不关心。</p></blockquote><p>这样一来，编写应用程序的时候，数据读写的功能就被大大地简化了。</p><h3 id="MySql简介"><a href="#MySql简介" class="headerlink" title="MySql简介"></a>MySql简介</h3><blockquote><p>MySql作为一种开源的轻量级数据库（<strong>关系型数据库</strong>），在开源数据库中比较流行，由于小巧安装方便快捷，经常会用于互联网公司， 维护也比较方便。因为开源，使用上比较灵活，mysql还有许多第三方的存储引擎，可以根据自己的需要安装。在功能上mysql可能没有oracle强大，但是对于资源的占用非常少，数据恢复快。在维护上，追求稳定的是性能和易用性。</p></blockquote><p>选择数据库时，既要考虑成本，还要考虑维护的稳定性和便利性， 需要 结合我们的业务，如果提高安全性，海量数据，能承担高昂的成本，可以选择oracle, 一般应用的快速查询，高并发访问，一般情况下都可以选择mysql，另外特殊情况特殊处理。</p><p><strong>优势</strong>：</p><ol><li>开源</li><li>成本低</li><li>快平台性</li><li>容易使用</li></ol><h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><h3 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h3><p>关系数据库是建立在关系模型上的。而关系模型本质上就是若干个存储数据的二维表，可以吧他们看作很多Excel表。</p><p><strong>例如</strong>:</p><p><img src="/images/MySql.assets/image-20211011195309404.png" alt="image-20211011195309404"></p><blockquote><p>表的每一行称为记录(Record),记录是一个逻辑上的数据。</p></blockquote><blockquote><p>表的每一列称为字段(Column),同一个表的每一刚记录都拥有相同的若干字段。</p></blockquote><blockquote><p>字段定义了数据类型（整型、浮点型、字符串、日期等），以及是否允许为NULL。注意NULL表示字段数据不存在。一个整型字段如果为NULL不表示它的值为0，同样的，一个字符串型字段为NULL也不表示它的值为空串’’。</p><p>通常情况下，字段应该避免允许为NULL。不允许为NULL可以简化查询条件，加快查询速度，也利于应用程序读取数据后无需判断是否为NULL。</p></blockquote><p>和Excel表有所不同的是，关系数据库的表和表之间需要建立“一对多”，“多对一”和“一对一”的关系，这样才能够按照应用程序的逻辑来组织和存储数据。</p><p><img src="/images/MySql.assets/image-20211013151630595.png" alt="image-20211013151630595"></p><p>每一行对应着一个班级，而一个班级对应着多个学生，所以班级表和学生表的关系就是“一对多”：</p><p><img src="/images/MySql.assets/image-20211013151657803.png" alt="image-20211013151657803"></p><p>反过来，如果我们先在学生表中定位了一行记录，例如ID=1的小花，要确定他的班级，只需要根据他的“班级ID”对应的值101找到班级表中ID=101的记录，即六年级一班。所以，学生表和班级表是“多对一”的关系。</p><p>如果我们把班级表分拆得细一点，例如，单独创建一个教师表：</p><p><img src="/images/MySql.assets/image-20211013151803516.png" alt="image-20211013151803516"></p><h3 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a>查看数据库</h3><p>像文件一样，数据库也能进行如下操作。</p><blockquote><p>（windows下不区分大小写<strong>，</strong>Linux下区分大小写。）</p><p>注意结尾的分号;(就像写C/C++一样)</p></blockquote><hr><ol><li>创建数据库</li><li>查看数据库</li><li>选择数据库</li><li>删除数据库</li></ol><p>在创建数据库之前，可以使用SHOW语句来显示当前已经存在的数据库，如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW DATABASES;</span><br></pre></td></tr></table></figure><p>因为数据库本身的需要，所以它默认自带了几个库。不要随意删除，否则可能会无法正常运行数据库。</p><p><img src="/images/MySql.assets/image-20211013155948125.png" alt="image-20211013155948125"></p><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><blockquote><p>创建数据库是指在数据库系统中划分一块空间，用来存储相应的数据，这是进行表操作的基础，也是进行数据库管理的基础。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE database_name(数据库的名字);</span><br></pre></td></tr></table></figure><p><strong>例如</strong>：<br><img src="/images/MySql.assets/image-20211013161521948.png" alt="image-20211013161521948"></p><p>再SHOW</p><p><img src="/images/MySql.assets/image-20211013161601379.png" alt="image-20211013161601379"></p><h3 id="选择数据库"><a href="#选择数据库" class="headerlink" title="选择数据库"></a>选择数据库</h3><p>在对数据库进行操作之前，应该先选择一个数据库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USE database_name(要记性操作的数据库名字); </span><br></pre></td></tr></table></figure><p>要选择已存在的库，否则会报错。</p><p><img src="/images/MySql.assets/image-20211013175924548.png" alt="image-20211013175924548"></p><h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP DATABASE database_name;</span><br></pre></td></tr></table></figure><p>要删除已有的数据库，  否则会报错。</p><p><img src="/images/MySql.assets/image-20211013180400284.png" alt="image-20211013180400284"></p><p>成功删除提示。</p><p><img src="/images/MySql.assets/image-20211013180433402.png" alt="image-20211013180433402"></p><h3 id="数据库命名规范"><a href="#数据库命名规范" class="headerlink" title="数据库命名规范"></a>数据库命名规范</h3><blockquote><p>可以采用26个英文字母 (不区分大小写) 和0-9的自然数 (一般不需要) 加上下划线 _ 组成，命名简介明确 (Student_Age)，多个单词用下划线 ‘_’ 分隔，一个项目一个数据库，多个项目慎用同一个数据库!!!</p></blockquote><h2 id="数据表的操作"><a href="#数据表的操作" class="headerlink" title="数据表的操作"></a>数据表的操作</h2><blockquote><p>表是一种很重要的数据库对象，是组成数据库的基本元素，由若干个字段组成，主要用来实现存储数据记录。表的操作包含创建表、查询表、修改表和删除表，这些操作是数据库对象的表管理中最基本也是最重要的操作。</p></blockquote><h3 id="创建一个班级表"><a href="#创建一个班级表" class="headerlink" title="创建一个班级表"></a>创建一个班级表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create database school;   #创建数据库school</span><br><span class="line"></span><br><span class="line">mysql&gt; use school;   #选择数据库school </span><br><span class="line">mysql&gt; create table class(class_id int, class_name varchar(128), class_teacher varchar(64));         #创建表class</span><br><span class="line">mysql&gt; insert into class values (101, &#39;六年级一班&#39;, &#39;马老师&#39;);  #往表中插入101班记录</span><br><span class="line">mysql&gt;insert into class values (102, &#39;六年级二班&#39;, &#39;潘老师&#39;);   #往表中插入102班记录</span><br><span class="line">mysql&gt;select * from class;  #查询表class 中的全部记录</span><br><span class="line">mysql&gt;select * from class where class_id&#x3D;101;  #查询表class 中的全部记录</span><br></pre></td></tr></table></figure><p><img src="/images/MySql.assets/image-20211013182829242.png" alt="image-20211013182829242"></p><p><img src="/images/MySql.assets/image-20211013182810106.png" alt="image-20211013182810106"></p><hr><p>补充:mysql中字符串用单引号括起来。</p><hr><h3 id="表的创建"><a href="#表的创建" class="headerlink" title="表的创建"></a>表的创建</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名([表定义选项])[表选项][分区选择];</span><br></pre></td></tr></table></figure><p>其中[表定义选项]格式为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;列名1&gt; &lt;类型1&gt; […] &lt;列名n&gt; &lt;类型n&gt;</span><br></pre></td></tr></table></figure><blockquote><p>CREATE TABLE 命令语法比较多，其主要是由</p><p>表创建定义（create-definition）、</p><p>表选项（table-options）和</p><p>分区选项（partition-options）所组成的。</p></blockquote><blockquote><p>- CREATE TABLE：用于创建给定名称的表，必须拥有表CREATE的权限。</p></blockquote><blockquote><p>有些数据库可以使用加引号的识别名，例如，’mydb’.’mytbl’ 是合法的，但 mysql 是不合法。</p></blockquote><p><strong>表的创建有两种方式</strong>：</p><p>1.选择选择数据库，然后按照上面方式创建表。</p><p>2.不选择先选择数据库，以db_name.tbl_name的方式创建，<strong>例如</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table school.class2(class_id int, class_name varchar(128), class_teacher varchar(64));  </span><br></pre></td></tr></table></figure><blockquote><p>&lt;表定义选项&gt;：表创建定义，由列名（col_name）、列的定义（column_definition, 或者叫类型定义）以及可能的空值说明、完整性约束或表索引组成。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use school;  #选择数据库school </span><br><span class="line">mysql&gt; create table class4(class_id int PRIMARY KEY, class_namevarchar(128) NOT NULL, class_teacher varchar(64) UNIQUE);#创建表class3 </span><br><span class="line"></span><br><span class="line"># UNIQUE 唯一限定-不能重复</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><blockquote><p>默认的情况是，表被创建到当前的数据库中。若表已存在、没有当前数据库或者数据库不存在，则会出现错误。</p><p>提示：使用 CREATE TABLE 创建表时，必须注意以下信息：</p><p>- 要创建的表的名称不区分大小写，不能使用SQL语言中的关键字，如DROP、ALTER、INSERT等。</p><p>- 数据表中每个列（字段）的名称和数据类型，如果创建多个列，要用逗号隔开。</p></blockquote><h4 id="列名"><a href="#列名" class="headerlink" title="列名"></a>列名</h4><p>1）采用26字母和0-9的自然数加上下互相 ‘<em>’ 组成，命名简洁明确，多个单词用下划线 ‘_’</em> 隔开。</p><p>2）全部小写命名，尽量避免出现大写</p><p>3）字段必须填写描述信息</p><p>4）禁止使用数据库关键字</p><p>5）字段名称一般采用名词或动宾短语</p><p>6）采用字段的名字必须是易于理解，一般不超过三个英文单词</p><p>7）在命名表的列时，不要重复表的名称（如：在 user 表中，出现 user_name 字段）</p><p>8）字段命名使用完整名称</p><h4 id="列的类型定义"><a href="#列的类型定义" class="headerlink" title="列的类型定义"></a>列的类型定义</h4><h5 id="整型类型"><a href="#整型类型" class="headerlink" title="整型类型"></a>整型类型</h5><blockquote><p>整数类型是数据库中最基本的数据类型。标准SQL中支持INTEGER和SMALLINT这两种数据类型。MySQL数据库除了支持这两种类型以外，还扩展支持了TINYINT、MEDIUMINT和BIGINT。下表从不同整数类型的字节数、取值范围等方面进行对比。</p></blockquote><p><img src="/images/MySql.assets/image-20211019161552115.png" alt="image-20211019161552115"></p><p><strong>整数类型的附带属性</strong>：</p><h6 id="1-类型名后面的小括号"><a href="#1-类型名后面的小括号" class="headerlink" title="(1)类型名后面的小括号"></a>(1)类型名后面的小括号</h6><p>指定显示宽度 (并不是该类型占用的字节数)。如果不显式指定宽度，则默认为:</p><blockquote><p>tinyint(3)、 smallint(5)、 mediumint(8)、 int(11) 和 bigint(20)。</p></blockquote><p>一般配合zerofill使用，顾名思义，zerofill就是用‘0’填充的意思，也就是在数字位不够的空间用字符“0”填满。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table class2(id,int(8) zerofill,name varchar(128),teacher varchar(64));</span><br></pre></td></tr></table></figure><p>效果如下:<br><img src="/images/MySql.assets/image-20211019171847340.png" alt="image-20211019171847340"></p><p>​    超过显示位数则不会补零</p><p><img src="/images/MySql.assets/image-20211019172153390.png" alt="image-20211019172153390"></p><h6 id="（2）UNSIGNED-无符号"><a href="#（2）UNSIGNED-无符号" class="headerlink" title="（2）UNSIGNED(无符号)"></a>（2）UNSIGNED(无符号)</h6><blockquote><p>如果需要在字段里面保存非负数或者需要较大的上限值时，可以用此选项，它的取值范围是正常值的下限取 0，上限取原值的 2 倍，例如，tinyint 有符号范围是-128～+127，而无符号范围是 0～255。如果一个列指定为 zerofill，则 MySQL 自动为该列添加 UNSIGNED 属性。 </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table class2(id int unsigned,name varchar(128),teacher varchar(64));</span><br></pre></td></tr></table></figure><p>添加一个zerofill属性。</p><p><img src="/images/MySql.assets/image-20211019182633019.png" alt="image-20211019182633019"></p><h6 id="3-AUTO-INCREMENT"><a href="#3-AUTO-INCREMENT" class="headerlink" title="(3)AUTO_INCREMENT"></a>(3)AUTO_INCREMENT</h6><blockquote><p>在需要产生唯一标识符或顺序值时，可利用此属性，这个属性只用于整数类型。AUTO_INCREMENT 值一般从 1 开始，每行增加 1。 一个表中最多只能有一个 AUTO_INCREMENT列 。对于任何想要使用 AUTO_INCREMENT 的列，应该定义为 NOT NULL，并定义为 <strong>PRIMARY KEY 或定义为 UNIQUE 键</strong>(不能有重复的)。 例如，可按下列任何一种方式定义 AUTO_INCREMENT 列： </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table class8(id integer auto_increment PRIMARY KEY , name varchar(128), teacher varchar(64) );         #创建表class8， id 具有自增长属性</span><br><span class="line"></span><br><span class="line">mysql&gt; create table class9(id integer auto_increment UNIQUE , name varchar(128), teacher varchar(64) );         #创建表class9， id 具有自增长属性</span><br></pre></td></tr></table></figure><p><strong>设置的类型可以不指定值</strong>，但要在value前进行一个声明，声明一下哪个需要手动设定。</p><p>插入的第一个元素如果不指定的话就从1开始，指定的话，后面的元素不指定，就前一个的基础上+1。</p><p><strong>如下图所示。</strong></p><p><img src="/images/MySql.assets/image-20211019201436096.png" alt="image-20211019201436096"></p><h5 id="浮点类型和定点数类型"><a href="#浮点类型和定点数类型" class="headerlink" title="浮点类型和定点数类型"></a>浮点类型和定点数类型</h5><blockquote><p>数据表中用浮点数类型和定点数类型来表示小数。浮点数类型包括单精度浮点数（FLOAT型）和双精度浮点数（DOUBLE型）。定点数类型就是DECIMAL型。下面从这三种类型的字节数、取值范围等方面进行对比，如下表所示。</p></blockquote><p><img src="/images/MySql.assets/image-20211025081911859.png" alt="image-20211025081911859"></p><p><strong>三种类型的区别</strong>：<br>float是单精度浮点型，double是双精度浮点型，decimal是定点型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table class10 (f1 float, do1 double, de1 decimal);  #创建表class10</span><br></pre></td></tr></table></figure><p><img src="/images/MySql.assets/image-20211025083153820.png" alt="image-20211025083153820"></p><hr><p>MySQL 浮点型和定点型可以用类型名称后加<strong>（M，D）</strong>来表示，M表示该值的总共长度，D表示小数点后面的长度，M和D又称为精度和标度，如float(7,4)的 可显示为-999.9999，MySQL保存值时进行四舍五入(<strong>当数的长度超过所设置精度</strong>)，如果插入999.00009，则结果为999.0001。</p><p>对于decimal,M是最大位数（精度），范围是1到65。可不指定，默认值是10。D是小数点右边的位数（小数位）。范围是0到30，并且不能大于M，可不指定，<strong>默认值是0</strong>。</p><p>FLOAT和DOUBLE在不指定精度时，默认会按照实际的精度来显示，而DECIMAL在不指定精度时，默认整数为10，小数为0,即(10, 0)。</p><hr><p><strong>注意</strong>：</p><blockquote><p>当我们需要存储小数，并且有精度要求，比如存储金额时，通常会考虑使用DECIMAL字段类型!!!</p></blockquote><h5 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h5><blockquote><p>日期与时间类型是为了方便在数据库中存储日期和时间而设计的，数据库有多种表示日期和时间的数据类型。其中，YEAR类型表示年，DATE类型表示日期，TIME类型表示时间，DATETIME和TIMESTAMP表示日期和时间。下面从这5种日期与时间类型的字节数、取值范围和零值等方面进行对比，如下表所示。</p></blockquote><p><img src="/images/MySql.assets/image-20211025091542570.png" alt="image-20211025091542570"></p><blockquote><p>每种日期与时间类型都有一个有效范围。如果插入的值超过了这个范围，系统就会报错，并将零值插入到数据库中。不同的日期与时间类型均有不同的零值.</p><p>插入日期时间时，日期年月日和时间时分秒可以使用 “<em><strong>*: - _ /*</strong></em> ”中的任意字符来分隔,如果单独插入时间，则会报错！！！</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table test(e_data date,e_datatime datetime,e_timestamp timestamp,e_time time,e_year year)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into test value(&#39;2021-10-25&#39;,&#39;2021-10-25 9:13:00&#39;,&#39;2021-10-25 9:13:00&#39;,&#39;9:13:00&#39;,&#39;2021&#39;);</span><br></pre></td></tr></table></figure><p><img src="/images/MySql.assets/image-20211025091829886.png" alt="image-20211025091829886"></p><hr><p><strong>常用的时间函数</strong>：</p><p><strong>CURDATE()</strong>  - 获得当前的DATE, 可直接插入DATE 类型中.</p><p><strong>NOW()</strong> - 获得当前的DATETIME, 可直接插入DATETIME 和TIMESTAMP类型中.</p><p><strong>TIME()</strong> - 获取参数给定时间串中的时分秒，可直接插入TIME 类型中.</p><p><strong>YEAR()</strong> - 获取参数给定时间串中的年份，可直接插入YEAR类型中.</p><p>MONTH() 、DAY()、HOUR()、MINUTE()、SECOND() 获取参数给定时间串中的月、日、时、分、秒值.</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into date_example values(CURDATE(), NOW(), NOW(), time(NOW()), YEAR(NOW()) );</span><br></pre></td></tr></table></figure><h5 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h5><h6 id="CHAR类型和VARCHAR类型"><a href="#CHAR类型和VARCHAR类型" class="headerlink" title="CHAR类型和VARCHAR类型"></a>CHAR类型和VARCHAR类型</h6><blockquote><p>CHAR类型和VARCHAR类型都在创建表时指定了最大长度，其基本形式如下：</p><p>字符串类型（M）</p><p>其中，“字符串类型”参数指定了数据类型为CHAR类型还是VARCHAR类型；M参数指定了该字符串的最大长度为M。例如，CHAR(4)就是数据类型为CHAR类型，其最大长度为4。</p><p><strong>CHAR类型的长度是固定的</strong>，在创建表时就指定了。其长度可以是0~255的任意值。例如，CHAR(100)就是指定CHAR类型的长度为100。CHAR 存储值时，它们会用空格右填充到指定的长度。</p><p><strong>VARCHAR类型的长度是可变的</strong>，在创建表时指定了最大长度。定义时，其最大值可以取0~65535之间的任意值。指定VARCHAR类型的最大值以后，其长度可以在0到最大长度之间。例如，VARCHAR(100)的最大长度是100，但是不是每条记录都要占用100个字节，而是在这个最大值范围内使用多少就分配多少。VARCHAR类型实际占用的空间为字符串的实际长度加1或2，这样即可有效节约系统的空间。</p></blockquote><p><img src="/images/MySql.assets/image-20211025103822831.png" alt="image-20211025103822831"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use test;   #选择数据库test </span><br><span class="line">mysql&gt; create table char_example(e_char char(5), v_char varchar(5)); #创建数据库表</span><br><span class="line">mysql&gt; insert into char_example values(&#39;12345&#39;,&#39;12345&#39;);  #正常插入数据</span><br><span class="line">mysql&gt; insert into char_example values(&#39;1 2  &#39;,&#39;1 2  &#39;);   #char类型会屏蔽后面隐藏的空格，varchar 不会</span><br><span class="line">mysql&gt;select concat(&#39;(&#39;,e_char, &#39;)&#39;), concat(&#39;(&#39;,v_char, &#39;)&#39;)  from char_example ; #让char 后面屏蔽的空格原型毕露 </span><br></pre></td></tr></table></figure><p><img src="/images/MySql.assets/image-20211025111412107.png" alt="image-20211025111412107"></p><p><strong>使用建议</strong>：</p><ol><li>char一定会使用指定的空间，varchar是根据数据来定空间。</li><li>char的数据查询效率比varchar高：varchar是需要通过后面的记录数来计算。</li><li>  如果确定数据一定是占指定长度，那么使用char类型。</li><li>如果不确定数据到底有多少，那么使用varchar类型。</li><li> 如果数据长度超过255个字符而在65535之内，直接使用varchar。</li><li> 如果字符串尾部要保留空格，<strong>必须</strong>选择varchar。</li></ol><h6 id="TEXT类型"><a href="#TEXT类型" class="headerlink" title="TEXT类型"></a>TEXT类型</h6><blockquote><p>TEXT类型是一种特殊的字符串类型，包括TINYTEXT、TEXT、MEDIUMTEXT和LONGTEXT，其长度和存储空间的对比下表所示:</p></blockquote><p><img src="/images/MySql.assets/image-20211025112721787.png" alt="image-20211025112721787"></p><blockquote><p>各种TEXT类型的区别在于允许的长度和存储空间不同。因此，在这几种TEXT类型中，根据需求选取既能满足需要又节省空间的类型即可。</p></blockquote><p><strong>注意</strong>：</p><ol><li>以上各类型<strong>无须指定长度</strong>！ </li><li><strong>允许的长度是指实际存储的字节数</strong>，而不是实际的字符个数，比如假设一个中文字符占两个字节，那么TEXT 类型可存储65535/2 = 32767个中文字符，而varchar(100)可存储100个中文字符，实际占200个字节，但varchar(65535) 并不能存储65535个中文字符，因为已超出表达范围。</li></ol><p><strong>使用建议</strong>：</p><ol><li>char长度固定，即每条数据占用等长字节空间，适合用在身份证号码、手机号码等。超过255字节的只能用varchar或者text。</li><li>varchar可变长度，可以设置最大长度，适合用在长度可变的属性。</li><li>text不设置长度，当不知道属性的最大长度来时，适合用text,能用varchar的地方不用text；</li><li>如果都可以选择，按照查询速度，<strong>char最快</strong>，<strong>varchar次之</strong>，<strong>text最慢</strong>。(跟数据库的设计有关，不同的类型有不同的特性。实现不用的功能都是有代价的。)</li></ol><h6 id="字符串类型选择练习"><a href="#字符串类型选择练习" class="headerlink" title="字符串类型选择练习"></a>字符串类型选择练习</h6><blockquote><p>创建一个用户信息表，用来存储用户的如下信息：姓名，手机号码，家庭地址，个人简介，性别，年龄，身份证号。数据库表名可定义为userinfo, 同时增加一个列id 用来作为每一条记录的唯一标识，并设为主键，自加！</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table userinfo (</span><br><span class="line"> id int(11) unsigned NOT NULL PRIMARY KEY AUTO_INCREMENT COMMENT ‘主键’,</span><br><span class="line"> name   varchar(64) DEFAULT NULL COMMENT ‘姓名’,</span><br><span class="line"> mobile  char(11)  DEFAULT NULL COMMENT ‘手机号码’,</span><br><span class="line"> address varchar(128) DEFAULT NULL COMMENT ‘居住地址’,</span><br><span class="line"> description text  DEFAULT NULL COMMENT ‘个人简介-不知道具体的范围，不常更新用text’,</span><br><span class="line"> sex     char(1)  DEFAULT NULL COMMENT ‘性别 - 男或女’,</span><br><span class="line"> age     tinyint unsigned DEFAULT 0 COMMENT ‘年龄’,</span><br><span class="line"> idno    char(18) DEFAULT NULL COMENT ‘身份证号码’</span><br><span class="line">);   </span><br></pre></td></tr></table></figure><p><img src="/images/MySql.assets/image-20211025154434847.png" alt="image-20211025154434847"></p><p><img src="/images/MySql.assets/image-20211025160948593.png" alt="image-20211025160948593"></p><hr><p><strong>设计数据库内容的时候就想好它的使用场景</strong>。</p><hr><h6 id="ENUM和SET类型"><a href="#ENUM和SET类型" class="headerlink" title="ENUM和SET类型"></a>ENUM和SET类型</h6><p><strong>ENUM类型</strong></p><blockquote><p>ENUM类型又称为枚举类型。在创建表时，ENUM类型的取值范围以列表的形式指定，其基本形式如下：</p><p>属性名  ENUM(‘值1’,  ‘值2’, …, ‘值n’)</p><p>其中，“属性名”参数指字段的名称，“值n”参数表示列表中的第n个值。ENUM类型的值只能取列表中的一个元素。其取值列表中最多能有65535个值。如果数据值列表在255个以内，那么一个字节就够，如果超过255但是小于65535，那么系统采用两个字节保存。列表中的每个值独有一个顺序排列的编号，MySQL中存入的是这个编号，而不是列表中的值。默认编号从1开始！</p><p>Enum(‘男’,’女’,‘选择保密’)  # ‘男’=&gt;1  ‘女’=&gt;2  ‘选择保密’=&gt; 3</p></blockquote><p><img src="/images/MySql.assets/image-20211025161901977.png" alt="image-20211025161901977"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use test;   #选择数据库test </span><br><span class="line">mysql&gt; create table enum_example (e_enum enum(&#39;男&#39;,&#39;女&#39;,&#39;选择保密&#39;) ); #创建表 </span><br><span class="line">mysql&gt; insert into enum_example values(&#39;男&#39;);  #插入记录,必须是enum 选项中的值</span><br><span class="line">mysql&gt; insert into enum_example values(1);  #插入记录可以用数值表示</span><br><span class="line">mysql&gt;select e_enum + 0  from enum_example; #查询enum 选项对应的整数值（是当前表中已经存的内容，对应enum类型中的数值）</span><br></pre></td></tr></table></figure><p>如果ENUM类型加上了NOT NULL属性，其默认值为取值列表的第一个元素。如果不加NOT NULL属性，ENUM类型将允许插入NULL，而且NULL为默认值。</p><hr><p> <strong>SET类型</strong></p><blockquote><p>在创建表时，SET类型的取值范围就以列表的形式指定了，其基本形式如下：</p><p>属性名  SET(‘值1’,  ‘值2’, …, ‘值n’)</p><p>其中，属性名参数指字段的名称，“值n”参数表示列表中的第n个值，这些值末尾的空格将会被系统直接删除。其基本形式与ENUM类型一样。SET类型的值可以取列表中的一个元素或者多个元素的组合。取多个元素时，不同元素之间用逗号隔开。SET类型的值最多只能是由64个元素构成的组合。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use test;   #选择数据库test </span><br><span class="line">mysql&gt; create table set_example (interest set(&#39;足球&#39;,&#39;追剧&#39;,&#39;篮球&#39;,&#39;撩妹&#39;) ); #创建表 </span><br><span class="line">mysql&gt; insert into set_example values( &#39;足球,撩妹&#39; ); #插入记录,必须是enum 选项中的值</span><br><span class="line">mysql&gt; insert into enum_example values(9);  #插入相应位效果等同，9 &#x3D;&gt;1001 选择1,4</span><br><span class="line">mysql&gt;select interest+0 from set_example;  #以整数的方式查询</span><br></pre></td></tr></table></figure><hr><p><strong>注意</strong>:对应二进制位计算的顺序是反过来的。</p><p>例：<br>选足球，其他的不选</p><p>足球 追剧 篮球 撩妹</p><p>1      0      0       0   </p><p>与正常顺序的二进制不同，正常算结果为8</p><p>在mysql的顺序计算就是1，反过来了。</p><hr><p><img src="/images/MySql.assets/image-20211025174638158.png" alt="image-20211025174638158"></p><h5 id="二进制类型"><a href="#二进制类型" class="headerlink" title="二进制类型"></a>二进制类型</h5><p>二级制数据和文本数据在mysql中的最大差距在于:</p><ul><li>二进制类型存储原始的二进制数据(如图片，视频，exe文件等)。文本类型(TEXT)用来存储字符字符串(如由英文字符、中文字符或其它语言字符组成的字符串)。</li><li>二进制类型没有字符集，并且排序和比较基于列值字节的数值。而TEXT类型有字符集，并且根据字符集的校对规则对值进行排序和比较。</li></ul><blockquote><p>二进制类型是存储二进制数据的数据类型，包括BINARY、VARBINARY、BIT、TINYBLOB、BLOB、MEDIUMBLOB和LONGBLOB。二进制类型之间的对比如下表所示。</p></blockquote><p><img src="/images/MySql.assets/image-20211025180137037.png" alt="image-20211025180137037"></p><h6 id="BINARY和VARBINARY"><a href="#BINARY和VARBINARY" class="headerlink" title="BINARY和VARBINARY"></a>BINARY和VARBINARY</h6><p>BINARY类型和VARBINARY类型都是在创建表时指定最大长度，其基本形式如下：<br><strong>类型M</strong></p><blockquote><p>其中，“字符串类型”参数指定数据类型为BINARY类型还是VARBINARY类型；M参数指定该二进制数的最大字节长度为M。这与CHAR类型和VARCHAR类型相似。例如，BINARY(10)就是指数据类型为BINARY类型，其最大长度为10。</p><p>BINARY类型的长度是<strong>固定</strong>的，在创建表时就指定了，<strong>不足最大长度的空间由″\0″补全</strong>。例如，BINARY(50)就是指定BINARY类型的长度为50。</p><p>VARBINARY类型的长度是<strong>可变</strong>的，在创建表时指定了最大的长度，其长度可以在0到最大长度之间，在这个最大值范围内使用多少就分配多少。</p></blockquote><p> <strong>例如</strong>：<br>都存ab</p><p><img src="/images/MySql.assets/image-20211025182844160.png" alt="image-20211025182844160"></p><p><strong>查</strong>：<br><img src="/images/MySql.assets/image-20211025192213889.png" alt="image-20211025192213889"></p><h6 id="BIT类型"><a href="#BIT类型" class="headerlink" title="BIT类型"></a>BIT类型</h6><p>BIT类型在创建表时指定最大长度，其基本形式如下:<br> <strong>BIT(M)</strong></p><blockquote><p>其中，“M”指定该二进制数的最大存储长度为M，M的最大值为64。例如，BIT(4)就是指数据类型为BIT类型，长度为4。若字段的类型BIT(4)存储的数据是0~15，因为变成二进制之后15的值为1111，则其长度为4。如果插入的值为16，其二进制数为10000，长度为5，超过了最大长度，因此大于16的数是不能插入BIT(4)类型字段中的。</p></blockquote><p><strong>注意</strong>：</p><ul><li>插入数据时，使用 b‘位串’的方式插入相应值!</li><li>查询时,可以使用 bin() 、oct() 、hex() 函数讲字段的值转成相应的二进制、八进制和十六进制。</li></ul><hr><p>(二进制位串高位0会省略)</p><hr><h6 id="BLOB类型"><a href="#BLOB类型" class="headerlink" title="BLOB类型"></a>BLOB类型</h6><p><img src="/images/MySql.assets/image-20211025194404200.png" alt="image-20211025194404200"></p><ol><li>以上各类型无需指定长度。</li><li>允许的长度是指实际存储的字节数，不用考虑字符编码。</li></ol><hr><p><strong>使用建议</strong>：</p><ol><li>binary长度固定，即每条数据占用等长字节空间；保存长度不超过255字节的二进制数据。</li><li>varbinary可变长度，可以设置最大长度,最大长度65535；适合用在长度可变的二进制数据。</li><li>blob不设置长度， 当不知道属性的最大长度时，适合用blob， 能用varbinary的地方不用blob。</li><li>如果都可以选择，按照查询速度： <strong>binary最快</strong>， <strong>varbinary次之</strong>，<strong>blob最慢</strong>。</li></ol><h5 id="其他数据类型"><a href="#其他数据类型" class="headerlink" title="其他数据类型"></a>其他数据类型</h5><p>JASON类型</p><p>SPATIAL数据类型</p><p>(略)</p><h4 id="列的完整性约束"><a href="#列的完整性约束" class="headerlink" title="列的完整性约束"></a>列的完整性约束</h4><p>完整性约束条件是对字段进行限制，要求用户对该属性进行的操作符合特定的要去，如果不满足完整性约束条件，数据库系统将不再执行用户的操作。下表为完整性约束条件。</p><p><img src="/images/MySql.assets/image-20211025201051406.png" alt="image-20211025201051406"></p><h5 id="设置表字段的主键约束-PRIMARY-KEY-PK"><a href="#设置表字段的主键约束-PRIMARY-KEY-PK" class="headerlink" title="设置表字段的主键约束(PRIMARY KEY,PK)"></a>设置表字段的主键约束(PRIMARY KEY,PK)</h5><blockquote><p>主键是表的一个特殊字段，<strong>能唯一标识该表中的每条信息</strong>。主键和记录的关系，如同身份证和人的关系。<strong>主键用来标识每个记录</strong>，每个记录的主键值都不同。身份证用来表明人的身份，每个人都具有唯一的身份证号。设置表的主键是指在创建表时设置表的某个字段为该表的主键。</p><p>主键的主要目的是帮助数据库管理系统<strong>以最快的速度查找到表的某一条信息</strong>。主键必须满足的条件就是<strong>主键必须是唯一的</strong>，表中任意两条记录的主键字段的值不能相同，并且是非空值。<strong>主键可以是单一的字段，也可以是多个字段的组合。</strong></p></blockquote><hr><p><strong>主键是唯一的</strong></p><hr><h6 id="单字段主键"><a href="#单字段主键" class="headerlink" title="单字段主键"></a>单字段主键</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">单字段主键的语法规则如下：</span><br><span class="line">CREATE TABLE tablename(</span><br><span class="line">    propName propType PRIMARY KEY, ......</span><br><span class="line">);</span><br><span class="line">或</span><br><span class="line">CREATE TABLE tablename(</span><br><span class="line">    propName propType , ......</span><br><span class="line">PRIMARY KEY(propType）</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create database school;   #创建数据库school</span><br><span class="line">mysql&gt; use school;   #选择数据库school </span><br><span class="line">mysql&gt; create table class(id int PRIMARY KEY, name varchar(128), teacher varchar(64));         #创建表class</span><br><span class="line">mysql&gt; desc class ;  #查询表class 的定义, describe class 效果等同</span><br><span class="line">mysql&gt; show create table class ;  #同样可以实现查询表class 的定义</span><br><span class="line">mysql&gt; insert into class VALUES(1,&#39;一班&#39;,&#39;s1&#39;);  #插入成功</span><br><span class="line">mysql&gt; insert into class VALUES(1,&#39;二班&#39;,&#39;s2&#39;);  #因主键约束，插入失败</span><br></pre></td></tr></table></figure><p><strong>MySQL支持给主键设置名字</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE tablename(</span><br><span class="line">    propName propType , ......</span><br><span class="line">CONSTRAINT pk_name PRIMARY KEY(propType）</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h6 id="多字节主键"><a href="#多字节主键" class="headerlink" title="多字节主键"></a>多字节主键</h6><p><strong>主键是由多个属性组合而成时</strong>，在属性定义完之后统一设置主键。语法规则如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE tablename(  </span><br><span class="line">    propName1 propType , </span><br><span class="line">    propName2 propType , </span><br><span class="line">    ......                     </span><br><span class="line">[CONSTRAINT pk_name]PRIMARY KEY(propName1, propName2)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>例如</strong>：<img src="/images/MySql.assets/image-20211026143246285.png" alt="image-20211026143246285"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table class3(id int, name varchar(128), teacher varchar(64), CONSTRAINT id_pk PRIMARY KEY(id, name));         #创建表class3,设置联合主键</span><br><span class="line">mysql&gt; insert into class VALUES(1,&#39;一班&#39;,&#39;S1&#39;);  #插入成功</span><br><span class="line">mysql&gt; insert into class VALUES(1,&#39;一班&#39;,&#39;S2&#39;);    #因联合主键约束，插入失败</span><br></pre></td></tr></table></figure><h5 id="设置表字段的外键约束-FORENIGN-KEY-FK"><a href="#设置表字段的外键约束-FORENIGN-KEY-FK" class="headerlink" title="设置表字段的外键约束(FORENIGN KEY,FK)"></a>设置表字段的外键约束(FORENIGN KEY,FK)</h5><p>(<strong>就是外部的约束</strong>)</p><blockquote><p>外键是表的一个特殊字段，外键约束是为了保证多个表（通常为两个表）之间的参照完整性，即构建两个表的字段之间的参照关系。</p><p>设置外键约束的两个表之间具有父子关系，即子表中某个字段的取值范围由父表决定。例如，表示一个班级和学生关系，即每个班级有多个学生。首先应该有两个表：班级表和学生表，然后学生表有一个表示班级编号的字段no，其依赖于班级表的主键，这样字段no就是学生表的外键，通过该字段班级表和学生表建立了关系。</p></blockquote><p>​    <img src="/images/MySql.assets/image-20211026150301435.png" alt="image-20211026150301435"></p><p>在具体设置外键约束时，<strong>设置外键约束的字段必须依赖于数据库中已经存在的父表的主键</strong>，同时外键可以为空（NULL）。</p><p>设置表中某字段的外键约束非常简单，可以在MySQL数据库管理系统中通过SQL语句FOREIGN KEY来实现，其语法形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE tablename_1(  </span><br><span class="line">    propName1 propType , </span><br><span class="line">    propName2 propType , </span><br><span class="line">    ......                     </span><br><span class="line">[CONSTRAINT fk_name]FOREIGN KEY(propName1) REFERENCES table2_name(table2_column)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><hr><p><strong>例如</strong>：学生表的外键(班级id字段)依赖于父类班级表的主键(id),插入的学生信息班级id必须是父类班级表主键中有的。否则就会插入失败。</p><p><img src="/images/MySql.assets/image-20211026152949789.png" alt="image-20211026152949789"></p><hr><p><strong>并且</strong>，<strong>外键是可以为空的</strong>，不为空一定要受父类表<strong>主键的约束</strong>。(父类表一定要有主键，否则不能为子类表创建外键。)</p><hr><h5 id="设置列的非空约束-NOT-NULL-NK"><a href="#设置列的非空约束-NOT-NULL-NK" class="headerlink" title="设置列的非空约束(NOT  NULL,NK)"></a>设置列的非空约束(NOT  NULL,NK)</h5><blockquote><p>当数据库表中的某个字段上的内容不希望设置为NULL时，可以使用NK约束进行设置。NK约束在创建数据库表时为某些字段上加上“NOT NULL”约束条件，保证所有记录中的该字段都有值。如果在用户插入的记录中该字段为空值，那么数据库管理系统会报错。</p><p>设置表中某字段的NK约束非常简单，查看帮助文档可以发现，在MySQL数据库管理系统中是通过SQL语句NOT NULL来实现的，其语法形式如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE tablename(</span><br><span class="line">    propName propType NOT NULL , ......</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create database school;   #创建数据库school</span><br><span class="line">mysql&gt; use school;   #选择数据库school </span><br><span class="line">mysql&gt; create table class(id int, name varchar(128) NOT NULL, teacher varchar(64));         #创建表class</span><br><span class="line">mysql&gt; desc class ;  #查询表class 的定义, describe class 效果等同 </span><br><span class="line">mysql&gt; show create table class ;  #同样可以实现查询表class 的定义</span><br></pre></td></tr></table></figure><p><img src="/images/MySql.assets/image-20211026165416585.png" alt="image-20211026165416585"></p><p>这个NULL的YES or  NO,意思是是否可以为空。(可以为空也就是没有设置非空约束)</p><h5 id="设置表字段唯一约束-UNIQUE-UK"><a href="#设置表字段唯一约束-UNIQUE-UK" class="headerlink" title="设置表字段唯一约束(UNIQUE,UK)"></a>设置表字段唯一约束(UNIQUE,UK)</h5><blockquote><p><strong>当数据库表中某个字段上的内容不允许重复时</strong>，可以使用UK约束进行设置。UK约束在创建数据库时为某些字段加上“UNIQUE”约束条件，保证所有记录中该字段上的值不重复。如果在用户插入的记录中该字段上的值与其他记录中该字段上的值重复，那么数据库管理系统会报错。</p><p>设置表中某字段的UK约束非常简单，可以在MySQL数据库管理系统中通过SQL语句UNIQUE来实现，其语法形式如下：</p></blockquote><p>(该列被设为主键了，就没必要再设置UNIQUE了，因为主键就是不可重复，为了区分表中的每一行数据。)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE tablename(</span><br><span class="line">    propName propType UNIQUE, ......</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>unique 约束允许约束的字段出现多个空值NULL，不算重复。(mysql8.0)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table class(id int, name varchar(128) UNIQUE, teacher varchar(64));         #创建表class</span><br></pre></td></tr></table></figure><h5 id="设置表字段值自动增加-AUTO-INCREMENT"><a href="#设置表字段值自动增加-AUTO-INCREMENT" class="headerlink" title="设置表字段值自动增加(AUTO_INCREMENT)"></a>设置表字段值自动增加(AUTO_INCREMENT)</h5><blockquote><p>AUTO_INCREMENT是MySQL唯一扩展的完整性约束，当向数据库表中插入新记录时，字段上的值会自动生成唯一的ID。在具体设置AUTO_INCREMENT约束时，<strong>一个数据库表中只能有一个字段使用该约束</strong>，<strong>该字段的数据类型必须是整数类型</strong>。由于设置AUTO_INCREMENT约束后的字段会生成唯一的ID，因此该字段也经常会同时设置成PK主键。</p><p>设置表中某字段值的自动增加约束非常简单，可以在MySQL数据库管理系统中通过SQL语句AUTO_INCREMENT来实现，其语法形式如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE tablename(</span><br><span class="line">    propName propType AUTO_INCREMENT, ......</span><br><span class="line">);</span><br></pre></td></tr></table></figure><blockquote><p>在上述语句中，tablename参数表示所要设置非空约束的字段名字，propName参数为属性名，propType为属性类型，propName字段要设置自动增加约束。默认情况下，字段propName的值从1开始增加，每增加一条记录，<strong>记录中该字段的值就会在前一条记录(或已存在的最大值（包括曾经存在的）)的基础上加1</strong>。</p></blockquote><hr><p>(<strong>自增的列类型，需要被设置成主键。</strong>)如下图所示:</p><p><img src="/images/MySql.assets/image-20211026172630406.png" alt="image-20211026172630406"></p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table class(id int PRIMARY KEY AUTO_INCREMENT, name varchar(128) UNIQUE, teacher varchar(64));         #创建表class,设置字段id为自增长</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p><strong>默认是在上一个的数据的基础上+1</strong></p><hr><p><strong>注意</strong>：mysql8中，AUTO_INCREMENT必须设为键(主键、外键和唯一键),否则会报错。</p><hr><p> <strong>小细节</strong>：受外键约束的一个列设置为自增，其实是没用的，无法根据外键限制自己增加，就是没用。</p><hr><h5 id="设置表字段的默认值-DEFAULT"><a href="#设置表字段的默认值-DEFAULT" class="headerlink" title="设置表字段的默认值(DEFAULT)"></a>设置表字段的默认值(DEFAULT)</h5><blockquote><p>当为数据库表中插入一条新记录时，如果没有为某个字段赋值，数据库系统就会自动为这个字段插入默认值。为了达到这种效果，可通过SQL语句关键字DEFAULT来设置。</p><p>设置数据库表中某字段的默认值非常简单，可以在MySQL数据库管理系统中通过SQL语句DEFAULT来实现，其语法形式如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE tablename(</span><br><span class="line">    propName propType DEFAULT defaultvalue, ......</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>如果没有设置，则默认为空。</strong></p><h5 id="调整列的完整性约束"><a href="#调整列的完整性约束" class="headerlink" title="调整列的完整性约束"></a>调整列的完整性约束</h5><h6 id="修改主键PK、外键FK和-唯一键UK"><a href="#修改主键PK、外键FK和-唯一键UK" class="headerlink" title="修改主键PK、外键FK和 唯一键UK"></a>修改主键PK、外键FK和 唯一键UK</h6><p><strong>新增</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table [table_name] add constraint [constraint_name] [unique key| primary key|foreign key] ([column_name])</span><br></pre></td></tr></table></figure><hr><p><strong>删除</strong></p><ol><li> 通过如下命令查询键值的约束名:</li></ol>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show index或keys from 表名;     </span><br></pre></td></tr></table></figure><ol start="2"><li>执行如下命令删除</li></ol><p><strong>主键</strong>： alter table 表名 drop primary key; (主键只有一个。直接通过限制名删除)</p><p><strong>外键或唯一键</strong>:alter table 表名 drop index 约束名;</p><hr><p><strong>修改</strong>:先删除再新增。</p><hr><h6 id="修改默认值DEFAULT、自增长和非空NK"><a href="#修改默认值DEFAULT、自增长和非空NK" class="headerlink" title="修改默认值DEFAULT、自增长和非空NK"></a>修改默认值DEFAULT、自增长和非空NK</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 modify 列名 类定义；</span><br></pre></td></tr></table></figure><h4 id="表索引"><a href="#表索引" class="headerlink" title="表索引"></a>表索引</h4><h5 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a>索引概述</h5><p>帮助我们快速找到想要的内容。</p><blockquote><p>索引是一种特殊的数据库结构，可以用来快速查询数据库表中的特定记录，是提高数据库性能的重要方式。MySQL中，所有的数据类型都可以被索引。</p><p>通过索引，查询数据时可以不必读完记录的所有信息，而只是查询索引列，否则数据库系统将读取每条记录的所有信息进行匹配。。使用索引可以在很大程度上提高数据库的查询速度，有效地提高了数据库系统的性能。</p></blockquote><h6 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h6><ul><li>普通索引</li><li>唯一性索引</li><li>全文索引</li><li>单列索引</li><li>空间索引</li><li>等</li></ul><h6 id="索引存储"><a href="#索引存储" class="headerlink" title="索引存储"></a>索引存储</h6><blockquote><p>数据库底层索引实现主要有两种存储类型，B树(BTREE)和哈希(HASH)索引，InnoDB和MyISAM 使用BTREE索引；而MEMORY 存储引擎可以使用BTREE 和HASH 索引，默认用BTREE.在没有指定的情况下，数据库使用的引擎是 InnoDB。 </p></blockquote><h6 id="索引优点"><a href="#索引优点" class="headerlink" title="索引优点"></a>索引优点</h6><p>可以提高检索数据的速度。</p><h6 id="索引缺点"><a href="#索引缺点" class="headerlink" title="索引缺点"></a>索引缺点</h6><blockquote><p>创建和维护索引需要耗费时间，耗费时间的数量随着数据量的增加而增加；索引需要占用物理空间，每一个索引要占一定的物理空间；增加、删除和修改数据时，要动态地维护索引，造成数据的维护速度降低了。</p></blockquote><h6 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h6><blockquote><p>索引可以提高查询的速度，但是会影响插入记录的速度，因为向有索引的表中插入记录时，数据库系统会按照索引进行排序，这样就降低了插入记录的速度，<strong>插入大量记录时的速度影响更加明显</strong>。这种情况下，最好的办法是先删除表中的索引，然后插入数据，<strong>插入完成后再创建索引。</strong></p></blockquote><h5 id="创建和查看索引"><a href="#创建和查看索引" class="headerlink" title="创建和查看索引"></a>创建和查看索引</h5><blockquote><p>创建索引是指在某个表的一列或多列上建立一个索引，以便提高对表的访问速度。创建索引有3种方式，分别是创建表的时候创建索引、在已经存在的表上创建索引和使用ALTER TABLE语句来创建索引。</p></blockquote><h5 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h5><p>就是在创建索引的时候<strong>不附加任何限制条件</strong>(唯一、非空等限制)，给类型的索引可以创建在任何数据类型的字段上。</p><p><strong>创建表时定义索引</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE tablename(</span><br><span class="line">    propname1 type1,</span><br><span class="line">    propname2 type2,</span><br><span class="line">    ……</span><br><span class="line">    propnamen type..n,</span><br><span class="line">     INDEX | KEY</span><br><span class="line">    [indexname] (propnamen [(length)] [ ASC | DESC ] ) );</span><br></pre></td></tr></table></figure><blockquote><p>其中，参数INDEX和KEY是用来指定字段为索引的，两者选择其中之一就可以了，作用是一样的；</p><p>参数indexname是索引名字，可省略；</p><p>参数propnamen是索引对应的字段的名称，该字段必须为前面定义好的字段；</p><p>参数length是可选参数，其指索引的长度，必须是字符串类型才可以使用；</p><p>参数ASC和DESC都是可选参数，ASC表示升序排列，DESC表示降序排列，如果不指定，则为升序。</p></blockquote><p><strong>代码示例</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create database school;   #创建数据库school  </span><br><span class="line">mysql&gt; use school;   #选择数据库school  </span><br><span class="line">mysql&gt; create table class(id int, name varchar(128) UNIQUE, teacher varchar(64), INDEX index_no(id DESC));       #创建表class, 并建立为id 字段索引  </span><br><span class="line">mysql&gt; show create table class;  #查看表结构 </span><br><span class="line">mysql&gt; insert into class values(1, &#39;一班&#39;, &#39;Martin&#39;);  # 插入记录1 </span><br><span class="line">mysql&gt; insert into class values(1, &#39;二班&#39;, &#39;Rock&#39;);   # 插入记录2 </span><br><span class="line">mysql&gt; select * from class where id &gt; 0 ;   #根据id查询记录，结果将降序排列  </span><br></pre></td></tr></table></figure><p> <strong>或者</strong>，在已存在的表上面创建索引。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tablename ADD INDEX | KEY indexname  </span><br><span class="line">     (propname [(length)] [ASC|DESC]);  </span><br></pre></td></tr></table></figure><p><strong>例如</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table class1 add index index_id(id DESC);</span><br></pre></td></tr></table></figure><h5 id="查询索引执行情况"><a href="#查询索引执行情况" class="headerlink" title="查询索引执行情况"></a>查询索引执行情况</h5><p><strong>EXPLAIN</strong> 查询语句</p><p><img src="/images/MySql.assets/image-20211101165612056.png" alt="image-20211101165612056"></p><blockquote><p>在上述语句中，参数tablename是需要创建索引的表；关键字IDNEX或KEY用来指定创建普通索引；参数indexname用来指定所创建的索引名；参数propname用来指定索引所关联的字段的名称；参数length用来指定索引的长度；参数ASC用来指定升序排序；参数DESC用来指定降序排序。</p></blockquote><p><strong>输出结果</strong>:<br>key: 实际使用的索引。如果为NULL，则没有使用索引。</p><p>possible_keys:显示可能应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用</p><p>key_len：表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。此值越短越好！</p><h5 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h5><p>所谓唯一索引，就是在创建索引时，限制索引的<strong>字段值必须是唯一的</strong>。</p><p>通过该类型的索引可以比普通索引更快速地查询某条记录。</p><hr><p><strong>创建表时定义索引</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE tablename(</span><br><span class="line">    propname1 type1,</span><br><span class="line">    ……</span><br><span class="line">    propnamen type..n,</span><br><span class="line">    UNIQUE INDEX | KEY [indexname] (propnamen [(length)] [ ASC | DESC ] ) );  </span><br></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table class(id int,name varchar(128) UNIQUE,teachar varchar(64),UNIQUE INDEX name_index (name(32)));</span><br></pre></td></tr></table></figure><hr><p><strong>补充</strong></p><p><strong>%为通配符，例如%班。</strong></p><p><strong>索引的数据量很小，便于核对查询是否有重复的。</strong></p><p><strong>对于已经设置UNIQUE约束的字段，在设置UNIQUE KEY(唯一约束)是多余的。</strong></p><hr><p><strong>注意</strong>：</p><blockquote><p>参数UNIQUE INDEX和UNIQUE KEY是用来指定字段为索引的，两者选择其中之一即可；</p><p>参数indexname是索引名字，可省略；</p><p>参数propnamen是索引对应的字段的名称，该字段必须为前面定义好的字段<strong>且必须定义为 UNIQUE 约束</strong>；</p><p>参数length是可选参数，其指索引的长度，必须是字符串类型才可以使用；</p><p>参数ASC和DESC都是可选参数，ASC表示升序排列，DESC表示降序排列，如果不指定，则为升序。</p></blockquote><p>**已存在的表上创建索引    **</p><p> <strong>方法1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE UNIQUE INDEX indexname  </span><br><span class="line">    ON tablename (propname [(length)] [ASC|DESC]);  </span><br></pre></td></tr></table></figure><p><strong>方法2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tablename ADD UNIQUE INDEX | KEY indexname (propname [(length)] [ASC|DESC]);  </span><br></pre></td></tr></table></figure><h5 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h5><p>全文索引主要对字符串类型建立基于分词的索引，主要是基于CHAR、VARCHAR和TEXT的字段上，以便能够更加快速地查询数据量较大的字符串类型的字段。</p><p><strong>全文索引以词为基础的</strong>，<strong>MySQL默认的分词是所有非字母和数字的特殊符号都是分词符。</strong></p><p>MySQL从3.23.23版本开始支持全文索引，MySQL5.6以前只能在存储引擎为MyISAM的数据表上创建全文索引,5.6之后InnoDB开始支持全文索引(5.7之后支持中文全文索引) 。在默认情况下，全文索引的搜索执行方式为不区分大小写，如果全文索引所关联的字段为二进制数据类型，就以区分大小写的搜索方式执行。</p><hr><p><strong>创建表时定义索引</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE tablename(</span><br><span class="line">    propname1 type1,</span><br><span class="line">    propname2 type2,</span><br><span class="line">    ……</span><br><span class="line">    propnamen type..n,</span><br><span class="line">    FULLTEXT INDEX | KEY</span><br><span class="line">    [indexname] (propnamen [(length)] ) );</span><br></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create database school;   #创建数据库school  </span><br><span class="line">mysql&gt; use school;   #选择数据库school  </span><br><span class="line">mysql&gt;create table class(id int, name varchar(128) UNIQUE, teacher varchar(64),comment varchar(1024),FULLTEXT INDEX index_comm(comment));       #创建表class, 并建立为comment 字段为全文索引  </span><br><span class="line">mysql&gt; insert into class values(1,&#39;1班&#39;,&#39;Martin&#39;,&#39;我是一个兵，来自老百姓!&#39;);  # 插入记录1 </span><br><span class="line">mysql&gt; insert into class values(2,&#39;2班&#39;,&#39;Rock&#39;,&#39;此班主任毕业自唐僧系&#39;);   # 插入记录2 </span><br><span class="line">mysql&gt; insert into class values(3,&#39;3班&#39;,&#39;Janny&#39;,&#39;I&#39;&#39;m Miss Zhang.&#39;);   #插入记录3  </span><br><span class="line">mysql&gt; select * from class where match(comment) AGAINST(&#39;我是一个兵&#39;);#利用全文检索索引快速查询记录</span><br></pre></td></tr></table></figure><p><strong>查找</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select* from tablename where match(propnamen)against(&#39;内容&#39;)；</span><br></pre></td></tr></table></figure><p><strong>已经存在的表上创建索引</strong></p><p><strong>方法1:执行create语句</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE FULLTEXT INDEX indexname</span><br><span class="line">   ON tablename( propname1 [ ( length ) ] ); </span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table class(id int, name varchar(128) UNIQUE, teacher varchar(64));       #创建表class, 并建立为id 字段索引  </span><br><span class="line">mysql&gt; create FULLTEXT index index_teacher on class(teacher );  #追加全文索引 </span><br></pre></td></tr></table></figure><p><strong>方法2:执行ALTER TABLE语句</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tablename</span><br><span class="line">ADD FULLTEXT INDEX|KEY indexname(propname [(length)]);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table class add fulltext index name_index(teacher);</span><br></pre></td></tr></table></figure><h5 id="MySQL8中文分词支持"><a href="#MySQL8中文分词支持" class="headerlink" title="MySQL8中文分词支持"></a>MySQL8中文分词支持</h5><p>配置文件my.ini（Windows 10默认路径: C:\ProgramData\MySQL\MySQL Server 8.0） 中增加如下配置项，同时重启MySQL80 服务:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">ngram_token_size&#x3D;2</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; mysql&gt; create table class(id int, name varchar(128) UNIQUE, teacher varchar(64),comment varchar(1024),FULLTEXT INDEX index_des(comment) with parser   ngram);       #创建表class, 并建立为comment 字段为全文索引  </span><br></pre></td></tr></table></figure><p><strong>这样对相关词进行检索也可以查到了。</strong></p><h5 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h5><p>多列索引，是指在创建索引时所关联的字段不是一个字段，而是多个字段，虽然可以通过所关联的字段进行查询，<strong>但是只有查询条件中使用了所关联字段中的第一个字段，多列索引才会被使用。</strong></p><p><strong>创建表时定义索引</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE tablename(</span><br><span class="line">    propname1 type1,</span><br><span class="line">    ……</span><br><span class="line">    propnamen type..n,</span><br><span class="line">    INDEX | KEY [indexname] (propname1 [(length)] [ ASC | DESC ],</span><br><span class="line">                             Propname2 [(length)] [ ASC | DESC ], </span><br><span class="line">                              ... ...                               </span><br><span class="line">                             Propnamen [(length)] [ ASC | DESC ]) </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>例如</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table class(id int, name varchar(128) UNIQUE, teacher varchar(64), INDEX index_mult_columns(id, teacher));  </span><br></pre></td></tr></table></figure><p><strong>就是在单个索引上增加了个索引列。</strong></p><hr><p><strong>已存在的表上创建索引</strong></p><p><strong>方法1:执行create语句</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE  INDEX indexname</span><br><span class="line">    ON tablename( propname1 [(length)] [ ASC | DESC ],  </span><br><span class="line">                   Propname2 [(length)] [ ASC | DESC ],   </span><br><span class="line">                              ... ...                                </span><br><span class="line">                         Propnamen [(length)] [ ASC | DESC ]  ); </span><br></pre></td></tr></table></figure><p><strong>方法2:执行ALTER TABLE 语句</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tablename</span><br><span class="line">   ADD INDEX|KEY indexname(propname1 [(length)] [ ASC | DESC ],  </span><br><span class="line">                  Propname2 [(length)] [ ASC | DESC ],              </span><br><span class="line">                             ... ...                                          </span><br><span class="line">                        Propnamen [(length)] [ ASC | DESC ]  ); </span><br></pre></td></tr></table></figure><hr><h5 id="隐藏索引"><a href="#隐藏索引" class="headerlink" title="隐藏索引"></a>隐藏索引</h5><p>MySQL 8开始支持<strong>隐藏索引</strong>。隐藏索引提供了更人性化的数据库操作。</p><p>隐藏索引，顾名思义，<strong>让索引暂时不可见</strong>，<strong>不会被优化器使用</strong>。默认情况下索引是可见的。隐藏索引可以用来测试索引的性能。<strong>验证索引的必要性时不需要删除索引，可以先将索引隐藏，如果优化器性能无影响就可以真正地删除索引。</strong></p><p>（**测试索引性能    **）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tablename ALTER  INDEX  index_name INVISIBLE;  #隐藏索引</span><br><span class="line">ALTER TABLE tablename ALTER  INDEX  index_name VISIBLE;    #取消隐藏</span><br></pre></td></tr></table></figure><h5 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h5><p>所谓删除索引，就是删除表中已经创建的索引。之所以要删除索引，是因为这些索引会降低表的更新速度，影响数据库的性能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX indexname ON tablename;</span><br></pre></td></tr></table></figure><p><strong>修改索引</strong>：先删除后增加。</p><h5 id="索引的设计原则"><a href="#索引的设计原则" class="headerlink" title="索引的设计原则"></a>索引的设计原则</h5><p>为了使索引的使用效率更高，在创建索引时，必须考虑在哪些字段上创建索引和创建什么类型的索引。</p><p><strong>1.选择唯一性索引</strong></p><p>唯一性索引的值是唯一的，可以更快速地通过该索引来确定某条记录。例如，学生表中学号是具有唯一性的字段，为该字段建立唯一性索引可以很快确定某个学生的信息，如果使用姓名的话，可能存在同名现象，从而降低查询速度。</p><p><strong>2.为经常需要排序、分组和联合的操作的字段建立索引</strong></p><p>经常需要使用ORDER BY、GROUP BY、DISTINCT和UNION等操作的字段，排序操作会浪费很多时间，如果为其建立索引，可以有效地避免排序操作。</p><p><strong>3.为经常作为查询条件的字段建立索引</strong></p><p>如果某个字段经常用来做查询条件，那么该字段的查询速度会影响整个表的查询速度，为这样的字段建立索引可以提高整个表的查询速度。</p><p><strong>4.限制索引的数目</strong></p><p>索引的数目不是越多越好。每个索引都需要占用磁盘空间，索引越多，需要的磁盘空间就越大，修改表时，对索引的重构和更新很麻烦。</p><p><strong>5.尽量使用数据量少的索引</strong></p><p>如果索引的值很长，那么查询的速度会受到影响。例如，对一个CHAR(100)类型的字段进行全文检索需要的时间肯定要比对CHAR(10)类型的字段需要的时间多。</p><p><strong>6.尽量使用前缀来索引</strong></p><p>如果索引的值很长，最好使用值的前缀来索引。例如，TEXT和BLOG类型的字段，进行全文检索会很浪费时间，如果只检索字段前面的若干字符，这样可以提高检索速度。</p><p><strong>7.删除不再使用或者很少使用的索引</strong></p><p>表中的数据被大量更新，或者数据的使用方式被改变后，原有的一些索引可能不再需要。数据库管理员应当定期找出这些索引，将它们删除，从而减少索引对更新操作的影响。</p><h3 id="表的插入"><a href="#表的插入" class="headerlink" title="表的插入"></a>表的插入</h3><p><strong>插入数据记录是常见的数据操作</strong>，可以显示向表中增加的新的数据记录。在MySQL中可以通过“INSERT INTO”语句来实现插入数据记录，该SQL语句可以通过如下4种方式使用：</p><ul><li>插入完整数据记录、</li><li>插入部分数据记录、</li><li>插入多条数据记录和</li><li>插入JSON结构的数据记录（略）。</li></ul><h4 id="插入完整数据记录"><a href="#插入完整数据记录" class="headerlink" title="插入完整数据记录"></a>插入完整数据记录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSERT INTO tablename(field1, field2, field3, ..., fieldn) VALUES(value1, value2, value3, ..., valuen); </span><br></pre></td></tr></table></figure><p><strong>tablename(xxx)省略</strong></p><p><strong>缩写为</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO tablename VALUES(value1, value2, value3, ..., valuen);</span><br></pre></td></tr></table></figure><p>tablename表示所要插入完整记录的表名，</p><p>参数fieldn表示表中的字段名字，</p><p>参数valuen表示所要插入的数值，</p><p>并且参数fieldn与参数valuen一一对应。</p><hr><h4 id="插入部分数据记录"><a href="#插入部分数据记录" class="headerlink" title="插入部分数据记录"></a>插入部分数据记录</h4><p>在插入完整数据记录的基础上指定要添加字段的名称。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO tablename(field1, field2, field3, ..., fieldn) VALUES(value1, value2, value3, ..., valuen);</span><br></pre></td></tr></table></figure><p><strong>注意</strong>： 如果域<strong>没有设定默认值</strong>，也<strong>没有设定为自增长</strong>，则插入记录时<strong>必须插入值</strong>。</p><h4 id="插入多条数据记录"><a href="#插入多条数据记录" class="headerlink" title="插入多条数据记录"></a>插入多条数据记录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO tablename(field1, field2, field3, ..., fieldn) </span><br><span class="line">VALUES(value11, value12, value13, ..., value1n)，   </span><br><span class="line">(value21, value22, value23, ..., value2n)，          </span><br><span class="line">... ....                                             </span><br><span class="line">(valuen1, valuen2, valuen3, ..., valuenn);           </span><br></pre></td></tr></table></figure><p>每条要插入的数据都要按着tablename(x,)所指定的插入数据个数。</p><h3 id="更新表中的数据记录"><a href="#更新表中的数据记录" class="headerlink" title="更新表中的数据记录"></a>更新表中的数据记录</h3><p>(更新就是修改)</p><p>更新数据记录是数据操作中常见的操作，可以更新表中已经存在数据记录中的值。在MySQL中可以通过<strong>UPDATE</strong>语句来实现更新数据记录，该SQL语句可以通过如下几种方式使用：</p><p><strong>更新特定数据记录、更新所有数据记录、更新JSON结构的数据记录。</strong></p><h4 id="更新特定数据记录"><a href="#更新特定数据记录" class="headerlink" title="更新特定数据记录"></a>更新特定数据记录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE tablename SET field1 &#x3D; value1, field2 &#x3D; value2, field3 &#x3D; value3, ..., fieldn &#x3D; valuen) WHERE CONDITION;   </span><br></pre></td></tr></table></figure><p>上述语句中：</p><p>参数tablename表示所要更新数据记录的表名，</p><p>参数field表示表中所要更新数值的字段名字，</p><p>参数valuen表示更新后的数值，</p><p>参数CONDITION<strong>指定更新满足条件的特定数据记录</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update class set teacher &#x3D; &#39;zyx&#39; where teacher &#x3D; &#39;zxx&#39;; </span><br><span class="line">#通过teacher 字段匹配更新记录   </span><br><span class="line">或   </span><br><span class="line">mysql&gt; update class set teacher &#x3D; &#39;zyx&#39; where id &#x3D; 2;  </span><br><span class="line">#通过id(其他)字段匹配更新记录</span><br></pre></td></tr></table></figure><hr><p><strong>个人理解:</strong></p><p><strong>可以将满足指定条件的数据记录都进行修改。</strong></p><p><strong>就是说要根据满足field和value(对应的字段和它的值)所进行更新(修改)。</strong></p><hr><h4 id="更新所有记录"><a href="#更新所有记录" class="headerlink" title="更新所有记录"></a>更新所有记录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE tablename SET field1 &#x3D; value1, field2 &#x3D; value2, field3 &#x3D; value3, ..., fieldn &#x3D; valuen)  WHERE CONDITION;      </span><br><span class="line">    或</span><br><span class="line">UPDATE tablename SET field1 &#x3D; value1, field2 &#x3D; value2, field3 &#x3D; value3, ..., fieldn &#x3D; valuen) ；</span><br></pre></td></tr></table></figure><p>在上述语句中：</p><p>参数tablename表示所要更新数据记录的表名，</p><p>参数field表示表中所要更新数值的字段名字，</p><p>参数valuen表示更新后的数值，</p><p>参数CONDITION表示满足表tablename中的所有数据记录，或不使用关键字WHERE语句。</p><p><strong>例</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> update class set teacher &#x3D; &#39;xx&#39; ;  #把所有记录的teacher列改成xx       </span><br><span class="line">       或   </span><br><span class="line">mysql&gt; update class set teacher &#x3D; &#39;xx&#39; where 1&#x3D;1;  </span><br></pre></td></tr></table></figure><h3 id="删除表中的数据记录"><a href="#删除表中的数据记录" class="headerlink" title="删除表中的数据记录"></a>删除表中的数据记录</h3><p>删除数据记录是数据操作中常见的操作，可以删除表中已经存在的数据记录。在MySQL中可以通过DELETE语句来删除数据记录，该SQL语句可以通过以下几种方式使用：<strong>删除特定数据记录、删除所有数据记录</strong>。</p><h4 id="删除特定数据记录"><a href="#删除特定数据记录" class="headerlink" title="删除特定数据记录"></a>删除特定数据记录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM tablename WHERE CONDITION; </span><br></pre></td></tr></table></figure><p>在上述语句中，参数tablename表示所要删除数据记录的表名，参数<strong>CONDITION指定删除满足条件的特定数据记录</strong>。</p><h4 id="删除所有数据记录"><a href="#删除所有数据记录" class="headerlink" title="删除所有数据记录"></a>删除所有数据记录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM tablename WHERE CONDITION;      </span><br><span class="line">或</span><br><span class="line">DELETE FROM tablename；</span><br></pre></td></tr></table></figure><p>在上述语句中，为了删除所有的数据记录,</p><p>参数CONDITION需要满足表tablename中所有数据记录，如id&gt;0; </p><p>或者无关键字WHERE语句。</p><h3 id="练习-设计游戏用户信息表"><a href="#练习-设计游戏用户信息表" class="headerlink" title="练习:设计游戏用户信息表"></a>练习:设计游戏用户信息表</h3><blockquote><p>游戏玩家访问游戏客户端，通过客户端界面输入用户名和密码,</p><p>在游戏玩家点击”确认”后，客户端连接至数据库服务器对用户名和密码进行确认， </p><p>如果验证成功，则 玩家可以进入大厅，如果失败，则不允许进入</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> create table users (</span><br><span class="line"> id int(11) unsigned NOT NULL PRIMARY KEY AUTO_INCREMENT COMMENT &#39;主键&#39;,</span><br><span class="line"> username   varchar(64)  NOT NULL UNIQUE COMMENT &#39;用户名&#39;,</span><br><span class="line">  </span><br><span class="line">    加上下面的user_auths表，所以将password字段从users表中剥离</span><br><span class="line">（ password   varchar(32)  NOT NULL COMMENT &#39;密码&#39;,）</span><br><span class="line">     </span><br><span class="line"> nickname   varchar(64)  DEFAULT NULL COMMENT &#39;昵称&#39;,</span><br><span class="line"> mobile      char(11)     DEFAULT NULL COMMENT &#39;手机号码&#39;,</span><br><span class="line"> age         tinyint(3)    unsigned DEFAULT 18 COMMENT &#39;年龄&#39;,</span><br><span class="line"> idno        char(18)     DEFAULT NULL COMMENT &#39;身份证号码&#39;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>作用1:验证用户身份</strong></p><p><strong>作用2:保存用户信息</strong></p><p><strong>更好的设计是分成2个表，用户信息表和用户验证表</strong></p><p><strong>基于以下三个方面考虑</strong>：</p><p><strong>1.面向对象考虑</strong></p><p>用户信息和用户验证是两种“对象”</p><p><strong>2.性能方面考虑</strong></p><p>登录验证的时候列较少，加快查询速度。</p><p><strong>3.安全方面考虑</strong></p><p>防止在查询用户信息时，将用户密码也直接查出来，容易被恶意攻击和进行恶意操作。</p><p>添加如下表:</p><p><strong>用户验证表</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create  table user_auths(</span><br><span class="line">userid int(11) unsigned NOT NULL COMMENT &#39;外键,对应users表中的id&#39;,</span><br><span class="line">username   varchar(64)  NOT NULL UNIQUE COMMENT &#39;用户名&#39;,</span><br><span class="line">password varchar(32) NOT NULL COMMENT &#39;密码&#39;,</span><br><span class="line">FOREIGN KEY(userid) REFERENCES users(id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">可以md5(&#39;xxx&#39;)进行加密</span><br></pre></td></tr></table></figure><p><strong>可以理解为users表用来输入查询个人信息，user_auths表用来验证(注册、登录)。</strong></p><hr><p><strong>数据量大的项目必须分表！</strong></p><hr><h2 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h2><p><strong>查询数据是指从数据库中获取所需要的数据。</strong></p><p>如Jack 要达到验证用户名和密码的目的，就需要从数据库已保存的用户表中读取当前用户的密码进行验证，以验明正身！保存查询数据是数据库操作中常用且重要的操作。</p><p><strong>用户可以根据自己对数据的需求，使用不同的查询方式，获得不同的数据。</strong></p><h3 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询"></a>简单查询</h3><p>在MySQL中可以通过SQL语句来实现基本数据查询，SQL语句可以通过如下多种使用：</p><ul><li>查询所有字段数据</li><li>查询指定字段数据</li><li>避免重复数据查询</li><li>对结果进行排序和分组等查询。、</li></ul><p><strong>SELECT语句</strong>来查询数据，根据查询条件的不同，数据库系统会找到不同的数据，通过SELECT语句可以很方便地获取所需的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT field1 field2 … fieldn</span><br><span class="line">    FROM tablename</span><br><span class="line">    [WHERE CONDITION1]</span><br><span class="line">    [GROUP BY fieldm [HAVING CONDITION2]]</span><br><span class="line">    [ORDER BY fieldn [ASC|DESC]]；</span><br></pre></td></tr></table></figure><p>filed1~fieldn参数表示需要查询的字段名；</p><p>tablename参数表示表的名称；</p><p>CONDITION1参数表示查询条件；</p><p>fieldm参数表示按该字段中的数据进行分组；</p><p>CONDITION2参数表示满足该表达式的数据才能输出；</p><p>fieldn参数指按该字段中数据进行排序。</p><p>排序方式由ASC和DESC两个参数指出；</p><p>ASC参数表示按升序的顺序进行排序，是默认参数；</p><p>DESC参数表示按降序的顺序进行排序。</p><p>**(<em>号可以代替所有的字段)</em>*</p><h4 id="列出表的所有字段"><a href="#列出表的所有字段" class="headerlink" title="列出表的所有字段"></a>列出表的所有字段</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT field1,field2,…,fieldn FROM tablename;  </span><br></pre></td></tr></table></figure><p>filed1~fieldn参数表示需要查询的字段名；</p><p>tablename参数表示表的名称。</p><h4 id="符号表示所有字段"><a href="#符号表示所有字段" class="headerlink" title="*符号表示所有字段"></a>*符号表示所有字段</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tablename;  </span><br></pre></td></tr></table></figure><p>查询所有数据。</p><p>‘*’符号方式的优势比较明显，即可<strong>用该符号代替表中的所有字段</strong>，但是这种方式不够灵活，<strong>只能按照表中字段的固定顺序显示</strong>，不能随便改变字段的顺序。</p><h4 id="查询指定字段数据"><a href="#查询指定字段数据" class="headerlink" title="查询指定字段数据"></a>查询指定字段数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT field FROM tablename; </span><br></pre></td></tr></table></figure><p><strong>如果关键字SELECT后面的字段不包含在所查询的表中，那么MySQL会报错。</strong></p><p>只显示该字段的一列数据。</p><h4 id="DISTINCT查询"><a href="#DISTINCT查询" class="headerlink" title="DISTINCT查询"></a>DISTINCT查询</h4><p>实现查询不重复。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT field1,field2,…,fieldn FROM tablename; </span><br></pre></td></tr></table></figure><p>可以多个字段组合查询。</p><hr><p>例如两个字段组合查询，有两条数据中，其中一个字段相同，一个不同，那这两个就不是重复的，显示两个。反之，两个字段都相同，那就是重复的，只显示一个。</p><hr><h4 id="IN查询"><a href="#IN查询" class="headerlink" title="IN查询"></a>IN查询</h4><p> 关键字IN可以实现判断字段的数值是否在指定集合中，该关键字的具体语句形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT field1,field2,…,fieldn FROM tablename WHERE filedn IN(value1,value2,value3,…,valuen);   </span><br></pre></td></tr></table></figure><p>参数fieldn表示名称为tablename的表中的字段名，</p><p>参数valuen表示集合中的值，通过关键字IN来判断字段fieldm的值是否在集合（value1,value2,value3,…,valuen）中，如果字段fieldm的值在集合中，就满足查询条件，该记录会被查询出来，否则不会被查询出来。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select* from class where name in (&#x27;1班&#x27;);</span><br></pre></td></tr></table></figure><p><img src="/images/MySql.assets/image-20211108092025134.png" alt="image-20211108092025134"></p><p><strong>使用NOT IN可以反向查询，显示对应字段值之外的值。</strong>相当于C++中的!取反。</p><hr><p><strong>查询时慎用NULL</strong></p><blockquote><p>在具体使用关键字IN时，查询的集合中如果存在NULL，NULL对应的数据查不出来，其它字段对应的数据可以正常查询出来；</p><p>但如果使用关键字NOT IN，查询的集合中如果存在NULL，则不会查询到任何的结果。</p></blockquote><h4 id="BETWEEN-AND查询"><a href="#BETWEEN-AND查询" class="headerlink" title="BETWEEN AND查询"></a>BETWEEN AND查询</h4><p>当我们需要查询指定范围内的数据（如： id 从0 到 100）的时候，MySQL提供了关键字BETWEEN AND，用来实现判断字段的数值是否在指定范围内的条件查询。该关键字的具体语法形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT field1,field2,…,fieldn FROM tablename WHERE fieldm BETWEEN minvalue AND maxvalue  </span><br></pre></td></tr></table></figure><p>参数fieldn表示名称为tablename的表中的字段名，通过关键字BETWEEN和AND来设置字段field的取值范围，如果字段field的值在所指定的范围内，那么满足查询条件，该记录会被查询出来，否则不会被查询出来。</p><p>BETWEEN minvalue AND maxvalue，表示的是一个范围间的判断过程，<strong>只针对数字类型</strong>。</p><hr><p><strong>符合范围内的数据查询</strong></p><p>通过关键字BETWEEN 和 AND设置查询范围。</p><p><strong>代码示例</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from class where chinese between  80 and 90 ;  #查询成绩表中语文成绩在80 和 90 之间的学员记录 </span><br></pre></td></tr></table></figure><p><strong>不符合范围的数据记录查询</strong></p><p>通过关键字NOT来实现反向查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   SELECT name,chinese   </span><br><span class="line">FROM grade WHERE Chinese NOT BETWEEN 85 AND 90; </span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name,chinese from grade where chinese &lt;85 or chinese &gt;90;</span><br></pre></td></tr></table></figure><h4 id="LIKE模糊查找"><a href="#LIKE模糊查找" class="headerlink" title="LIKE模糊查找"></a>LIKE模糊查找</h4><p>当我们只想用字符串中间的一部分特征查找含有特征字串的信息时，MySQL提供了关键字LIKE来实现模糊查询，需要使用<strong>通配符</strong>，具体语法形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT field1,field2,…,fieldn FROM tablename WHERE fieldm LIKE value;    </span><br></pre></td></tr></table></figure><p>参数tablename表示表名，</p><p>参数fieldn表示表中的字段名字，通过关键字LIKE来判断字段field的值是否与value字符串匹配，如果相匹配，则满足查询条件，该记录就会被查询出来；否则就不会被查询出来。</p><hr><p>MySQL中，字符串必须加上单引号（’’）和双引号（″″）。由于关键字LIKE可以实现模糊查询，因此该关键字后面的字符串参数除了可以使用完整的字符串外，还可以包含通配符。</p><hr><table><thead><tr><th>符号</th><th>功能描述</th></tr></thead><tbody><tr><td>-</td><td>该通配符能匹配单个字符</td></tr><tr><td>%</td><td>该通配符可以匹配任意长度的字符串，既可以是0个字符、1个字符，也可以是很多字符。</td></tr></tbody></table><p><img src="/images/MySql.assets/image-20211108113404454.png" alt="image-20211108113404454"></p><p>同样的，使用NOT关键字可以查询除了这个模糊之外的数据。</p><p>在对应查询字段前加上!是同样的效果。</p><hr><p><strong>利用模糊查找同样可以实现between的效果</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例如:</span><br><span class="line">select* from grade where english like &#x27;9_&#x27;;</span><br><span class="line">查询english在<span class="number">90</span><span class="number">-99</span>之间的记录</span><br></pre></td></tr></table></figure><h4 id="对排序结果进行排序"><a href="#对排序结果进行排序" class="headerlink" title="对排序结果进行排序"></a>对排序结果进行排序</h4><p>在MySQL中，从表中查询出的数据可能是无序的，或者其排列顺序不是用户所期望的顺序，为了使查询结果的顺序满足用户的要求，可以使用关键字<strong>ORDER BY</strong>对记录进行排序，其语法形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT field1, field2, field3, …, fieldn  FROM tablename ORDER BY fieldm [ASC|DESC] </span><br></pre></td></tr></table></figure><p>参数tablename表示所要进行排序的表名，</p><p>参数fieldn表示表中的字段名字，参数fieldm表示按照该字段进行排序；ASC表示按升序进行排序；DESC表示按降序进行排序。默认的情况下按ASC进行排序。</p><hr><p><strong>注意</strong>:<br><strong>如果存在一条记录字段的值为空值（NULL）</strong>，那么按升序排序时，含空值的记录将最先显示，可以理解为空值是该字段的最小值；按降序排列时，字段为空值的记录将最后显示。</p><p><strong>例如</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select* from grade order by chinese;# 按照语文成绩排序</span><br></pre></td></tr></table></figure><h4 id="简单分组查询"><a href="#简单分组查询" class="headerlink" title="简单分组查询"></a>简单分组查询</h4><p>在具体使用统计函数时，都是针对表中所有记录数或指定特定条件（WHERE子句）的数据记录进行统计计算。在现实应用中，经常会先把所有数据记录进行分组，再对这些分组后的数据记录进行统计计算。</p><p>MySQL通过SQL语句GROUP BY来实现，分组数据查询语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT function()[,filed ]</span><br><span class="line">FROM tablename WHERE CONDITION GROUP BY field;</span><br></pre></td></tr></table></figure><p>参数field表示某字段名，通过该字段对名称为tablename的表的数据记录进行分组。</p><hr><p><strong>依据该字段的不同名字进行分组</strong></p><hr><p><strong>五个统计函数</strong></p><p>1.统计数量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OUNT(*)：该种方式可以实现对表中记录进行统计,不管表字段中包含的是NULL值还是非NULL值。</span><br><span class="line">COUNT(field):该种方式可以实现对指定字段的记录进行统计,在具体统计时将忽略NULL值。</span><br></pre></td></tr></table></figure><p>2.统计计算平均值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">该函数只有一种使用方式。</span><br><span class="line">AVG(field)使用方式:该种方式可以实现对指定字段的平均值进行计算,在具体统计时将忽略NULL值。</span><br></pre></td></tr></table></figure><p>3.统计计算求和</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">该函数只有一种使用方式。</span><br><span class="line">SUM(field)使用方式:该种方式可以实现计算指定字段值之和,在具体统计时将忽略NULL值。</span><br></pre></td></tr></table></figure><p>4.统计最大值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">该函数只有一种使用方式。</span><br><span class="line">MAX(field)使用方式:该种方式可以实现计算指定字段值中的最大值,在具体统计时将忽略NULL值。</span><br></pre></td></tr></table></figure><p>5.统计最小值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">该函数只有一种使用方式。</span><br><span class="line">MIN(field)使用方式:该种方式可以实现计算指定字段值中的最小值,在具体统计时将忽略NULL值。</span><br></pre></td></tr></table></figure><p><strong>代码示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select avg(math), class_id id from grade group by class_id;</span><br></pre></td></tr></table></figure><h4 id="统计分组"><a href="#统计分组" class="headerlink" title="统计分组"></a>统计分组</h4><p>如果想显示每个分组中的字段，可以通过函数GROUP_CONCAT()来实现。该函数可以实现显示每个分组中的指定字段，函数的具体语法形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT GROUP_CONCAT(field)</span><br><span class="line"> FROM tablename WHERE CONDITION GROUP BY field;</span><br></pre></td></tr></table></figure><p><strong>代码示例</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select class_id,count(*),group_concat(name) from grade group by class_id;</span><br></pre></td></tr></table></figure><h3 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h3><h4 id="内连接查询"><a href="#内连接查询" class="headerlink" title="内连接查询"></a>内连接查询</h4><p>联合多个表来实现查询。</p><p>在MySQL中内连接数据查询通过“INNER JOIN…ON”语句来实现，语法形式如下所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT field1,field2,…,fieldn FROM tablename1 INNER JOIN tablename2 [INNER JOIN tablenamen] ON CONDITION</span><br></pre></td></tr></table></figure><p>其中：<br>参数fieldn表示要查询的字段名，来源于所连接的表tablename1和tablename2，关键字INNER JOIN表示表进行内连接，</p><p>参数CONDITION表示进行匹配的条件。</p><p><strong>例如</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from class  inner join student  on class.id &#x3D; student.class_id;  #查询class 表和student 表中班级字段相同的记录并进行内连接  </span><br></pre></td></tr></table></figure><p>无所谓两个表的前后顺序。</p><p><strong>也可以通过起别名进行链接查询。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from class as a inner join student as b where a.id &#x3D; b.class_id; #同上，使用别名查询</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT field1, field2, ...,fieldn [AS] otherfieldn </span><br><span class="line">FROM tablename1 [AS] othertablename1, ...,</span><br><span class="line">  Tablenamen [AS] othertablenamen ... where othertablename1.fieldx &#x3D; othertablenamen.fieldx ... ;</span><br></pre></td></tr></table></figure><p>其中，参数tablename<em>为表原来的名字，参数othertablename</em>为新表名，之所以要为表设置新的名字，是为了让SQL语句代码更加直观、更加人性化和实现更加复杂的功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select t1.id,t1.name,t1.sex,t1.class_id from student AS t1 inner join class t2 on  t1.class_id &#x3D; t2.id;</span><br></pre></td></tr></table></figure><h5 id="自链接"><a href="#自链接" class="headerlink" title="自链接"></a>自链接</h5><p>就是表与其自身进行连接。</p><p>例如在一个学生表中找到小花的同班同学。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select* from student s1 inner join student s2 on s1.class_id &#x3D; s2.class_id and s1.name &#x3D; &#39;小花&#39;and s2.name !&#x3D;&#39;小花&#39;;</span><br></pre></td></tr></table></figure><h5 id="等值连接"><a href="#等值连接" class="headerlink" title="等值连接"></a>等值连接</h5><p>内连接查询中的等值连接就是在关键字ON后的匹配条件中通过等于关系运算符(=)来实现等值条件。</p><p>例如:将班级表和学生表连接到一起，条件是班级的id和学生的班级id相同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select* from class as a inner join student as b where a.id &#x3D; b.class_id;</span><br></pre></td></tr></table></figure><h5 id="不等值连接"><a href="#不等值连接" class="headerlink" title="不等值连接"></a>不等值连接</h5><p>同等值连接，只不过运算符不同。</p><p>内连接查询中的不等连接就是在关键字ON后的匹配条件中通过除了等于关系运算符来实现不等条件外，还可以使用关系运算符，包含“&gt;”“&gt;=”“&lt;”“&lt;=”和“!=”等运算符号。</p><h4 id="外连接查询"><a href="#外连接查询" class="headerlink" title="外连接查询"></a>外连接查询</h4><p>当我们在查询数据时，要求返回所操作表中至少一个表的所有数据记录，通过SQL语句“OUTER JOIN…ON”来实现。外连接数据查询语法形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT field1,field2,…,fieldn FROM tablename1 LEFT|RIGHT [OUTER] JOIN tablename2</span><br><span class="line"> ON CONDITION</span><br></pre></td></tr></table></figure><p>参数fieldn表示所要查询的字段名字，来源于所连接的表tablename1和tablename2，</p><p>关键字OUTER JOIN表示表进行外连接，</p><p>参数CONDITION表示进行匹配的条件。</p><h5 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h5><p>就是指新关系中执行匹配条件时，以关键字<strong>LEFT JOIN</strong>(outer可以省略)左边的表为参考表。<strong>左连接的结果包括LEFT OUTER字句中指定的左表的所有行</strong>，而不仅仅是连接列所匹配的行，如果左表的某行在右表中没有匹配行，则在相关联的结果行中，右表的所有选择列表均为空值。</p><hr><p><strong>就是</strong>,left join左边的表中所有数据都会显示，而left join表右边的值根据on 后面的条件进行保留匹配。</p><hr><p><strong>例如:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select* from class as a left join student as b on a.id &#x3D; b.class_id;</span><br></pre></td></tr></table></figure><h5 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h5><p>同左外连接，只是肯定显示(保留)的是right join的右边表。</p><hr><p>无论是哪种查询方式，先写的表的字段在前面显示。</p><hr><h4 id="合并查询数据记录"><a href="#合并查询数据记录" class="headerlink" title="合并查询数据记录"></a>合并查询数据记录</h4><p>在MySQL中通过关键字UNION来实现合并操作，即可以通过其将多个SELECT语句的查询结果合并在一起，组成新的关系。在MySQL软件中，合并查询数据记录可通过SQL语句UNION来实现，具体语法形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT field1,field2,…,fieldn  FROM tablename1</span><br><span class="line">    UNION | UNION ALL</span><br><span class="line">    SELECT field1,field2,…,fieldn  FROM tablename2</span><br><span class="line">    UNION | UNION ALL  SELECT field1,field2,…,fieldn ;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：<br>多个选择语句select 的列数相同就可以合并,union和union all的主要区别是union all是把结果集直接合并在一起，而union 是将union all后的结果再执行一次distinct，去除重复的记录后的结果。</p><p><strong>前后的字段个数相同</strong></p><p><strong>例如</strong>：将class表中的老师和student表中的学生整合到一起。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select teacher from class union all select name  from student;</span><br></pre></td></tr></table></figure><p><img src="/images/MySql.assets/image-20211121123500746.png" alt="image-20211121123500746"></p><p><strong>字段显示优化</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select teacher as person from class union all select name as person from student;</span><br></pre></td></tr></table></figure><p><img src="/images/MySql.assets/image-20211121123631571.png" alt="image-20211121123631571"></p><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><p>所谓子查询，是指在一个查询中嵌套了其他的若干查询，即在一个SELECT查询语句的WHERE或FROM子句中包含另一个SELECT查询语句。在查询语句中，外层SELECT查询语句称为主查询，WHERE子句中的SELECT查询语句被称为子查询，也被称为嵌套查询。</p><p>通过子查询可以实现多表查询，该查询语句中可能包含IN、ANY、ALL和EXISTS等关键字，除此之外还可能包含比较运算符。理论上，子查询可以出现在查询语句的任意位置，但是在实际开发中子查询经常出现在WHERE和FROM子句中。</p><h5 id="带比较运算符的子查询"><a href="#带比较运算符的子查询" class="headerlink" title="带比较运算符的子查询"></a>带比较运算符的子查询</h5><p>子查询可以使用比较运算符。这些比较运算符包括=、!=、&gt;、&gt;=、&lt;、&lt;=和&lt;&gt;等。其中，&lt;&gt;与!=是等价的。比较运算符在子查询中使用得非常广泛，如查询分数、年龄、价格和收入等。</p><p><strong>示例</strong>：查询云云的班主任是谁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select teacher from class where id &#x3D; (select class_id from student where name &#x3D;&#39;云云&#39;); # 查询在class表中，那个老师教的班级和student表中云云的班级相同</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：使用比较运算符时，select子句获得的数据不能大于1条。</p><h5 id="带有关键字IN的子查询"><a href="#带有关键字IN的子查询" class="headerlink" title="带有关键字IN的子查询"></a>带有关键字IN的子查询</h5><p>用途：一个查询语句的条件可能在另一个Select语句的结果中，这时候就可以使用IN /  NOT IN 关键字。</p><p><strong>示例</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select teacher from class where id in (select class_id from student where name like &#39;小%&#39;);# 查询名字是小什么的班主任都是谁</span><br></pre></td></tr></table></figure><h5 id="带关键字EXISTS的子查询"><a href="#带关键字EXISTS的子查询" class="headerlink" title="带关键字EXISTS的子查询"></a>带关键字EXISTS的子查询</h5><p>​        关键字EXISTS表示存在，后面的参数是一个任意的子查询，系统对子查询进行运算以判断它是否返回行；如果至少返回一行，那么EXISTS的结果为true，此时外层语句将进行查询；如果子查询没有返回任何行，那么EXISTS返回的结果是<strong>false，此时外层语句将不进行查询。</strong></p><p><strong>示例</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select* from class where id &#x3D; 102 and exists(select* from student where class_id &#x3D; 102); # 如果102班存在学生记录，就查询102班的班级信息</span><br></pre></td></tr></table></figure><h5 id="带关键字ANY的子查询"><a href="#带关键字ANY的子查询" class="headerlink" title="带关键字ANY的子查询"></a>带关键字ANY的子查询</h5><p>​        关键字ANY表示满足其中任一条件。使用关键ANY时，<strong>只要满足内层查询语句返回的结果中的任何一个就可以通过该条件来执行外层查询语句。</strong></p><p><strong>示例</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select id,name,chinese+math+english as total from grade where chinese+english+math &gt;&#x3D; ANY(select score from scholarship);</span><br><span class="line">#查询能获得将学金的同学记录</span><br></pre></td></tr></table></figure><h5 id="带关键字ALL的子查询"><a href="#带关键字ALL的子查询" class="headerlink" title="带关键字ALL的子查询"></a>带关键字ALL的子查询</h5><p>类似带关键字ANY的子查询，内层查询语句要全部满足条件才能执行外部查询语句。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id,name,chinese+math+english as total from grade where chinese + english + math &gt;&#x3D; ALL(select score from scholarship);</span><br></pre></td></tr></table></figure><h2 id="视图操作"><a href="#视图操作" class="headerlink" title="视图操作"></a>视图操作</h2><p>例如:每个班抽出几个学生组成一个临时班级。</p><p>视图是从一个或多个表中导出来的表，是一种虚拟存在的表。视图就像一个窗口，通过这个窗口可以看到系统的专门提供的数据，这样用户就可以不看整个数据库表中的数据，而只关心对自己有用的数据。</p><p>视图可以使用户的操作更方便，并且可以保障数据库系统的安全性。</p><h3 id="为什么要使用视图"><a href="#为什么要使用视图" class="headerlink" title="为什么要使用视图"></a>为什么要使用视图</h3><p>为了提高复杂的SQL语句的复用性和表的操作的安全性，MySQL数据库管理系统提供了视图特性。所谓视图，<strong>本质上是一种虚拟表</strong>，其内容与真实的表相似，包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储数据值的形式存在，行和列数据来自定义视图的查询所引用的基本表，并且在具体引用视图时动态生成。</p><p>视图使程序员只关心感兴趣的某些特定数据和他们所负责的特定任务。这样程序员只能看到视图中所定义的数据，而不是视图所引用表中的数据，从而提高数据库中数据的安全性。</p><h3 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h3><p>虽然视图可以被看成是一种虚拟表，但是其物理上是不存在的，即MySQL并没有专门的位置为视图存储数据。根据视图的概念可以发现其数据来源于查询语句，因此创建视图的基本语法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE[OR REPLACE] VIEW viewname[columnlist] AS SELECT statement; </span><br></pre></td></tr></table></figure><p><strong>查看用户权限创建视图的权限</strong></p><p>创建视图需要登陆用户有相应的权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select user,Select_priv,Create_view_priv from mysql.user;</span><br></pre></td></tr></table></figure><p><strong>示例</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#为学生表创建视图</span><br><span class="line">CREATE VIEW view_student AS select id,class_id,name from student;</span><br><span class="line">#查看视图</span><br><span class="line">desc view_student;</span><br><span class="line">#根据视图进行查询</span><br><span class="line">select* from view student;</span><br></pre></td></tr></table></figure><p>通过视同只允许查询者查看允许查看的那几个字段。</p><p>也可以修改视图中对应字段的值，就相当于更新了对应表中对应字段的值。</p><hr><p><strong>在多表上创建视图(联合多个表创建视图)</strong><br>不能联合重复名字的字段。用as起别名解决。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE[OR REPLACE] VIEW viewname[columnlist] AS SELECT statement                  </span><br></pre></td></tr></table></figure><p><strong>示例</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW view_student_class AS select student.id, student.name, class.name as class_name,  class.teacher from class inner join student  on class.id &#x3D; student.class_id;</span><br><span class="line"># class.id &#x3D;&#x3D; student.class_id 班级id和学生对应的班级id相同的数据。</span><br></pre></td></tr></table></figure><h3 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h3><p>更新视图是指通过视图来插入（INSERT）、更新（UPDATE）和删除（DELETE）表中的数据。因为视图实质是一个虚拟表，其中没有数据，通过视图更新时都是转换到基本表更新。更新视图时，只能更新权限范围内的数据，超出范围就不能更新了。</p><p>更新视图就是对原来的表进行更新。</p><p><strong>示例</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update view_student set name&#x3D;&#39;小花花&#39; where name&#x3D;&#39;小花&#39;; #通过视图更新小花为小花花</span><br></pre></td></tr></table></figure><p><strong>不能更新的情况</strong></p><ol><li><p>视图中包含SUM()、COUNT()、MAX()和MIN()等函数</p></li><li><p>视图中包含UNION、UNION ALL、DISTINCT、GROUP BY和HAVING等关键字</p></li><li><p>视图对应的表存在没有默认值的列，而且该列没有包含在视图里</p></li><li><p>包含子查询的视图</p></li><li><p>其他特殊情况</p></li></ol><p>**就是，在视图视角下，准备输入的这条插入语句是否可以在原来的表情况下完成插入，能插入就能在当前视图下插入(更新视图)**。</p><h3 id="修改视图"><a href="#修改视图" class="headerlink" title="修改视图"></a>修改视图</h3><p>修改视图是指修改数据库中存在的视图，当基本表的某些字段发生变化的时候，可以通过修改视图来保持与基本表的一致性。ALTER语句来修改视图。</p><p><strong>示例</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter view view_student_class as select id,class_id ,name1,sex from student;</span><br></pre></td></tr></table></figure><p><strong>追加视图</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter view view_student_class AS select student.id,student.name1,class.name,class.id as class_id,class.teacher from class inner join student on class.id &#x3D; student.class_id;</span><br></pre></td></tr></table></figure><h3 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h3><p>删除数据库中已经存在的视图。</p><p>删除是视图时，只能删除视图的定义，不会删除数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP VIEW viewname;</span><br></pre></td></tr></table></figure><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>触发器（TRIGGER）是由事件来触发某个操作。这些事件包括INSERT语句、UPDATE语句和DELETE语句。当数据库系统执行这些事件时，就会激活触发器执行相应的操作。MySQL从5.0.2版本开始支持触发器。</p><h3 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h3><p>CREATE TRIGGER来实现创建。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE trigger trigger_name BEFORE|AFTER trigger_EVENT ON TABLE_NAME FOR EACH ROW trigger_STMT           </span><br></pre></td></tr></table></figure><p>参数trigger_name表示要创建的触发器名；</p><p>参数BEFORE和AFTER指定了触发器执行的时间，前者在触发器事件之前执行触发器语句，后者在触发器事件之后执行触发器语句；</p><p>参数trigger_EVENT表示触发事件，即触发器执行条件，包含DELETE、INSERT和UPDATE语句；参数TABLE_NAME表示触发事件的操作表名；参数FOR EACH ROW表示任何一条记录上的操作满足触发事件都会触发该触发器；</p><p>参数trigger_STMT表示激活触发器后被执行的语句。执行语句中如果要引用更新记录中的字段，<strong>对于INSERT语句,只有NEW是合法的</strong>，表示当前已插入的记录；<strong>对于DELETE语句，只有OLD才合法，表示当前删除的记录；而UPDATE语句可以和NEW（更新后）以及OLD（更新前）同时使用。</strong></p><p><strong>示例</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create trigger tri_insert_student after insert on student for each row update class set count&#x3D;count+1 where class.id &#x3D; NEW.class_id; #创建触发器，新增学员班级人数增1</span><br><span class="line"></span><br><span class="line">create trigger tri_delete_student after delete on student for each row update class set count&#x3D;count-1 where id &#x3D; OLD.class_id; </span><br><span class="line">#创建触发器，删除学员班级人数减1</span><br></pre></td></tr></table></figure><p><strong>触发器包含多条语句</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE   trigger trigger_name BEFORE|AFTER trigger_EVENT  ON TABLE_NAME FOR EACH ROW                                 </span><br><span class="line">BEGIN                                                        </span><br><span class="line">trigger_STMT                                                 </span><br><span class="line">END       </span><br></pre></td></tr></table></figure><p>在上述语句中，比“只有一条执行语句的触发器”语法多出来两个关键字BEGIN和END，在这两个关键字之间是所要执行的多个执行语句的内容，执行语句之间用分号隔开。</p><p>在MySQL中，一般情况下用“;”符号作为语句的结束符号，可是在创建触发器时，需要用到“;”符号作为执行语句的结束符号。为了解决该问题，可以使用关键字DELIMITER语句。<strong>例如，“DELIMITER $$”可以将结束符号设置成“$$”。</strong></p><p><strong>示例</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create trigger tri_delete_student after delete on student for each row </span><br><span class="line">      BEGIN                                    </span><br><span class="line">       Delete from grade where id &#x3D; OLD.id;  #删除成绩表中的记录                                                        </span><br><span class="line">       update class set count&#x3D;count-1 where id &#x3D; OLD.class_id; #更新班级表中的记录   </span><br><span class="line">       END;                                    </span><br><span class="line">       $$          </span><br></pre></td></tr></table></figure><h3 id="查看触发器"><a href="#查看触发器" class="headerlink" title="查看触发器"></a>查看触发器</h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW TRIGGER;</span><br></pre></td></tr></table></figure><p>执行完“SHOW TRIGGERS”语句后会显示一个列表，在该列表中会显示出所有触发器的信息。其中，参数Trigger表示触发器的名称；参数Event表示触发器的激发事件；参数Table表示触发器对象触发事件所操作的表；参数Statement表示触发器激活时所执行的语句；参数Timing表示触发器所执行的时间。</p><p><strong>示例</strong>：<br><img src="/images/MySql.assets/image-20211125162851920.png" alt="image-20211125162851920"></p><p><strong>从系统表查看触发器</strong></p><p>在MySQL中，在系统数据库information_schema中存在一个存储所有触发器信息的系统表triggers，因此查询该表格的记录也可以实现查看触发器功能。系统表triggers的表结构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;  use information_schema;   #选择数据库information_schema                  </span><br><span class="line">mysql&gt;  select * from triggers;                                                        </span><br><span class="line">mysql&gt;  select * from triggers where trigger_name&#x3D;’tri_delete_student’; #查询系统表triggers中的触发器    </span><br></pre></td></tr></table></figure><p><strong>删除触发器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TRIGGERS triggers_name;</span><br></pre></td></tr></table></figure><h2 id="存储过程和函数"><a href="#存储过程和函数" class="headerlink" title="存储过程和函数"></a>存储过程和函数</h2><h3 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h3><p>创建存储过程和函数是指将经常使用的一组SQL语句组合在一起，并将这些SQL语句当作一个整体存储在MySQL服务器中。存储程序可以分为存储过程和函数。在MySQL中创建存储过程使用的语句CREATE PROCEDURE。其语法形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE procedure_name([proc_param[,…]])   routine_body    </span><br></pre></td></tr></table></figure><p>在上述语句中，参数procedure_name表示所要创建的存储过程名字，参数proc_param表示存储过程的参数，参数routine_body表示存储过程的SQL语句代码，可以用BEGIN…END来标志SQL语句的开始和结束。</p><p>proc_param中每个参数的语法形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[IN|OUT|INOUT] param_name type</span><br></pre></td></tr></table></figure><p>在上述语句中，每个参数由三部分组成，分别为输入/输出类型、参数名和参数类型。其中，输入/输出类型有三种类型，分别为IN（表示输入类型）、OUT（表示输出类型）、INOUT（表示输入/输出类型）。param_name表示参数名；type表示参数类型，可以是MySQL软件所支持的任意一个数据类型。</p><p><strong>示例</strong>：</p><p>删除一名学生同时删除对应的成绩表中的信息，并将对应班级表中的人数-1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">create PROCEDURE  proc_delete_student (IN sid int )                                   </span><br><span class="line">        BEGIN </span><br><span class="line">         declare cid  int ;   #定义变量cid                            </span><br><span class="line">         Select class_id into cid from student where id &#x3D; sid;    #通过查询语句设置变量      </span><br><span class="line"> #根据输入的学生在student表拿到该学生对应的班级id，并将这个班级id存储到cid中，用于下面的操作。</span><br><span class="line">         delete from grade where id &#x3D; sid;  #删除成绩表中的记录  </span><br><span class="line">         delete from student where id &#x3D; sid;   #删除学生表中的记录                                                    </span><br><span class="line">         update class set count&#x3D;count-1 where id &#x3D; cid; #更新班级表中的记录   </span><br><span class="line">        END;                                                                        </span><br><span class="line">        ##     </span><br></pre></td></tr></table></figure><p><strong>调用存储过程</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call proc_delete_student(3);# 删除学生的id号。</span><br></pre></td></tr></table></figure><p><strong>注意：上述代码并没有对合法性进行检查，是有出现错误的风险的！！！</strong></p><h4 id="在存储过程中使用变量"><a href="#在存储过程中使用变量" class="headerlink" title="在存储过程中使用变量"></a>在存储过程中使用变量</h4><p>在存储过程和函数中，可以定义和使用变量。用户可以使用关键字DECLARE来定义变量，然后为变量赋值。这些变量的作用范围是在BEGIN…END程序段中。</p><h5 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE var_name[,…] type [DEFAULT value]   </span><br></pre></td></tr></table></figure><p>其中，关键字DECLARE是用来声明变量的；</p><p>参数var_name是变量的名称，可以同时定义多个变量；</p><p>参数type用来指定变量的类型；</p><p>DEFAULT value子句将变量默认值设置为value，没有使用DEFAULT子句时，默认值为NULL。</p><p>定义变量cid，数据类型为INT型，默认值为10，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE cid INT DEFAULT 10;  </span><br></pre></td></tr></table></figure><h5 id="为变量赋值"><a href="#为变量赋值" class="headerlink" title="为变量赋值"></a>为变量赋值</h5><p>关键字SET用来为变量赋值；</p><p>参数var_name是变量的名称；</p><p>参数expr是赋值表达式。</p><p>一个SET语句可以同时为多个变量赋值，各个变量的赋值语句之间用逗号隔开。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE cid INT DEFAULT 10;  </span><br></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set tmp_id &#x3D; 88;</span><br></pre></td></tr></table></figure><p>还可以使用SELECT…INTO语句为变量赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT col_name[,…] INTO var_name[,…]   </span><br><span class="line"></span><br><span class="line">FROM table_name WHERE condition     </span><br></pre></td></tr></table></figure><p>参数col_name表示查询的字段名称；</p><p>参数var_name是变量的名称；</p><p>参数table_name指表的名称；</p><p>参数condition指查询条件。</p><p><strong>示例</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">create procedure  query_student_class_info (IN sid int, OUT cname varchar(128), OUT ccount  int)                                   </span><br><span class="line">       BEGIN   </span><br><span class="line">           declare tmp_name varchar(128);</span><br><span class="line">           declare tmp_count int;</span><br><span class="line">           declare tmp_cid  int;</span><br><span class="line">           select class_id into tmp_cid from student where id &#x3D; sid;         </span><br><span class="line">           select name, count into tmp_name, tmp_count from class where id &#x3D; tmp_cid;</span><br><span class="line">           set cname &#x3D; tmp_name, ccount &#x3D; tmp_count;</span><br><span class="line">        END;    </span><br><span class="line">        $$    </span><br></pre></td></tr></table></figure><p><strong>调用存储过程</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class query_student_class_info(4,@name,@count);</span><br><span class="line"># 显示</span><br><span class="line">select name,count;</span><br></pre></td></tr></table></figure><h4 id="光标的使用"><a href="#光标的使用" class="headerlink" title="光标的使用"></a>光标的使用</h4><p>查询语句<strong>可能查询出多条记录</strong>，在存储过程和函数中使用光标来逐条读取查询结果集中的记录。有些书上将光标称为游标。光标的使用包括声明光标、打开光标、使用光标和关闭光标。<strong>光标必须声明在处理程序之前，并且声明在变量和条件之后。</strong></p><h5 id="声明光标"><a href="#声明光标" class="headerlink" title="声明光标"></a>声明光标</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DECLARE cursor_name CURSOR         </span><br><span class="line">FOR select_statement;                  </span><br></pre></td></tr></table></figure><p>参数cursor_name表示光标的名称；</p><p>参数select_statement表示SELECT语句的内容。</p><p><strong>示例</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create procedure  query_student (IN sid int, OUT cname varchar(128), OUT class_id  int )                                 </span><br><span class="line">       BEGIN                                                  </span><br><span class="line">           DECLARE cur_student CURSOR                     </span><br><span class="line">               FOR SELECT name, class_id FROM  student;    </span><br><span class="line">        END;                                                  </span><br><span class="line">        $$      </span><br></pre></td></tr></table></figure><p>上面的字段中，光标的名称为cur_student;</p><p>select语句部分是从表student中查询出字段name和class_id的值。</p><h5 id="打开光标"><a href="#打开光标" class="headerlink" title="打开光标"></a>打开光标</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OPEN cursor_name;</span><br></pre></td></tr></table></figure><h5 id="使用光标"><a href="#使用光标" class="headerlink" title="使用光标"></a>使用光标</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FETCH cursor_name </span><br><span class="line">INTO var_name[var_name] </span><br></pre></td></tr></table></figure><p>参数cursor_name表示光标的名称；</p><p>参数var_name表示将光标中的SELECT语句查询出来的信息存入该参数中。var_name必须在声明光标之前就定义好。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> create procedure query_student (IN sid int, OUT cname varchar(128), OUT cid int)                            </span><br><span class="line">        BEGIN                               </span><br><span class="line">            declare tmp_name varchar(128);  #必须定义在声明光标之前 </span><br><span class="line">            declare tmp_cid  int;                     </span><br><span class="line">            declare  done int default 0;               </span><br><span class="line">            declare cur_student CURSOR FOR SELECT name, class_id FROM  student where id &#x3D; sid;                 </span><br><span class="line">            declare continue handler for not found set done &#x3D; 1; #将结束标志绑定到游标上                           </span><br><span class="line">            open  cur_student;                         </span><br><span class="line">            select done;                               </span><br><span class="line">            fetch cur_student into tmp_name, tmp_cid;   </span><br><span class="line">            select done;                               </span><br><span class="line">            select tmp_name, tmp_cid; #打印从光标中获取到的值                 </span><br><span class="line">            close cur_student;                         </span><br><span class="line">            set cname &#x3D; tmp_name, cid &#x3D; tmp_cid;       </span><br><span class="line">         END;                                                                              </span><br><span class="line">mysql&gt; ##    </span><br></pre></td></tr></table></figure><h4 id="流程控制的使用"><a href="#流程控制的使用" class="headerlink" title="流程控制的使用"></a>流程控制的使用</h4><h5 id="IF语句"><a href="#IF语句" class="headerlink" title="IF语句"></a>IF语句</h5><p>IF语句用来进行条件判断。根据条件执行不同的语句。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IF search_condition THEN statement_list       </span><br><span class="line">[ELSEIF search_condition THEN statement_list] ...</span><br><span class="line">[ELSE statement_list]                           </span><br><span class="line">END  IF                                      </span><br></pre></td></tr></table></figure><p>参数search_condition表示条件判断语句；参数statement_list表示不同条件的执行语句。</p><p><strong>示例</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> create procedure proc_test_if (IN input int, OUT output int)</span><br><span class="line">        begin</span><br><span class="line">            if input&gt;20 then set input&#x3D;input+1;</span><br><span class="line">            elseif input&#x3D;20 then  set input&#x3D;input+2;</span><br><span class="line">            else  set input &#x3D; input+3;</span><br><span class="line">            end if;</span><br><span class="line"></span><br><span class="line">            set output &#x3D; input;</span><br><span class="line">        end; </span><br><span class="line">mysql&gt;  $$             </span><br></pre></td></tr></table></figure><h5 id="CASE语句"><a href="#CASE语句" class="headerlink" title="CASE语句"></a>CASE语句</h5><p>CASE语句可以实现比IF语句更复杂的条件判断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CASE case_value                                  </span><br><span class="line">WHEN when_value THEN statement_list            </span><br><span class="line">[ WHEN when_value THEN statement_list ]          </span><br><span class="line">[ELSE statement_list]                               </span><br><span class="line">END CASE                                         </span><br></pre></td></tr></table></figure><p>其中，参数case_value表示条件判断的变量；</p><p>参数when_value表示变量的取值；</p><p>参数statement_list表示不同when_value值的执行语句。</p><p>类似IF ELSE语句。</p><p><strong>示例</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  create procedure proc_test_case3 (IN input int, OUT output int)</span><br><span class="line">       begin</span><br><span class="line">       case input</span><br><span class="line">            when 30 then set output&#x3D;input+1;</span><br><span class="line">            when 20 then  set output&#x3D;input+2;</span><br><span class="line">            else  set output &#x3D; input+3;</span><br><span class="line">            end case;      </span><br><span class="line">        end; </span><br><span class="line">##    </span><br></pre></td></tr></table></figure><p><strong>case语句要是确定的值，不能像IF语句一样是一个范围。</strong></p><h5 id="LOOP语句"><a href="#LOOP语句" class="headerlink" title="LOOP语句"></a>LOOP语句</h5><p>LOOP语句可以使某些特定的语句重复执行，实现一简单的循环。</p><p>LOOP语句本身没有停止循环，只有遇到LEVEA语句等才能停止循环。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[begin_label:] LOOP             </span><br><span class="line">statement_list                  </span><br><span class="line">END LOOP [end_label]          </span><br></pre></td></tr></table></figure><p>参数begin_label和参数end_label分别表示循环开始和结束的标志，这两个标志必须相同，而且都可以省略；</p><p>参数statement_list表示需要循坏执行的语句。</p><p><strong>示例</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add_num:LOOP                 </span><br><span class="line">     SET @count &#x3D; @count + 1; </span><br><span class="line">END LOOP add_num;            </span><br></pre></td></tr></table></figure><p>该示例循环执行count加1的操作。因为没有跳出循环的语句，这个循环成了一个死循环。LOOP循环都以END LOOP结束。</p><h5 id="LEVEA语句"><a href="#LEVEA语句" class="headerlink" title="LEVEA语句"></a>LEVEA语句</h5><p>LEAVE语句主要用于跳出循环控制，其语法形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LEAVE label          </span><br></pre></td></tr></table></figure><p>其中，参数label表示循环的标志。</p><p><strong>相当于C/C++中的break</strong></p><p><strong>示例</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add_num: LOOP             </span><br><span class="line">SET @count&#x3D;@count + 1;</span><br><span class="line">Select @count;</span><br><span class="line">IF @count &#x3D; 100 THEN </span><br><span class="line">    LEAVE add_num;     </span><br><span class="line">END IF;</span><br><span class="line">END LOOP add_num;         </span><br></pre></td></tr></table></figure><p>该示例循环执行count值加1的操作。当count的值等于100时，LEAVE语句跳出循环。</p><p><strong>示例1</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">create procedure proc_test_loop(IN input int,OUT output int)</span><br><span class="line">     begin</span><br><span class="line">     add_num:LOOP</span><br><span class="line">     set input &#x3D; input +1;</span><br><span class="line">     if input&#x3D;100 then</span><br><span class="line">      LEAVE add_num;</span><br><span class="line">     end if;</span><br><span class="line">     end loop add_num;</span><br><span class="line">     set output &#x3D; input;</span><br><span class="line">     select input,output;</span><br><span class="line">     end;</span><br><span class="line">     ##</span><br></pre></td></tr></table></figure><p><strong>示例2</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">create procedure proc_test_loop1(IN input int,OUT output int)</span><br><span class="line">      begin</span><br><span class="line">      set @count &#x3D;1;&#x2F;&#x2F;会话变量，只在当前窗口生效</span><br><span class="line">      add_num:LOOP</span><br><span class="line">      set @count &#x3D; @count +1;</span><br><span class="line">      if @count &#x3D;100 then leave add_num ;</span><br><span class="line">      select @count;</span><br><span class="line">      end if;</span><br><span class="line">      end LOOP add_num;</span><br><span class="line">      end ;</span><br><span class="line">      ##</span><br></pre></td></tr></table></figure><h5 id="ITERATE语句"><a href="#ITERATE语句" class="headerlink" title="ITERATE语句"></a>ITERATE语句</h5><p>ITERATE语句也是用来跳出循环的语句，但是ITERATE语句是跳出本次循环，然后直接进入下一次循环。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ITERATE label  </span><br></pre></td></tr></table></figure><p>参数label表示循环的标志。</p><p><strong>类似于C/C++中的continue</strong></p><p><strong>示例</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">create procedure proc_test_proc(IN input int,OUT output int)</span><br><span class="line">     begin</span><br><span class="line">      add_num1:LOOP</span><br><span class="line">     if input&gt;10 then iterate add_num1;</span><br><span class="line">     else set output &#x3D; input+100;</span><br><span class="line">   leave add_num1;</span><br><span class="line">     end if;</span><br><span class="line">     end LOOP add_num1;</span><br><span class="line">     end;</span><br><span class="line">     ##</span><br></pre></td></tr></table></figure><p>上述示例中，输入大于10的数就会陷入死循环。</p><h5 id="REPEAT语句"><a href="#REPEAT语句" class="headerlink" title="REPEAT语句"></a>REPEAT语句</h5><p>REPEAT语句是有条件控制的循环语句。当满足特定条件时，就会跳出循环语句。</p><p><strong>先执行再判断条件。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[begin_label:] REPEAT        </span><br><span class="line">statement_list;       </span><br><span class="line">UNTIL search_condition </span><br><span class="line">END REPEAT [end_label]     </span><br></pre></td></tr></table></figure><p>参数statement_list表示循环的执行语句；</p><p>参数search_condition表示结束循环的条件，满足该条件时循环结束。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">create procedure proc_test_repeat2(IN input int,OUT output int)</span><br><span class="line">      begin</span><br><span class="line">      REPEAT</span><br><span class="line">      set input &#x3D; input + 1;</span><br><span class="line">      UNTIL input &gt;100</span><br><span class="line">      END REPEAT;</span><br><span class="line">      set output &#x3D; input;</span><br><span class="line">      end;</span><br><span class="line">      ##</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：结束条件后不用加；</p><h5 id="WHILE语句"><a href="#WHILE语句" class="headerlink" title="WHILE语句"></a>WHILE语句</h5><p>WHILE语句也是有条件控制的循环语句，但WHILE语句和REPEAT语句是不一样的。WHILE语句是当满足条件时执行循环内的语句。</p><p><strong>先判断条件再执行语句。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[begin_label:] WHILE search_condition DO   </span><br><span class="line">        Statement_list                      </span><br><span class="line">END WHILE [end_label]                     </span><br></pre></td></tr></table></figure><p>其中，参数statement_condition表示循环执行的条件，满足该条件时循环执行；参数statement_list表示循环的执行语句。</p><p>​    <strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WHILE @count&lt;100 DO       </span><br><span class="line">SET @count &#x3D; @count + 1;</span><br><span class="line">END WHILE;    </span><br></pre></td></tr></table></figure><h5 id="流程控制综合运用"><a href="#流程控制综合运用" class="headerlink" title="流程控制综合运用"></a>流程控制综合运用</h5><p><strong>示例</strong>：<strong>循环访问光标操作，访问光标中的所有记录。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">reate procedure query_all_students (IN sid int, OUT cname varchar(128), OUT cid int)                                                                                    </span><br><span class="line">        BEGIN                                                                             </span><br><span class="line">            declare tmp_name varchar(128);    #必须定义在声明光标之前                                                                                             </span><br><span class="line">            declare tmp_cid  int;                                                           </span><br><span class="line">            declare  done int default 0;                                                                                                                                                </span><br><span class="line">            declare cur_student CURSOR FOR SELECT name, class_id FROM  student ;                                                                                      </span><br><span class="line">            declare continue handler for not found set done &#x3D; 1; #将结束标志绑定到游标上                                                                             </span><br><span class="line">            open  cur_student;                                                             </span><br><span class="line">            read_loop:LOOP      #循环读取                                                                   </span><br><span class="line">                fetch cur_student into tmp_name, tmp_cid;                                                                                                                              </span><br><span class="line">                IF done&#x3D;1 then                                                              </span><br><span class="line">                    Leave read_loop;                                                                  </span><br><span class="line">                END IF;                                                                     </span><br><span class="line">                select tmp_name, tmp_cid;         #打印从光标中获取到的值                                                                                       </span><br><span class="line">            END LOOP read_loop;                                                                                </span><br><span class="line">            close cur_student;                                                              </span><br><span class="line">            set cname &#x3D; tmp_name, cid &#x3D; tmp_cid;                                               END;  </span><br><span class="line">           ##                </span><br></pre></td></tr></table></figure><hr><p><strong>示例</strong>：<strong>在学生表中插入一条记录，并返回记录的自增长id</strong>。</p><blockquote><p><strong>返回记录的自增长最新id,select last_insert_id();</strong></p><p><strong>而不是用select max(id) from student;避免多用户对数据库进行操作的情况。</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;  use school;   #选择数据库school                                                                                                                         </span><br><span class="line">mysql&gt; DELIMITER $$                                                                                </span><br><span class="line">mysql&gt; create procedure fetch_insert_student_id (IN p_name varchar(128), in p_class_id int, IN p_sex char(1), OUT rid int)                                                                                    </span><br><span class="line">        BEGIN                                                                             </span><br><span class="line">            Insert into student (name, class_id, sex) values(p_name, p_class_id, p_sex);                                                                                </span><br><span class="line">            select last_insert_id() as rid;                                                                                                                     </span><br><span class="line">         END;                                                                              </span><br><span class="line">mysql&gt;  $$                                                                               </span><br><span class="line">mysql&gt;  DELIMITER ;         </span><br></pre></td></tr></table></figure><p><strong>从第二个示例不难看出，存储结构就是对一些语句的整合。</strong></p><h3 id="查看存储过程"><a href="#查看存储过程" class="headerlink" title="查看存储过程"></a>查看存储过程</h3><p>存储过程创建以后，用户可以通过SHOW STATUS语句来查看存储过程的状态，也可以通过SHOW CREATE语句来查看存储过程的定义。用户也可以通过查询information_schema数据库下的Routines表来查看存储过程的信息。</p><p><strong>查看存储过程</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW PROCEDURE STATUS  [ like ‘pattern’ ] ;  </span><br></pre></td></tr></table></figure><p>参数PROCEDURE表示查询存储过程；</p><p>参数LIKE ‘pattern’用来匹配存储过程的名称。</p><p><strong>示例</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show procedure status like &#39;%student%&#39;##</span><br></pre></td></tr></table></figure><p> <strong>查看存储过程的定义</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW CREATE PROCEDURE proc_name    </span><br></pre></td></tr></table></figure><p>参数PROCEDURE表示查询存储过程；</p><p>参数proc_name表示存储过程的名称。</p><p><strong>示例</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show create procedure fetch_insert_student_id##</span><br></pre></td></tr></table></figure><p><strong>查看存储过程的信息</strong></p><p>存储过程和函数的信息存储在information_schema数据库下的Routines表中。可以通过查询该表的记录来查询存储过程和函数的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM information_schema.Routines</span><br><span class="line">               Where ROUTINE_NAME &#x3D; ‘proc_name’;</span><br></pre></td></tr></table></figure><p>字段ROUTINE_NAME是Routines 存储存储过程和函数的列名称；</p><p>参数proc_name表示存储过程或函数的名称。</p><p><strong>示例</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select *from information_schema.Routines where ROUTINE_NAME &#x3D; &#39;fetch_insert_student_id&#39;##</span><br></pre></td></tr></table></figure><h3 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DRPO PROCEDURE proc_name;</span><br></pre></td></tr></table></figure><p>关键字DROP PROCEDURE用来表示实现删除存储过程，</p><p>参数proc_name表示所要删除的存储过程名称。</p><h2 id="数据库的存储引擎"><a href="#数据库的存储引擎" class="headerlink" title="数据库的存储引擎"></a>数据库的存储引擎</h2><h3 id="什么是存储引擎"><a href="#什么是存储引擎" class="headerlink" title="什么是存储引擎"></a>什么是存储引擎</h3><p>​    MySQL中存在多种存储引擎的概念。简而言之，<strong>存储引擎就是指表的类型</strong>。在具体开发时，为了提高MySQL数据库管理系统的使用效率和灵活性，可以根据实际需要来选择存储引擎。因为存储引擎指定了表的类型，即如何存储和索引数据、是否支持事务等，同时存储引擎也决定了<strong>表在计算机中的存储方式</strong>。</p><h3 id="MySQL支持的引擎"><a href="#MySQL支持的引擎" class="headerlink" title="MySQL支持的引擎"></a>MySQL支持的引擎</h3><p><strong>查看存储引擎</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW ENGINES</span><br></pre></td></tr></table></figure><p><img src="/images/MySql.assets/image-20211126173227774.png" alt="image-20211126173227774"></p><p><strong>查看当前默认存储引擎</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#39;default_storage_engine&#39;;  </span><br></pre></td></tr></table></figure><h4 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h4><p>nnoDB是MySQL数据库的一种存储引擎。InnoDB给MySQL的表提供了事务、回滚、崩溃修复能力和多版本并发控制的事务安全。MySQL从3.23.34a开始就包含InnoDB存储引擎。InnoDB是MySQL第一个提供外键约束的表引擎，而且InnoDB对事务处理的能力也是MySQL对其他存储引擎所无法与之比拟的(<strong>保证数据的安全</strong>)。</p><p>MySQL 5.6版本之后，除系统数据库之外，默认的存储引擎由MyISAM改为InnoDB，MySQL 8.0版本在原先的基础上将系统数据库的存储引擎也改为了InnoDB。</p><p>InnoDB存储引擎中支持自动增长列AUTO_INCREMENT。自动增长列的值不能为空，且值必须唯一。MySQL中规定自增列必须为主键。在插入值时，如果自动增长列不输入值，那么插入的值为自动增长后的值；如果输入的值为0或空（NULL），那么插入的值也为自动增长后的值；如果插入某个确定的值，且该值在前面没有出现过，那么可以直接插入。</p><p>InnoDB存储引擎中支持外键（FOREIGN KEY）。外键所在的表为子表，外键所依赖的表为父表。父表中被子表外键关联的字段必须为主键。当删除、更新父表的某条信息时，子表也必须有相应的改变。</p><p><strong>InnoDB存储引擎的优势在于提供了良好的事务管理、崩溃修复能力和并发控制；缺点是其读写效率稍差，占用的数据空间相对比较大。</strong></p><h4 id="MylSAM存储引擎"><a href="#MylSAM存储引擎" class="headerlink" title="MylSAM存储引擎"></a>MylSAM存储引擎</h4><p>MyISAM存储引擎是MySQL中常见的存储引擎，曾是MySQL的默认存储引擎。MyISAM存储引擎是基于ISAM存储引擎发展起来的。MyISAM增加了很多有用的扩展。</p><p>MyISAM存储引擎的表存储成3个文件。文件的名字与表名相同，或站名包括frm、MYD和MYI。其中，frm为扩展名的文件存储表的结构；MYD为扩展名的文件存储数据，是MYData的缩写；MYI为扩展名的文件存储索引，是MYIndex的缩写。</p><p>基于MyISAM存储引擎的表支持3种存储格式，包括静态型、动态型和压缩型。其中，静态型为MyISAM存储引擎的默认存储格式，其字段是固定长度的；动态型包含变长字段，记录的长度不是固定的；压缩型需要使用myiampack工具创建，占用的磁盘空间较小。</p><p><strong>MyISAM存储引擎的优势在于占用空间小，处理速度快；缺点是不支持事务的完整性和并发性。</strong></p><p>MEMORY存储引擎</p><p>MEMORY存储引擎是MySQL中一类特殊存储引擎。其使用存储在内存中的内容来创建表，而且所有数据也放在内存中。这些特性都与InnoDB存储引擎、MyISAM存储引擎不同。</p><p>每个基于MEMORY存储引擎的表实际对应一个磁盘文件，该文件的文件名与表名相同，类型为frm类型，该文件中只存储表的结构，而其数据文件都是存储在内存中的。这样有利于数据的快速处理，提供整个表的处理效率。值得注意的是，服务器需要有足够的内存来维持MEMORY存储引擎的表的使用。如果不需要使用了，可以释放这些内存，甚至可以删除不需要的表。</p><p>MEMORY存储引擎默认使用哈希（HASH）索引。其速度要比使用B型树（BTREE）索引快。如果读者希望使用B型树索引，可以在创建索引时选择使用。</p><p>MEMORY表的大小是受到限制的。表的大小主要取决于两个参数，分别是max_rows和max_heap_table_size。其中，max_rows可以在创建表时指定；max_heap_table_size的大小默认为16MB，可以按需要进行扩大。<strong>因此，其存在于内存中的特性，这类表的处理速度非常快。但是，其数据易丢失，生命周期短。基于这个缺陷，选择MEMORY存储引擎时需要特别小心。</strong></p><h4 id="选择存储引擎"><a href="#选择存储引擎" class="headerlink" title="选择存储引擎"></a>选择存储引擎</h4><p>在具体使用MySQL数据库管理系统时，选择一个合适的存储引擎是非常复杂的问题。因为每种存储引擎都有自己的特性、优势和应用场合，所以不能随便选择存储引擎。为了能够正确地选择存储引擎，必须掌握各种存储引擎的特性。</p><p>下面从存储引擎的事务安全、存储限制、空间使用、内存使用、插入数据的速度和对外键的支持等角度来比较InnoDB、MyISAM和MEMORY。</p><p><img src="/images/MySql.assets/image-20211126175817656.png" alt="image-20211126175817656"></p><hr><p>表锁：一个用户一个用户的用，当某一位用户插入数据时，直接“占据”表的所有位置，其他用户不许插入。</p><p>行锁:一个用户只“占据”他要插入数据的那一行。</p><p>相关联想:上厕所，你只锁住了你的那个坑位，而不是锁住厕所的大门。</p><p><strong>就是：是否允许多个用户同时更新一个表。</strong></p><hr><p>个简单的循环，LOOP语句本身没有停止循环，只有遇到LEAVE </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MySQL&quot;&gt;&lt;a href=&quot;#MySQL&quot; class=&quot;headerlink&quot; title=&quot;MySQL&quot;&gt;&lt;/a&gt;MySQL&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前</summary>
      
    
    
    
    <category term="MySQL" scheme="https://doraemon-hub-art.github.io/categories/MySQL/"/>
    
    
    <category term="-MySQL" scheme="https://doraemon-hub-art.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>【MySQL】C/C++链接MySQL数据库</title>
    <link href="https://doraemon-hub-art.github.io/2021/11/26/%E3%80%90MySQL%E3%80%91C%20or%20C++%E9%93%BE%E6%8E%A5MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>https://doraemon-hub-art.github.io/2021/11/26/%E3%80%90MySQL%E3%80%91C%20or%20C++%E9%93%BE%E6%8E%A5MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2021-11-26T10:06:58.000Z</published>
    <updated>2021-11-27T05:40:57.921Z</updated>
    
    <content type="html"><![CDATA[<p>​    <strong>VS2019链接</strong></p><p>1.找到这个文件夹</p><p><img src="/images/C++%E9%93%BE%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93.assets/image-20211126181149532.png" alt="image-20211126181149532"></p><p>拿到这两个路径，库文件路径，和头文件路径</p><p>C:\Program Files\MySQL\MySQL Server 8.0\lib</p><p>C:\Program Files\MySQL\MySQL Server 8.0\include</p><p>2.打开vs2019</p><p>新建项目，解决方案改成x64。打开项目属性。</p><p>将头文件目录放到这里面。</p><p><img src="/images/C++%E9%93%BE%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93.assets/image-20211126181600209.png" alt="image-20211126181600209"></p><p>3.添加库文件路径到库目录</p><p><img src="/images/C++%E9%93%BE%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93.assets/image-20211126181719023.png" alt="image-20211126181719023"></p><p>4.将mysql安装文件夹中lib目录中的libmysql.lib文件添加到依赖项中。</p><p><img src="/images/C++%E9%93%BE%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93.assets/image-20211126181957110.png" alt="image-20211126181957110"></p><p>5.把mysql安装目录中lib文件夹中的libmysql.dll文件复制到c:\windows\system32下</p><p>6.编写代码开始连接</p><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mysql.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MYSQL mysql;<span class="comment">//数据库句柄</span></span><br><span class="line">MYSQL_RES* res;<span class="comment">//查询结果集</span></span><br><span class="line">MYSQL_ROW row;<span class="comment">//记录结构体</span></span><br><span class="line"><span class="comment">//初始化数据库</span></span><br><span class="line">mysql_init(&amp;mysql);</span><br><span class="line"><span class="comment">//设置字符编码</span></span><br><span class="line">mysql_options(&amp;mysql, MYSQL_SET_CHARSET_NAME, <span class="string">&quot;gbk&quot;</span>);</span><br><span class="line"><span class="comment">//连接数据库</span></span><br><span class="line"><span class="keyword">if</span> (mysql_real_connect(&amp;mysql, <span class="string">&quot;127.0.0.1&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;PASSWORD&quot;</span>, <span class="string">&quot;temp5&quot;</span>, <span class="number">3306</span>, <span class="literal">NULL</span>, <span class="number">0</span>) == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;错误原因:%s\n&quot;</span>, mysql_error(&amp;mysql));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;连接失败!\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查询数据</span></span><br><span class="line"><span class="keyword">int</span> ret = mysql_query(&amp;mysql, <span class="string">&quot;select * from student&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ret:%d\n&quot;</span>, ret);</span><br><span class="line"><span class="comment">//获取结果集</span></span><br><span class="line">res = mysql_store_result(&amp;mysql);</span><br><span class="line"><span class="comment">//给ROW赋值，判断ROW是否为空，不为空就打印数据</span></span><br><span class="line"><span class="keyword">while</span> (row = mysql_fetch_row(res))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>, row[<span class="number">0</span>]);<span class="comment">//ID</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>, row[<span class="number">1</span>]);<span class="comment">//姓名</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>, row[<span class="number">2</span>]);<span class="comment">//班级</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s \n&quot;</span>, row[<span class="number">3</span>]);<span class="comment">//性别</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放结果集</span></span><br><span class="line">mysql_free_result(res);</span><br><span class="line"><span class="comment">//关闭数据库</span></span><br><span class="line">mysql_close(&amp;mysql);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>小补充:hexo文章标题不能包括[]</strong></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​    &lt;strong&gt;VS2019链接&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.找到这个文件夹&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/C++%E9%93%BE%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93.assets/image-20</summary>
      
    
    
    
    <category term="MySQL" scheme="https://doraemon-hub-art.github.io/categories/MySQL/"/>
    
    
    <category term="-C++" scheme="https://doraemon-hub-art.github.io/tags/C/"/>
    
    <category term="-C" scheme="https://doraemon-hub-art.github.io/tags/C/"/>
    
    <category term="-MySQL" scheme="https://doraemon-hub-art.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>学习记录1</title>
    <link href="https://doraemon-hub-art.github.io/2021/11/19/%E3%80%90%E7%A7%AF%E7%B4%AF%E3%80%91%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951/"/>
    <id>https://doraemon-hub-art.github.io/2021/11/19/%E3%80%90%E7%A7%AF%E7%B4%AF%E3%80%91%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951/</id>
    <published>2021-11-19T08:13:17.000Z</published>
    <updated>2021-11-19T08:32:32.905Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>​        最近的这半个月，通过与老师和学长交流以及学习理解别人写的代码让我接触到了一些新鲜的事物，比如cmake,linux下C++项目的运行，vscode等软件在Centos7环境下的安装与运行，以及网络协议等相关知识。</p><p>​        网络部分我感觉其实它并不难，不过我最近还不能深入的去学，因为我想的MFC,MySQL,还没有学完，同时我发现这套体系课的内容貌似不是很细节，但其实这并不是重点，我一直认同一句话，想深入细致的学习一块内容，只凭一本书，一套视频，肯定是不够的。</p><p>​        vim和cmake是个有趣的东西，尤其是vim，linux下的开发，vim可少不了，通过纯键盘的操作，确实比鼠标加键盘的效率要高(虽然我只会两个指令，而且都是现学的。还没有具体的学习vim的骚操作。)而cmake我理解它就是个可以跨平台的编译工具(我更愿意叫它为生成可执行文件的工具，它自己并不会编译代码，而是去调用对应的编译器来对代码进行编译。)，使得我们编译项目方便了不少，将相关的编译操作指令，都包含在CMakeLists.txt这个文件中。</p><p>​        目前来看，我的大概学习路线为MySQL、MFC、QT、Linux相关……</p></blockquote><p><strong>未完待续……</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;​        最近的这半个月，通过与老师和学长交流以及学习理解别人写的代码让我接触到了一些新鲜的事物，比如cmake,linux下C++项目的运行，vscode等软件在Centos7环境下的安装与运行，以及网络协议等相关知识。&lt;/p&gt;
&lt;p&gt;​</summary>
      
    
    
    
    <category term="学习记录" scheme="https://doraemon-hub-art.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="-学习记录" scheme="https://doraemon-hub-art.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>【网络编程】简单的服务端客户端实现</title>
    <link href="https://doraemon-hub-art.github.io/2021/11/14/%E3%80%90%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E3%80%91%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%9E%E7%8E%B0/"/>
    <id>https://doraemon-hub-art.github.io/2021/11/14/%E3%80%90%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E3%80%91%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-11-14T05:57:06.000Z</published>
    <updated>2021-11-14T06:00:47.107Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><hr><p>有些图片来源——<a href="https://blog.csdn.net/TT_love9527">https://blog.csdn.net/TT_love9527</a></p><p>其他图片来源未知，侵删。</p><hr><h2 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h2><p><img src="/images/%E7%BD%91%E7%BB%9C.assets/image-20211113113551491.png" alt=" "></p><p>发送方在一层一层的打包，接受方，一层一层解包，拿到数据。</p><p><img src="/images/%E7%BD%91%E7%BB%9C.assets/image-20211113114043879.png" alt="image-20211113114043879"></p><p>我们要做的只是使用打包好的API函数，传递参数即可。</p><h2 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP/IP模型"></a>TCP/IP模型</h2><p>可以理解为OSI七层模型的简化版本。</p><p><strong>对比</strong>：</p><p><img src="/images/%E7%BD%91%E7%BB%9C.assets/image-20211113114251036.png" alt="image-20211113114251036"></p><hr><p><img src="/images/%E7%BD%91%E7%BB%9C.assets/image-20211113114406218.png" alt="image-20211113114406218"></p><p><strong>收发过程可以想象成收发快递。</strong></p><p><img src="/images/%E7%BD%91%E7%BB%9C.assets/image-20211113114519988.png" alt="image-20211113114519988"></p><p>每层只做它应该做的事，其余的它都不知道。</p><p>上层调用下层服务。</p><p><strong>经典的分层模型。</strong></p><p>双方遵守协议的内容，正确完成通信。</p><h2 id="网络套接字编程"><a href="#网络套接字编程" class="headerlink" title="网络套接字编程"></a>网络套接字编程</h2><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p><img src="/images/%E7%BD%91%E7%BB%9C.assets/image-20211113114946319.png" alt="image-20211113114946319"></p><h3 id="TCP套接字"><a href="#TCP套接字" class="headerlink" title="TCP套接字"></a>TCP套接字</h3><p><img src="/images/%E7%BD%91%E7%BB%9C.assets/image-20211113115130159.png" alt="image-20211113115130159"></p><p><strong>无论客户端还是服务端在发送的时候都多发送1个长度，字符串结束符。</strong></p><h4 id="TCP套接字服务端"><a href="#TCP套接字服务端" class="headerlink" title="TCP套接字服务端"></a>TCP套接字服务端</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化套接字库</span></span><br><span class="line">    WORD wVersion;</span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    wVersion = MAKEWORD(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    err = WSAStartup(wVersion, &amp;wsaData);<span class="comment">//初始化哪个版本的网络库，并且将数据存放到哪里</span></span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (LOBYTE(wsaData.wVersion) != <span class="number">1</span>  || HIBYTE(wsaData.wVersion) != <span class="number">1</span>)<span class="comment">//版本检查</span></span><br><span class="line">    &#123;</span><br><span class="line">        WSACleanup();<span class="comment">//清理套接字库</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建套接字</span></span><br><span class="line">    SOCKET sockServer = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);  <span class="comment">//协议族、协议栈</span></span><br><span class="line">    <span class="comment">//准备绑定的信息</span></span><br><span class="line">    SOCKADDR_IN addrServer;</span><br><span class="line">    addrServer.sin_addr.S_un.S_addr = htonl(INADDR_ANY);<span class="comment">//htonl——</span></span><br><span class="line">    addrServer.sin_family = AF_INET;<span class="comment">//协议栈</span></span><br><span class="line">    addrServer.sin_port = htons(<span class="number">6000</span>);<span class="comment">//端口-1024以下的端口是系统保留的，htons——大小端转换,x86小端，网络传输-大端</span></span><br><span class="line">    <span class="comment">//绑定到本机</span></span><br><span class="line">    bind(sockServer,(SOCKADDR*)&amp;addrServer,<span class="keyword">sizeof</span>(SOCKADDR));</span><br><span class="line">    <span class="comment">//监听</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Server start at port 6000&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    listen(sockServer,<span class="number">10</span>);</span><br><span class="line">    SOCKADDR_IN addrClient;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(SOCKADDR);</span><br><span class="line">    <span class="keyword">char</span> recvBuf[<span class="number">100</span>];<span class="comment">//创建两个缓冲区</span></span><br><span class="line">    <span class="keyword">char</span> sendBuf[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//接收连接请求,返回根据客户端的套接字</span></span><br><span class="line">        SOCKET sockConnect = accept(sockServer,(SOCKADDR*)&amp;addrClient,&amp;len);</span><br><span class="line">        sprintf_s(sendBuf,<span class="number">100</span>,<span class="string">&quot;hello client&quot;</span>);</span><br><span class="line">        <span class="comment">//发</span></span><br><span class="line">        send(sockConnect, sendBuf, <span class="built_in">strlen</span>(sendBuf)+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">         <span class="comment">//收</span></span><br><span class="line">        recv(sockConnect, recvBuf, <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; recvBuf &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        closesocket(sockConnect); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭套接字</span></span><br><span class="line">    closesocket(sockServer);</span><br><span class="line">    <span class="comment">//清理套接字库</span></span><br><span class="line">    WSACleanup();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="TCP套接字客户端"><a href="#TCP套接字客户端" class="headerlink" title="TCP套接字客户端"></a>TCP套接字客户端</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化套接字库</span></span><br><span class="line">    WORD wVersion;</span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    wVersion = MAKEWORD(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    err = WSAStartup(wVersion, &amp;wsaData);<span class="comment">//初始化哪个版本的网络库，并且将数据存放到哪里</span></span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (LOBYTE(wsaData.wVersion) != <span class="number">1</span> || HIBYTE(wsaData.wVersion) != <span class="number">1</span>)<span class="comment">//版本检查</span></span><br><span class="line">    &#123;</span><br><span class="line">        WSACleanup();<span class="comment">//清理套接字库</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建TCP套接字</span></span><br><span class="line">    SOCKET sockClient = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//绑定</span></span><br><span class="line">    SOCKADDR_IN addrSrv;</span><br><span class="line">    addrSrv.sin_addr.S_un.S_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    addrSrv.sin_port = htons(<span class="number">6000</span>);<span class="comment">//与服务器绑定端口保持一致，否则无法连接</span></span><br><span class="line">    addrSrv.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">//连接</span></span><br><span class="line">    connect(sockClient, (SOCKADDR*)&amp;addrSrv, <span class="keyword">sizeof</span>(SOCKADDR));</span><br><span class="line">    <span class="comment">//缓冲区</span></span><br><span class="line">    <span class="keyword">char</span> sendBuf[] = <span class="string">&quot;hello server&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> recvBuf[<span class="number">100</span>];</span><br><span class="line">    <span class="comment">//发送数据到服务器</span></span><br><span class="line">    send(sockClient, sendBuf, <span class="built_in">strlen</span>(sendBuf)+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//接收数据</span></span><br><span class="line">    recv(sockClient, recvBuf, <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; recvBuf &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  </span><br><span class="line">    <span class="comment">//关闭清理</span></span><br><span class="line">    closesocket(sockClient);</span><br><span class="line">    WSACleanup();</span><br><span class="line">   <span class="comment">// system(&quot;pause&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UDP套接字"><a href="#UDP套接字" class="headerlink" title="UDP套接字"></a>UDP套接字</h3><p><img src="/images/%E7%BD%91%E7%BB%9C.assets/image-20211113203130824.png" alt="image-20211113203130824"></p><p><strong>UDP套接字不需要监听、建立链接，绑上网卡和端口，直接发送就可以。</strong></p><h4 id="UDP套接字服务端"><a href="#UDP套接字服务端" class="headerlink" title="UDP套接字服务端"></a>UDP套接字服务端</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//初始化套接字库</span></span><br><span class="line">WORD wVersion;</span><br><span class="line">WSADATA wsaData;</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line">wVersion = MAKEWORD(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">err = WSAStartup(wVersion, &amp;wsaData);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (HIBYTE(wsaData.wVersion) != <span class="number">1</span> || LOBYTE(wsaData.wVersion) != <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">WSACleanup();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建套接字</span></span><br><span class="line">SOCKET sockServer = socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">SOCKADDR_IN addrSrv;</span><br><span class="line">addrSrv.sin_addr.S_un.S_addr = htonl(INADDR_ANY);<span class="comment">//主机上任何一个网卡</span></span><br><span class="line">addrSrv.sin_port = htons(<span class="number">6002</span>);</span><br><span class="line">addrSrv.sin_family = AF_INET;</span><br><span class="line"><span class="comment">//绑定到本机6002端口</span></span><br><span class="line">bind(sockServer,(SOCKADDR*)&amp;addrSrv,<span class="keyword">sizeof</span>(SOCKADDR));</span><br><span class="line"><span class="comment">//接收请求, 处理请求</span></span><br><span class="line">SOCKADDR_IN addrClient;</span><br><span class="line"><span class="keyword">int</span> len = <span class="keyword">sizeof</span>(SOCKADDR);</span><br><span class="line"><span class="keyword">char</span> sendBuf[] = <span class="string">&quot;hello client&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> recvBuf[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Start UDP Server at port 6002&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//接收数据</span></span><br><span class="line">recvfrom(sockServer,recvBuf,<span class="number">100</span>,<span class="number">0</span>,(SOCKADDR*)&amp;addrClient,&amp;len);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;Recv:&quot;</span>&lt;&lt; recvBuf &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//发送数据</span></span><br><span class="line">sendto(sockServer, sendBuf, <span class="built_in">strlen</span>(sendBuf) + <span class="number">1</span>, <span class="number">0</span>, (SOCKADDR*)&amp;addrClient, len);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Send:&quot;</span> &lt;&lt; sendBuf &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="UDP套接字客户端"><a href="#UDP套接字客户端" class="headerlink" title="UDP套接字客户端"></a>UDP套接字客户端</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//初始化套接字库</span></span><br><span class="line">WORD wVersion;</span><br><span class="line">WSADATA wsaData;</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line">wVersion = MAKEWORD(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">err = WSAStartup(wVersion, &amp;wsaData);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (HIBYTE(wsaData.wVersion) != <span class="number">1</span> || LOBYTE(wsaData.wVersion) != <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">WSACleanup();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建UDP套接字</span></span><br><span class="line">SOCKET sockClient = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">SOCKADDR_IN addrSrv;</span><br><span class="line">addrSrv.sin_addr.S_un.S_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">addrSrv.sin_port = htons(<span class="number">6002</span>);</span><br><span class="line">addrSrv.sin_family = AF_INET;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len = <span class="keyword">sizeof</span>(SOCKADDR);</span><br><span class="line"><span class="comment">//缓冲区</span></span><br><span class="line"><span class="keyword">char</span> sendBuf[] = <span class="string">&quot;hello Server :)&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> recvBuf[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;send to Server:&quot;</span> &lt;&lt; sendBuf&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">sendto(sockClient, sendBuf, <span class="built_in">strlen</span>(sendBuf) + <span class="number">1</span>,<span class="number">0</span>,(SOCKADDR*)&amp;addrSrv,len);</span><br><span class="line">recvfrom(sockClient, recvBuf, <span class="number">100</span>, <span class="number">0</span>,(SOCKADDR*)&amp;addrSrv, &amp;len);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;recv from Server:&quot;</span> &lt;&lt; recvBuf &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">closesocket(sockClient);</span><br><span class="line">WSACleanup();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;网络编程&quot;&gt;&lt;a href=&quot;#网络编程&quot; class=&quot;headerlink&quot; title=&quot;网络编程&quot;&gt;&lt;/a&gt;网络编程&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;有些图片来源——&lt;a href=&quot;https://blog.csdn.net/TT_love9527&quot;&gt;https</summary>
      
    
    
    
    <category term="网络编程" scheme="https://doraemon-hub-art.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="-网络编程" scheme="https://doraemon-hub-art.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    <category term="-TCP" scheme="https://doraemon-hub-art.github.io/tags/TCP/"/>
    
    <category term="-UDP" scheme="https://doraemon-hub-art.github.io/tags/UDP/"/>
    
  </entry>
  
  <entry>
    <title>【MFC】MFC基础篇(1)</title>
    <link href="https://doraemon-hub-art.github.io/2021/11/13/%E3%80%90MFC%E3%80%91MFC%E5%9F%BA%E7%A1%80%E7%AF%87(1)/"/>
    <id>https://doraemon-hub-art.github.io/2021/11/13/%E3%80%90MFC%E3%80%91MFC%E5%9F%BA%E7%A1%80%E7%AF%87(1)/</id>
    <published>2021-11-13T03:20:46.000Z</published>
    <updated>2021-11-14T05:36:02.778Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MFC基础篇"><a href="#MFC基础篇" class="headerlink" title="MFC基础篇"></a>MFC基础篇</h1><p>以C++类的形式对WINDOWS API进行封装。</p><h2 id="MFC框架理论"><a href="#MFC框架理论" class="headerlink" title="MFC框架理论"></a>MFC框架理论</h2><h3 id="关键类"><a href="#关键类" class="headerlink" title="关键类"></a>关键类</h3><p>CWinApp:MFC应用程序抽象，管理DocumentTemplate。</p><p>CFrameWnd: 框架窗口，负责创建应用主窗口，含标题栏，菜单栏，工具栏，状态栏等 。</p><p>CView: 负责展示应用数据，View其实是一个没有边框的窗口, 客户区 。</p><p>CDocument: 负责存储应用数据 。</p><p>CDocTemplate：DocumentTemplate: 隐藏Boss， 负责管理MainFrame，View和Document。</p><h2 id="窗口与窗口对象"><a href="#窗口与窗口对象" class="headerlink" title="窗口与窗口对象"></a>窗口与窗口对象</h2><p><strong>关系：</strong></p><ol><li>每个窗口对象都包含一个窗口</li><li>窗口对象使用Create方法创建窗口，在Create方法个中将窗口对象与窗口绑定</li><li><strong>窗口对象的与窗口的生命周期不同，并不同生共死。(menu.Detach()将对象与它绑定在窗口的这一块区域分离(分离窗口对象和窗口))</strong></li></ol><h2 id="afx"><a href="#afx" class="headerlink" title="afx"></a>afx</h2><p>微软mfx小组。</p><h2 id="消息映射"><a href="#消息映射" class="headerlink" title="消息映射"></a>消息映射</h2><p>把消息ID和相应函数关联起来。 当这种消息发送出来后，对应的函数就会触发。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BEGIN_MESSAGE_MAP(CMFCApplicationView, CView)</span><br><span class="line">ON_COMMAND(ID_MSG_DRAW_PEN,&amp;CMFCApplicationView::OnPen)</span><br><span class="line">ON_COMMAND(ID_MSG_DRAW_RECT,&amp;CMFCApplicationView::OnRect)</span><br><span class="line">    ......</span><br><span class="line">END_MESSAGE_MAP()</span><br></pre></td></tr></table></figure><h2 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h2><h3 id="元文件"><a href="#元文件" class="headerlink" title="元文件"></a>元文件</h3><p>元文件(Metafile)是记录所有”绘图指令”的集合，拥有录制，重放的功能。</p><p>view文件中的代码示例:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一个Metefile的对象</span></span><br><span class="line">HMETAFILEmetafile;</span><br><span class="line"><span class="comment">//结束录制，保存文件</span></span><br><span class="line">metafile = m_dcMetaFile.Close();</span><br><span class="line"><span class="comment">//重放文件</span></span><br><span class="line">pDC-&gt;PlayMetaFile(metafile);</span><br><span class="line"><span class="comment">//准备一个新的录制</span></span><br><span class="line">m_dcMetaFile.Create();</span><br><span class="line"><span class="comment">//在新的录制中重放旧元文件  </span></span><br><span class="line">m_dcMetaFile.PlayMetaFile(metafile);</span><br><span class="line"><span class="comment">//删除元文件</span></span><br><span class="line">DeleteMetaFile(metafile);</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无效界面-请求重绘</span></span><br><span class="line">Invalidate();</span><br></pre></td></tr></table></figure><h3 id="兼容设备描述表"><a href="#兼容设备描述表" class="headerlink" title="兼容设备描述表"></a>兼容设备描述表</h3><p>兼容设备是一种内存设备，在显示图像的过程中，可以先在内存中准备这些图像，之后可以直接<strong>拷贝</strong>内存数据到真实的设备中，完成图像的显示。</p><p><strong>起到一个二次缓冲的效果</strong></p><h3 id="自定义重绘"><a href="#自定义重绘" class="headerlink" title="自定义重绘"></a>自定义重绘</h3><p>定义一个类，略……。</p><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h3><p><strong>写入文件</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMFCApplicationView::OnFileWirte</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加命令处理程序代码</span></span><br><span class="line">CString hello = _T(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line"><span class="comment">//打开文件对话框</span></span><br><span class="line"><span class="function">CFileDialog <span class="title">fileDlg</span><span class="params">(FALSE)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IDOK==fileDlg.DoModal())</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//获取对话框返回的文件名</span></span><br><span class="line"><span class="comment">//打开文件</span></span><br><span class="line"><span class="comment">//写入文件</span></span><br><span class="line"><span class="comment">//关闭文件</span></span><br><span class="line">CString path = fileDlg.GetPathName();</span><br><span class="line"><span class="function">CFile <span class="title">file</span><span class="params">(path, CFile::modeWrite | CFile::modeCreate)</span></span>;</span><br><span class="line"><span class="keyword">int</span> len = hello.GetLength()* <span class="keyword">sizeof</span>(TCHAR);</span><br><span class="line">file.Write(hello, len); </span><br><span class="line">file.Close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>读取文件</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMFCApplicationView::OnFileRead</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加命令处理程序代码</span></span><br><span class="line"><span class="function">CFileDialog <span class="title">fileDlg</span><span class="params">(TRUE)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (IDOK == fileDlg.DoModal())</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//获取文件名</span></span><br><span class="line">CString path = fileDlg.GetPathName();</span><br><span class="line"><span class="comment">//以读取方式打开文件</span></span><br><span class="line"><span class="function">CFile <span class="title">file</span><span class="params">(path, CFile::modeRead)</span></span>;</span><br><span class="line"><span class="comment">//准备缓冲区</span></span><br><span class="line">TCHAR* pBuf;</span><br><span class="line"><span class="keyword">int</span> cnt = file.GetLength();</span><br><span class="line"><span class="keyword">int</span> chars = cnt / <span class="keyword">sizeof</span>(TCHAR);</span><br><span class="line">pBuf = <span class="keyword">new</span> TCHAR[chars + <span class="number">1</span>];</span><br><span class="line"><span class="comment">//读取文件内容到缓冲区</span></span><br><span class="line">file.Read(pBuf, cnt);</span><br><span class="line"><span class="comment">//设置字符串结束位置</span></span><br><span class="line">pBuf[chars] = <span class="number">0</span>;</span><br><span class="line">MessageBox(pBuf);</span><br><span class="line">file.Close();</span><br><span class="line"><span class="keyword">delete</span>[] pBuf;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类的序列化"><a href="#类的序列化" class="headerlink" title="类的序列化"></a>类的序列化</h3><p>类的序列化是将程序中对象<strong>以一种二进制格式存放到设备中</strong>，如文件/数据库等，以实现”永生”或随意”流动”。</p><ul><li>类要从CObject派生，或是CObject的派生类派生 </li><li>实现Serialize方法 </li><li>在类声明中使用DECLARE_SERIAL宏 </li><li>DECLARE_SERIAL(类名) </li><li>定义不带参数的构造函数 </li><li>在类实现中添加IMPLEMNET_SERIAL宏 </li><li>IMPLEMNET_SERIAL(类名，父类名，版本号) </li></ul><h2 id="常用控件"><a href="#常用控件" class="headerlink" title="常用控件"></a>常用控件</h2><p>与使用者进行交互。</p><ul><li>获得控件</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GetDlgItem(控件ID)获取相应的控件</span><br></pre></td></tr></table></figure><ul><li>通过绑定控件和变量</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用</span><br><span class="line">UpdateData(TRUE|FALSE)同步， </span><br><span class="line">默认为True，将控件内容同步到变量，FALSE，将变量同步回控件</span><br></pre></td></tr></table></figure><h3 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h3><p>Radio Button——单选</p><p>Check Box——多选</p><p>响应事件，如点击按钮时间.</p><p><strong>示例</strong>：多选按钮。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CContrlObjectDlg::OnBnClickedButton1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">UpdateData();<span class="comment">//同步控件与变量</span></span><br><span class="line">CString str;</span><br><span class="line">str.Format(_T(<span class="string">&quot;上衣=%d\n裤子=%d\n鞋子=%d\n&quot;</span>),m_clothes,m_pants,m_shoes);</span><br><span class="line">MessageBox(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>多选按钮</strong>：<br><img src="/images/MFC%E5%9F%BA%E7%A1%80%E7%AF%871.assets/image-20211112181938778.png" alt="image-20211112181938778"></p><h3 id="文本框和列表"><a href="#文本框和列表" class="headerlink" title="文本框和列表"></a>文本框和列表</h3><ul><li>List Box——列表</li><li>Edit Control——文本框</li></ul><p><strong>示例</strong>：将文本框的内容放到列表中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CContrlObjectDlg::OnBnClickedButton2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line"><span class="comment">//获取文本框中的内容</span></span><br><span class="line">CString text;</span><br><span class="line"><span class="comment">//得到文本框对象</span></span><br><span class="line">CEdit* edit = (CEdit*)GetDlgItem(IDC_EDIT1);</span><br><span class="line"><span class="comment">//将文本框中的文字存放到text中</span></span><br><span class="line">edit-&gt;GetWindowText(text);</span><br><span class="line"><span class="comment">//得到列表对象</span></span><br><span class="line">CListBox* <span class="built_in">list</span> = (CListBox*)GetDlgItem(IDC_LIST1);</span><br><span class="line"><span class="comment">//将文本框中的文字添加到列表框中</span></span><br><span class="line"><span class="built_in">list</span>-&gt;AddString(text);</span><br><span class="line"><span class="comment">//清空文本框的输入框</span></span><br><span class="line">edit-&gt;SetWindowText(_T(<span class="string">&quot;&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/images/MFC%E5%9F%BA%E7%A1%80%E7%AF%871.assets/image-20211112185648190.png" alt="image-20211112185648190"></p><p><strong>示例2</strong>：<br>查看在列表中选择了什么</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CContrlObjectDlg::OnBnClickedButton2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line"><span class="comment">//储存获取的内容</span></span><br><span class="line">CString text;</span><br><span class="line">CListBox* <span class="built_in">list</span> = (CListBox*)GetDlgItem(IDC_LIST1);</span><br><span class="line"><span class="comment">//获取当前在列表中的选择，返回一个整型，该选项在列表中的位置 </span></span><br><span class="line"><span class="keyword">int</span> n = <span class="built_in">list</span>-&gt;GetCurSel();</span><br><span class="line"><span class="comment">//返回选项放到text中</span></span><br><span class="line"><span class="built_in">list</span>-&gt;GetText(n,text);</span><br><span class="line">MessageBox(text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="下拉列表"><a href="#下拉列表" class="headerlink" title="下拉列表"></a>下拉列表</h3><ul><li>ComboBox——下拉列表</li></ul><p>类似于ListBox，基本上操作一直，只是ListBox直接展开所有选项，而ComboBox需要点开查看。</p><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CContrlObjectDlg::OnBnClickedButton2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line"><span class="comment">//储存获取的内容</span></span><br><span class="line">CString text;</span><br><span class="line">CComboBox* <span class="built_in">list</span> = (CComboBox*)GetDlgItem(IDC_COMBO1);</span><br><span class="line"><span class="keyword">int</span> n = <span class="built_in">list</span>-&gt;GetCurSel();</span><br><span class="line"><span class="built_in">list</span>-&gt;GetLBText(n,text);</span><br><span class="line">MessageBox(text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="进度条"><a href="#进度条" class="headerlink" title="进度条"></a>进度条</h3><ul><li>Progress Control——进度条</li></ul><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">BOOL CContrlObjectDlg::OnInitDialog()中</span><br><span class="line">    </span><br><span class="line"><span class="comment">//得到进度条控件</span></span><br><span class="line">CProgressCtrl* prog = (CProgressCtrl*)GetDlgItem(IDC_PROGRESS1);</span><br><span class="line"><span class="comment">//设置范围</span></span><br><span class="line">prog-&gt;SetRange(<span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//根据条件进行进度条的变动</span></span><br><span class="line">prog = (CProgressCtrl*)GetDlgItem(IDC_PROGRESS1);</span><br><span class="line">num = prog-&gt;GetPos();</span><br><span class="line">prog-&gt;SetPos(++num);</span><br><span class="line">prog-&gt;GetRange(low, high);</span><br><span class="line"><span class="keyword">if</span> (num&gt;= high)</span><br><span class="line">&#123;</span><br><span class="line">    prog-&gt;SetPos(low);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><ul><li>Picture Control——图片</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BOOL CMFCPicODlg::OnInitDialog()中</span><br><span class="line"></span><br><span class="line"><span class="comment">//例如:加载bitmap，以局部变量的方式</span></span><br><span class="line">BitMap bitmap;    </span><br><span class="line">m_bitmap.LoadBitmap(IDB_BITMAP1);</span><br><span class="line">m_pic.SetBitmap(m_bitmap);</span><br><span class="line">bitmap.Detach();</span><br></pre></td></tr></table></figure><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><ul><li>List Control</li></ul><p><strong>例如</strong>：Windows文件查看</p><p><img src="/images/MFC%E5%9F%BA%E7%A1%80%E7%AF%871.assets/image-20211113082415733.png" alt="image-20211113082415733"></p><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绘制表头</span></span><br><span class="line">m_list.InsertColumn(<span class="number">0</span>, _T(<span class="string">&quot;ADDRESS&quot;</span>), LVCFMT_LEFT, <span class="number">400</span>);</span><br><span class="line">m_list.InsertColumn(<span class="number">0</span>, _T(<span class="string">&quot;AGE&quot;</span>), LVCFMT_LEFT, <span class="number">50</span>);</span><br><span class="line">m_list.InsertColumn(<span class="number">0</span>, _T(<span class="string">&quot;NAME&quot;</span>), LVCFMT_LEFT, <span class="number">100</span>);</span><br><span class="line">m_list.InsertColumn(<span class="number">0</span>, _T(<span class="string">&quot;ID&quot;</span>), LVCFMT_LEFT, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入第一行数据</span></span><br><span class="line"><span class="keyword">int</span> index;</span><br><span class="line">index = m_list.InsertItem(<span class="number">0</span>, _T(<span class="string">&quot;0001&quot;</span>));</span><br><span class="line">m_list.SetItemText(index, <span class="number">1</span>, _T(<span class="string">&quot;kenny&quot;</span>));</span><br><span class="line">m_list.SetItemText(index, <span class="number">2</span>, _T(<span class="string">&quot;26&quot;</span>));</span><br><span class="line">m_list.SetItemText(index, <span class="number">3</span>, _T(<span class="string">&quot;Franch&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入第二行数据</span></span><br><span class="line">index = m_list.InsertItem(<span class="number">1</span>, _T(<span class="string">&quot;0002&quot;</span>));</span><br><span class="line">m_list.SetItemText(index, <span class="number">1</span>, _T(<span class="string">&quot;olofm&quot;</span>));</span><br><span class="line">m_list.SetItemText(index, <span class="number">2</span>, _T(<span class="string">&quot;29&quot;</span>));</span><br><span class="line">m_list.SetItemText(index, <span class="number">3</span>, _T(<span class="string">&quot;Sweden&quot;</span>));</span><br></pre></td></tr></table></figure><p><img src="/images/MFC%E5%9F%BA%E7%A1%80%E7%AF%871.assets/image-20211113093242047.png" alt="image-20211113093242047"></p><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><ul><li>Tree Control</li></ul><p><strong>示例</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">HTREEITEM root;</span><br><span class="line">HTREEITEM first_sub;</span><br><span class="line">HTREEITEM second_sub;</span><br><span class="line">m_tree.ModifyStyle(<span class="number">0</span>, TVS_HASLINES | TVS_HASBUTTONS | TVS_LINESATROOT);</span><br><span class="line">root = m_tree.InsertItem(_T(<span class="string">&quot;Root&quot;</span>));</span><br><span class="line"><span class="comment">//root的子节点</span></span><br><span class="line">first_sub = m_tree.InsertItem(_T(<span class="string">&quot;First_Sub&quot;</span>), root);</span><br><span class="line"><span class="comment">//与first同级的四个</span></span><br><span class="line">m_tree.InsertItem(_T(<span class="string">&quot;1&quot;</span>),root);</span><br><span class="line">m_tree.InsertItem(_T(<span class="string">&quot;2&quot;</span>),root);</span><br><span class="line">m_tree.InsertItem(_T(<span class="string">&quot;3&quot;</span>),root);</span><br><span class="line">m_tree.InsertItem(_T(<span class="string">&quot;4&quot;</span>),root);</span><br><span class="line"><span class="comment">//first的子结点</span></span><br><span class="line">second_sub = m_tree.InsertItem(_T(<span class="string">&quot;Second&quot;</span>),first_sub);</span><br><span class="line"><span class="comment">//second的四个子节点</span></span><br><span class="line">m_tree.InsertItem(_T(<span class="string">&quot;5&quot;</span>), second_sub);</span><br><span class="line">m_tree.InsertItem(_T(<span class="string">&quot;6&quot;</span>), second_sub);</span><br><span class="line">m_tree.InsertItem(_T(<span class="string">&quot;7&quot;</span>), second_sub);</span><br><span class="line">m_tree.InsertItem(_T(<span class="string">&quot;8&quot;</span>), second_sub);</span><br></pre></td></tr></table></figure><p><img src="/images/MFC%E5%9F%BA%E7%A1%80%E7%AF%871.assets/image-20211113104231000.png" alt="image-20211113104231000"></p><p><strong>引入、加载图片</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前2张，还能加4张</span></span><br><span class="line">m_imgList.Create(<span class="number">32</span>, <span class="number">32</span>, ILC_MASK | ILC_COLOR32, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    HICON icon = theApp.LoadIcon(IDI_ICON1+i);</span><br><span class="line">    m_imgList.Add(icon);</span><br><span class="line">&#125;</span><br><span class="line">m_tree.SetImageList(&amp;m_imgList,TVSIL_NORMAL);</span><br><span class="line"><span class="comment">//这两个1分别代表的属性</span></span><br><span class="line"><span class="comment">//分别是:未选中时显示哪张图片，被选中时显示哪在张。</span></span><br><span class="line">m_tree.InsertItem(_T(<span class="string">&quot;1&quot;</span>),<span class="number">1</span>,<span class="number">1</span>,root);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MFC基础篇&quot;&gt;&lt;a href=&quot;#MFC基础篇&quot; class=&quot;headerlink&quot; title=&quot;MFC基础篇&quot;&gt;&lt;/a&gt;MFC基础篇&lt;/h1&gt;&lt;p&gt;以C++类的形式对WINDOWS API进行封装。&lt;/p&gt;
&lt;h2 id=&quot;MFC框架理论&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="MFC" scheme="https://doraemon-hub-art.github.io/categories/MFC/"/>
    
    
    <category term="-C++" scheme="https://doraemon-hub-art.github.io/tags/C/"/>
    
    <category term="-MFC" scheme="https://doraemon-hub-art.github.io/tags/MFC/"/>
    
  </entry>
  
  <entry>
    <title>【Win32】初识Win32编程</title>
    <link href="https://doraemon-hub-art.github.io/2021/11/08/%E3%80%90Win32%E3%80%91%E5%88%9D%E8%AF%86Win32%E7%BC%96%E7%A8%8B/"/>
    <id>https://doraemon-hub-art.github.io/2021/11/08/%E3%80%90Win32%E3%80%91%E5%88%9D%E8%AF%86Win32%E7%BC%96%E7%A8%8B/</id>
    <published>2021-11-08T00:48:10.000Z</published>
    <updated>2021-11-13T03:23:51.151Z</updated>
    
    <content type="html"><![CDATA[<hr><p>相关视频——<a href="https://www.bilibili.com/video/BV1NA411K7aN?p=1">链接</a></p><hr><h1 id="Windows编程"><a href="#Windows编程" class="headerlink" title="Windows编程"></a>Windows编程</h1><h2 id="应用程序分类"><a href="#应用程序分类" class="headerlink" title="应用程序分类"></a>应用程序分类</h2><ul><li>控制台程序Console<ul><li>DOS程序，<strong>本身没有窗口</strong>，通过Windows DOS窗口执行。(DOS是操作系统预留的)</li></ul></li><li>窗口程序<ul><li>拥有自己的窗口，可以与用户交互。</li></ul></li><li>库程序<ul><li>存放代码、数据的程序、执行文件可以从中取出代码执行和获取数据</li><li>静态库程序:扩展名LIB,在编译链接程序时，将代码放入到执行文件中。</li><li>动态库程序：扩展名DLL，在执行文件时从中获取代码 。</li></ul>静态库中的代码是直接嵌入到你的项目中，而动态库中的内容是通过地址来找到。<ul><li><strong>静态库程序无法执行，也就是说它最终生成的文件无法进入内存。</strong></li><li>动态库程序有入口函数，可以执行。<strong>但是它不能独立运行。</strong>谁调动态库里面的东西，它就依附于谁。</li></ul></li></ul><h2 id="应用程序对比"><a href="#应用程序对比" class="headerlink" title="应用程序对比"></a>应用程序对比</h2><ul><li>入口函数<ul><li>控制台程序-main</li><li>窗口程序-WinMain</li><li>动态库程序-DllMain</li><li>静态库程序-无入口函数</li></ul></li><li>文件存在方式<ul><li>控制台程序、窗口程序-EXE文件</li><li>动态库程序-DLL文件</li><li>静态库程序-LIB文件</li></ul></li></ul><h2 id="编译工具"><a href="#编译工具" class="headerlink" title="编译工具"></a>编译工具</h2><ul><li>编译器CL.EXE,将源代码编译成目标代码.obj。</li><li>链接器LINK.EXE,将目标代码、库链接生成最终文件。</li><li>资源编译器RC.EXE,(.rc)将资源编译，最终通过链接器存入最终文件</li></ul><h2 id="库文件和头文件"><a href="#库文件和头文件" class="headerlink" title="库文件和头文件"></a>库文件和头文件</h2><p><strong>库文件</strong></p><ul><li>kernel32.dll-提供核心的API,消息进程，线程，内存管理等。</li><li>user32.dll-提供了窗口、消息等API。</li><li>gdi32.dll-绘图相关的API</li></ul><p><strong>头文件</strong></p><ul><li>windows.h——所有windows头文件的集合</li><li>windef.h——windows数据类型</li><li>winbase.h——kernel32的API</li><li>wingdi.h——user32的API</li><li>winnt.h——UNICODE字符集支持</li></ul><h2 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">wWinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    HINSTANCE hInstance,<span class="comment">//当前程序的实例句柄，找到你当前进程所占据的那块内存</span></span></span></span><br><span class="line"><span class="function"><span class="params">    HINSTANCE hPrevInstance,<span class="comment">//当前程序前一个示例句柄，废弃了</span></span></span></span><br><span class="line"><span class="function"><span class="params">    PWSTR pCmdLine, <span class="comment">//命令行参数字符串</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> nCmdShow<span class="comment">//窗口的显示方式</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>暂时可以将句柄理解成，句柄是用来找到内存的东西，但绝对不是指针。</strong></p><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MessageBox</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional] HWND    hWnd,<span class="comment">//父窗口句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional] LPCTSTR lpText,<span class="comment">//显示在消息框中的文字</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional] LPCTSTR lpCaption,<span class="comment">//显示在标题栏中的文字</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in]           UINT    uType<span class="comment">//消息框中的按钮、图标显示了类型</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;<span class="comment">//返回点击的按钮ID</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>能够将程序暂停在这里，说明它是个阻塞函数。它执行，可能不会立即返回。</p><hr><p><strong>如何理解分析一个阻塞函数</strong>？<br>1.这个函数什么情况下阻塞。</p><p>2.这个函数什么情况下解除阻塞返回。</p><hr><p><strong>看到数据类型以H开头，多半就是个句柄。</strong></p><hr><h2 id="程序编译过程"><a href="#程序编译过程" class="headerlink" title="程序编译过程"></a>程序编译过程</h2><ul><li><p>可以直接用vs集成好的环境。<img src="/images/win32(1).assets/image-20211029171632365.png" alt="image-20211029171632365"></p></li><li><p>编译程序-CL,CL.EXE -C xxx.c，生成obj文件</p></li><li><p>链接程序-LINK，LINK.EXE xxx.obj xxx.lib</p></li><li><p>执行生成的exe文件</p></li></ul><hr><ul><li>编写资源的文件，.rc资源脚本文件</li><li>编译rc文件，RC.EXE</li><li>将资源链接到程序中，LINK.EXE</li></ul><p>.res文件和.obj文件统称为目标文件(中间文件，因为不是最终文件)</p><hr><p> <strong>编译链接过程</strong>：将代码转换为机器语言，将生成的res文件和obj文件加上使用的库链接到一起，整合出一个exe文件，这是用编译器所感受不到的。</p><p><img src="/images/win32(1).assets/image-20211029172712321.png" alt="image-20211029172712321"></p><hr><h2 id="窗口创建过程"><a href="#窗口创建过程" class="headerlink" title="窗口创建过程"></a>窗口创建过程</h2><ul><li>定义WinMain函数</li><li>定义窗口的处理函数(自定义，消息处理)</li><li>注册窗口类(向操作系统中写入一些数据)</li><li>创建窗口(内存中创建窗口)</li><li>显示窗口(绘制窗口的图像)</li><li>消息循环(获取/翻译/派发消息)</li><li>消息处理</li></ul><h2 id="第一个windows窗口"><a href="#第一个windows窗口" class="headerlink" title="第一个windows窗口"></a>第一个windows窗口</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//窗口处理函数（自定义、处理消息）</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hWnd, UINT msgID, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> DefWindowProc(hWnd, msgID, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入口函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> CALLBACK <span class="title">WinMain</span><span class="params">(HINSTANCE hIns, HINSTANCE hPerIns, LPSTR lpCmdLine, <span class="keyword">int</span> nCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//注册窗口类</span></span><br><span class="line">WNDCLASS wc = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">//申请两种不用的缓冲区</span></span><br><span class="line">wc.cbClsExtra = <span class="number">0</span>;</span><br><span class="line">wc.cbWndExtra = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + <span class="number">1</span>);</span><br><span class="line">wc.hCursor = <span class="literal">NULL</span>;</span><br><span class="line">wc.hIcon = <span class="literal">NULL</span>;</span><br><span class="line">wc.hInstance = hIns;</span><br><span class="line">wc.lpfnWndProc = WndProc;</span><br><span class="line">wc.lpszClassName = <span class="string">&quot;myWindow&quot;</span>;</span><br><span class="line">wc.lpszMenuName = <span class="literal">NULL</span>;</span><br><span class="line">wc.style = CS_HREDRAW | CS_VREDRAW;</span><br><span class="line"><span class="comment">//将上面赋的这些值全部写入操作系统</span></span><br><span class="line">RegisterClass(&amp;wc);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在内存中创建窗口</span></span><br><span class="line">HWND hWnd = CreateWindow(<span class="string">&quot;myWindow&quot;</span>, <span class="string">&quot;menu&quot;</span>, WS_OVERLAPPEDWINDOW, <span class="number">100</span>, <span class="number">100</span>, <span class="number">500</span>, <span class="number">500</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, hIns, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//显示窗口</span></span><br><span class="line">ShowWindow(hWnd, SW_SHOW);</span><br><span class="line"><span class="comment">//再画一遍(刷新窗口)</span></span><br><span class="line">UpdateWindow(hWnd);</span><br><span class="line"><span class="comment">//消息循环</span></span><br><span class="line">MSG nMsg = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">while</span> (GetMessage(&amp;nMsg,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">TranslateMessage(&amp;nMsg);</span><br><span class="line">DispatchMessage(&amp;nMsg);<span class="comment">//将消息交给窗口处理函数来处理</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>窗口有无与进程退不退没有关系。</p><h2 id="Unit04字符编码"><a href="#Unit04字符编码" class="headerlink" title="Unit04字符编码"></a>Unit04字符编码</h2><p><strong>编码历史背景</strong></p><ul><li>ASC——7位代表一个字符</li><li>ASCII——8位代表一个字符</li><li>DBCS——<strong>单双字节混合编码</strong>，没有同一标准，存在解析问题。</li><li>UNICODE——字符集，有多种编码方式，一般windows只的是utf-16(所有的字符无论中文汉子还是英文字母，都按两个字符编码。),linux utf-8,有统一标准，不存在解析问题。</li></ul><h2 id="宽字节数据类型"><a href="#宽字节数据类型" class="headerlink" title="宽字节数据类型"></a>宽字节数据类型</h2><p>这个数据类型下的所有字符， 都占2个字节。</p><blockquote><p>wchar_t每个字符占2个字节，wchar_t实际上是unsigned short类型，定义时，需要增加‘L’，通知编译器按照双字节编译字符串，采用UNICODE编码。</p><p>需要使用支持wchar_t函数操作宽字节字符串，例如:<br>wchar_t* s1=  L”123456”;</p><p>wprintf(L”%s\n”,s1);</p></blockquote><hr><p>有操作char类型字符串的函数，肯定就有对应操作宽字节字符串的函数。</p><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">wchar_t</span>* s1 = <span class="string">L&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, wcslen(s1));<span class="comment">//5,有效字符个数</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TCHAR"><a href="#TCHAR" class="headerlink" title="TCHAR"></a>TCHAR</h2><p>如果定义了unicode宏，该字符串为wchar*类型，反之为char *类型。</p><h2 id="打印UNICODE字符"><a href="#打印UNICODE字符" class="headerlink" title="打印UNICODE字符"></a>打印UNICODE字符</h2><p>UNICODE字符打印，wprintf对UNICODE字符打印支持不完善。</p><p>在windows下使用<strong>WriteConsole</strong>打印UNICODE字符。</p><p>GetStdHandle获取标准句柄(标准输入句柄、标准输出句柄、标准错误句柄)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WriteConsole(标准输出句柄，pszText,wcslen(pszText),<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>下面的使用案例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> width = LOWORD(lParam);</span><br><span class="line"><span class="keyword">short</span> height = HIWORD(lParam);</span><br><span class="line"><span class="keyword">char</span> szText[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">sprintf_s(szText, <span class="string">&quot;WM_SIZE:宽度%d，高度：%d\n&quot;</span>, width, height);</span><br><span class="line">WriteConsole(g_HOUTPUT, szText, <span class="built_in">strlen</span>(szText), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><hr><p>创建项目时候为什么要改成多字节字符集?</p><p>如果项目的属性选择是UNICODE字符集，编译器会自动给你增加一个UNICODE的宏定义。反之，则不会。</p><hr><p><strong>系统调用函数的参数类型</strong>：</p><p>(对已有的类型进行重命名)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LPSTR =&gt; <span class="keyword">char</span>*</span><br><span class="line">LPSTR =&gt; <span class="keyword">const</span> <span class="keyword">char</span>*</span><br><span class="line">LPWSTR =&gt; <span class="keyword">wchar_t</span>*</span><br><span class="line">LPCWSTR =&gt; <span class="keyword">const</span> <span class="keyword">wchar_t</span>*</span><br><span class="line">   </span><br><span class="line">用的多的是这两个</span><br><span class="line">LPTSTR =&gt; TCHAR </span><br><span class="line">LPCTSTR =&gt; <span class="keyword">const</span> TCHAR*</span><br></pre></td></tr></table></figure><hr><h2 id="注册窗口类"><a href="#注册窗口类" class="headerlink" title="注册窗口类"></a>注册窗口类</h2><p><strong>窗口类的概念</strong></p><ul><li>窗口类是包含了窗口的各种参数信息的数据结构。 </li><li>每个窗口都具有窗口类，基于窗口类创建窗口。</li><li>每个窗口类都具有一个名称，使用前必须注册到系统。</li></ul><p><strong>在操作系统内核里存着就叫窗口类，在程序里存着就叫窗口类。</strong></p><hr><p><strong>窗口类的分类</strong>：</p><ul><li>系统窗口类<ul><li>系统已经定义好的窗口类，<strong>所有</strong>应用程序都可以直接使用。</li><li>不需要注册，直接使用窗口类即可。系统已经注册好了。</li><li>例如:按钮-BUTTON,编辑框-EDIT</li></ul></li><li>应用程序全局窗口类<ul><li>由用户自己定义，当前应用程序所有模块都可以使用。</li></ul></li><li>应用程序局部窗口类<ul><li>由用户自己定义，当前应用程序中本模块可以直接使用。</li></ul></li></ul><p><strong>全局及局部窗口类</strong> ：</p><p>注册窗口类的函数</p><p>(ATOM——unsigned short)</p><p>ATOM RegisterClass(</p><p>​    CONST WNDCLASS *lpWndClass//窗口类的数据);</p><p>//注册成功后 ，返回一个数字标识。(0失败，非0成功。)</p><p><img src="/images/win32(1).assets/image-20211030091746959.png" alt="image-20211030091746959"></p><hr><p><strong>style窗口类风格</strong></p><p>应用程序全局窗口类的注册，需要在窗口类的风格中添加CS_GLOBALCLASS。</p><p>应用程序局部类窗口类注册，无需添加如上风格。</p><p><strong>不建议使用全局窗口类</strong>——因为局部窗口类能完成全局窗口类的功能，并且全局窗口类可能会产生冗余。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CS_HREDRAW ——当窗口水平变化时，窗口重新绘制</span><br><span class="line">CS_VREDRAW ——当窗口垂直变化时，窗口重新绘制</span><br><span class="line">CS_DBLCLKS ——允许窗口接收鼠标双击</span><br><span class="line">CS_NOCLOSE ——窗口没有关闭按钮</span><br></pre></td></tr></table></figure><h2 id="窗口创建"><a href="#窗口创建" class="headerlink" title="窗口创建"></a>窗口创建</h2><p><strong>窗口创建</strong>：</p><p>CreateWindow / CreateWindowEx</p><p><img src="/images/win32(1).assets/image-20211030092735421.png" alt="image-20211030092735421"></p><p><strong>CreateWindow内部是如何实现的</strong></p><ul><li>系统(CreateWindows函数内部)根据传入的窗口类名称，在应用程序局部窗口类中查找，如果找到执行2 ，没找到执行3。</li><li>比较局部窗口与创建窗口时传入的HINSTANCE变量。如果有发现相等。创建和注册类在同一模块，创建窗口返回。如果不相等，继续执行3。</li><li>在应用程序全局窗口类，如果找到，执行4， 没找到执行5。</li><li>使用找到的窗口类信息，创建窗口返回。</li><li>在系统窗口类中查找，如果找到创建窗口返回，否则创建窗口失败。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//窗口处理函数（自定义、处理消息）</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hWnd, UINT msgID, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (msgID)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">PostQuitMessage(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> DefWindowProc(hWnd, msgID, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入口函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> CALLBACK <span class="title">WinMain</span><span class="params">(HINSTANCE hIns, HINSTANCE hPerIns, LPSTR lpCmdLine, <span class="keyword">int</span> nCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册窗口类</span></span><br><span class="line">WNDCLASS wc = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">//申请两种不用的缓冲区</span></span><br><span class="line">wc.cbClsExtra = <span class="number">0</span>;</span><br><span class="line">wc.cbWndExtra = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + <span class="number">1</span>);</span><br><span class="line">wc.hCursor = <span class="literal">NULL</span>;</span><br><span class="line">wc.hIcon = <span class="literal">NULL</span>;</span><br><span class="line">wc.hInstance = hIns;</span><br><span class="line">wc.lpfnWndProc = WndProc;</span><br><span class="line">wc.lpszClassName = <span class="string">&quot;myWindow&quot;</span>;</span><br><span class="line">wc.lpszMenuName = <span class="literal">NULL</span>;</span><br><span class="line">wc.style = CS_HREDRAW | CS_VREDRAW;</span><br><span class="line"><span class="comment">//将上面赋的这些值全部写入操作系统</span></span><br><span class="line">RegisterClass(&amp;wc);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在内存中创建窗口</span></span><br><span class="line">HWND hWnd = CreateWindow(<span class="string">&quot;myWindow&quot;</span>, <span class="string">&quot;menu&quot;</span>, WS_OVERLAPPEDWINDOW, <span class="number">100</span>, <span class="number">100</span>, <span class="number">500</span>, <span class="number">500</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, hIns, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//显示窗口</span></span><br><span class="line">ShowWindow(hWnd, SW_SHOW);</span><br><span class="line"><span class="comment">//再画一遍(刷新窗口)</span></span><br><span class="line">UpdateWindow(hWnd);</span><br><span class="line"><span class="comment">//消息循环</span></span><br><span class="line">MSG nMsg = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">while</span> (GetMessage(&amp;nMsg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">TranslateMessage(&amp;nMsg);</span><br><span class="line">DispatchMessage(&amp;nMsg);<span class="comment">//将消息交给窗口处理函数来处理</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>子窗口创建过程</strong></p><ul><li>创建时要设置父窗口句柄</li><li>创建风格要增加WS_CHILD | WS_VISBLE</li></ul><p>(<strong>根据注册的窗口类，来创建多个窗口。</strong>)</p><p>(个人理解发现：注册的窗口可以复用(覆盖创建一个新的))。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HWND hChild1 = CreateWindowEx(<span class="number">0</span>, <span class="string">&quot;Child&quot;</span>, <span class="string">&quot;C1&quot;</span>, WS_CHILD | WS_VISIBLE | WS_OVERLAPPEDWINDOW, <span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>, hWnd, <span class="literal">NULL</span>, hIns, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">HWND hChild2 = CreateWindowEx(<span class="number">0</span>, <span class="string">&quot;Child&quot;</span>, <span class="string">&quot;C2&quot;</span>, WS_CHILD | WS_VISIBLE | WS_OVERLAPPEDWINDOW, <span class="number">200</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>, hWnd, <span class="literal">NULL</span>, hIns, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><h2 id="消息基础"><a href="#消息基础" class="headerlink" title="消息基础"></a>消息基础</h2><h3 id="消息的概念和作用"><a href="#消息的概念和作用" class="headerlink" title="消息的概念和作用"></a>消息的概念和作用</h3><ul><li>消息组成(windows平台下)<ul><li>窗口句柄</li><li>消息ID</li><li>消息的两个参数(两个附带信息)</li><li>消息产生的时间</li><li>消息产生时的鼠标位置</li></ul></li><li>消息的作用<ul><li>当系统通知窗口工作时，就采用消息的方式(DispatchMessage)派发给(<strong>调用</strong>)窗口的<strong>窗口处理函数</strong>(将MSG的前四个信息传递给消息处理函数)。</li><li><strong>每一个窗口都有窗口处理函数</strong></li></ul></li></ul><p><strong>MSG结构体接收消息</strong></p><p>结构体定义如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对应解释同上消息组成</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagMSG</span> &#123;</span></span><br><span class="line">    HWND        hwnd;</span><br><span class="line">    UINT        message;</span><br><span class="line">    WPARAM      wParam;</span><br><span class="line">    LPARAM      lParam;</span><br><span class="line">    DWORD       time;</span><br><span class="line">    POINT       pt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _MAC</span></span><br><span class="line">    DWORD       lPrivate;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; MSG, *PMSG, NEAR *NPMSG, FAR *LPMSG;</span><br></pre></td></tr></table></figure><p><strong>DispatchMessage如何找到窗口处理函数</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nMsg.hwnd-&gt;保存窗口数据的内存-&gt;找到对应的窗口处理函数-&gt;WndProc</span><br><span class="line">    </span><br><span class="line">回到你自己定义的消息处理函数-&gt;传递参数-&gt;处理消息</span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hWnd, UINT msgID, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line">    传递这四个参数，不用关系后两个</span><br></pre></td></tr></table></figure><h3 id="窗口处理函数"><a href="#窗口处理函数" class="headerlink" title="窗口处理函数"></a>窗口处理函数</h3><p><strong>每个窗口都必需有窗口处理函数，只要基于窗口类创建窗口，就肯定要有个窗口处理函数。</strong></p><p><strong>窗口处理依照如下结构定义</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProc</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HWND hWnd;<span class="comment">//窗口句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">UINT uMsg;<span class="comment">//消息ID</span></span></span></span><br><span class="line"><span class="function"><span class="params">WPARAM wParam;<span class="comment">//消息参数</span></span></span></span><br><span class="line"><span class="function"><span class="params">LPARAM lParam;<span class="comment">//消息参数</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>当系统通知窗口时，(<strong>DispatchMessage</strong>)会调用窗口处理函数，同时将消息ID和消息参数传递给窗口处理函数。</p><p>在窗口处理函数中，<strong>不处理的消息</strong>，<strong>使用缺省窗口处理函数</strong>。</p><p>例如:**DefWindowProc(可以给各种消息做默认处理)**。</p><hr><h3 id="消息循环中的相关函数-浅谈"><a href="#消息循环中的相关函数-浅谈" class="headerlink" title="消息循环中的相关函数(浅谈)"></a>消息循环中的相关函数(浅谈)</h3><p><strong>GetMessage-到系统的某个地方抓本进程的消息</strong></p><p>函数原型如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">GetMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">LPMSG lpMsg,<span class="comment">//存放获取到消息的BUFF，</span></span></span></span><br><span class="line"><span class="function"><span class="params">    HWND hWndp;<span class="comment">//窗口句柄，要是定为NULL，将会抓取本进程中所有窗口中的消息</span></span></span></span><br><span class="line"><span class="function"><span class="params">    UNIT wMsgFilterMin,<span class="comment">//获取的最小ID</span></span></span></span><br><span class="line"><span class="function"><span class="params">    UNIT wMsgFilterMax<span class="comment">//获取消息的最大ID</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">//最后两个参数都为0，就是不管ID有多大，只要是本进程的消息都抓过来</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>其中后三个参数可以限制抓取消息的范围</strong>，如果设置为NULL,0,0那其实就是没有进行限制，只要是本进程的消息我都把它抓过来。</p><p><strong>GetMessage的返回值</strong></p><p>消息WM_QUIT会使GetMessage返回0，从而中终止消息接收。</p><p>PostQuitMessage(0);会在进程中扔出WM_QUIT这个消息，get后从而使得消息循环终止。</p><hr><p><strong>TranslateMessage-翻译消息</strong>——它可不是什么消息都翻译。</p><p><strong>将按键(可见字符按键，a~z)消息翻译成字符消息。</strong></p><p>所以进入到它的内部， 它所做的第一件事就是检查这个消息是否合法，是否是它要翻译的消息类型。 </p><p><strong>如果不是按键类型消息</strong>，不做任何处理，继续执行。</p><p>函数原型如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOL TranslateMessage</span><br><span class="line">&#123;</span><br><span class="line">    CONST  MSG* lpMsg;<span class="comment">//要翻译的消息地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>DispatchMessage-派发消息(调用对应窗口的消息处理函数)</strong></p><p>函数原型如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT <span class="title">DispatchMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">CONST MSG* lpmsg<span class="comment">//要派发的消息</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="常见消息"><a href="#常见消息" class="headerlink" title="常见消息"></a>常见消息</h2><p><strong>如何学习一个消息</strong></p><p>1.掌握这个消息的<strong>产生时间</strong>。</p><ol start="2"><li>分析每个消息附带的<strong>两个信息</strong>。</li><li> 这个消息可以用来干什么(<strong>一般用法</strong>)。 </li></ol><h3 id="WM-DESTORY"><a href="#WM-DESTORY" class="headerlink" title="WM_DESTORY"></a>WM_DESTORY</h3><ul><li>产生时间:窗口被销毁时产生</li><li>附带信息:wParam:为0，lParam:为0</li><li>一般用法:常用于在窗口被销毁前，做相应的善后处理，例如资源、内存等(<strong>该回收回收，该释放释放。</strong>)。</li></ul><h3 id="WM-SYSCOMMAND"><a href="#WM-SYSCOMMAND" class="headerlink" title="WM_SYSCOMMAND"></a>WM_SYSCOMMAND</h3><ul><li>产生时间：当点击窗口最大化，最小化，关闭等。</li><li>附带信息:<ul><li>wParam:具体点击的位置，例如关闭SC_CLOSE等，</li><li>lParam:鼠标光标的位置(<strong>这个不重要，我们只需要知道点没点就行，具体在哪个位置其实无所谓(具体情况具体使用)</strong>)，LOWORD(lParam);水平位置，HIWORD(lParam)；垂直位置。(<strong>高两字节传纵坐标，低两字节传横坐标。</strong>)</li></ul></li><li>一般用法:常用在窗口关闭时，提示用户处理。</li></ul><hr><h3 id="WM-CREATE"><a href="#WM-CREATE" class="headerlink" title="WM_CREATE"></a>WM_CREATE</h3><ul><li>产生时间:在窗口创建成功但还没显示时。</li><li>附带信息:<ul><li>wParam:为0</li><li>lParam:为CREATESTRUCT类型的指针(<strong>强转成这个类型再用</strong>)，通过这个指针可以获取CreatWindowEx中全部12个参数的信息。</li></ul></li><li>一般用法：常用于初始化窗口函数、资源等等，包括创建子窗口等。</li></ul><hr><h3 id="WM-SIZE"><a href="#WM-SIZE" class="headerlink" title="WM_SIZE"></a>WM_SIZE</h3><ul><li>产生时间:在窗口的大小发生变化后。</li><li>附带信息:<ul><li>wParam:窗口大小变化的原因。</li><li>lParam:窗口变化后的大小<ul><li>LOWORD(lParam)变化后的宽度</li><li>HIWORD(lParam)变化后的高度</li></ul></li></ul></li><li>一般用法:常用于窗口大小发生变化后，调整窗口内各个部分的布局。</li></ul><hr><h3 id="WM-QUIT"><a href="#WM-QUIT" class="headerlink" title="WM_QUIT"></a>WM_QUIT</h3><ul><li>产生时间:程序员发送。</li><li>附带信息:<ul><li>wPram:PostQuitmessage函数传递的参数。</li><li>lParam：0。</li></ul></li><li>一般用法:用于结束消息循环，当GetMessage收到这个消息后，会返回FALSE,结束while处理，退出消息循环。</li></ul><p><strong>这个消息不用我们去处理</strong>,进不去我们定义的窗口处理函数,GetMessage()返回了0，无法进入循环获取消息。</p><hr><h3 id="WM-PAINT"><a href="#WM-PAINT" class="headerlink" title="WM_PAINT"></a>WM_PAINT</h3><ul><li>产生时间:当窗口需要绘制的时候 or( GetMessage没消息可抓的时候，详情请看下面。)</li><li>附带信息:(没用)<ul><li>wParam: 0</li><li>lParam:0</li></ul></li><li>专职用法:就是用于绘图。</li></ul><p>第一个WM_PAINT是系统发送的，当第一次创建窗口。</p><p>也就是说产生WM_SIZE消息的同时肯定回产生WM_PAINT消息，重新绘制。</p><p><strong>相关函数</strong></p><ul><li>窗口无效区域:需要重新绘制的区域。</li><li>调用这个函数，让窗口需要重新绘制，<strong>GetMessAge</strong>会发送WM_PAINT消息，<strong>注意，是谁发送消息</strong>。  (就可以理解说这个函数告诉GetMessage说，这个窗口需要绘制了，GetMessage发送消息到消息队列，然后转发到对应进程的消息队列中，开始执行。)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">InvalidateRect</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] HWND       hWnd,<span class="comment">//窗口句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">const</span> RECT *lpRect,<span class="comment">//区域的矩形坐标，对窗口的哪一部分进行重新绘制</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] BOOL       bErase<span class="comment">//重绘前是否先擦除</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="调试技巧"><a href="#调试技巧" class="headerlink" title="调试技巧"></a>调试技巧</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">设置一个全局变量</span><br><span class="line">    HANDLE g_HOUTPUT = <span class="number">0</span>;<span class="comment">//接收标准输出句柄</span></span><br><span class="line">增加一个dos窗口</span><br><span class="line">AllocConsole();</span><br><span class="line">g_HOUTPUT = GetStdHandle(STD_OUTPUT_HANDLE);</span><br></pre></td></tr></table></figure><p>  <strong>dos窗口只能接收字符串类型</strong></p><p><strong>sprintf转，writeconsole打印</strong></p><hr><h2 id="消息循环的原理"><a href="#消息循环的原理" class="headerlink" title="消息循环的原理"></a>消息循环的原理</h2><h3 id="消息循环的阻塞"><a href="#消息循环的阻塞" class="headerlink" title="消息循环的阻塞"></a>消息循环的阻塞</h3><ul><li>GetMessage-从系统获取消息，将消息从系统中移除，阻塞函数。当系统无消息时，会等候下一条消息。</li></ul><blockquote><p>对人来说消息是一直存在的，但是对于CPU来说(速度接近光速)，消息不是经常有的，所以会经常发生阻塞。这样程序的效率就不高，从而引出下面这个函数。</p></blockquote><ul><li>PeekMessage-以查看的方式从系统中获取消息，可以不将消息从系统出移除，非阻塞函数。当系统无消息时，返回FALSE,继续执行后续代码。</li></ul><p><strong>函数原型如下:</strong></p><p>(前四个参数同GetMessage)</p><p>最后一个参数是，是否赋予它抓取消息的能力，一般是不给它的，也就是填写</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">PeekMessageA</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [out]          LPMSG lpMsg,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional] HWND  hWnd,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]           UINT  wMsgFilterMin,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]           UINT  wMsgFilterMax,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]           UINT  wRemoveMsg</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>也就是说</strong>，更好的流程是，先派PeekMessage去侦查是否有消息，有就告诉GetMessage让它来处 理。没有就不要派Get去了，因为它会一直在那里等着消息的出现。</p><p><strong>例如</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (PeekMessage(&amp;nMsg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, PM_NOREMOVE))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//有消息-判断是否是WM_QUIT</span></span><br><span class="line"><span class="keyword">if</span> (GetMessage(&amp;nMsg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">TranslateMessage(&amp;nMsg);</span><br><span class="line">DispatchMessage(&amp;nMsg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//没有消息——空闲处理</span></span><br><span class="line">WriteConsole(g_HOUTPUT, <span class="string">&quot;空闲ing\n&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;空闲ing&quot;</span>), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><p><strong>Windows平台上的消息，都是它们两个造出来的。</strong></p><ul><li>SendMessage-发送消息，会等候消息处理的结果。</li><li>PostMessage-投递消息，消息发出后立刻返回，不等候消息执行结果。</li></ul><p><strong>函数原型如下</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT <span class="title">SendMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] HWND   hWnd,<span class="comment">//消息发送的目的创建</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] UINT   Msg,<span class="comment">//消息ID</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] WPARAM wParam,<span class="comment">//消息参数</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] LPARAM lParam<span class="comment">//消息参数</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>这四个参数就是一个消息的前四个参数，剩下的两个参数函数内部以某种手段自加来获取。 </p><p>（<strong>其中，</strong>sendmessage的消息扔到哪去，我们不知道，在之后的课程中会补充。postmessage的消息会扔到getmessage能接收到的区域）</p><h3 id="消息分类"><a href="#消息分类" class="headerlink" title="消息分类"></a>消息分类</h3><ul><li>系统消息-ID范围0~0x03FF<ul><li>由系统定义好的消息，可以在程序中直接使用。</li><li>程序员只负责一头，要么发送不用处理，要么处理不用发送。</li></ul></li><li>用户自定义的消息-ID范围0x0400(WM_USER) -  0x7FFF(31743)<ul><li>由用户自己定义，满足用户自己的需求。由用户自己发出消息，并响应处理。</li><li>由程序员，自己定制，自己发送，自己处理。</li><li>自定义消息宏：WM_USER(叫什么都行)</li></ul></li></ul><p><strong>例如</strong>:</p><p>定义消息名称</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WM_MYMESSAGE WM_USER+1001</span></span><br></pre></td></tr></table></figure><p>发送,在哪发都可以,附加消息，你自己的，附加什么都行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PostMessage/SendMessage(hWnd, WM_MYMESSAGE, <span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><h3 id="消息队列的概念"><a href="#消息队列的概念" class="headerlink" title="消息队列的概念"></a>消息队列的概念</h3><ul><li>消息队列是用于存放消息的队列。</li><li>消息在队列中先进先出。</li><li>所有窗口都具有消息队列。</li><li>程序(<strong>GetMessage()</strong>)可以从队列中获取消息。</li></ul><hr><h3 id="消息队列的分类"><a href="#消息队列的分类" class="headerlink" title="消息队列的分类"></a>消息队列的分类</h3><ul><li>系统消息队列——由系统维护的消息队列。存放系统产生的消息，例如鼠标、键盘等。</li><li>程序消息队列——属于每个应用程序的(线程)的消息队列。由应用程序(线程)维护。</li></ul><blockquote><p>每个进程都有一个消息队列，都有GetMessage(),在本进程的消息队列中抓取消息。</p><p>细节解释:<br>所有进程产生的消息都先进系统消息队列，操作系统会每个一段时间，将消息转发到各个进程中去。所以才能在本进程中抓到本进程的消息。</p><p>如何做到正确转发:<br>消息的第一个参数是窗口句柄，保存窗口数据的内存，通过它可以找到当前程序实例句柄，找到本进程对应内存，从而正确转发。</p></blockquote><p>SendMessage既没有扔到系统消息队列里，也没有扔到进程消息队列中。</p><hr><h3 id="消息和消息队列的关系"><a href="#消息和消息队列的关系" class="headerlink" title="消息和消息队列的关系"></a>消息和消息队列的关系</h3><ul><li><p>消息和消息队列的关系</p><ul><li>当鼠标、键盘产生消息时，会将消息存放到消息队列中。</li><li>系统会根据存放的消息，找到对应程序的消息队列。</li><li>将消息投递到程序的消息队列中</li></ul></li><li><p>根据消息和消息队列之间使用关系，将消息分成两类</p><ul><li>队列消息-消息的发送和获取，都是通过消息队列完成。<ul><li>消息发送后，首先放入队列，然后通过消息循环，从队列中获取。</li><li>GetMessage-从消息队列中获取消息</li><li>PostMessage-将消息投递到消息队列</li><li>常见的消息队列:WM_PAINT、键盘、鼠标、定时器</li></ul></li><li>非队列消息-消息的发送和获取，是直接调用消息的窗口处理函数完成。 <ul><li>消息发送时，首先找到消息接收窗口的窗口处理函数，直接调用处理函数，完成消息。<ul><li>SendMessage-<strong>直接将消息发送窗口的处理函数，并等待处理结果</strong>。</li><li>常见消息:WM_CREATE(它是必须不能进队列的，否则就没办法把它抓出来了)、WM_SIZE等。</li></ul></li></ul></li></ul></li></ul><h3 id="GetMessage"><a href="#GetMessage" class="headerlink" title="GetMessage"></a>GetMessage</h3><ul><li>在程序(线程)消息队列查找消息，如果队列有消息，**检查消息是否满足指定条件(HWND,ID范围)**，不满足条件就不会取出消息，否则从队列取出消息返回。</li><li>如果程序(线程)消息队列没有消息，会向系统消息队列获取(<strong>找系统要，发起请求</strong>)属于班本程序的消息(<strong>之前说系统会定时分发属于对应进程的消息，如果这个时间没到，但是有的进程没消息了，会打破这个时间，提前分发。</strong>)。如果系统队列的当前消息属于本程序，系统会将消息转发到程序消息队列中。</li><li><strong>如果系统消息也没有消息(那也不闲着)<strong>，检查当前进程的所有窗口需要重新绘制的区域，如果发现有需要绘制的区域，</strong>产生WM_PAINT消息扔到系统的消息队列</strong>，取得消息返回处理。</li><li><strong>如果没有重新绘制区域</strong>，检查定时器，如果有到时的定时器，产生WM_TIMER，返回处理执行。</li><li>如果没有到时的定时器，整理程序的资源、内存等等。</li><li>GetMessage会继续等候下一条消息。PeekMessage会返回FASLE,交出程序的控制权。</li><li>注意:GetMessage如果获取到的是WM_QUIT，函数会返回FALSE。</li></ul><p><strong>总结</strong>：总结起来就是，GetMessage非常的死心眼，没消息就找系统要，要不来就自己造，造不来就整理下资源(干点打扫卫生的活儿)，还没有消息来，那就阻塞，等待消息的传来，<strong>但是依然不返回</strong>。</p><p>阻塞了，就说明GetMessage已经尽力了。</p><p>PeekMessage也会干上面的事儿，<strong>但是它最后不会傻等</strong>。</p><h2 id="键盘消息"><a href="#键盘消息" class="headerlink" title="键盘消息"></a>键盘消息</h2><h3 id="键盘消息分类"><a href="#键盘消息分类" class="headerlink" title="键盘消息分类"></a>键盘消息分类</h3><ul><li>WM_KEYDOWN-按键被按下时产生</li><li>WM_KEYUP-按键被放开时产生</li><li>WM_SYSKEYDOWN-系统键按下时产生，比如ALT、F10</li><li>WM_SYSKEYUP-系统键放开时产生</li></ul><p>附带信息:<br>.WPARAM-按键的Virtual Key(每个这个对应一个按键-这个虚拟键码值无法区分大小写，所以我们才需要去翻译消息)</p><p>LPARAM-按键的参数，例如按下的次数 </p><h3 id="字符消息-WM-CHAR"><a href="#字符消息-WM-CHAR" class="headerlink" title="字符消息(WM_CHAR)"></a>字符消息(WM_CHAR)</h3><ul><li>TranslateMessage在转换WM_KEYDOWN消息时，对于可见字符可以产生WM_CHAR,不可见字符无此消息。</li><li>附带信息:<ul><li>WMPARAM-<strong>输入的字符的ASCII字符编码值</strong></li><li>LPARAM-按键的相关参数</li></ul></li></ul><p>翻译消息的内部大致流程，如下图所示:</p><p><img src="/images/win32(1).assets/image-20211031160052913.png" alt="image-20211031160052913"></p><p><strong>文字解释</strong>:</p><p>先检查是否有按键被按下， 没有直接return,有则判断是否是可见字符消息（<strong>刚才的按键消息再一次被GET过来时，已经变成了字符消息</strong>，不是按键消息，在这部就直接return了），不是直接return,都通过了，那就判断大写键是否打开，根据大小写发出相应的消息。    </p><h2 id="鼠标消息"><a href="#鼠标消息" class="headerlink" title="鼠标消息"></a>鼠标消息</h2><h3 id="鼠标消息的分类"><a href="#鼠标消息的分类" class="headerlink" title="鼠标消息的分类"></a>鼠标消息的分类</h3><ul><li>基本鼠标消息<ul><li>WM_LBUTTONDOWN-鼠标左键按下</li><li>WM_LBUTTONUP-鼠标左键抬起</li><li>WM_RBUTTONDOWN-鼠标右键按下</li><li>WM_RBUTTONUO-鼠标右键抬起</li><li>WM_MOUSEMOVE-鼠标移动消息</li></ul></li><li>双击消息<ul><li>WM_ LBUTTONDBLCLK-鼠标左键双击</li><li>WM_RBUTTONDBLCLK-鼠标右键双击</li></ul></li><li>滚轮消息<ul><li>WM_MOUSEWHEEL-鼠标滚轮消息</li></ul></li></ul><h3 id="鼠标基本消息"><a href="#鼠标基本消息" class="headerlink" title="鼠标基本消息"></a>鼠标基本消息</h3><ul><li>附带信息<ul><li>WPARAM:其他按键的状态，例如Ctrl/Shift等。<ul><li>LPARAM:鼠标的位置，窗口客户区坐标系。<ul><li>LOWWORD X坐标位置</li><li>HIWORD Y坐标位置</li></ul></li></ul></li></ul></li><li>一般情况鼠标按下/抬起成对出现。在鼠标移动过程中，会根据移动速度产生一系列的WM_ MOUSEMOVE消息。</li></ul><h3 id="鼠标双击消息"><a href="#鼠标双击消息" class="headerlink" title="鼠标双击消息"></a>鼠标双击消息</h3><ul><li>附带消息:<ul><li>WPARAM-其它按键的状态，例如CTRL/SHIFT。</li><li>LPARAM-鼠标的位置，窗口客户区坐标系。<ul><li>LOWORD(lParam)-X坐标位置</li><li>HIWORD(lParam)-Y坐标位置</li></ul></li></ul></li><li>消息产生顺序<ul><li>一左键双击为例:<ul><li>WM_LBUTTONDOWN</li><li>WM_LBUTTONUP</li><li>WM_LBUTTONDBLCLK</li><li>WM_LBUTTONU</li><li>使用时需要在注册窗口类的时候添加CS_DBLCLKS风格。</li></ul></li></ul></li></ul><h3 id="鼠标滚轮消息"><a href="#鼠标滚轮消息" class="headerlink" title="鼠标滚轮消息"></a>鼠标滚轮消息</h3><ul><li>附带消息<ul><li>WPARAM<ul><li>LOWORD-其他按键的状态</li><li>HIWORD-滚轮的偏移量(120的倍数 )，通过正负值表示滚轮的方向</li><li>正-向前滚动，负-向后滚动</li></ul></li><li>LPARAM:鼠标当前的位置，屏幕坐标系<ul><li>LOWORD-X坐标</li><li>HIWORD-Y坐标</li></ul></li></ul></li><li>使用:通过偏移量，获取滚轮的方向和距离</li></ul><h2 id="定时器消息"><a href="#定时器消息" class="headerlink" title="定时器消息"></a>定时器消息</h2><h3 id="定时器消息介绍"><a href="#定时器消息介绍" class="headerlink" title="定时器消息介绍"></a>定时器消息介绍</h3><ul><li>产生时间:<br>在程序中创建定时器，当到达时间间隔时，定时器会向程序发送一个WM_TIMER消息。定时器的精度是毫秒，但是准确度很低。例如时间间隔为1000ms，但是会在非1000毫秒到达消息。</li><li>附带信息:<ul><li>WPARAM:<strong>定时器ID(到时间的)</strong></li><li>LPARAM:定时器处理函数的指针</li></ul></li></ul><p>GetMessage肯定有没事干的时候，所以WM_TIMER消息肯定会产生。</p><p>按照一定周期去执行，时间要求不严格，都可以用这个定时器。</p><h3 id="创建销毁定时器"><a href="#创建销毁定时器" class="headerlink" title="创建销毁定时器"></a>创建销毁定时器</h3><ul><li>创建定时器</li></ul><p>函数原型如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UINT_PTR <span class="title">SetTimer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional] HWND      hWnd,<span class="comment">//定时器窗口句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in]           UINT_PTR  nIDEvent,<span class="comment">//定时器ID</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in]           UINT      uElapse,<span class="comment">//时间间隔(毫秒为单位)</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional] TIMERPROC lpTimerFunc；<span class="comment">//定时器处理函数指针(一般不使用，为NULL)创建成功，返回非0。</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>关闭定时器</li></ul><p>函数原型如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">KillTimer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional] HWND     hWnd,<span class="comment">//窗口句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in]           UINT_PTR uIDEvent<span class="comment">//定时器ID</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="菜单资源"><a href="#菜单资源" class="headerlink" title="菜单资源"></a>菜单资源</h2><h3 id="菜单分类"><a href="#菜单分类" class="headerlink" title="菜单分类"></a>菜单分类</h3><ul><li>窗口的顶层菜单(不需要也不能设置ID,因为它的唯一作用的就是弹出下拉次菜单)</li><li>弹出式菜单</li><li>系统菜单</li></ul><p>HMENU(<strong>菜单句柄</strong>)类型表示菜单，ID表示菜单项。</p><h3 id="资源相关"><a href="#资源相关" class="headerlink" title="资源相关"></a>资源相关</h3><ul><li>资源脚本文件:.rc文件</li><li>编译器:RC.EXE</li></ul><h3 id="菜单资源的使用"><a href="#菜单资源的使用" class="headerlink" title="菜单资源的使用"></a>菜单资源的使用</h3><ul><li>添加菜单资源-添加文件.rc文件</li><li>加载菜单资源<ol><li>注册窗口类时设置菜单<ol><li>(wc.lpszMenuName = (char*)IDR_MENU1;//菜单设置)</li></ol></li><li>创建窗口传参设置菜单<ol><li>CreateWindow的导数第三个参数 </li></ol></li><li>在主窗口WM_CREATE消息中利用SetMenu函数设置菜单</li></ol></li></ul><p>LoadMenuW函数原型:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HMENU <span class="title">LoadMenuW</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional] HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]           LPCWSTR   lpMenuName</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>SetMenu函数原型:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">SetMenu</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]           HWND  hWnd,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional] HMENU hMenu</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="命令消息-WM-COMMAND-处理"><a href="#命令消息-WM-COMMAND-处理" class="headerlink" title="命令消息(WM_COMMAND)处理"></a>命令消息(WM_COMMAND)处理</h3><ul><li>附带消息:<ul><li>WPARAM：<ul><li>HIWORD-对于菜单为0(没用)</li><li>LOWRD-<strong>被鼠标点击的</strong>菜单项的ID</li></ul></li><li>LPARAM<ul><li>对于菜单项为0(没用)</li></ul></li></ul></li></ul><h2 id="Windows资源"><a href="#Windows资源" class="headerlink" title="Windows资源"></a>Windows资源</h2><h3 id="图标资源"><a href="#图标资源" class="headerlink" title="图标资源"></a>图标资源</h3><p><strong>指的就是.ico为后缀的图片</strong></p><ul><li>添加资源<ul><li>注意图标的大小， 一个图标文件中，可以有多个不同大小的图标。</li></ul></li><li>加载</li></ul><p>函数原型如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">到本进程的内存中找图标的数据同loadMenu</span><br><span class="line"><span class="function">HICON <span class="title">LoadIconA</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional] HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]           LPCSTR    lpIconName</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;<span class="comment">//成功返回HICON句柄</span></span><br><span class="line"></span><br><span class="line">例：使用</span><br><span class="line">wc.hIcon = LoadIcon(hIns,(<span class="keyword">char</span>*)IDI_ICON1);</span><br></pre></td></tr></table></figure><ul><li>设置<ul><li>注册窗口类</li></ul></li></ul><h3 id="光标资源"><a href="#光标资源" class="headerlink" title="光标资源"></a>光标资源</h3><ul><li>添加光标的资源<ul><li>光标的大小默认是32X32像素，每个光标有HotSpot,是当前鼠标的热点(点击图标生效的那个点)。</li></ul></li><li>加载资源</li></ul><p>函数原型如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HCURSOR <span class="title">LoadCursorW</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional] HINSTANCE hInstance,<span class="comment">//可以为NULL，获取系统默认的Cursor</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in]           LPCWSTR   lpCursorName</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>设置资源</p><ul><li>在注册窗口时，设置光标。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc.hCursor = LoadCursor(hIns,(<span class="keyword">char</span>*)IDC_CURSOR1);</span><br></pre></td></tr></table></figure><ul><li>使用SetCursor设置光标。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HCURSOR <span class="title">SetCursor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HCURSOR hCursor</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//必须放在处理下面这个消息的时候调用</span></span><br></pre></td></tr></table></figure><ul><li>WM_SETCURSOR消息参数<ul><li>WPARAM-当前使用的光标句柄</li><li>LPARAM-LOWORD-当前区域代码(Hit-Test code)HICLIENT/HTCAPTION…</li><li>HIWORD-当前鼠标消息ID</li></ul></li></ul></li></ul><h3 id="字符串资源"><a href="#字符串资源" class="headerlink" title="字符串资源"></a>字符串资源</h3><ul><li>添加字符串资源<ul><li>添加字符串资源，在表中增加字符串。</li></ul></li><li>字符串资源的使用<ul><li>函数原型如下</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LoadStringW</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional] HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]           UINT      uID,<span class="comment">//字符串ID</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [out]          LPWSTR    lpBuffer,<span class="comment">//存放字符串 </span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in]           <span class="keyword">int</span>       cchBufferMax</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;<span class="comment">//成功返回字符串长度，失败0</span></span><br></pre></td></tr></table></figure><p>使用:例如实现中英文两版的软件。使用这个就非常方便。</p><hr><p><strong>字符串能写就写在这张字符串表中，容易修改。</strong></p><p>用loadstring去读，然后在字符串表中改。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> szTitle[<span class="number">256</span>] = &#123; &#125;;</span><br><span class="line">LoadString(hIns, IDS_WIND, szTitle, <span class="number">256</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/win32(1).assets/image-20211102190831358.png" alt="image-20211102190831358"></p><hr><h3 id="加速键资源"><a href="#加速键资源" class="headerlink" title="加速键资源"></a>加速键资源</h3><p>什么ctrl+c,v之类的，就是快捷键呗。</p><p>能使用加速键(组合键)的功能，在菜单栏中也对应有一个，一般是绑定使用。</p><ul><li>添加,资源添加<strong>加速键表</strong>，增加命令ID对应的加速键。</li><li>使用:</li></ul><p>函数原型如下:</p><p>加载加速键表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HACCEL <span class="title">LoadAcceleratorsA</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional] HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]           LPCSTR    lpTableName<span class="comment">//加速键表资源ID</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;<span class="comment">//返回加速键表句柄</span></span><br></pre></td></tr></table></figure><p>翻译加速键</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TranslateAcceleratorA</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] HWND   hWnd,<span class="comment">//处理消息的句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] HACCEL hAccTable,<span class="comment">//加速键句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] LPMSG  lpMsg<span class="comment">//消息</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;<span class="comment">//如果是加速键，返回非0</span></span><br><span class="line"></span><br><span class="line">位置：一定是放在GetMessage的后面，因为它不抓哪来的消息。</span><br><span class="line">并且放在TranslateMessage的后面，假如我按了ctrl+m，我是想让他区分按的是大M还是小m吗？不是，我为的是实现对应的功能(产生对应的消息WM_COMMAND。)</span><br><span class="line">    </span><br><span class="line">如果按的是加速键，在内部会发送出WM_COMMAND消息。</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p> <strong>代码示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HACCEL hAcc = LoadAccelerators(hIns, (<span class="keyword">char</span>*)IDR_ACCELERATOR1);<span class="comment">//加载加速键表</span></span><br><span class="line"><span class="keyword">while</span> (GetMessage(&amp;nMsg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!TranslateAccelerator(hWnd, hAcc, &amp;nMsg))<span class="comment">//不是加速键</span></span><br><span class="line">&#123;</span><br><span class="line">TranslateMessage(&amp;nMsg);</span><br><span class="line">DispatchMessage(&amp;nMsg);<span class="comment">//将消息交给窗口处理函数来处理</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>注意</strong>：<br>由TranslateAccelerator发出的WM_COMMMAND消息,HIWORD(WPARAM)为1。</p><p>而鼠标点击菜单资源的HIWORD(WPARAM)为0。</p><p>LOWORD(WPARAM)都代表命令ID。</p><p>LPARAM为0。</p><hr><h2 id="绘图编程"><a href="#绘图编程" class="headerlink" title="绘图编程"></a>绘图编程</h2><h3 id="绘图基础"><a href="#绘图基础" class="headerlink" title="绘图基础"></a>绘图基础</h3><ul><li>绘图设备(上下文/描述表)DC(Device Context)绘图上下文/绘图描述表</li><li>HDC - DC句柄，表示绘图设备，<strong>绘图设备句柄</strong>。 </li><li>GDI-Windows graphics device interface(Win32提供的绘图API)</li><li>颜色<ul><li>计算机使用红、绿、蓝(RGB)</li><li>每个点颜色是3个字节24位保存0~2^24 - 1种颜色</li><li>16位：5,5,6</li><li>32位：8,8,8,8绘图或透明度</li></ul></li><li>颜色的使用<ul><li>COLORREF-实际DWORD<ul><li>例如:COLORREF nColor = 0;</li></ul></li><li>赋值使用RGB宏<ul><li>例如:nColor = RGB(0,0,255);</li></ul></li><li>获取RGB值<ul><li>GetRBValue/GetGValue/GetBValue</li><li>例如:BYTE nRed  =GetRValue(nColor);</li></ul></li></ul></li></ul><h3 id="基本图形绘制"><a href="#基本图形绘制" class="headerlink" title="基本图形绘制"></a>基本图形绘制</h3><p><strong>在绘图消息中绘图</strong></p><p><strong>绘制点</strong></p><ul><li>SetPixel设置指定点的颜色</li></ul><p>函数原型如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">COLORREF <span class="title">SetPixel</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] HDC      hdc,<span class="comment">//绘图设备句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>      x,<span class="comment">//X坐标 </span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>      y,<span class="comment">//Y坐标</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] COLORREF color<span class="comment">//设置的颜色</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;<span class="comment">//返回点原来的颜色</span></span><br></pre></td></tr></table></figure><p><strong>例如</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PAINTSTRUCT PS = &#123; &#125;;<span class="comment">//抓到画家</span></span><br><span class="line">HDC hdc = BeginPaint(hwnd, &amp;PS);<span class="comment">//开始绘图</span></span><br><span class="line">SetPixel(hdc,<span class="number">100</span>,<span class="number">100</span>,RGB(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">EndPaint(hwnd,&amp;PS);<span class="comment">//放掉画家</span></span><br></pre></td></tr></table></figure><hr><ul><li><p>线的使用(直线、弧线)</p><ul><li><p>MoveToEx-指名窗口当前点(更改窗口当前点) </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">MoveToEx</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]  HDC     hdc,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]  <span class="keyword">int</span>     x,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]  <span class="keyword">int</span>     y,</span></span></span><br><span class="line"><span class="function"><span class="params">  [out] LPPOINT lppt<span class="comment">//为空则不返回上一个点</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>LineTo-从窗口当前点到指定点绘制一条直线(并且致命窗口当前点我)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">LineTo</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] HDC hdc,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span> x,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span> y</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>当前点：上一次绘图时的最后一点，初始为(0,0)点</li></ul></li></ul></li><li><p>封闭图形:能够使用画刷填充的图形(反之则不是)。</p><ul><li>Rectangle/Ellipse——(圆形/矩形)</li></ul></li></ul><p><img src="/images/win32(1).assets/image-20211103164837584.png" alt="image-20211103164837584"></p><p><img src="/images/win32(1).assets/image-20211103164851493.png" alt="image-20211103164851493"></p><p>内切圆，参数相同。</p><h2 id="GDI绘图对象"><a href="#GDI绘图对象" class="headerlink" title="GDI绘图对象"></a>GDI绘图对象</h2><h3 id="画笔"><a href="#画笔" class="headerlink" title="画笔"></a>画笔</h3><ul><li>画笔的作用<ul><li>线的颜色、线型、线粗。</li><li>HPAN-画笔句柄</li></ul></li><li>画笔的使用</li></ul><p>1.创建画笔，函数原型如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HPEN <span class="title">CreatePen</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>      iStyle,<span class="comment">//画笔的样式</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>      cWidth,<span class="comment">//画笔的粗细</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] COLORREF color<span class="comment">//画笔的颜色</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;<span class="comment">//创建成功画笔句柄</span></span><br></pre></td></tr></table></figure><p>PS_SOILD-实心线，可以支持多个像素宽，其它线型只能是一个像素宽。</p><p>2.将画笔应用到DC中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HGDIOBJ <span class="title">SelectObject</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] HDC     hdc,<span class="comment">//绘图设备句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] HGDIOBJ h<span class="comment">//GDI绘图对象句柄，(包括)兼容画笔句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;<span class="comment">//返回原来的GDI绘图对象句柄</span></span><br></pre></td></tr></table></figure><p>3.绘图</p><p>4.取出DC中的画笔</p><p>将原来的画笔，使用SelectObject函数，放入到设备DC中，就会将我们创建的画笔取出。</p><p>5.释放画笔，函数原型如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">DeleteObject</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] HGDIOBJ ho<span class="comment">//GDI绘图对象句柄，画笔句柄。</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>只能删除不被DC使用的画笔，所以在释放前，必须从将画笔从DC中取出。</p><p>大致过程就是，创建-交换-绘画-取出-释放</p><p> <strong>示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PAINTSTRUCT PS = &#123; &#125;;<span class="comment">//抓到画家</span></span><br><span class="line">HDC hdc = BeginPaint(hwnd, &amp;PS);</span><br><span class="line">HPEN hPen = CreatePen(PS_SOLID,<span class="number">20</span>,RGB(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>));<span class="comment">//创建</span></span><br><span class="line">HGDIOBJ nOldPen = SelectObject(hdc, hPen);<span class="comment">//交换</span></span><br><span class="line">Ellipse(hdc, <span class="number">100</span>, <span class="number">100</span>, <span class="number">300</span>, <span class="number">300</span>);</span><br><span class="line">SelectObject(hdc, nOldPen);<span class="comment">//交换,这里可以不用接收，上面创建时的句柄可以找到这跟笔，让画家松手就行了，我们就能销毁了。</span></span><br><span class="line">DeleteObject(hPen);</span><br><span class="line">EndPaint(hwnd,&amp;PS);</span><br></pre></td></tr></table></figure><h3 id="画刷"><a href="#画刷" class="headerlink" title="画刷"></a>画刷</h3><ul><li>画刷相关<ul><li>画刷-封闭图形的填充颜色、图案</li><li>HBRUSH-画刷句柄</li><li>画刷的使用套路就跟画笔一样</li><li>默认是画刷颜色是白色的</li></ul></li><li>画刷的使用</li></ul><p>1.创建画刷</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">创建实心画刷</span><br><span class="line"><span class="function">HBRUSH <span class="title">CreateSolidBrush</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] COLORREF color</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;    </span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">创建纹理画刷</span><br><span class="line"><span class="function">HBRUSH <span class="title">CreateHatchBrush</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>      iHatch,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] COLORREF color</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>2.将画刷应用到DC中</p><p>SelectObject</p><p>3.绘图</p><p>4.将画刷从DC中取出</p><p>SelectObject</p><p>5.删除画刷</p><p>DeleteObject</p><hr><ul><li>其他</li></ul><p>可以使用GetStockObject函数获取系统维护的画刷，画笔等。</p><p>如果不使用画刷填充，需要使用NULL_BRUSH参数，获取不填充的画刷。</p><p>GetStockObject返回的画刷不需要DeleteObject。</p><p><strong>示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向操作系统借一把透明刷子</span></span><br><span class="line">HGDIOBJ hBrush = GetStockObject(NULL_BRUSH);</span><br></pre></td></tr></table></figure><h2 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h2><h3 id="位图绘制"><a href="#位图绘制" class="headerlink" title="位图绘制"></a>位图绘制</h3><ul><li><p>位图相关</p><ul><li>光栅图形-记录图像中每一点的颜色等信息</li><li>矢量图形-记录图像算法、绘图指令等。</li><li>HBITMAP-位图句柄</li></ul></li><li><p>位图的使用</p><p>1.在资源中添加位图资源</p><p>2.从资源中加载位图——loadBitMap</p><p>3.创建一个与当前DC相匹配的DC(内存DC)(在内存的一个虚拟的区域画)</p><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HDC <span class="title">CreateCompatibleDC</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] HDC hdc<span class="comment">//当前DC句柄，可以为NULL(使用屏幕DC)</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;<span class="comment">//返回创建好的DC句柄</span></span><br></pre></td></tr></table></figure><hr><p><strong>兼具资源的步骤和GDI绘图对象的步骤。</strong></p><p>4.将位图放入匹配的DC中SelectObject</p><p>5.成像(1:1)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">BitBlt</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] HDC   hdc,<span class="comment">//目的DC</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>   x,<span class="comment">//目的左上X坐标</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>   y,<span class="comment">//目的左上Y坐标</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>   cx,<span class="comment">//目的宽度</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>   cy,<span class="comment">//目的高度</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] HDC   hdcSrc,<span class="comment">//源DC</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>   x1,<span class="comment">//源左上X坐标</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>   y1,<span class="comment">//源左上Y坐标</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] DWORD rop<span class="comment">//成像方法SRCCOPY</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>缩放成像</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">StretchBlt</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] HDC   hdcDest,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>   xDest,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>   yDest,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>   wDest,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>   hDest,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] HDC   hdcSrc,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>   xSrc,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>   ySrc,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>   wSrc,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>   hSrc,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] DWORD rop</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><p>6.取出位图</p><p>SelectObject</p><p>7.释放位图</p><p>DeleteObject</p><p>8.释放匹配的DC</p><p>DeleteDC</p><p><strong>代码示例</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PAINTSTRUCT ps = &#123; &#125;;</span><br><span class="line">HDC hdc = BeginPaint(hwnd, &amp;ps);</span><br><span class="line">HBITMAP hBmp = LoadBitmap(g_HINSTANCE, (<span class="keyword">char</span>*)IDB_BITMAP1);</span><br><span class="line">HDC hMemdc = CreateCompatibleDC(hdc);<span class="comment">//创建一个内存DC，并构建一个虚拟区域，并且内存DC在虚拟区域中绘图</span></span><br><span class="line">HGDIOBJ nOldBmp = SelectObject(hMemdc,hBmp);<span class="comment">//将位图数据送给内存DC,内存DC在虚拟区域中将位图绘制出来，返回旧位图(原来并没有，这是个假的，只是为了我们将来能够换回来）</span></span><br><span class="line">BitBlt(hdc, <span class="number">100</span>, <span class="number">100</span>, <span class="number">48</span>, <span class="number">48</span>, hMemdc, <span class="number">0</span>, <span class="number">0</span>, SRCCOPY);<span class="comment">//将虚拟区域绘制好的图像成像到窗口中</span></span><br><span class="line">StretchBlt(hdc, <span class="number">200</span>, <span class="number">200</span>, <span class="number">96</span>, <span class="number">96</span>,hMemdc,<span class="number">0</span>,<span class="number">0</span>,<span class="number">48</span>,<span class="number">48</span>,SRCCOPY);<span class="comment">//缩放成像</span></span><br><span class="line"><span class="comment">//开辟的区域比要成像的图像大，就是放大图像。</span></span><br><span class="line"></span><br><span class="line">SelectObject(hMemdc, nOldBmp);<span class="comment">//换回来</span></span><br><span class="line">DeleteObject(hBmp);<span class="comment">//释放画的位图</span></span><br><span class="line">DeleteDC(hMemdc);<span class="comment">//释放内存DC</span></span><br></pre></td></tr></table></figure><h2 id="文本绘制"><a href="#文本绘制" class="headerlink" title="文本绘制"></a>文本绘制</h2><h3 id="文字的绘制"><a href="#文字的绘制" class="headerlink" title="文字的绘制"></a>文字的绘制</h3><ul><li>TextOut-将文字绘制在指定坐标位置</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">TextOutW</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] HDC     hdc,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>     x,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>     y,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] LPCWSTR lpString,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>     c</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>DrawText</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DrawText</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]      HDC     hdc,<span class="comment">//DC句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in, out] LPCTSTR lpchText,<span class="comment">//字符串</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in]      <span class="keyword">int</span>     cchText,<span class="comment">//字符数量</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in, out] LPRECT  lprc,<span class="comment">//绘制文字的矩形框</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in]      UINT    format<span class="comment">//绘制的方式</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>文字颜色和背景</p><ul><li>文字颜色:SetTextColor</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">COLORREF <span class="title">SetTextColor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] HDC      hdc,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] COLORREF color</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>文字背景色:SetBkColor——只适用在不透明</li><li>文字背景模式:SetBkMode(OPAQUE/TRANSPARENT)(透明(默认)/非透明)</li></ul></li></ul><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><ul><li>字体相关:</li><li>window常用的字体为TrueType格式的字体文件<ul><li>字体名-标识字体类型</li><li>HFONT-字体句柄(保存字体的数据信息——外观形状)</li></ul></li><li>字体的使用</li></ul><p>1.创建字体CreateFont</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HFONT <span class="title">CreateFontA</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>    cHeight,<span class="comment">//字体高度</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>    cWidth,<span class="comment">//字体宽度</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>    cEscapement,<span class="comment">//字符串倾斜角度</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>    cOrientation,<span class="comment">//字体的旋转角度</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] <span class="keyword">int</span>    cWeight,<span class="comment">//字体的粗细</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] DWORD  bItalic,<span class="comment">//斜体</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] DWORD  bUnderline,<span class="comment">//字符下划线</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] DWORD  bStrikeOut,<span class="comment">//删除线</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] DWORD  iCharSet,<span class="comment">//字符集-GB2312_CHARSET</span></span></span></span><br><span class="line"><span class="function"><span class="params">    </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">//下面的4参数全写0即可</span></span></span></span><br><span class="line"><span class="function"><span class="params">    </span></span></span><br><span class="line"><span class="function"><span class="params">  [in] DWORD  iOutPrecision,<span class="comment">//输出精度</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] DWORD  iClipPrecision,<span class="comment">//剪切精度</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] DWORD  iQuality,<span class="comment">//输出质量</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] DWORD  iPitchAndFamily,<span class="comment">//匹配字体</span></span></span></span><br><span class="line"><span class="function"><span class="params">    </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">//这个得写</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] LPCSTR pszFaceName<span class="comment">//字体名称</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>代码示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">PAINTSTRUCT ps = &#123; &#125;;</span><br><span class="line">HDC hdc = BeginPaint(hwnd,&amp;ps);</span><br><span class="line"></span><br><span class="line">SetTextColor(hdc, RGB(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">SetBkColor(hdc, RGB(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HFONT hFront = CreateFont(<span class="number">30</span>,<span class="number">0</span>,<span class="number">45</span>,<span class="number">0</span>,<span class="number">900</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>, GB2312_CHARSET,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="string">&quot;黑体&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HGDIOBJ nOldFron = SelectObject(hdc, hFront);<span class="comment">//将创建的字体给它</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* szText = <span class="string">&quot;我是TEXTOUT&quot;</span>;</span><br><span class="line">TextOut(hdc,<span class="number">100</span>,<span class="number">100</span>,szText,<span class="built_in">strlen</span>(szText));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//DrawText在矩形的范围内画，所以首先要确定一个范围</span></span><br><span class="line">RECT rc;</span><br><span class="line">rc.left = <span class="number">100</span>;</span><br><span class="line">rc.top = <span class="number">150</span>;</span><br><span class="line">rc.right = <span class="number">200</span>;</span><br><span class="line">rc.bottom = <span class="number">200</span>;</span><br><span class="line"><span class="comment">//DrawText有矩形作为限制边界(可以打破)</span></span><br><span class="line">DrawText(hdc, szText, <span class="built_in">strlen</span>(szText),&amp;rc,DT_LEFT | DT_TOP);</span><br><span class="line"><span class="comment">//DT_VCENTER和DT_BOTTOM只适用于DT_SINGLELINE和DT_WORDBREAK冲突</span></span><br><span class="line"></span><br><span class="line">SelectObject(hdc, nOldFron);<span class="comment">//让它放开</span></span><br><span class="line">DeleteObject(hFront);<span class="comment">//字体更要记得释放，因为字体占的内存较大</span></span><br><span class="line">EndPaint(hwnd,&amp;ps);</span><br></pre></td></tr></table></figure><h2 id="对话框"><a href="#对话框" class="headerlink" title="对话框"></a>对话框</h2><p><strong>处理消息的方式与普通窗口相反</strong>，缺省的函数调用自定义函数。</p><h3 id="对话框原理"><a href="#对话框原理" class="headerlink" title="对话框原理"></a>对话框原理</h3><ul><li>对话框的分类<ul><li>模式对话框-当前对话框显示时，会禁止本进程其它窗口和用户交互操作。</li><li>无模式对话框-在对话框显示后，本进程其它窗口仍然可以和用户进行操作。</li></ul></li><li>对话框基本使用 <ol><li>对话框窗口处理函数</li><li>注册窗口函数(不使用)</li><li>创建对话框</li><li>对话框的关闭</li></ol></li></ul><hr><p><strong>谁注册窗口类，窗口处理函数就由谁来实现。</strong></p><hr><ul><li>对话框处理函数(并非真正的对话框处理函数，真正的系统内部。)</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DLGPROC Dlgproc;</span><br><span class="line"></span><br><span class="line"><span class="function">INT_PTR <span class="title">Dlgproc</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HWND unnamedParam1,<span class="comment">//窗口句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  UINT unnamedParam2,<span class="comment">//消息ID</span></span></span></span><br><span class="line"><span class="function"><span class="params">  WPARAM unnamedParam3,<span class="comment">//消息参数</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPARAM unnamedParam4<span class="comment">//消息参数</span></span></span></span><br><span class="line">)；</span><br></pre></td></tr></table></figure><p>返回TRUE——缺省处理函数不需要处理。</p><p>返回False——交给缺省处理函数处理。不需要调用缺省对话框处理函数。</p><h3 id="模式对话框"><a href="#模式对话框" class="headerlink" title="模式对话框"></a>模式对话框</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DialogBoxA</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional]  hInstance,<span class="comment">//当前程序实例句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in]            lpTemplate,<span class="comment">//对话框资源ID</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional]  hWndParent,<span class="comment">//对话框父窗口</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional]  lpDialogFunc<span class="comment">//自定义函数</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>DialogBox是一个阻塞函数，只有当对话框关闭后，才会返回，继续执行后续代码。</p><p>返回值是通过EndDialog设置。</p><ul><li>对话框的关闭</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">EndDialog</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] HWND    hDlg,<span class="comment">//关闭的对话框窗口</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] INT_PTR nResult<span class="comment">//关闭的返回值，能指定返回值就说明能接触阻塞</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>关闭模式对话框，只能使用EndDialog,不能使用DestoryWindow等函数。</p><p>nRsult是DiglogBox函数退出时的返回值。</p><ul><li>对话框的消息</li></ul><p>WM_INITDIALOG-对话框创建之后在显示之前，通知对话框窗口处理函数，可以完成自己的初始化相关的操作。</p><hr><p>EndDialog销毁对话框，并且解除阻塞。</p><p>而DestroyWindow只能销毁对话框，并不能解除阻塞。</p><hr><h3 id="无模式对话框"><a href="#无模式对话框" class="headerlink" title="无模式对话框"></a>无模式对话框</h3><ul><li>创建对话框</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HWND <span class="title">CreateDialog</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HINSTANCE hInstance,<span class="comment">//应用程序实例句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">        LPCTSTR lpName,<span class="comment">//模板资源ID</span></span></span></span><br><span class="line"><span class="function"><span class="params">        HWND hWndParent hWndParent,<span class="comment">//父窗口</span></span></span></span><br><span class="line"><span class="function"><span class="params">        DLGPROC lpDialogFunc<span class="comment">//自定义函数</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>非阻塞函数，创建成功后返回窗口句柄，需要使用ShowWindow函数显示对话框。</p><ul><li>对话框关闭</li></ul><p>关闭时使用DestroyWindow销毁窗口，不能使用EndDiaglog关闭对话框。</p><p><strong>代码示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HWND noModel = CreateDialog(g_Hinstance, (<span class="keyword">char</span>*)IDD_DIALOG1,hwnd, DlgProc);</span><br><span class="line">ShowWindow(noModel, SW_SHOW);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xxx</span><br><span class="line">DestroyWindow(hwnd);</span><br></pre></td></tr></table></figure><h2 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h2><p> Windows上静态库和Linux上的静态库在原理上没有任何区别，都是封装一堆东西等着别人去掉。</p><h3 id="静态库的特点"><a href="#静态库的特点" class="headerlink" title="静态库的特点"></a>静态库的特点</h3><ul><li>运行不存在。<ul><li>没有如何，不能执行，生成的文件无法形成静态影像，无法进内存。</li></ul></li><li>静态库源码被链接到调用程序中。</li><li>目标程序的归档。</li></ul><h3 id="C语言静态库"><a href="#C语言静态库" class="headerlink" title="C语言静态库"></a>C语言静态库</h3><ul><li>C静态库的创建<ul><li>创建一个静态库程序。</li><li>添加库程序，源文件使用C文件。</li></ul></li><li>C静态库的使用<ul><li>库路径设置:可以使用#pragma关键字设置<ul><li>#pragma comment(lib,”../lib/clib.lib”)</li></ul></li></ul></li></ul><h3 id="C-静态库"><a href="#C-静态库" class="headerlink" title="C++静态库"></a>C++静态库</h3><ul><li>C++静态库的创建<ul><li>创建一个静态库项目</li><li>添加库程序，源文件使用CPP文件。</li></ul></li><li>C++静态库的使用<ul><li>库路径设置:可以使用pragma关键字设置</li><li>#pragma comment(lib,”../xx/xxx.lib”)</li></ul></li></ul><p><strong>示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//给编译器看</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CLIB_add</span><span class="params">(<span class="keyword">int</span> add1, <span class="keyword">int</span> add2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CLIB_sub</span><span class="params">(<span class="keyword">int</span> add1, <span class="keyword">int</span> add2)</span></span>;</span><br><span class="line"><span class="comment">//给链接器看</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;../Debug/CPPLIB.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; CLIB_add(<span class="number">5</span>, <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; CLIB_sub(<span class="number">5</span>, <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>C++调库中函数需要在前面声明。告诉编译器到底换不换名。</strong></p><p><strong>C++编译器编译时会更改函数名。</strong></p><p><strong>解决</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span><span class="string">&quot;C&quot;</span> 函数声明；告诉编译器以C语言方式编译(不要给我改名)。</span><br></pre></td></tr></table></figure><h2 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h2><h3 id="动态库的特点"><a href="#动态库的特点" class="headerlink" title="动态库的特点"></a>动态库的特点</h3><ol><li>运行时独立存在(依附着其它程序运行起来的之后)</li><li>源码不会链接到执行程序</li><li>使用时加载(使用动态库必须使动态库执行)</li></ol><p><strong>与静态库进行比较</strong></p><ol><li>由于静态库是将代码嵌入到使用程序中，多个程序使用时，会有多分代码，所以代码体积会增大。动态库的代码只需要存一份，其他程序通过函数地址使用，所以代码体积较小。</li><li>静态库发生变化后，新的代码需要重新链接嵌入到执行程序中。动态库发生变化后，如果库中函数的定义(或地址)未变化(仅仅是函数的实现发生了变化)，其他使用DLL的程序不需要重新链接。</li></ol><h3 id="动态库的创建"><a href="#动态库的创建" class="headerlink" title="动态库的创建"></a>动态库的创建</h3><ul><li><p>创建动态库项目</p></li><li><p>添加库程序</p></li><li><p>库程序导出-提供给使用库者库中的函数等信息。</p><ol><li><p>声明导出:使用_declspec(dllexport)导出函数。将函数的地址存放在动态库的文件头中。(换名之后的函数)</p><p><strong>注意</strong>：动态库编译链接后，也会有LIB文件(与该DLL配套生成的)，是作为动态库函数映射使用，与静态库不完全相同。<strong>LIB中存放每个函数的名字和它对应的标号，还有与它配套的DLL文件名——xxx.dll</strong></p></li><li><p>模块定义文件.def</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">LIBRARY DLLFunc <span class="comment">//库</span></span><br><span class="line">EXPORTS<span class="comment">//库导出表</span></span><br><span class="line">DLL_Mul  <span class="comment">//导出的函数</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="动态库的使用"><a href="#动态库的使用" class="headerlink" title="动态库的使用"></a>动态库的使用</h3><ul><li>隐式链接(操作系统负责使动态库执行，系统偷偷的把动态库扔到内存中。)<ol><li>头文件和函数原型，在函数原型的声明前，增加_declspec(dllimport)</li><li>导入动态库的LIB文件</li><li>在程序中使用函数<ol><li>隐式的链接的情况，dll文件可以存放的路径(编译器可以找到的位置):</li><li>与执行文件中同一个目录下</li><li>当前工作目录</li><li>Windows目录,(三个window..不建议使用，因为是系统路径， 公共场所，容易出现问题。)</li><li>Windows/System32目录</li><li>Windows/System</li><li>环境变量PATH指定目录</li></ol></li></ol></li></ul><hr><ul><li>显式链接(程序员自己负责使动态库执行)</li></ul><p>1.定义函数指针类型 typedef</p><p>2.加载动态库</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HMODULE <span class="title">LoadLibrary</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCTSTR lpFileName<span class="comment">//动态库文件名或全路径  </span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;<span class="comment">//返回DLL的实例局句柄(HINSTANCE)</span></span><br></pre></td></tr></table></figure><p>3.获取函数(绝对/真实)地址</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FARPROC  <span class="title">GetProcAddress</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HMODULE hModule,<span class="comment">//DLL句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">         LPCSTR lpProcName<span class="comment">//函数名称</span></span></span></span><br><span class="line">)；//成功返回函数地址</span><br></pre></td></tr></table></figure><p>4.使用函数</p><p>5.卸载动态库(释放那块内存，结束动态库执行。)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">FreeLibrary</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HMODULE hModule<span class="comment">//DLL的实例句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>代码示例</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LIBRARY Dll3</span><br><span class="line">EXPORTS</span><br><span class="line">Print @1</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*PRINT)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HINSTANCE hDll = LoadLibrary(<span class="string">&quot;Dll3.dll&quot;</span>);</span><br><span class="line">PRINT MYPRINT = (PRINT)GetProcAddress(hDll, <span class="string">&quot;Print&quot;</span>);</span><br><span class="line">MYPRINT();</span><br><span class="line">FreeLibrary(hDll);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态库中封装类"><a href="#动态库中封装类" class="headerlink" title="动态库中封装类"></a>动态库中封装类</h3><p>类导出的其实也是函数地址。</p><ul><li>在类名称前增加_declspec(dllexport)定义，例如:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">declspec</span>(<span class="title">dllexport</span>)<span class="title">CMath</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通常使用预编译开关切换类的导入导出定义，例如:<br><img src="/images/win32(1).assets/image-20211106214536869.png" alt="image-20211106214536869"></li></ul><p><strong>代码示例</strong>：</p><p>(如果生成错误就改一下代码顺序)</p><p>动态库中封装类.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _DLLCLASS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _DLLCLASS_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DLLCLASS_EXPORTS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXT_CLASS _declspec(dllexport)<span class="comment">//导出</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXT_CLASS _declspec(dllimport)<span class="comment">//导入</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EXT_CLASS</span> <span class="title">Print</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PRINT</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p> 动态库中实现.cpp</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;CLASSDLL.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span><span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLLCLASS_EXPORTS</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print::PRINT</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;123&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用该动态库</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;../CLASSDLL/CLASSDLL.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;../Debug/CLASSDLL.lib&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Print p1;</span><br><span class="line">p1.PRINT();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h3><ul><li>Windows的线程是可以执行代码的实例。系统是以线程为单位调度程序。一个程序当中可以有多个线程，实现多任务的处理。</li><li>进程开启意味着分内存，线程开辟意味着程序的执行。</li><li>Windows线程的特点:<ol><li>线程都具有1个ID</li><li>每个线程都具有自己的内存栈</li><li>同一进程中的线程使用同一个地址空间</li></ol></li><li>线程的调度:</li></ul><p><strong>操作系统</strong>将CPU的执行时间划分成时间片，依次根据时间片执行不同的线程</p><p>线程轮询:线程A-&gt;线程B-&gt;线程A……</p><p><strong>在一个时间点上，CPU只能执行一个线程。</strong></p><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><ul><li>创建线程</li></ul><p>函数原型如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateThread</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional]  LPSECURITY_ATTRIBUTES   lpThreadAttributes,<span class="comment">//安全属性</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in]            SIZE_T                  dwStackSize,<span class="comment">//线程栈的大小</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in]            LPTHREAD_START_ROUTINE  lpStartAddress,<span class="comment">//线程处理函数的函数地址</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional]  __drv_aliasesMem LPVOID lpParameter,<span class="comment">//传递给线程处理函数的参数</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in]            DWORD                   dwCreationFlags,<span class="comment">//线程的创建方式</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [out, optional] LPDWORD                 lpThreadId<span class="comment">//创建成功，返回线程的ID</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;<span class="comment">//创建成功，返回线程句柄。</span></span><br></pre></td></tr></table></figure><p><strong>只要看到安全属性这个参数就通通置空，这个参数已经被废弃了。</strong></p><p><strong>线程栈大小，按照1MB对齐。</strong></p><p><strong>看到处理函数，就说明这个函数由我们程序员去定义，由系统调用。</strong></p><p><strong>线程的创建方式有两种，立即执行方式，挂起方式。</strong></p><p><strong>多线程，宏观上同时开始(并行)，真实是，一个时间点只能执行一个线程(串行)。</strong></p><ul><li>定义线程处理函数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">LPVOID lpParameter<span class="comment">//创建线程时，传递给线程的参数。</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>代码示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD CALLBACK <span class="title">TestProc</span><span class="params">(LPVOID pParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">char</span>*)pParam &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">Sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">DWORD CALLBACK <span class="title">TestProc1</span><span class="params">(LPVOID pParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">char</span>*)pParam &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">Sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DWORD nID = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* text = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">HANDLE hTread = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, TestProc, (<span class="keyword">void</span>*)text, <span class="number">0</span>, &amp;nID);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* text1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">HANDLE hTread1 = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, TestProc1, (<span class="keyword">void</span>*)text1, <span class="number">0</span>, &amp;nID);</span><br><span class="line"></span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程挂起-销毁"><a href="#线程挂起-销毁" class="headerlink" title="线程挂起/销毁"></a>线程挂起/销毁</h3><p><strong>挂起</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">SuspendTread</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HANDLE hThread <span class="comment">//线程句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>唤醒</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">ResumeTread</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HANDLE hThread<span class="comment">//线程句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>结束指定线程</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL Terminate <span class="title">Thread</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HANDLE hThread,<span class="comment">//线程句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">        DWORD dwExitCode<span class="comment">//退出码，没有实际意义</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>结束函数所在的线程</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">ExitThread</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">DWORD dwExitCode<span class="comment">//退出码</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="线程相关操作"><a href="#线程相关操作" class="headerlink" title="线程相关操作"></a>线程相关操作</h3><p><strong>获取当前线程ID</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GetCurrentThreadId();</span><br></pre></td></tr></table></figure><p><strong>获取当前线程的句柄</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GetCurrentThread();</span><br></pre></td></tr></table></figure><p><strong>等候(可等候)单个句柄有信号</strong>——线程句柄</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">WaitForSingleObject</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HANDLE handle，<span class="comment">//句柄BUFF的地址</span></span></span></span><br><span class="line"><span class="function"><span class="params">DOWRD dwMilliseconds<span class="comment">//等候时间INFINITE(无限大)</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>一个可等候的句柄，一定有有信号和无信号的两种状态。</p><p>等候的时间已经到了，该句柄还是无信号那就返回了。</p><p><strong>同时等候多个句柄有信号</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">WaitForMultipleObjects</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">DOWRD nCount,<span class="comment">//要等候的句柄数量</span></span></span></span><br><span class="line"><span class="function"><span class="params">    CONST HANDLE*lpHandle,<span class="comment">//句柄BUFF的地址</span></span></span></span><br><span class="line"><span class="function"><span class="params">    </span></span></span><br><span class="line"><span class="function"><span class="params">    BOOL bWaitAll,<span class="comment">//等候方式</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">//TRUE-所有事件都有信号才返回</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">//FALSE-有一个事件有信号就返回</span></span></span></span><br><span class="line"><span class="function"><span class="params">    </span></span></span><br><span class="line"><span class="function"><span class="params">    </span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD dwMilliseconds<span class="comment">//等候时间INFINITE</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>bWaitAll-等候方式</p><ul><li>TRUE-表示所有句柄都有信号，才结束等候。</li><li>FALSE-表示句柄中只要1个有信号，就结束等候。</li></ul><hr><p>线程句柄执行的时候无信号，结束的时候有信号。</p><hr><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><h3 id="原子锁"><a href="#原子锁" class="headerlink" title="原子锁"></a>原子锁</h3><ul><li>相关问题</li></ul><p>多个线程对同一个数据进行原子操作，会产生结果丢失。比如执行++运算时。</p><ul><li>错误代码分析</li></ul><p>当线程A执行g_value++时，如果线程切换时间正好是在线程A再次被切换回来之后，会将原来线程A保存的值保存到g_values上，线程B进行的加法操作被覆盖。(汇编角度)</p><blockquote><p>当CPU在执行某个线程的时候，一旦时间到了它要离开，它会将这个线程已经执行到的位置保护起来，一般是压栈保护。将位置信息压到本线程的栈中。再来，先弹栈读取，恢复战场。</p></blockquote><ul><li>图示</li></ul><p><img src="/images/win32(1).assets/image-20211107172354028.png" alt="image-20211107172354028"></p><p><strong>解释/错误分析</strong>:</p><blockquote><p>第一个线程刚要将+1后的值赋给g_value,cpu给它的时间就到了，这时切换到线程2，线程2执行完毕，g_value == 1，切换回线程1，先弹栈恢复，执行完毕得到g_value == 1,这就丢失了一次数据。</p></blockquote><p><strong>解决</strong>：使用原子锁函数，来++</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD CALLBACK <span class="title">TestProc1</span><span class="params">(LPVOID pParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//g_value++;</span></span><br><span class="line">InterlockedIncrement(&amp;g_value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD CALLBACK <span class="title">TestProc2</span><span class="params">(LPVOID pParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//g_value++;</span></span><br><span class="line">InterlockedIncrement(&amp;g_value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li> 使用原子锁函数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InterlockedIncrement</span><br><span class="line">......</span><br><span class="line">每一个操作符都有对应的一个原子锁函数</span><br></pre></td></tr></table></figure><p><strong>原子锁的实现</strong>：直接对数据所在的内存进行操作，并且在任何一个瞬间只能有一个线程访问这块内存。(++并不是直接对内存进行操作，而是对寄存器进行操作，然后再赋值给变量。)</p><p><strong>锁的是数据所在的这块内存，并不是CPU。</strong></p><p><strong>解释</strong>：</p><blockquote><p>先执行线程1，进来直接给g_value(内存)上锁，如果这时候CPU给的时间到了，那就压栈保护，然后转去执行线程2，线程2一看已经g_value已经被锁了，不会重复锁，发生阻塞，等到时间的耗尽，又转去执行线程1，弹栈恢复，完成执行完后，给g_value解锁，再去执行线程2，线程2就能给g_value上锁了……重复上述过程。</p><p>简单来说就是，上了锁之后可以保证一个线程对该变量，完成一次完整的操作后，另一个线程再进行一次完整的操作。</p></blockquote><p>使用原子锁之后执行效率变慢，因为这两个线程老是对着睡觉。</p><p>重要的是保证结果的正确性，如果保证不了正确性，宁可牺牲效率也要保证结果正确。</p><ul><li>局限性&amp;优点</li></ul><p>只能对运算符进行原子锁。而且有大量函数。但是在所有的枷锁机制中，它的效率最高。</p><hr><h3 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h3><ul><li>相关的问题</li></ul><p>多线程下代码或资源的共享使用</p><ul><li>互斥的使用</li></ul><p>一.创建互斥</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateMutex</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">LPSECURITY_ATTRIBUTES lpMutexAttributes,<span class="comment">//安全属性</span></span></span></span><br><span class="line"><span class="function"><span class="params">    BOOL bInitialOwner,<span class="comment">//初识的拥有者TRUE/FALSE</span></span></span></span><br><span class="line"><span class="function"><span class="params">    LPCTSTR lpName<span class="comment">//命名</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;<span class="comment">//创建成功返回互斥句柄</span></span><br></pre></td></tr></table></figure><p>互斥不光能对操作符进行枷锁，也能对其它东西进行枷锁，比如说锁定一段或一行代码。</p><p>原子锁能解决的问题，互斥都能解决，但是互斥能解决的问题，原子锁不一定能解决。</p><p> <strong>互斥句柄也是可等候句柄。</strong></p><p><strong>特点</strong>：</p><p>1.任何一个时间点上只能有一个线程拥有互斥。其它线程只能等待这个线程把互斥扔掉才能拥有。<strong>独占性和排他性、</strong></p><ol start="2"><li>  当任何一个线程都不拥有互斥，互斥句柄有信号。一旦某个线程有互斥，互斥句柄无信号。</li><li>谁先等待互斥，谁先得到互斥。</li></ol><p>二.等到互斥</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WaitForSingleObject/WaitForMultipleObjects...互斥的等候遵循谁先等候谁先获取</span><br></pre></td></tr></table></figure><p>三.释放互斥</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">ReleaseMutex</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HANDLE hMutex<span class="comment">//互斥句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>四.关闭互斥句柄</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CloseHandle</span><br></pre></td></tr></table></figure><p><strong>代码示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">HANDLE g_hMutex = <span class="number">0</span>;<span class="comment">//接收互斥句柄</span></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD CALLBACK <span class="title">TestProc</span><span class="params">(LPVOID pParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span>* text = (<span class="keyword">char</span>*)pParam;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">WaitForSingleObject(g_hMutex, INFINITE);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(text); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; text[i];</span><br><span class="line">Sleep(<span class="number">333</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">ReleaseMutex(g_hMutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">DWORD CALLBACK <span class="title">TestProc1</span><span class="params">(LPVOID pParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span>* text = (<span class="keyword">char</span>*)pParam;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">WaitForSingleObject(g_hMutex, INFINITE);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(text); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; text[i];</span><br><span class="line">Sleep(<span class="number">333</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">ReleaseMutex(g_hMutex);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建互斥的这个主线程也不拥有它，</span></span><br><span class="line">g_hMutex = CreateMutex(<span class="literal">NULL</span>,FALSE,<span class="literal">NULL</span>);</span><br><span class="line">DWORD nID = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* text = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">HANDLE hTread = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, TestProc, (<span class="keyword">void</span>*)text, <span class="number">0</span>, &amp;nID);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* text1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">HANDLE hTread1 = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, TestProc1, (<span class="keyword">void</span>*)text1, <span class="number">0</span>, &amp;nID);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">getchar();</span><br><span class="line">CloseHandle(g_hMutex);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>解释</strong>：互斥句柄在主函数中创建出来，设备FALSE，谁都不拥有，<strong>互斥句柄有信号</strong>，等待抢占，假设CPU先执行线程1， 拿到互斥句柄，<strong>互斥句柄变为无信号</strong>，执行打印，到时间后，压栈保存，转去执行线程2，此时WaitForSingObject就无法通过，阻塞，等待时间结束，又执行线程1，恢复现场，假设执行完毕，线程1丢掉互斥，<strong>互斥句再次变为有信号</strong>，线程2WaitForSingObject通过，拿到互斥……。      </p><hr><p>原子锁和互斥都是枷锁机制，实现的都是多个线程之间有排斥关系。 <strong>多个线程之间去竞争临界资源。</strong></p><hr><p>下面这两个同步技术，事件和信号量，实现的是线程之间的<strong>协调工作关系</strong>。</p><hr><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><ul><li>相关问题</li></ul><p>程序(线程)之间的通知的问题。</p><p>两个线程要协调工作，它们两个就得通信。</p><ul><li>事件的使用</li></ul><p>1.创建事件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateEvent</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">LPSECURITY_ATTRIBUTES lpEventAttributes,<span class="comment">//安全属性</span></span></span></span><br><span class="line"><span class="function"><span class="params">    BOOL bManualReset,<span class="comment">//事件重置(复位(将事件变为无信号))方式，TRUE手动，FALSE自动</span></span></span></span><br><span class="line"><span class="function"><span class="params">    BOOL bInitialState,<span class="comment">//事件初识状态，TRUE有信号</span></span></span></span><br><span class="line"><span class="function"><span class="params">    LPCTSTR lpName<span class="comment">//事件命名</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;<span class="comment">//创建成功返回事件句柄</span></span><br></pre></td></tr></table></figure><p>2.等候事件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WaitForSingleObject/WaitForMultipleObjects</span><br></pre></td></tr></table></figure><p>3.触发事件(将事件设置成有信号状态)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">SetEvent</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HANDLE hEvent <span class="comment">//事件句柄 </span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br></pre></td></tr></table></figure><p>4.复位事件(将事件设置成无信号状态)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">ResetEvent</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HANDLE hEvent<span class="comment">//事件句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>5.关闭事件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CloseHandle</span><br></pre></td></tr></table></figure><p> <strong>代码示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">HANDLE g_hEvent = <span class="number">0</span>;<span class="comment">//接收事件句柄</span></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD CALLBACK <span class="title">PrintProc</span><span class="params">(LPVOID pParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">WaitForSingleObject(g_hEvent,INFINITE);</span><br><span class="line"><span class="comment">//ResetEvent(g_hEvent);//将事件设置成无信号</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;*************&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过事件进行通信</span></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD CALLBACK <span class="title">CtrlProc</span><span class="params">(LPVOID pParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">Sleep(<span class="number">1000</span>);</span><br><span class="line">SetEvent(g_hEvent);<span class="comment">//解救线程1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//FALSE为自动复位，当经过WaitForSingleObject函数之后</span></span><br><span class="line"><span class="comment">//TRUE为手动复位，手动在WaitForSingleObject后ResetEvent</span></span><br><span class="line">g_hEvent = CreateEvent(<span class="literal">NULL</span>,FALSE,FALSE,<span class="literal">NULL</span>);</span><br><span class="line">DWORD nID = <span class="number">0</span>;</span><br><span class="line">HANDLE hThread[<span class="number">2</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">hThread[<span class="number">0</span>] = CreateThread(<span class="literal">NULL</span>,<span class="number">0</span>,PrintProc,<span class="literal">NULL</span>,<span class="number">0</span>,&amp;nID);</span><br><span class="line">hThread[<span class="number">1</span>] = CreateThread(<span class="literal">NULL</span>,<span class="number">0</span>,CtrlProc,<span class="literal">NULL</span>,<span class="number">0</span>,&amp;nID);</span><br><span class="line">WaitForMultipleObjects(<span class="number">2</span>,hThread,TRUE,INFINITE);</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>注意</strong>：<strong>小心事件死锁。</strong></p><p><img src="/images/win32(1).assets/image-20211107213811934.png" alt="image-20211107213811934"></p><hr><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><ul><li>相关的问题</li></ul><p>类似于事件(不是原理类似时间，是作用类似事件)，解决通知的相关问题。但提供一个<strong>计数器</strong>，<strong>可以设置次数</strong>。</p><ul><li>信号量的使用</li></ul><p>1.创建 信号量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateSemaphoreW</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional] LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,<span class="comment">//安全属性</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in]   LONG    lInitialCount,<span class="comment">//初始化信号量数量(初识计数值)</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in]   LONG    lMaximumCount,<span class="comment">//信号量(计数器)的最大值</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional] LPCWSTR   lpName<span class="comment">//命名</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;<span class="comment">//创建成功返回信号量句柄</span></span><br></pre></td></tr></table></figure><p><strong>信号量的计数器不为0时，信号量句柄有信号。</strong><br>2.等候信号量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WaitForSingleObject/WaitForMultipleObjects</span><br></pre></td></tr></table></figure><p>每等候一次，信号量减1，直到为0阻塞。</p><p>3.给信号量指定计数值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">ReleaseSemaphore</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]            HANDLE hSemaphore,<span class="comment">//信号量句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in]            LONG   lReleaseCount,<span class="comment">//释放数量</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [out, optional] LPLONG lpPreviousCount<span class="comment">//释放前原来信号量的数量，可以为NULL</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>4.关闭句柄</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CloseHandle  </span><br></pre></td></tr></table></figure><p><strong>代码示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">HANDLE h_handle = <span class="number">0</span>;<span class="comment">//信号量句柄</span></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD CALLBACK <span class="title">TestProc</span><span class="params">(LPVOID pParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">WaitForSingleObject(h_handle, INFINITE);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;******&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">h_handle = CreateSemaphore(<span class="literal">NULL</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="literal">NULL</span>);</span><br><span class="line">DWORD nID = <span class="number">0</span>;</span><br><span class="line">HANDLE hThread = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, TestProc, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;nID);</span><br><span class="line"></span><br><span class="line">getchar();<span class="comment">//回车之后信号量数量改为5</span></span><br><span class="line">ReleaseSemaphore(h_handle, <span class="number">5</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">WaitForSingleObject(hThread, INFINITE);</span><br><span class="line">CloseHandle(h_handle);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;相关视频——&lt;a href=&quot;https://www.bilibili.com/video/BV1NA411K7aN?p=1&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;Windows编程&quot;&gt;&lt;a href=&quot;#Windows编程&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="Win32" scheme="https://doraemon-hub-art.github.io/categories/Win32/"/>
    
    
    <category term="-Win32 - -C" scheme="https://doraemon-hub-art.github.io/tags/Win32-C/"/>
    
  </entry>
  
  <entry>
    <title>【算法】查找算法</title>
    <link href="https://doraemon-hub-art.github.io/2021/10/29/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    <id>https://doraemon-hub-art.github.io/2021/10/29/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</id>
    <published>2021-10-29T06:35:47.000Z</published>
    <updated>2021-11-02T10:48:34.048Z</updated>
    
    <content type="html"><![CDATA[<h1 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h1><h2 id="查找的定义"><a href="#查找的定义" class="headerlink" title="查找的定义"></a>查找的定义</h2><blockquote><p>查找:又称检索或查询，是指在查找表中找出满足一定条件的结点或记录对应的操作。</p></blockquote><blockquote><p>查找表:在计算机中，是指被查找的数据对象是由同一个类型的记录构成的集合，如顺序表、链表、二叉树和哈希表等。</p></blockquote><blockquote><p>查找效率:查找算法中的基本运算是通过记录的关键字与给定值进行比较，所以查找的效率通常取决于比较所花的时间，而时间取决于比较的次数。通常以关键字与给定值进行比较的记录个数的平均值来计算。</p></blockquote><p><strong>查找操作及分类</strong></p><p><strong>操作</strong>：</p><ol><li>查找某个“特定的”数据元素是否成存在在查找表里。</li><li>某个“特定的”数据元素的各种属性。</li><li>在查找表中插入一个数据元素。</li><li>从查找表中删除某个数据元素。</li></ol><p><strong>分类</strong>:</p><blockquote><p>若对查找表只进行(1)或(2)两种操作，则称此类查找表为静态查找表。</p><p>若在查找的过程中同时插入查找表中存在的数据元素，或者从查找表中删除已经存在的某个数据元素，则称次类查找表为动态查找表。</p></blockquote><h2 id="数组和索引"><a href="#数组和索引" class="headerlink" title="数组和索引"></a>数组和索引</h2><blockquote><p>索引把线性表分为若干块，每一块中的元素存储顺序是任意的，但是块与块之间必须按关键字大小顺序排列。即前一块中的最大关键字值小于后一块中的最小关键字值。</p></blockquote><blockquote><p>分块以后，为了快速定义块，还需要建立一个索引表，索引表中的一项对应于线性表中的块，索引项由键域和链域组成。键域存放相应关键字的键值，链域存放指向本块第一个节点和最后一个节点的指针，索引表按关键字由小到大的顺序排列！</p></blockquote><p><strong>数组是特殊的块索引（一个块一个元素）</strong>：</p><p><img src="%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95.assets/image-20211028180054162.png" alt="image-20211028180054162"></p><p><strong>哈希表是非常经典的块索引!</strong><br><img src="%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95.assets/image-20211028180620292.png" alt="image-20211028180620292"></p><blockquote><p>分块查找的算法分两步进行，首先确定所查找的节点属于哪一块，即在索引表中查找其所在的块，然后在块内查找待查询的数据。由于索引表是递增有序的，可采用二分查找，而块内元素是无序的，只能采用顺序查找。（块内元素较少，则不会对执行速度有太大的影响）</p></blockquote><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><blockquote><p>二分查找法实质上是不断地将有序数据集进行对半分割，并检查每个分区的中间元素。再重 复根据中间数确定目标范围并递归实行对半分割，直到中间数等于待查找的值或是目标数不在搜 索范围之内！</p></blockquote><p><strong>代码实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(<span class="keyword">int</span>* sorted, <span class="keyword">int</span> len, <span class="keyword">int</span> search)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> middle = <span class="number">0</span>;</span><br><span class="line">left = <span class="number">0</span>;</span><br><span class="line">right = len - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">&#123;</span><br><span class="line">middle = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (sorted[middle] == search)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> middle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sorted[middle] &gt; search)</span><br><span class="line">&#123;</span><br><span class="line">right = middle - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">left = middle + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">16</span>,<span class="number">58</span>,<span class="number">74</span>,<span class="number">169</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> search = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> index = BinarySearch(arr, <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]),search);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; index;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果要实现其他类型的比较查找</strong></p><p>注意用void*类型接收不同类型，根据传进来类型的不同调用对应的比较函数。</p><p><strong>代码实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">int_compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* key1, <span class="keyword">const</span> <span class="keyword">void</span>* key2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* ch1 = (<span class="keyword">const</span> <span class="keyword">int</span>*)key1;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* ch2 = (<span class="keyword">const</span> <span class="keyword">int</span>*)key2;</span><br><span class="line"><span class="keyword">return</span> *ch1 - *ch2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">char_compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* key1, <span class="keyword">const</span> <span class="keyword">void</span>* key2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* ch1 = (<span class="keyword">const</span> <span class="keyword">char</span>*)key1;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* ch2 = (<span class="keyword">const</span> <span class="keyword">char</span>*)key2;</span><br><span class="line"><span class="keyword">return</span> *ch1 - *ch2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(<span class="keyword">void</span>* sorted, <span class="keyword">int</span> len,<span class="keyword">int</span> elemSize,<span class="keyword">void</span> *search, <span class="keyword">int</span>(*compare)(<span class="keyword">const</span> <span class="keyword">void</span>* key1, <span class="keyword">const</span> <span class="keyword">void</span>* key2))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> middle = <span class="number">0</span>;</span><br><span class="line">left = <span class="number">0</span>;  </span><br><span class="line">right = len - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">middle = (left + right) / <span class="number">2</span>;</span><br><span class="line">ret = compare( (<span class="keyword">char</span>*)sorted+(middle * elemSize),search);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> middle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">right = middle - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">left = middle + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">16</span>,<span class="number">58</span>,<span class="number">74</span>,<span class="number">169</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> search = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> index = BinarySearch(arr, <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]),<span class="keyword">sizeof</span>(<span class="keyword">int</span>),&amp;search,int_compare);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; index;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>补充</strong>:<strong>上面代码中为什么要转成char类型指针</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret = compare( (<span class="keyword">char</span>*)sorted+(middle * elemSize),search);</span><br></pre></td></tr></table></figure><p>什么类型的指针，增加偏移量的大小的是不同的。</p><p><strong>例如</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>*指针 +<span class="number">1</span>，内存偏移<span class="number">1</span>字节</span><br><span class="line"><span class="keyword">int</span>* 指针 +<span class="number">1</span>，内存偏移<span class="number">4</span>字节</span><br></pre></td></tr></table></figure><p>因为我们的运算加的是对应数组元素类型的大小*middle,求出偏移的字节个数，所以转成char类型指针，可以保证我们加了几个这个类型的大小等同于与数组第一个元素相距了几个元素，得到对应的地址。</p><p><strong>指针的运算！！！</strong></p><p>如下图所示，+1和+4，指向的是同一个地址。</p><p><img src="%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95.assets/image-20211028203724495.png" alt="image-20211028203724495"></p><hr><h2 id="穷举搜索"><a href="#穷举搜索" class="headerlink" title="穷举搜索"></a>穷举搜索</h2><blockquote><p>有 20 枚硬币，可能包括 4 种类型：1 元、5 角、1 角和 5 分。 </p><p>已知 20 枚硬币的总价值为 10 元，求各种硬币的数量。 </p><p>例如：4、11、5、0 就是一种方案。而 8、2、10、 0 是另一个可能的方案，显然方案并不是 </p><p>唯一的，请编写程序求出类似这样的不同的方案一共有多少种？ </p><p>（1）编程思路。 </p><p>直接对四种类型的硬币的个数进行穷举。其中，1 元最多 10 枚、5 角最多 20 枚、1 角最多 20 枚、5 分最多 20 枚。 </p><p>如果以元为单位，则 5 角、1 角、5 分会化成浮点型数据，容易计算出错。可以将 1 元、5 角、1 角、5 分变成 100 分、50 分、10 分和 5 分，从而全部采用整型数据处理。</p></blockquote><p><strong>代码实现</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a100 = <span class="number">0</span>;<span class="comment">//一元硬币的数量</span></span><br><span class="line"><span class="keyword">int</span> a50 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> a10 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> a5 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//可行方案总数</span></span><br><span class="line">    <span class="comment">//for循环可以进行优化，根据上一个纸币面额所花费钱的多少</span></span><br><span class="line"><span class="keyword">for</span> (a100 = <span class="number">0</span>; a100 &lt;= <span class="number">10</span>; a100++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (a50 = <span class="number">0</span>; a50 &lt;= <span class="number">20</span>; a50++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (a10 = <span class="number">0</span>; a10 &lt;= <span class="number">20</span>; a10++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (a5 = <span class="number">0</span>; a5 &lt;= <span class="number">20</span>; a5++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a100 * <span class="number">100</span> + a50 * <span class="number">50</span> + a10 * <span class="number">10</span> + a5 * <span class="number">5</span> == <span class="number">1000</span> &amp;&amp; (a100 + a50 + a10 + a5 == <span class="number">20</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a100:&quot;</span> &lt;&lt; a100 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="string">&quot;a50:&quot;</span> &lt;&lt; a50 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="string">&quot;a10:&quot;</span> &lt;&lt; a10 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="string">&quot;a5:&quot;</span> &lt;&lt; a5 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;一共有&quot;</span> &lt;&lt; count &lt;&lt; <span class="string">&quot;种可行方案&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>穷举法(枚举法)的基本思想是</strong>:列出所有的可能情况，逐个判断有哪些是符合问题所要求 的条件，从而得到问题的全部解答。</p><p>它利用计算机运算速度快、精确度高的特点，对要解决问题的所有可能情况，一个不漏地进行检查，从中找出符合要求的答案。</p><p><strong>用穷举法解决问题,通常可以从两个方面进行分析:</strong></p><blockquote><p>（1）问题所涉及的情况：问题所涉及的情况有哪些，情况的种数必须可以确定。把它描述出来。应用穷举时对问题所涉及的有限种情形必须一一列举，既不能重复，也不能遗漏。重复列 举直接引发增解，影响解的准确性；而列举的遗漏可能导致问题解的遗漏。 </p><p>（2）答案需要满足的条件：分析出来的这些情况，需要满足什么条件，才成为问题的答案。把这些条件描述出来。 </p></blockquote><h2 id="并行搜索"><a href="#并行搜索" class="headerlink" title="并行搜索"></a>并行搜索</h2><p><strong>并发的基本概念</strong>：<br>所谓并发就是在同一实体上的多个事件同时发生。并发编程是指在同一台计算机上”同时”处理多个任务。</p><p><strong>进程</strong>：</p><p>通常每个进程对应一个在运行中的执行程序，比如，QQ 和微信运行的时候，他们分别是不同的进程。</p><p>任一时刻，单个 CPU 一次只能运行一个进程，此时其他进程处于非运行状态。</p><p><strong>线程</strong>：</p><p>一个进程可以拥有多个线程，每个线程可以可以独立并行执行，多个线程共享同一进程的资源，受进程管理。</p><blockquote><p>要从一个无序数据集中进行搜索，我们可以将数据分成N个块，每块由一个线程来并行搜索。</p></blockquote><p><strong>代码实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST_SIZE (1024*1024*200)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUMBER 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">search</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span>* data;<span class="comment">//搜索的数据集</span></span><br><span class="line"><span class="keyword">size_t</span> start;<span class="comment">//搜索的开始位置</span></span><br><span class="line"><span class="keyword">size_t</span> end;<span class="comment">//搜索的结束位置</span></span><br><span class="line"><span class="keyword">size_t</span> count;<span class="comment">//搜索结果</span></span><br><span class="line">&#125;search;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(<span class="keyword">void</span>* lpParm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">search* s = (search*)lpParm;</span><br><span class="line"><span class="keyword">time_t</span> start, end;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;新的线程开始执行...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">time(&amp;start);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;<span class="number">10</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = s-&gt;start; i &lt;= s-&gt;end; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (s-&gt;data[i] == NUMBER)</span><br><span class="line">&#123;</span><br><span class="line">s-&gt;count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">time(&amp;end);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;进程所用时间:&quot;</span> &lt;&lt; end - start &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>* data = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">search s1, s2;</span><br><span class="line">data = <span class="keyword">new</span> <span class="keyword">int</span>[TEST_SIZE];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;TEST_SIZE; i++)</span><br><span class="line">&#123;</span><br><span class="line">data[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">mid = TEST_SIZE / <span class="number">2</span>;</span><br><span class="line">s1.data = data;</span><br><span class="line">s1.start = <span class="number">0</span>;</span><br><span class="line">s1.end = mid;</span><br><span class="line">s1.count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">s2.data = data;</span><br><span class="line">s2.start = mid + <span class="number">1</span>;</span><br><span class="line">s2.end = TEST_SIZE - <span class="number">1</span>;</span><br><span class="line">s2.count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DWORD threadID1;<span class="comment">//线程1的身份证</span></span><br><span class="line">HANDLE hthread1;<span class="comment">//线程1的句柄</span></span><br><span class="line">DWORD threadID2;<span class="comment">//线程2的身份证</span></span><br><span class="line">HANDLE hthread2;<span class="comment">//线程2的句柄</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建线程</span></span><br><span class="line">hthread1 = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc, &amp;s1, <span class="number">0</span>, &amp;threadID1);</span><br><span class="line">hthread2 = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc, &amp;s2, <span class="number">0</span>, &amp;threadID2);</span><br><span class="line"></span><br><span class="line">WaitForSingleObject(hthread1, INFINITE);</span><br><span class="line">WaitForSingleObject(hthread2, INFINITE);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1.count + s2.count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;查找算法&quot;&gt;&lt;a href=&quot;#查找算法&quot; class=&quot;headerlink&quot; title=&quot;查找算法&quot;&gt;&lt;/a&gt;查找算法&lt;/h1&gt;&lt;h2 id=&quot;查找的定义&quot;&gt;&lt;a href=&quot;#查找的定义&quot; class=&quot;headerlink&quot; title=&quot;查找的定义&quot;&gt;</summary>
      
    
    
    
    <category term="算法" scheme="https://doraemon-hub-art.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="-算法" scheme="https://doraemon-hub-art.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>不同指针的偏移量不同</title>
    <link href="https://doraemon-hub-art.github.io/2021/10/28/%E4%B8%8D%E5%90%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%81%8F%E7%A7%BB%E9%87%8F%E4%B8%8D%E5%90%8C/"/>
    <id>https://doraemon-hub-art.github.io/2021/10/28/%E4%B8%8D%E5%90%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%81%8F%E7%A7%BB%E9%87%8F%E4%B8%8D%E5%90%8C/</id>
    <published>2021-10-28T12:52:24.000Z</published>
    <updated>2021-10-28T12:54:23.166Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/4320f6444cac46528f82b567c60adc79.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARG8yZU0wTg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><strong>这里的偏移量我指的是对应指针+几，地址所偏移的长度。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/4320f6444cac46528f82b567c60adc79.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,sha</summary>
      
    
    
    
    <category term="C++" scheme="https://doraemon-hub-art.github.io/categories/C/"/>
    
    
    <category term="-指针" scheme="https://doraemon-hub-art.github.io/tags/%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
</feed>
