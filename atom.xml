<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>半生瓜のblog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-06-16T05:21:37.332Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Do2eM0N</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【树】之二叉树(C语言)</title>
    <link href="http://example.com/2021/06/16/%E3%80%90%E6%A0%91%E3%80%91%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91(C%E8%AF%AD%E8%A8%80)/"/>
    <id>http://example.com/2021/06/16/%E3%80%90%E6%A0%91%E3%80%91%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91(C%E8%AF%AD%E8%A8%80)/</id>
    <published>2021-06-16T04:57:39.000Z</published>
    <updated>2021-06-16T05:21:37.332Z</updated>
    
    <content type="html"><![CDATA[<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="树的概念及结构"><a href="#树的概念及结构" class="headerlink" title="树的概念及结构"></a>树的概念及结构</h2><h2 id="树的概念"><a href="#树的概念" class="headerlink" title="树的概念"></a>树的概念</h2><p>树是一种<strong>非线性</strong>的数据结构，它是由n(n &gt;= 0)个有限结点组成的一个具有层次关系的集合，<strong>把它叫做树是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的</strong>。</p><ul><li>有一个特殊的结点，称为根结点，根节点没有前驱结点。</li><li>除跟根结点外，其余结点被分成M（M&gt;0）个互不相交的集合T1、T2……Tm,其中每一个集合Ti(1&lt;=i&lt;=m)又是一棵结构与树类似的子树。每颗子树的根节点有且只有一个前驱，可以有0个或多个后继。</li><li>因此，树是递归定义的。</li></ul><hr><p>结点的度：到底有多少个链接的子节点</p><p>叶子结点或终端结点：度为0的结点称为叶子结点，</p><p><img src="/images/%E6%A0%91%E5%9E%8B%E7%BB%93%E6%9E%84.assets/image-20210612113428728.png" alt="image-20210612113428728"></p><ul><li>节点的度:一个节点含有的子树的个数称为该节点的度;如上图:A的为6</li><li>叶节点或终端节点:度为0的节点称为叶节点;如上图:B、C、H、I..等节点为叶节点非终端节点或分支节点:度不为0的节点;如上图:D、E、F、G…等节点为分支节点</li><li>兄弟节点:具有相同父节点的节点互称为兄弟节点;如上图:B、C是兄弟节点</li><li>树的度:一棵树中，最大的节点的度称为树的度;如上图:树的度为6</li><li>节点的层次:从根开始定义起，根为第1层，根的子节点为第2层，以此类推;</li><li>树的高度或深度:树中节点的最大层次;如上图:树的高度为4（有两种说法-从0开始还是从1开始，空树-1，空树0）</li><li>节点的祖先:从根到该节点所经分支上的所有节点;如上图:A是所有节点的祖先</li><li>子孙:以某节点为根的子树中任一节点都称为该节点的子孙。如上图:所有节点都是A的子孙</li><li>森林:由m (m&gt;0)棵互不相交的多颗树的集合称为森林;(数据结构中的学习并查集本质就是一个森林)——(日常很少碰到森林，并查集就是一个森林)</li></ul><h2 id="树的要求"><a href="#树的要求" class="headerlink" title="树的要求"></a>树的要求</h2><ul><li>子树是不相交的</li><li>除了根结点之外，每个结点有且仅有一个父结点</li><li>一个N个结点的树有N-1条边</li></ul><h2 id="树的表示"><a href="#树的表示" class="headerlink" title="树的表示"></a>树的表示</h2><p>相对于线性表，树的结构就复杂很多了。最常用的表示方法——孩子兄弟表示法。</p><h2 id="现实应用"><a href="#现实应用" class="headerlink" title="现实应用"></a>现实应用</h2><p>文件系统的目录树，</p><p>树在实际当中，不太作为存储数据这个角度去用，因为意义不是很大。</p><p>主要用的是二叉树</p><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>现实中的二叉树</p><p>这还是个满二叉树</p><p><img src="/images/%E3%80%90%E6%A0%91%E3%80%91%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91(C%E8%AF%AD%E8%A8%80).assets/src=http___pic2.zhimg.com_v2-48ad88b651e76da3f8958831ba1cd80b_1200x500.jpg&refer=http___pic2.zhimg.jpg"></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>与普通的树最大的不同是它最多只有两个子树。</p><h2 id="特殊的二叉树"><a href="#特殊的二叉树" class="headerlink" title="特殊的二叉树"></a>特殊的二叉树</h2><ol><li><p>满二叉树：每一层都是满的。</p><p>假设一棵满二叉树的高度是 h,那么它的总结点个数是：2^0+2^1+2^2+……2^(h-1) =N。</p><p>推导公式:2^h-1 = N;h = log2N+1以2位底N的对数+1。</p><p><img src="/images/%E6%A0%91%E5%9E%8B%E7%BB%93%E6%9E%84.assets/image-20210614201257487.png" alt="image-20210614201257487"></p></li><li><p>完全二叉树</p><p>完全二叉树是个效率很高的数据结构，完全二叉树是由满二叉树引出来的。</p><p>假设树的高度是h,前h-1层是满的，最后一层不满，但是最后一层从左往右都是连续的。</p><p>最后一层最少有一个结点。</p><p>结点个数为:2^h-1-X= N,高度近似为:h = log2N+1+X以二为底N的对数+1</p><p> <img src="/images/%E6%A0%91%E5%9E%8B%E7%BB%93%E6%9E%84.assets/image-20210614202340668.png" alt="image-20210614202340668"></p></li></ol><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>在实际中普通二叉树的增删查改没得意义。</p><p><strong>有意义的是搜索二叉树</strong>。</p><p><strong>搜索二叉树</strong>:任何一棵树，左子树都比跟要小，右子树都比根要大。在搜索树中查找一个数，最多查找高度次。时间复杂度O(N)。</p><p>引申：左右两边的结点数量比较均匀。</p><p>接着引出 ——<strong>平衡树</strong></p><ul><li>AVL树</li><li>红黑树</li></ul><p>学习普通二叉树可以为后面学习复杂的有用的平衡树做铺垫。</p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>1.若规定根结点的层数为1，则一棵非空二叉树的第i层上最多有2^(i-1)个结点</p><p>2.若规定根节点的层数是1，则深度为h的二叉树的最大节点数是2^-1</p><p>3.对于任何一棵二叉树，如果度为0其叶结点个数为n0,度为2的分支结点个数为n2,则有n0 = n2 +1（度为2的结点个数总是比度为0的结点个数多1）</p><p>4.若规定根节点的层数是1，具有n个结点的满二叉树的深度是h = log2 N +1（以2为底N的对数+1）</p><h2 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h2><p>顺序结构存储就是使用数组来存储，一般使用数组只适合表示完全二叉树，因为不是完全二叉树会有空间的浪费。而现实中使用中只有堆才会使用数组来存储。二叉树顺序存储在物理上是一个数组，在逻辑上是一颗二叉树。</p><h2 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h2><p>二叉树的链式存储结构是指，用链表来表示一棵二叉树，即用链来指示元素的逻辑关系。通常的方法是链表中每个结点由三个域组成，数据域和左右指针域，左右指针分别用来给出该结点左孩子和右孩子所在的链结点的存储地址。链式结构又分为二叉链和三叉链，当前我们学习中一般都是二叉链，后面到高阶数据结构如红黑树等会用到三叉链。</p><h2 id="构成-amp-遍历"><a href="#构成-amp-遍历" class="headerlink" title="构成&amp;遍历"></a>构成&amp;遍历</h2><p><img src="/images/%E6%A0%91%E5%9E%8B%E7%BB%93%E6%9E%84.assets/image-20210613173854712.png" alt="image-20210613173854712"></p><p>任何一个二叉树由三个部分构成</p><p>1.根节点——2.左子树——3.右子树</p><p> 分治算法：分而治之，大问题分成子问题，子问题再分成子问题，直到无法分割</p><p>前序遍历：根左右——(上图：A-B-D-NULL-NULL-E-NULL-NULL-C-NULL-NULL)</p><p>中序遍历：左根右——(NULL-D-NULL-B-NULL-E-NULL-A-NULL-C-NULL)</p><p>后序遍历：左右根——(NULL-NULL-D-NULL-NULL-E-B-NULL-NULL-C-A) </p><h2 id="结构定义"><a href="#结构定义" class="headerlink" title="结构定义"></a>结构定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> BinaryTreeType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span>* <span class="title">left</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span>* <span class="title">right</span>;</span></span><br><span class="line">BinaryTreeType data;</span><br><span class="line">&#125;BTNode;</span><br></pre></td></tr></table></figure><h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrevOrder</span><span class="params">(BTNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//如果树是空树就直接return</span></span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NULL &quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, root-&gt;data);</span><br><span class="line">PrevOrder(root-&gt;left);</span><br><span class="line">PrevOrder(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(BTNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NULL &quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">InOrder(root-&gt;left);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,root-&gt;data);</span><br><span class="line">InOrder(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(BTNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NULL &quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">PostOrder(root-&gt;left);</span><br><span class="line">PostOrder(root-&gt;right);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, root-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构建一个简单的树"><a href="#构建一个简单的树" class="headerlink" title="构建一个简单的树"></a>构建一个简单的树</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构建一个简单的树</span></span><br><span class="line">BTNode* A = (BTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));</span><br><span class="line">A-&gt;data = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">A-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">A-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">BTNode* B = (BTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));</span><br><span class="line">B-&gt;data = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">B-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">B-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">BTNode* C = (BTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));</span><br><span class="line">C-&gt;data = <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">C-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">C-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">BTNode* D = (BTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));</span><br><span class="line">D-&gt;data = <span class="string">&#x27;D&#x27;</span>;</span><br><span class="line">D-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">D-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">BTNode* E = (BTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));</span><br><span class="line">E-&gt;data = <span class="string">&#x27;E&#x27;</span>;</span><br><span class="line">E-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">E-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">BTNode* F = (BTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));</span><br><span class="line">F-&gt;data = <span class="string">&#x27;F&#x27;</span>;</span><br><span class="line">F-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">F-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">A-&gt;left = B;</span><br><span class="line">A-&gt;right = C;</span><br><span class="line">B-&gt;left = D;</span><br><span class="line">B-&gt;right = E;</span><br><span class="line"> </span><br><span class="line">PrevOrder(A);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/%E6%A0%91%E5%9E%8B%E7%BB%93%E6%9E%84.assets/image-20210613202834074.png" alt="image-20210613202834074"></p><h2 id="函数递归图——前序遍历"><a href="#函数递归图——前序遍历" class="headerlink" title="函数递归图——前序遍历"></a>函数递归图——前序遍历</h2><p><img src="/images/%E6%A0%91%E5%9E%8B%E7%BB%93%E6%9E%84.assets/%E6%97%A0%E6%A0%87%E9%A2%98-1623589214513.png"></p><h2 id="结点个数"><a href="#结点个数" class="headerlink" title="结点个数"></a>结点个数</h2><p><strong>方法一</strong>：因为我们要对同一个size进行++,所以要设置一个全局变量size进行++就完事了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TreeSize</span><span class="params">(BTNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">size++;</span><br><span class="line">&#125;</span><br><span class="line">TreeSize(root-&gt;left);</span><br><span class="line">TreeSize(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是在进行多次调用的时候因为累加，调用前要先将他置成0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TreeSize(A);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;结点个数%d&quot;</span>,size);</span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line">TreeSize(B);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;结点个数%d&quot;</span>, size);</span><br></pre></td></tr></table></figure><p>但是这种方法不是线程安全的。引出我们的第二种方法。</p><p><strong>方法二</strong>：传参</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TreeSize</span><span class="params">(BTNode* root,<span class="keyword">int</span>* psize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">(*psize)++;</span><br><span class="line">&#125;</span><br><span class="line">TreeSize(root-&gt;left, psize);</span><br><span class="line">TreeSize(root-&gt;right, psize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Asize = <span class="number">0</span>;</span><br><span class="line">TreeSize(A,&amp;Asize);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;结点个数%d&quot;</span>,Asize);</span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> Bsize = <span class="number">0</span>;</span><br><span class="line">TreeSize(B, &amp;Bsize);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;结点个数%d&quot;</span>, Bsize);</span><br></pre></td></tr></table></figure><p><strong>方法三</strong></p><p><strong>分治</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TreeSize</span><span class="params">(BTNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> root == <span class="literal">NULL</span> ? <span class="number">0</span>:TreeSize(root-&gt;left) + TreeSize(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, TreeSize(A));</span><br></pre></td></tr></table></figure><p><strong>图解</strong></p><p><img src="/images/%E6%A0%91%E5%9E%8B%E7%BB%93%E6%9E%84.assets/image-20210615194041323.png" alt="image-20210615194041323"></p><h2 id="叶子结点的个数"><a href="#叶子结点的个数" class="headerlink" title="叶子结点的个数"></a>叶子结点的个数</h2><p>  叶子结点没有子结点，叶子结点就是度为0的结点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TreeLeafSize</span><span class="params">(BTNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> TreeLeafSize(root-&gt;left) + TreeLeafSize(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程：判断是否为空，为空返回0，不为空看左右孩子是否都为空，为空返回1，如果上面两个条件都不满足，分别计算左右孩子…孩子的孩子…递归返回相应的根结点。</p><p><img src="/images/%E6%A0%91%E5%9E%8B%E7%BB%93%E6%9E%84.assets/image-20210616113316365.png" alt="image-20210616113316365"></p><h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><p>前序中序后序遍历其实也叫深度优先遍历。</p><p>层序遍历本质上也叫做广度优先遍历，以根为主一层一层往下遍历。</p><p>用队列先进先出的性质，</p><p>核心思路:上一层带下一层。</p><p><img src="/images/%E6%A0%91%E5%9E%8B%E7%BB%93%E6%9E%84.assets/%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9%E4%B8%AA%E6%95%B0.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(BTNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Queue q;</span><br><span class="line">QueueInit(&amp;q);</span><br><span class="line"><span class="keyword">if</span> (root)<span class="comment">//不为空进队 </span></span><br><span class="line">&#123;</span><br><span class="line">QueuePush(&amp;q, root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!QueueEmpty(&amp;q))<span class="comment">//队列不为空就继续</span></span><br><span class="line">&#123;</span><br><span class="line">BTNode* front = QueueFront(&amp;q);</span><br><span class="line">QueuePop(&amp;q);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, front-&gt;data);</span><br><span class="line"><span class="keyword">if</span> (front-&gt;left)</span><br><span class="line">&#123;</span><br><span class="line">QueuePush(&amp;q, front-&gt;left);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (front-&gt;right)</span><br><span class="line">&#123;</span><br><span class="line">QueuePush(&amp;q, front-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">QueueDestory(&amp;q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/%E6%A0%91%E5%9E%8B%E7%BB%93%E6%9E%84.assets/image-20210613173854712.png" alt="image-20210613173854712"></p><p><img src="/images/%E6%A0%91%E5%9E%8B%E7%BB%93%E6%9E%84.assets/image-20210616125449237.png" alt="image-20210616125449237"></p><h2 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h2><hr><p>上面是队列</p><p>相关链接——<a href="https://blog.csdn.net/qq_51604330/article/details/117697458?spm=1001.2014.3001.5501">【线性表】之队列_半生瓜のblog-CSDN博客</a></p><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="comment">/// 队列</span></span><br><span class="line"><span class="comment">//前置声明</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span>* <span class="title">QueueDataType</span>;</span><span class="comment">//存二叉树的结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span>* <span class="title">next</span>;</span></span><br><span class="line">QueueDataType data;</span><br><span class="line">&#125;QueueNode;</span><br><span class="line"><span class="comment">//单链表除了尾插还要尾删，所以不会加这个</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">QueueNode* tail;</span><br><span class="line">QueueNode* head;</span><br><span class="line">&#125;Queue;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QueueInit</span><span class="params">(Queue* pq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(pq);</span><br><span class="line">pq-&gt;tail = pq-&gt;head = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//销毁</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QueueDestory</span><span class="params">(Queue* pq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(pq);</span><br><span class="line">QueueNode* cur = pq-&gt;head;</span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line">QueueNode* curNext = cur-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(cur);</span><br><span class="line">cur = curNext;</span><br><span class="line">&#125;</span><br><span class="line">pq-&gt;head = pq-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//队尾入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QueuePush</span><span class="params">(Queue* pq, QueueDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(pq);</span><br><span class="line">QueueNode* newnode = (QueueNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QueueNode));</span><br><span class="line"><span class="keyword">if</span> (newnode == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;malloc is fail\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">newnode-&gt;data = x;</span><br><span class="line">newnode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pq-&gt;tail == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">pq-&gt;head = pq-&gt;tail = newnode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">pq-&gt;tail-&gt;next = newnode;</span><br><span class="line">pq-&gt;tail = newnode;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//队头出</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QueuePop</span><span class="params">(Queue* pq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(pq);</span><br><span class="line">assert(pq-&gt;head);<span class="comment">//队列是不等于空的</span></span><br><span class="line"><span class="keyword">if</span> (pq-&gt;head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(pq-&gt;head);</span><br><span class="line">pq-&gt;head = pq-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//先保存一下下一个结点</span></span><br><span class="line">QueueNode* nextNode = pq-&gt;head-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(pq-&gt;head);</span><br><span class="line">pq-&gt;head = nextNode;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//队头数据</span></span><br><span class="line"><span class="function">QueueDataType <span class="title">QueueFront</span><span class="params">(Queue* pq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(pq);</span><br><span class="line">assert(pq-&gt;head);</span><br><span class="line"><span class="keyword">return</span> pq-&gt;head-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//队尾数据</span></span><br><span class="line"><span class="function">QueueDataType <span class="title">QueueBack</span><span class="params">(Queue* pq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(pq);</span><br><span class="line">assert(pq-&gt;head);</span><br><span class="line"><span class="keyword">return</span> pq-&gt;tail-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QueueEmpty</span><span class="params">(Queue* pq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(pq);</span><br><span class="line"><span class="keyword">return</span> pq-&gt;head == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回数据个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueSize</span><span class="params">(Queue* pq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(pq);</span><br><span class="line"><span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">QueueNode* cur = pq-&gt;head;</span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line">size++;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// //////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> BinaryTreeType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span>* <span class="title">left</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span>* <span class="title">right</span>;</span></span><br><span class="line">BinaryTreeType data;</span><br><span class="line">&#125;BTNode;</span><br><span class="line"><span class="comment">//二叉树不学习增删查改，因为没得意义</span></span><br><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrevOrder</span><span class="params">(BTNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//如果树是空树就直接return</span></span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NULL &quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, root-&gt;data);</span><br><span class="line">PrevOrder(root-&gt;left);</span><br><span class="line">PrevOrder(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(BTNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NULL &quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">InOrder(root-&gt;left);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,root-&gt;data);</span><br><span class="line">InOrder(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(BTNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NULL &quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">PostOrder(root-&gt;left);</span><br><span class="line">PostOrder(root-&gt;right);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, root-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结点的个数</span></span><br><span class="line"><span class="comment">/*因为我们要对同一个size进行++,</span></span><br><span class="line"><span class="comment">所以要设置一个全局变量size进行++就完事了,</span></span><br><span class="line"><span class="comment">但是在进行多次调用的时候因为累加，调用前要先将他置成0*/</span></span><br><span class="line"><span class="comment">//int size = 0;</span></span><br><span class="line"><span class="comment">//void TreeSize(BTNode* root)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//if (root == NULL)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//return;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//else</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//size++;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//TreeSize(root-&gt;left);</span></span><br><span class="line"><span class="comment">//TreeSize(root-&gt;right);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//传参</span></span><br><span class="line"><span class="comment">//int size = 0;</span></span><br><span class="line"><span class="comment">//void TreeSize(BTNode* root,int* psize)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//if (root == NULL)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//return;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//else</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//(*psize)++;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//TreeSize(root-&gt;left, psize);</span></span><br><span class="line"><span class="comment">//TreeSize(root-&gt;right, psize);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TreeSize</span><span class="params">(BTNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> root == <span class="literal">NULL</span> ? <span class="number">0</span>:TreeSize(root-&gt;left) + TreeSize(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//叶子结点的个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TreeLeafSize</span><span class="params">(BTNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> TreeLeafSize(root-&gt;left) + TreeLeafSize(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//层序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(BTNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Queue q;</span><br><span class="line">QueueInit(&amp;q);</span><br><span class="line"><span class="keyword">if</span> (root)<span class="comment">//不为空进队 </span></span><br><span class="line">&#123;</span><br><span class="line">QueuePush(&amp;q, root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!QueueEmpty(&amp;q))<span class="comment">//队列不为空就继续</span></span><br><span class="line">&#123;</span><br><span class="line">BTNode* front = QueueFront(&amp;q);</span><br><span class="line">QueuePop(&amp;q);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, front-&gt;data);</span><br><span class="line"><span class="keyword">if</span> (front-&gt;left)</span><br><span class="line">&#123;</span><br><span class="line">QueuePush(&amp;q, front-&gt;left);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (front-&gt;right)</span><br><span class="line">&#123;</span><br><span class="line">QueuePush(&amp;q, front-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">QueueDestory(&amp;q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//构建一个简单的树</span></span><br><span class="line">BTNode* A = (BTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));</span><br><span class="line">A-&gt;data = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">A-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">A-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">BTNode* B = (BTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));</span><br><span class="line">B-&gt;data = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">B-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">B-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">BTNode* C = (BTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));</span><br><span class="line">C-&gt;data = <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">C-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">C-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">BTNode* D = (BTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));</span><br><span class="line">D-&gt;data = <span class="string">&#x27;D&#x27;</span>;</span><br><span class="line">D-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">D-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">BTNode* E = (BTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));</span><br><span class="line">E-&gt;data = <span class="string">&#x27;E&#x27;</span>;</span><br><span class="line">E-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">E-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">BTNode* F = (BTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));</span><br><span class="line">F-&gt;data = <span class="string">&#x27;F&#x27;</span>;</span><br><span class="line">F-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">F-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">A-&gt;left = B;</span><br><span class="line">A-&gt;right = C;</span><br><span class="line">B-&gt;left = D;</span><br><span class="line">B-&gt;right = E;</span><br><span class="line"> </span><br><span class="line">LevelOrder(A);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;树&quot;&gt;&lt;a href=&quot;#树&quot; class=&quot;headerlink&quot; title=&quot;树&quot;&gt;&lt;/a&gt;树&lt;/h1&gt;&lt;h2 id=&quot;树的概念及结构&quot;&gt;&lt;a href=&quot;#树的概念及结构&quot; class=&quot;headerlink&quot; title=&quot;树的概念及结构&quot;&gt;&lt;/a&gt;树的</summary>
      
    
    
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="-C语言" scheme="http://example.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="-数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="-树" scheme="http://example.com/tags/%E6%A0%91/"/>
    
    <category term="-二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题(8)【栈&amp;队列】用栈实现队列(C语言)</title>
    <link href="http://example.com/2021/06/14/LeetCode%E5%88%B7%E9%A2%98(8)%E3%80%90%E6%A0%88&amp;%E9%98%9F%E5%88%97%E3%80%91%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97(C%E8%AF%AD%E8%A8%80)/"/>
    <id>http://example.com/2021/06/14/LeetCode%E5%88%B7%E9%A2%98(8)%E3%80%90%E6%A0%88&amp;%E9%98%9F%E5%88%97%E3%80%91%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97(C%E8%AF%AD%E8%A8%80)/</id>
    <published>2021-06-14T10:05:19.000Z</published>
    <updated>2021-06-14T10:13:29.776Z</updated>
    
    <content type="html"><![CDATA[<p><strong>用栈实现队列</strong></p><p><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">232. 用栈实现队列 - 力扣（LeetCode） (leetcode-cn.com)</a></p><hr><p>相似题目——<strong>用队列实现栈</strong></p><p><a href="https://blog.csdn.net/qq_51604330/article/details/117826806?spm=1001.2014.3001.5501">LeetCode刷题(7)【栈&amp;队列】用队列实现栈(C语言)_半生瓜のblog-CSDN博客</a></p><hr><p><strong>思路</strong>：</p><p><img src="/images/LeetCode%E5%88%B7%E9%A2%988.assets/image-20210614164351913.png" alt="image-20210614164351913"></p><p>用栈实现队列要比用队列实现栈要简单一些，我们不用来回在两个栈里面导数据，只需要导一次，然后在依次出栈就成功实现队列的出队操作了。</p><p><img src="/images/LeetCode%E5%88%B7%E9%A2%988.assets/image-20210614164357870.png" alt="image-20210614164357870"></p><p><img src="/images/LeetCode%E5%88%B7%E9%A2%988.assets/image-20210614165007351.png" alt="image-20210614165007351"></p><p><strong>结论</strong>：</p><ol><li>入数据往push栈里面入</li><li>出数据从pop栈里面出，如果里面有数据，直接出，没有就把push栈里面的数据导过来，然后再出。</li></ol><p><strong>代码实现</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> StackDataType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">StackDataType* arry;</span><br><span class="line"><span class="keyword">int</span> top;<span class="comment">//指向栈顶</span></span><br><span class="line"><span class="keyword">int</span> capacity;<span class="comment">//栈的容量——能放几个数据</span></span><br><span class="line">&#125;Stack;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StackInit</span><span class="params">(Stack* ps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(ps);</span><br><span class="line">ps-&gt;arry = (StackDataType*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackDataType)*<span class="number">4</span>);</span><br><span class="line"><span class="keyword">if</span> (ps-&gt;arry == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;malloc fail&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">ps-&gt;capacity = <span class="number">4</span>;</span><br><span class="line">ps-&gt;top = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//销毁</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StackDestory</span><span class="params">(Stack* ps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(ps);</span><br><span class="line"><span class="built_in">free</span>(ps-&gt;arry);</span><br><span class="line">ps-&gt;arry = <span class="literal">NULL</span>;</span><br><span class="line">ps-&gt;top = ps-&gt;capacity =<span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StackPush</span><span class="params">(Stack* ps, StackDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(ps);</span><br><span class="line"><span class="comment">//满了</span></span><br><span class="line"><span class="keyword">if</span> (ps-&gt;top == ps-&gt;capacity)</span><br><span class="line">&#123;</span><br><span class="line">StackDataType* tmp = (StackDataType*)<span class="built_in">realloc</span>(ps-&gt;arry, ps-&gt;capacity * <span class="number">2</span> * <span class="keyword">sizeof</span>(StackDataType));</span><br><span class="line"><span class="keyword">if</span> (tmp == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;realloc fail&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">ps-&gt;arry = tmp;</span><br><span class="line">ps-&gt;capacity *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ps-&gt;arry[ps-&gt;top] = x;</span><br><span class="line">ps-&gt;top++;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StackPop</span><span class="params">(Stack* ps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(ps);</span><br><span class="line"><span class="comment">//如果栈空了调用top，直接终止程序报错</span></span><br><span class="line">assert(ps-&gt;top &gt; <span class="number">0</span>);</span><br><span class="line">ps-&gt;top--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回栈顶元素</span></span><br><span class="line"><span class="function">StackDataType <span class="title">StackTop</span><span class="params">(Stack* ps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(ps);</span><br><span class="line">assert(ps-&gt;top &gt; <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> ps-&gt;arry[ps-&gt;top - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回栈中元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StackSize</span><span class="params">(Stack* ps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(ps);</span><br><span class="line"><span class="keyword">return</span> ps-&gt;top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StackEmpty</span><span class="params">(Stack* ps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(ps);</span><br><span class="line"><span class="keyword">return</span> ps-&gt;top == <span class="number">0</span>;<span class="comment">//真为空，假为非空。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Stack pushST;</span><br><span class="line">    Stack popST;</span><br><span class="line">&#125; MyQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line"></span><br><span class="line"><span class="function">MyQueue* <span class="title">myQueueCreate</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyQueue* q = (MyQueue*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyQueue));</span><br><span class="line">    <span class="keyword">if</span>(q == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;malloc is fail!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    StackInit(&amp;q-&gt;pushST);</span><br><span class="line">    StackInit(&amp;q-&gt;popST);</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myQueuePush</span><span class="params">(MyQueue* obj, <span class="keyword">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//入数据就往pushST里面入</span></span><br><span class="line">    StackPush(&amp;obj-&gt;pushST,x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myQueuePop</span><span class="params">(MyQueue* obj)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//类似于下面的peek</span></span><br><span class="line">    <span class="comment">// if(StackEmpty(&amp;obj-&gt;popST))</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     while(!StackEmpty(&amp;obj-&gt;pushST))</span></span><br><span class="line">    <span class="comment">//     &#123;</span></span><br><span class="line">    <span class="comment">//         StackPush(&amp;obj-&gt;popST,StackTop(&amp;obj-&gt;pushST));</span></span><br><span class="line">    <span class="comment">//         StackPop(&amp;obj-&gt;pushST);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// int top = StackTop(&amp;obj-&gt;popST);</span></span><br><span class="line">    <span class="comment">///////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//或者直接调用下面的myQueuePeek函数直接获取popST的栈顶元素</span></span><br><span class="line">    <span class="comment">//保存给top之后删除，然后return</span></span><br><span class="line">    <span class="keyword">int</span> top = myQueuePeek(obj);</span><br><span class="line">    StackPop(&amp;obj-&gt;popST);</span><br><span class="line">    <span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Get the front element. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myQueuePeek</span><span class="params">(MyQueue* obj)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//出数据要从popST里面出</span></span><br><span class="line">    <span class="comment">//如果popST里面是空的</span></span><br><span class="line">    <span class="comment">//就要先从pushST里面拿</span></span><br><span class="line">    <span class="keyword">if</span>(StackEmpty(&amp;obj-&gt;popST))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把pushST里面的元素导到popST里面</span></span><br><span class="line">        <span class="comment">//然后取第一个</span></span><br><span class="line">        <span class="keyword">while</span>(!StackEmpty(&amp;obj-&gt;pushST))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//取pushST最上面的元素依次压进popST</span></span><br><span class="line">            StackPush((&amp;obj-&gt;popST),StackTop(&amp;obj-&gt;pushST));</span><br><span class="line">            StackPop(&amp;obj-&gt;pushST);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> StackTop(&amp;obj-&gt;popST);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myQueueEmpty</span><span class="params">(MyQueue* obj)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> StackEmpty(&amp;obj-&gt;popST) &amp;&amp; StackEmpty(&amp;obj-&gt;pushST);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myQueueFree</span><span class="params">(MyQueue* obj)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    StackDestory(&amp;obj-&gt;pushST);</span><br><span class="line">    StackDestory(&amp;obj-&gt;popST);</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue struct will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue* obj = myQueueCreate();</span></span><br><span class="line"><span class="comment"> * myQueuePush(obj, x);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * int param_2 = myQueuePop(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * int param_3 = myQueuePeek(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * bool param_4 = myQueueEmpty(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * myQueueFree(obj);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;用栈实现队列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/implement-queue-using-stacks/&quot;&gt;232. 用栈实现队列 - 力扣（LeetCode） (leetc</summary>
      
    
    
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="-C语言" scheme="http://example.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="-数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="-LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
    <category term="-栈" scheme="http://example.com/tags/%E6%A0%88/"/>
    
    <category term="-队列" scheme="http://example.com/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题(7)【栈&amp;队列】用队列实现栈(C语言)</title>
    <link href="http://example.com/2021/06/11/LeetCode%E5%88%B7%E9%A2%98(7)%E3%80%90%E6%A0%88&amp;%E9%98%9F%E5%88%97%E3%80%91%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88(C%E8%AF%AD%E8%A8%80)/"/>
    <id>http://example.com/2021/06/11/LeetCode%E5%88%B7%E9%A2%98(7)%E3%80%90%E6%A0%88&amp;%E9%98%9F%E5%88%97%E3%80%91%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88(C%E8%AF%AD%E8%A8%80)/</id>
    <published>2021-06-11T11:41:18.000Z</published>
    <updated>2021-06-11T13:00:17.685Z</updated>
    
    <content type="html"><![CDATA[<p><strong>用队列实现栈</strong></p><p><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/">225. 用队列实现栈 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p><img src="/images/LeetCode7.assets/image-20210611195234710.png" alt="image-20210611195234710"></p><p><strong>目的</strong>：用队列实现栈，从先进先出——&gt;先进后出，</p><p>1234这四个数据依次从队列1的队尾进入，要让4先出，一个队列是无法实现的，所以这里的队列2就排上用场了，我们可以利用队列2来进行导数据。</p><p><img src="/images/LeetCode7.assets/image-20210611195716778.png" alt="image-20210611195716778"></p><p>将123依次由队列2的队尾进入到队列2中，此时队列1中还剩一个4，将4弹出，同理，再将12依次进入到队列1中，将3弹出……</p><p><strong>也就是说</strong>。</p><p>出数据把不为空的 队列数据向为空的队列中导，知道剩最后一个。</p><p>入数据向不为空的队列入。</p><p>始终保持一个队列为空，一个不为空。</p><hr><p><strong>队列的实现</strong>——队列的实现——<a href="https://blog.csdn.net/qq_51604330/article/details/117697458">【线性表】之队列_半生瓜のblog-CSDN博客</a></p><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> QueueDataType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span>* <span class="title">next</span>;</span></span><br><span class="line">QueueDataType data;</span><br><span class="line">&#125;QueueNode;</span><br><span class="line"><span class="comment">//单链表除了尾插还要尾删，所以不会加这个</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">QueueNode* tail;</span><br><span class="line">QueueNode* head;</span><br><span class="line">&#125;Queue;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QueueInit</span><span class="params">(Queue* pq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(pq);</span><br><span class="line">pq-&gt;tail = pq-&gt;head = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//销毁</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QueueDestory</span><span class="params">(Queue* pq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(pq);</span><br><span class="line">QueueNode* cur = pq-&gt;head;</span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line">QueueNode* curNext = cur-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(cur);</span><br><span class="line">cur = curNext;</span><br><span class="line">&#125;</span><br><span class="line">pq-&gt;head = pq-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//队尾入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QueuePush</span><span class="params">(Queue* pq, QueueDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(pq);</span><br><span class="line">QueueNode* newnode = (QueueNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QueueNode));</span><br><span class="line"><span class="keyword">if</span> (newnode == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;malloc is fail\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">newnode-&gt;data = x;</span><br><span class="line">newnode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pq-&gt;tail == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">pq-&gt;head = pq-&gt;tail = newnode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">pq-&gt;tail-&gt;next = newnode;</span><br><span class="line">pq-&gt;tail = newnode;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//队头出</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QueuePop</span><span class="params">(Queue* pq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(pq);</span><br><span class="line">assert(pq-&gt;head);<span class="comment">//队列是不等于空的</span></span><br><span class="line"><span class="keyword">if</span> (pq-&gt;head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(pq-&gt;head);</span><br><span class="line">pq-&gt;head = pq-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//先保存一下下一个结点</span></span><br><span class="line">QueueNode* nextNode = pq-&gt;head-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(pq-&gt;head);</span><br><span class="line">pq-&gt;head = nextNode;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//队头数据</span></span><br><span class="line"><span class="function">QueueDataType <span class="title">QueueFront</span><span class="params">(Queue* pq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(pq);</span><br><span class="line">assert(pq-&gt;head);</span><br><span class="line"><span class="keyword">return</span> pq-&gt;head-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//队尾数据</span></span><br><span class="line"><span class="function">QueueDataType <span class="title">QueueBack</span><span class="params">(Queue* pq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(pq);</span><br><span class="line">assert(pq-&gt;head);</span><br><span class="line"><span class="keyword">return</span> pq-&gt;tail-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QueueEmpty</span><span class="params">(Queue* pq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(pq);</span><br><span class="line"><span class="keyword">return</span> pq-&gt;head == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回数据个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueSize</span><span class="params">(Queue* pq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(pq);</span><br><span class="line"><span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">QueueNode* cur = pq-&gt;head;</span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line">size++;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">//创建两个队列</span></span><br><span class="line">    Queue q1;</span><br><span class="line">    Queue q2;</span><br><span class="line">&#125; MyStack;</span><br><span class="line"><span class="comment">//creat a queue above this</span></span><br><span class="line"><span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line"></span><br><span class="line"><span class="function">MyStack* <span class="title">myStackCreate</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">//保证出了函数还在</span></span><br><span class="line">    MyStack* ps = (MyStack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyStack));</span><br><span class="line">    <span class="keyword">if</span>(ps == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;malloc is fail!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    QueueInit(&amp;ps-&gt;q1);</span><br><span class="line">    QueueInit(&amp;ps-&gt;q2);</span><br><span class="line">    <span class="keyword">return</span> ps;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Push element x onto stack. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myStackPush</span><span class="params">(MyStack* obj, <span class="keyword">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//谁为空就往谁里面入</span></span><br><span class="line">    <span class="keyword">if</span>(!QueueEmpty(&amp;obj-&gt;q1))</span><br><span class="line">    &#123;</span><br><span class="line">        QueuePush(&amp;obj-&gt;q1,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        QueuePush(&amp;obj-&gt;q2,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myStackPop</span><span class="params">(MyStack* obj)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//谁不为空就把谁中的元素导到另一个队列中，直到该队列只剩一个元素</span></span><br><span class="line">    <span class="comment">//先假设一个队列不为空一个队列为空，如果不是这样，就交换一下</span></span><br><span class="line">    Queue* emptyQ = &amp;obj-&gt;q1;</span><br><span class="line">    Queue* noemptyQ = &amp;obj-&gt;q2;</span><br><span class="line">    <span class="keyword">if</span>(!QueueEmpty(&amp;obj-&gt;q1))</span><br><span class="line">    &#123;</span><br><span class="line">        emptyQ = &amp;obj-&gt;q2;</span><br><span class="line">        noemptyQ = &amp;obj-&gt;q1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//然后循环，进行导元素，将noemptyQ的导入emptyQ中</span></span><br><span class="line">    <span class="keyword">while</span>(QueueSize(noemptyQ)&gt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        QueuePush(emptyQ,QueueFront(noemptyQ));</span><br><span class="line">        <span class="comment">//出一个删一个</span></span><br><span class="line">        QueuePop(noemptyQ);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//接口要求——返回栈顶的元素，就是noemptyQ中剩下的那个元素</span></span><br><span class="line">    <span class="keyword">int</span> top = QueueFront(noemptyQ);</span><br><span class="line">    QueuePop(noemptyQ);</span><br><span class="line">    <span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Get the top element. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myStackTop</span><span class="params">(MyStack* obj)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//取栈的最上面的元素，也就是取队列的最后一个元素</span></span><br><span class="line">    <span class="comment">//谁不为空就取谁</span></span><br><span class="line">    <span class="keyword">if</span>(!QueueEmpty(&amp;obj-&gt;q1))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBack(&amp;obj-&gt;q1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBack(&amp;obj-&gt;q2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myStackEmpty</span><span class="params">(MyStack* obj)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//两个队列都为空才为空</span></span><br><span class="line">    <span class="keyword">return</span> QueueEmpty(&amp;obj-&gt;q1) &amp;&amp; QueueEmpty(&amp;obj-&gt;q2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myStackFree</span><span class="params">(MyStack* obj)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QueueDestory(&amp;obj-&gt;q1);</span><br><span class="line">    QueueDestory(&amp;obj-&gt;q2);</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack struct will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack* obj = myStackCreate();</span></span><br><span class="line"><span class="comment"> * myStackPush(obj, x);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * int param_2 = myStackPop(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * int param_3 = myStackTop(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * bool param_4 = myStackEmpty(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * myStackFree(obj);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;用队列实现栈&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/implement-stack-using-queues/&quot;&gt;225. 用队列实现栈 - 力扣（LeetCode） (leetc</summary>
      
    
    
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="-C语言" scheme="http://example.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="-数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="-LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
    <category term="-栈" scheme="http://example.com/tags/%E6%A0%88/"/>
    
    <category term="-队列" scheme="http://example.com/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>如果你准备学习C++,并且有C语言的基础，我希望你能简单的过一遍知识点。</title>
    <link href="http://example.com/2021/06/10/%E5%A6%82%E6%9E%9C%E4%BD%A0%E5%87%86%E5%A4%87%E5%AD%A6%E4%B9%A0C++,%E5%B9%B6%E4%B8%94%E6%9C%89C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%9F%BA%E7%A1%80%EF%BC%8C%E6%88%91%E5%B8%8C%E6%9C%9B%E4%BD%A0%E8%83%BD%E7%AE%80%E5%8D%95%E7%9A%84%E8%BF%87%E4%B8%80%E9%81%8D%E7%9F%A5%E8%AF%86%E7%82%B9%E3%80%82/"/>
    <id>http://example.com/2021/06/10/%E5%A6%82%E6%9E%9C%E4%BD%A0%E5%87%86%E5%A4%87%E5%AD%A6%E4%B9%A0C++,%E5%B9%B6%E4%B8%94%E6%9C%89C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%9F%BA%E7%A1%80%EF%BC%8C%E6%88%91%E5%B8%8C%E6%9C%9B%E4%BD%A0%E8%83%BD%E7%AE%80%E5%8D%95%E7%9A%84%E8%BF%87%E4%B8%80%E9%81%8D%E7%9F%A5%E8%AF%86%E7%82%B9%E3%80%82/</id>
    <published>2021-06-10T12:10:43.000Z</published>
    <updated>2021-06-10T12:46:38.058Z</updated>
    
    <content type="html"><![CDATA[<hr><p>相关视频——<a href="https://www.bilibili.com/video/BV1et411b73Z?p=1">黑马程序员匠心之作|C++教程从0到1入门编程,学习编程不再难_哔哩哔哩_bilibili</a>（1-83）</p><p>我知道这个视频早已经被很多人学习并且记录笔记，但是我还是想再过一遍前面的基础知识点，所以我这个笔记会非常的简洁，适合有C语言基础的小伙伴进行简单的基础知识复习，好尽快投入到C++的学习中。</p><hr><p>在基础知识部分，好像只有头文件的引用和输入输出函数发生了变化。</p><p>头文件下加入using namespace std;</p><p>#include&lt;stdio.h&gt;——&gt;#include<iostream></p><p>printf——&gt;cout</p><p>scanf——&gt;cin</p><p>C++有字符串类型string,这是C语言所不具备的。</p><hr><p><strong>下面就让我们开始吧！</strong></p><p><img src="/images/%E5%A6%82%E6%9E%9C%E4%BD%A0%E5%87%86%E5%A4%87%E5%AD%A6%E4%B9%A0C.assets/%E6%99%83%E5%8A%A8%E7%9A%84%E5%B0%8F%E8%80%97%E5%AD%90.gif"></p><h2 id="Hello-C"><a href="#Hello-C" class="headerlink" title="Hello C++"></a>Hello C++</h2><h3 id="第一个程序"><a href="#第一个程序" class="headerlink" title="第一个程序"></a>第一个程序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hellow world&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>方便自己和他人阅读,不会被程序执行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单行</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*多行注释*/</span></span><br></pre></td></tr></table></figure><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p><strong>作用：</strong>给一段指定的内存空间起名，方便操作这段内存。</p><p><strong>语法：</strong>数据类型  变量名 = 初始值；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a = &quot;</span>&lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p><strong>作用：</strong>用于记录程序中不可更改的数据。</p><p>C++定义常量的两种方法</p><p>1.#define宏定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> 常量名 常量值</span></span><br></pre></td></tr></table></figure><p>通常在文件上方定义,表示一个常量。</p><p>2.const修饰的变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> 数据类型 常量名 = 常量值</span><br></pre></td></tr></table></figure><p>通常在变量定义之前加关键字const,修饰该变量为常量，不可修改。</p><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> day 7<span class="comment">//是不可修改的值，一旦修改就会报错</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> month = <span class="number">30</span>;</span><br></pre></td></tr></table></figure><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>**作用:**关键字是C++中预先保留的单词（标识符）</p><p>在定义变量或常量的时候不要使用关键字。</p><p><img src="/images/%E5%A6%82%E6%9E%9C%E4%BD%A0%E5%87%86%E5%A4%87%E5%AD%A6%E4%B9%A0C.assets/image-20210608180216685.png" alt="image-20210608180216685"></p><p>来源（菜鸟教程——<a href="https://www.runoob.com/w3cnote/cpp-keyword-intro.html">C++ 的关键字（保留字）完整介绍 | 菜鸟教程 (runoob.com)</a>）</p><h3 id="标识符命名规则"><a href="#标识符命名规则" class="headerlink" title="标识符命名规则"></a>标识符命名规则</h3><p><strong>作用：</strong>C++规定给标识符(变量、常量)命名时，有一套自己的规则</p><ul><li>标识符不能是关键字</li><li>标识符只能由字母、数字、下划线组成</li><li>第一个字符必须为字母或者下划线</li><li>标识符中字母区分大小写</li><li>(建议：给标识符命名的时候，争取做到见名知意，方便自己和他人阅读。)</li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>C++规定在创建一个变量或者常量的时候，必须要指定出相应的数据类型，否则无法给该变量分配内存空间。</p><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><p><strong>作用：</strong>整型变量表示的是整型类型的数据。</p><p>C++中能够表示整型的类型有以下几种方式，<strong>区别在于占用的内存空间不同。</strong></p><p><img src="/images/%E5%A6%82%E6%9E%9C%E4%BD%A0%E5%87%86%E5%A4%87%E5%AD%A6%E4%B9%A0C.assets/image-20210608181144671.png" alt="image-20210608181144671"></p><h3 id="sizeof关键字"><a href="#sizeof关键字" class="headerlink" title="sizeof关键字"></a>sizeof关键字</h3><p><strong>作用：</strong>统计数据类型所占空间的大小。</p><p><strong>语法</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(数据类型/变量);</span><br></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;int类型所占空间的大小是：&quot;</span> &lt;&lt;<span class="keyword">sizeof</span>(<span class="keyword">int</span>)&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实型-浮点型"><a href="#实型-浮点型" class="headerlink" title="实型(浮点型)"></a>实型(浮点型)</h3><p><strong>作用：</strong>用于表示小数。</p><p>浮点型分为两种-单精度float-双精度double。</p><p>两者的区别在于有效数字的表示范围不一样。</p><p><img src="/images/%E5%A6%82%E6%9E%9C%E4%BD%A0%E5%87%86%E5%A4%87%E5%AD%A6%E4%B9%A0C.assets/image-20210608181700530.png" alt="image-20210608181700530"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f1 = <span class="number">3.14f</span>;<span class="comment">//编译器会默认把一个小数当做双精度</span></span><br><span class="line"><span class="comment">//默认情况下输出一个小数会显示出6位有效数字</span></span><br><span class="line"><span class="comment">//例如：下面这个f1只输出到6</span></span><br><span class="line"><span class="keyword">float</span> f1 = <span class="number">3.1234567f</span>;</span><br></pre></td></tr></table></figure><h3 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h3><p><strong>作用：</strong>字符型变量用于显示单个字符。</p><p>语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> sb = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="comment">/*注意：</span></span><br><span class="line"><span class="comment">显示字符型变量时用单引号括起来，不是双引号。</span></span><br><span class="line"><span class="comment">单引号内只能有一个字符，不可以是字符串。*/</span></span><br></pre></td></tr></table></figure><ul><li>C和C++中字符型变量只占1个字节。</li><li>字符型变量并不是把所有的字符本身放到内存中存储，而是将对饮的ASCII编码放入到存储单元中。</li></ul><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p><strong>作用：</strong>用于表示一些不能显示出来的ASCII字符。</p><p><img src="/images/%E5%A6%82%E6%9E%9C%E4%BD%A0%E5%87%86%E5%A4%87%E5%AD%A6%E4%B9%A0C.assets/image-20210608183348489.png" alt="image-20210608183348489"></p><p>(图片来源——w3cschoolw3cschool<a href="http://c.biancheng.net/view/1769.html">C语言转义字符 (biancheng.net)</a>)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; “hello world\n”&lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p><strong>作用：</strong>用于表示一串字符串。</p><p><strong>两种风格：</strong></p><p>1.C风格字符串</p><p>要用双引号括起来</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> 变量名[] = <span class="string">&quot;字符串值&quot;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str1[] = <span class="string">&quot;hello world&quot;</span>;</span><br></pre></td></tr></table></figure><p>2.C++风格字符串</p><p>需要加入头文件#include <string></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> 变量名 = <span class="string">&quot;字符串值&quot;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> st2 = <span class="string">&quot;hellow world&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="布尔类型bool"><a href="#布尔类型bool" class="headerlink" title="布尔类型bool"></a>布尔类型bool</h3><p>**作用:**布尔类型数据代表真或假的值。</p><p>bool类型只有两个值：</p><ul><li>true——真（1）</li><li>false——假（0）</li></ul><p><strong>bool类型占1个字节大小</strong></p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h3 id="数据-输入"><a href="#数据-输入" class="headerlink" title="数据 输入"></a>数据 输入</h3><p><strong>作用：</strong>用于从键盘获取数据</p><p><strong>关键字：</strong>cin</p><p><strong>语法</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; 变量</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt;a;</span><br></pre></td></tr></table></figure><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>**作用:**用于代码的运算。</p><p><img src="/images/%E5%A6%82%E6%9E%9C%E4%BD%A0%E5%87%86%E5%A4%87%E5%AD%A6%E4%B9%A0C.assets/image-20210608193429732.png" alt="image-20210608193429732"></p><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><p><strong>作用：</strong>用于处理四则运算</p><p><img src="/images/%E5%A6%82%E6%9E%9C%E4%BD%A0%E5%87%86%E5%A4%87%E5%AD%A6%E4%B9%A0C.assets/image-20210608193743764.png" alt="image-20210608193743764"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ - * / % ++ -- </span><br><span class="line">两个整数相除结果还是整数</span><br><span class="line">两个小数相除结构还是小数</span><br><span class="line">两个数相除除数不可以为<span class="number">0</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">前置递增++a——先让变量+<span class="number">1</span>然后再进行表达式运算</span><br><span class="line">   后置递增a++——先进行表达式运算然后变量再+<span class="number">1</span></span><br><span class="line">   递减同理</span><br></pre></td></tr></table></figure><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p><strong>作用：</strong>用于将表达式的值赋给变量。</p><p><img src="/images/%E5%A6%82%E6%9E%9C%E4%BD%A0%E5%87%86%E5%A4%87%E5%AD%A6%E4%B9%A0C.assets/image-20210608194415559.png"></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">a *=<span class="number">2</span>;<span class="comment">//意思就是就是a = a *2;</span></span><br></pre></td></tr></table></figure><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p><strong>作用：</strong>用于表达式的比较，并返回一个真值或假值。</p><p><img src="/images/%E5%A6%82%E6%9E%9C%E4%BD%A0%E5%87%86%E5%A4%87%E5%AD%A6%E4%B9%A0C.assets/image-20210608194714016.png" alt="image-20210608194714016"></p><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (a &lt; b)&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//真返回1，假0</span></span><br></pre></td></tr></table></figure><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p><strong>作用：</strong>用于根据表达式的值返回真值或假值。</p><p><img src="/images/%E5%A6%82%E6%9E%9C%E4%BD%A0%E5%87%86%E5%A4%87%E5%AD%A6%E4%B9%A0C.assets/image-20210608194954139.png" alt="image-20210608194954139"></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; !a &lt;&lt;<span class="built_in">endl</span>;<span class="comment">//0</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; !!a &lt;&lt;<span class="built_in">endl</span>;<span class="comment">//1</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; (a &amp;&amp; b) &lt;&lt;<span class="built_in">endl</span>;<span class="comment">//1</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; (a &amp;&amp; c) &lt;&lt;<span class="built_in">endl</span>;<span class="comment">//0</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; (a || c) &lt;&lt;<span class="built_in">endl</span>;<span class="comment">//1</span></span><br></pre></td></tr></table></figure><h2 id="程序流程结构"><a href="#程序流程结构" class="headerlink" title="程序流程结构"></a>程序流程结构</h2><p>C/C++支持最基本的三大基本程序运算结构:<strong>顺序结构、选择结构、循环结构。</strong></p><ul><li>顺序结构：程序按顺序执行，不发生跳转。</li><li>选择结构：依据条件是否满足,有选择的执行相应代码。</li><li>循环结构：依据条件是否满足，循环多次指定某段代码。</li></ul><h3 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h3><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a><strong>if语句</strong></h4><p><strong>作用：</strong>执行满足条件的语句。</p><ul><li>单行格式if语句</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//条件满足执行的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>多行格式if语句</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件)&#123;    <span class="comment">//条件满足执行的语句&#125;else&#123;    //条件不满足执行的语句&#125;</span></span><br></pre></td></tr></table></figure><ul><li>多条件if语句</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//条件1满足执行的语句</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(条件<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//条件2满足执行的语句</span></span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//都不满足执行的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>嵌套if语句</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h4><p><strong>作用：</strong>通过三目运算符实现简单的判断</p><p><strong>语法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表达式<span class="number">1</span>？表达式<span class="number">2</span>：表达式<span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><p>如果1为真，则结果为表达式2的值。</p><p>如果1为假，则结果为表达式3的值。</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">c = a &gt; b ? a : b;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//结果为10</span></span><br></pre></td></tr></table></figure><h4 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h4><p><strong>作用：</strong>执行多条件分支语句</p><p><strong>语法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">case</span> 结果<span class="number">1</span>：</span><br><span class="line">            执行语句;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">default</span>：</span><br><span class="line">            执行语句;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><h4 id="while循环语句"><a href="#while循环语句" class="headerlink" title="while循环语句"></a>while循环语句</h4><p><strong>作用：</strong>满足循环条件，执行循环语句</p><p><strong>语法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(循环条件)&#123;    循环语句&#125;</span><br></pre></td></tr></table></figure><p><strong>解释：</strong>只要满足循环条件的结果为真，就执行循环语句。</p><h5 id="猜数字练习"><a href="#猜数字练习" class="headerlink" title="猜数字练习"></a>猜数字练习</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = rand() % <span class="number">100</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> puT = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请你猜一下这个数是多少\n&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">while</span> ((<span class="built_in">cin</span> &gt;&gt; puT))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (puT &gt; num)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;猜大了\n&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (puT &lt;= num / <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;太小了\n&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (puT &gt;= num / <span class="number">2</span> &amp;&amp; puT &lt; num)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;再大一点\n&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (num == puT)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;猜对了\n&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="do-while循环语句"><a href="#do-while循环语句" class="headerlink" title="do-while循环语句"></a>do-while循环语句</h4><p><strong>作用：</strong>满足循环条件，执行循环语句。</p><p><strong>语法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;    循环语句&#125;<span class="keyword">while</span>(循环条件)</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>与while的区别在于do-while会先执行一次循环语句，再判断循环条件。</p><h5 id="水仙花数练习"><a href="#水仙花数练习" class="headerlink" title="水仙花数练习"></a>水仙花数练习</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ge = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> shi = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> bai = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">ge = i % <span class="number">10</span>;</span><br><span class="line">shi = (i / <span class="number">10</span>) % <span class="number">10</span>;</span><br><span class="line">bai = i / <span class="number">100</span>;</span><br><span class="line"><span class="keyword">if</span> (i == ge * ge * ge + shi * shi * shi + bai * bai * bai)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; <span class="number">1000</span>);</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="for循环语句"><a href="#for循环语句" class="headerlink" title="for循环语句"></a>for循环语句</h4><p><strong>作用：</strong>满足循环条件，执行循环语句</p><p><strong>语法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(起始条件;条件表达式;末尾循环体)&#123;    循环语句&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)   </span><br><span class="line">    &#123;    </span><br><span class="line">        </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="敲桌子练习"><a href="#敲桌子练习" class="headerlink" title="敲桌子练习"></a>敲桌子练习</h4><h5 id="是7的倍数、各位有7、十位有7"><a href="#是7的倍数、各位有7、十位有7" class="headerlink" title="是7的倍数、各位有7、十位有7"></a>是7的倍数、各位有7、十位有7</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ge = i % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> shi = (i /<span class="number">10</span>)% <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">7</span> == <span class="number">0</span> || ge == <span class="number">7</span> || shi == <span class="number">7</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="嵌套循环"><a href="#嵌套循环" class="headerlink" title="嵌套循环"></a>嵌套循环</h4><p><strong>作用：</strong>在循环体中再嵌套一层循环，解决一些实际问题。</p><h5 id="打印10-10的正方形"><a href="#打印10-10的正方形" class="headerlink" title="打印10*10的正方形"></a>打印10*10的正方形</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;* &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="乘法口诀表练习"><a href="#乘法口诀表练习" class="headerlink" title="乘法口诀表练习"></a>乘法口诀表练习</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt;<span class="string">&quot;*&quot;</span>&lt;&lt; j&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt; i* j&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h4><h4 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h4><p><strong>作用：</strong>用于跳出选择结构或者循环结构。</p><p>break使用的时机：</p><ul><li>出现在switch语句中，作用是终止case并跳出swtich</li><li>出现在循环语句中，作用是跳出当前的循环语句</li><li>出现在嵌套语句中，跳出最近的内层循环语句</li></ul><h4 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h4><p>作用：在循环语句中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环。</p><h4 id="goto语句"><a href="#goto语句" class="headerlink" title="goto语句"></a>goto语句</h4><p><strong>作用：</strong>可以无条件跳转语句</p><p><strong>语法：</strong>goto标记；</p><p><strong>解释：</strong>如果标记的名称存在，执行到goto语句的时候，会跳转到标记的位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">goto</span> sb;......sb:......</span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>所谓数组就是一个集合，里面存放了相同类型的数据元素</p><p><strong>特点1</strong>：数组中的每个数据元素都是相同的数据类型。</p><p><strong>特点2</strong>：数组是由连续的内存位置组成的。</p><h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型 数组名[数组长度];数据类型 数组名[数组长度] = &#123;值<span class="number">1</span>，值<span class="number">2.</span>.....&#125;;数据类型 数组名[] = &#123;值<span class="number">1</span>，值<span class="number">2.</span>.....&#125;;;</span><br></pre></td></tr></table></figure><h4 id="数组名的用途"><a href="#数组名的用途" class="headerlink" title="数组名的用途"></a>数组名的用途</h4><p>1.可以统计整个数组在内存中的长度</p><p>2.可以获取数组在内存中的首地址</p><h4 id="输出最重的一只小猪的体重"><a href="#输出最重的一只小猪的体重" class="headerlink" title="输出最重的一只小猪的体重"></a>输出最重的一只小猪的体重</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> Weight[<span class="number">5</span>] = &#123; <span class="number">300</span>,<span class="number">250</span>,<span class="number">200</span>,<span class="number">400</span>,<span class="number">450</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Weight[i] &gt; temp)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = Weight[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;最重的小猪是&quot;</span> &lt;&lt; temp &lt;&lt; <span class="string">&quot;kg&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组元素逆置"><a href="#数组元素逆置" class="headerlink" title="数组元素逆置"></a>数组元素逆置</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    nt nums[<span class="number">5</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = <span class="keyword">sizeof</span>(nums)/<span class="keyword">sizeof</span>(nums[<span class="number">0</span>]) <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = nums[start];</span><br><span class="line">        nums[start] = nums[end];</span><br><span class="line">        nums[end] = temp;</span><br><span class="line">        end--;</span><br><span class="line">        start++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p><strong>作用：</strong>最常用的排序算法，对数组内元素进行排序</p><ol><li>比较相邻两个元素，如果第一个比第二个大就交换他们的位置</li><li>每一对相邻元素做同样的工作，整型完毕后，找到第一个最大值。</li><li>重复以上的步骤，每次比较次数-1，知道不需要比较</li></ol><p><strong>示例</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//排列这个数组&#123;7,5,2,4,9,8,6,7,1&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="comment">//排序的总轮数=元素个数-1</span></span><br><span class="line"><span class="comment">//每轮对比的次数 = 元素个数- 排序轮数 </span></span><br><span class="line"><span class="keyword">int</span> nums[<span class="number">9</span>] = &#123; <span class="number">7</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span> ; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//内层循环对比</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span> - i<span class="number">-1</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//第一个数比第二个数大就交换他们两个的位置</span></span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">temp = nums[j+<span class="number">1</span>];</span><br><span class="line">nums[j + <span class="number">1</span>] = nums[j];</span><br><span class="line">nums[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; nums[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>二维数组就是在一维数组的基础上多加一个维度，就是在一维数组里面存储一维数组。</p><p><strong>定义:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数据类型 数组名[行][列];</span><br><span class="line">数据类型 数组名[行][列] = &#123;&#123;数据<span class="number">1</span>，数据<span class="number">2</span>&#125;，&#123;数据<span class="number">3</span>，数据<span class="number">4</span>&#125;&#125;;</span><br><span class="line">数据类型 数组名[行][列] = &#123;数据<span class="number">1</span>，数据<span class="number">2</span>，数据<span class="number">3</span>，数据<span class="number">4</span>&#125;;</span><br><span class="line">数据类型 数组名[][列] = &#123;数据<span class="number">1</span>，数据<span class="number">2</span>，数据<span class="number">3</span>，数据<span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure><p><strong>建议：</strong>以上4种定义方式，利用第二种更加直观，提高代码的可读性。</p><h4 id="数组名"><a href="#数组名" class="headerlink" title="数组名"></a>数组名</h4><ul><li>查看二维数组所占内存空间</li><li>获取二维数组首地址</li></ul><h4 id="考试成绩统计练习"><a href="#考试成绩统计练习" class="headerlink" title="考试成绩统计练习"></a>考试成绩统计练习</h4><table><thead><tr><th></th><th>语文</th><th>数学</th><th>英语</th></tr></thead><tbody><tr><td>甲</td><td>50</td><td>40</td><td>60</td></tr><tr><td>乙</td><td>20</td><td>10</td><td>30</td></tr><tr><td>丙</td><td>70</td><td>80</td><td>90</td></tr></tbody></table><p>分别输出三个人的总成绩</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> score[<span class="number">3</span>][<span class="number">3</span>] = &#123; &#123;<span class="number">60</span>,<span class="number">50</span>,<span class="number">40</span>&#125;,&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;,&#123;<span class="number">70</span>,<span class="number">80</span>,<span class="number">90</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">//嵌套循环解决</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp += score[i][j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; temp &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p><strong>作用：</strong>将一段经常使用的代码封装起来，减少重复代码。</p><p>一个较大的程序，一般分为若干个程序块，每个模块实现特定的功能。</p><h3 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h3><p>函数的几个要素<br>返回值类型，函数名 ，参数，函数体语句，return表达式</p><p><strong>语法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 函数名(参数列表)</span><br><span class="line">&#123;</span><br><span class="line">    函数语句;</span><br><span class="line">    <span class="keyword">return</span> 表达式;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h3><p><strong>功能</strong>：使用定义好的函数</p><p><strong>语法：</strong>函数名(参数)</p><h3 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h3><ul><li>就是函数调用时将参数值传给形参</li><li>值传递时，如果形参发生变化，并不会影响到实参</li></ul><h3 id="函数的常见样式"><a href="#函数的常见样式" class="headerlink" title="函数的常见样式"></a>函数的常见样式</h3><p>无参无返、有参无返、无参有返、有参有返</p><h3 id="函数的声明"><a href="#函数的声明" class="headerlink" title="函数的声明"></a>函数的声明</h3><p><strong>作用</strong>：告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。</p><p>函数的声明可以有很多次，定义只能有一次。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a ,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数的分文件编写"><a href="#函数的分文件编写" class="headerlink" title="函数的分文件编写"></a>函数的分文件编写</h3><p><strong>作用：</strong>让代码结构更加清晰</p><p>就是在.h的头文件里面放函数声明，函数的定义放到.c文件里</p><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>指针的作用:可以通过指针间接访问内存。</p><ul><li>内存编号是从0开始记录的，一般用16进制数字标识。</li><li>可以利用指针变量保存地址。</li></ul><h3 id="指针变量的定义和使用"><a href="#指针变量的定义和使用" class="headerlink" title="指针变量的定义和使用"></a>指针变量的定义和使用</h3><p><strong>指针变量定义语法</strong>：数据类型+变量名</p><h3 id="指针所占内存空间"><a href="#指针所占内存空间" class="headerlink" title="指针所占内存空间"></a>指针所占内存空间</h3><p>在32位操作系统下无论是什么类型的指针，都占4个字节的内存空间。</p><h3 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h3><p><strong>空指针：</strong>指针变量指向内存中编号为0的空间</p><p><strong>用途：</strong>初始化指针变量</p><p><strong>注意：</strong>空指针指向的内存空间是不可以访问的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><h3 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h3><p>指针变量指向非法的内存空间。</p><h3 id="const修饰指针"><a href="#const修饰指针" class="headerlink" title="const修饰指针"></a>const修饰指针</h3><p>const修饰指针有3种情况 </p><ol><li>const修饰指针—常量指针</li><li>const修饰常量—指针常量</li><li>const既修饰指针，又修饰常量、</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>修饰的是指针，指针指向可以改，指针指向的值不可以改</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>* p1 = &amp;a;</span><br><span class="line"><span class="keyword">const</span>修饰的是常量，指针指向不可以改，指针指向的值可以更改</span><br><span class="line">    <span class="keyword">int</span>* <span class="keyword">const</span> p2 = &amp;a;</span><br><span class="line"><span class="keyword">const</span>既修饰指针，又修饰常量，指针的指向和指针指向的值都不可以改变</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">const</span> p = &amp;a;</span><br></pre></td></tr></table></figure><h3 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h3><p><strong>作用：</strong>利用指针访问数组元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>* p = arr;</span><br></pre></td></tr></table></figure><h3 id="指针和函数"><a href="#指针和函数" class="headerlink" title="指针和函数"></a>指针和函数</h3><p><strong>作用：</strong>利用指针作函数的参数，可以修改实参的值。</p><p>——<strong>传(址)引用</strong></p><h3 id="指针、数组、函数"><a href="#指针、数组、函数" class="headerlink" title="指针、数组、函数"></a>指针、数组、函数</h3><p>封装一个函数，利用冒泡排序，实现对整型数组的升序排列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PopSort</span><span class="params">(<span class="keyword">int</span>* a,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len-i - <span class="number">1</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">temp = a[j];</span><br><span class="line">a[j] = a[j + <span class="number">1</span>];</span><br><span class="line">a[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arry[<span class="number">5</span>] = &#123; <span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">5</span> &#125;;</span><br><span class="line">PopSort(arry, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arry[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>​    结构体属于用户自定义的数据类型，允许用户存储不同的数据类型。</p><h3 id="定义和使用"><a href="#定义和使用" class="headerlink" title="定义和使用"></a>定义和使用</h3><p><strong>语法</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名称</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    结构体成员列表</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过结构体创建变量的方式有三种</p><ul><li>struct 结构体名 变量名</li><li>struct 结构体名 变量名 = （成员1值，成员2值……)</li><li>定义结构体时顺便创建变量</li></ul><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="built_in">string</span> name;</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">  <span class="keyword">int</span> score;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h3><p><strong>作用：</strong>将自定义的结构头放入到数组中方便维护</p><p><strong>语法</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名 数组名[元素个数]=</span>  &#123;&#123;&#125;，&#123;&#125;...&#123;&#125;&#125;;</span><br></pre></td></tr></table></figure><h3 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h3><p><strong>作用</strong>：通过指针访问结构体中的成员</p><p>利用操作符-&gt;可以通过结构体指针访问结构体属性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s1</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>* <span class="title">p</span> =</span> &amp;s1;</span><br><span class="line">p-&gt;score = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h3 id="结构体嵌套结构体"><a href="#结构体嵌套结构体" class="headerlink" title="结构体嵌套结构体"></a>结构体嵌套结构体</h3><p><strong>作用</strong>：结构体中的成员可以是另一个结构体</p><p><strong>例如</strong>:每个老师辅导一个学员，一个老师的结构体中，记录一个学生的的结构体</p><h3 id="结构体做函数参数"><a href="#结构体做函数参数" class="headerlink" title="结构体做函数参数"></a>结构体做函数参数</h3><p><strong>作用：</strong>将结构体作为参数向函数中传递</p><p>传递方式有两种</p><p>同上函数参数-指针</p><ul><li>值传递-无法改变实参</li><li>地址传递-可以改变实参</li></ul><h3 id="结构体中const使用场景"><a href="#结构体中const使用场景" class="headerlink" title="结构体中const使用场景"></a>结构体中const使用场景</h3><p><strong>作用</strong>：用const来防止误操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChangeInformation</span><span class="params">(<span class="keyword">const</span> struct student* stu1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    加了<span class="keyword">const</span>就无法改变该结构体内的信息</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结构体案例"><a href="#结构体案例" class="headerlink" title="结构体案例"></a>结构体案例</h3><p> 每个老师带三个学生</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Teacher</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">sArry</span>[5];</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inPutInformation</span><span class="params">(struct Teacher tArry[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> Name = <span class="string">&quot;ABCDE&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">tArry[i].name = <span class="string">&quot;Teacher_&quot;</span>;</span><br><span class="line">tArry[i].name += Name[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">tArry[i].sArry[j].name = <span class="string">&quot;Student_&quot;</span>;</span><br><span class="line">tArry[i].sArry[j].name += Name[j];</span><br><span class="line"><span class="keyword">int</span> random = rand()% <span class="number">60</span> +<span class="number">40</span>;</span><br><span class="line">tArry[i].sArry[j].score = random;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printInformation</span><span class="params">(struct Teacher tArry[],<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;老师的姓名：&quot;</span> &lt;&lt; tArry[i].name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t学生的姓名：&quot;</span> &lt;&lt; tArry[i].sArry[j].name &lt;&lt; <span class="string">&quot;考试分数：&quot;</span> &lt;&lt; tArry[i].sArry[j].score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Teacher</span> <span class="title">tArry</span>[3];</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="keyword">sizeof</span>(tArry) / <span class="keyword">sizeof</span>(tArry[<span class="number">0</span>]);</span><br><span class="line">inPutInformation(tArry,len);</span><br><span class="line">printInformation(tArry,len);</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建5个人并按年龄排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Hero</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="built_in">string</span> categories;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Hero</span> <span class="title">heroArry</span>[5] =</span></span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="string">&quot;欣南&quot;</span>,<span class="number">20</span>,<span class="string">&quot;火&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;东杉&quot;</span>,<span class="number">24</span>,<span class="string">&quot;木&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;北淼&quot;</span>,<span class="number">23</span>,<span class="string">&quot;水&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;坤中&quot;</span>,<span class="number">18</span>,<span class="string">&quot;土&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;西昭&quot;</span>,<span class="number">22</span>,<span class="string">&quot;金&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> len = <span class="keyword">sizeof</span>(heroArry) / <span class="keyword">sizeof</span>(heroArry[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (heroArry[j].age &gt; heroArry[j + <span class="number">1</span>].age)</span><br><span class="line">&#123;</span><br><span class="line">temp = heroArry[j].age;</span><br><span class="line">heroArry[j].age = heroArry[j + <span class="number">1</span>].age;</span><br><span class="line">heroArry[j + <span class="number">1</span>].age = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;len; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; heroArry[i].name &lt;&lt; heroArry[i].age &lt;&lt; heroArry[i].categories &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通讯录"><a href="#通讯录" class="headerlink" title="通讯录"></a>通讯录</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 1000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="built_in">string</span> sex;</span><br><span class="line"><span class="built_in">string</span> phone;</span><br><span class="line"><span class="built_in">string</span> addr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addreassbooks</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">personarry</span>[<span class="title">MAX</span>];</span></span><br><span class="line"><span class="keyword">int</span> m_Size;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mainMenu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;1.增加联系人&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;2.显示联系人&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;3.删除联系人&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;4.查找联系人&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;5.修改联系人&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;6.清空联系人&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;0.退出通讯录&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addPerson</span><span class="params">(addreassbooks* <span class="built_in">abs</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">abs</span>-&gt;m_Size == MAX)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;联系人已满，无法添加&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入姓名&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; name;</span><br><span class="line"><span class="built_in">abs</span>-&gt;personarry[<span class="built_in">abs</span>-&gt;m_Size].name = name;</span><br><span class="line"><span class="built_in">string</span> sex;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入性别&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; sex;</span><br><span class="line"><span class="built_in">abs</span>-&gt;personarry[<span class="built_in">abs</span>-&gt;m_Size].sex = sex;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入年龄&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; age;</span><br><span class="line"><span class="built_in">abs</span>-&gt;personarry[<span class="built_in">abs</span>-&gt;m_Size].age = age;</span><br><span class="line"><span class="built_in">string</span> phone;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入电话&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; phone;</span><br><span class="line"><span class="built_in">abs</span>-&gt;personarry[<span class="built_in">abs</span>-&gt;m_Size].phone = phone;</span><br><span class="line"><span class="built_in">string</span> addr;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入地址&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; addr;</span><br><span class="line"><span class="built_in">abs</span>-&gt;personarry[<span class="built_in">abs</span>-&gt;m_Size].addr = addr;</span><br><span class="line"><span class="comment">//更新通讯录人数</span></span><br><span class="line"><span class="built_in">abs</span>-&gt;m_Size++;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;添加成功&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPerson</span><span class="params">(addreassbooks* <span class="built_in">abs</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">abs</span>-&gt;m_Size == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;当前记录为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">abs</span>-&gt;m_Size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名\t&quot;</span> &lt;&lt; <span class="built_in">abs</span>-&gt;personarry[i].name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;性别\t&quot;</span> &lt;&lt; <span class="built_in">abs</span>-&gt;personarry[i].sex &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;年龄\t&quot;</span> &lt;&lt; <span class="built_in">abs</span>-&gt;personarry[i].age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;电话\t&quot;</span> &lt;&lt; <span class="built_in">abs</span>-&gt;personarry[i].phone &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;地址\t&quot;</span> &lt;&lt; <span class="built_in">abs</span>-&gt;personarry[i].addr &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">checkPerson</span><span class="params">(addreassbooks* <span class="built_in">abs</span>, <span class="built_in">string</span> name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">abs</span>-&gt;m_Size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">abs</span>-&gt;personarry[i].name == name)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deletePerson</span><span class="params">(addreassbooks* <span class="built_in">abs</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> dname;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入你要删除的人名&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; dname;</span><br><span class="line"><span class="keyword">int</span> ret = checkPerson(<span class="built_in">abs</span>, dname);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;查无此人&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = ret; i &lt; <span class="built_in">abs</span>-&gt;m_Size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">abs</span>-&gt;personarry[i] = <span class="built_in">abs</span>-&gt;personarry[i + <span class="number">1</span>];</span><br><span class="line"> &#125;</span><br><span class="line"><span class="built_in">abs</span>-&gt;m_Size--;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;删除成功&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findPerson</span><span class="params">(addreassbooks* <span class="built_in">abs</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> fname;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入要查找的联系人姓名&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; fname;</span><br><span class="line"><span class="keyword">int</span> result = checkPerson(<span class="built_in">abs</span>, fname);</span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;查无此人&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名\t&quot;</span> &lt;&lt; <span class="built_in">abs</span>-&gt;personarry[result].name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;性别\t&quot;</span> &lt;&lt; <span class="built_in">abs</span>-&gt;personarry[result].sex &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;年龄\t&quot;</span> &lt;&lt; <span class="built_in">abs</span>-&gt;personarry[result].age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;电话\t&quot;</span> &lt;&lt; <span class="built_in">abs</span>-&gt;personarry[result].phone &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;地址\t&quot;</span> &lt;&lt; <span class="built_in">abs</span>-&gt;personarry[result].addr &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modifyPerson</span><span class="params">(addreassbooks* <span class="built_in">abs</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> mname;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入要修改的联系人姓名&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; mname;</span><br><span class="line"><span class="keyword">int</span> result = checkPerson(<span class="built_in">abs</span>, mname);</span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;查无此人&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入姓名&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; name;</span><br><span class="line"><span class="built_in">abs</span>-&gt;personarry[result].name = name;</span><br><span class="line"><span class="built_in">string</span> sex;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入性别&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; sex;</span><br><span class="line"><span class="built_in">abs</span>-&gt;personarry[result].sex = sex;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入年龄&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; age;</span><br><span class="line"><span class="built_in">abs</span>-&gt;personarry[result].age = age;</span><br><span class="line"><span class="built_in">string</span> phone;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入电话&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; phone;</span><br><span class="line"><span class="built_in">abs</span>-&gt;personarry[result].phone = phone;</span><br><span class="line"><span class="built_in">string</span> addr;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入地址&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; addr;</span><br><span class="line"><span class="built_in">abs</span>-&gt;personarry[result].addr = addr;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;修改成功&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanPerson</span><span class="params">(addreassbooks*<span class="built_in">abs</span>)</span><span class="comment">//逻辑清空</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">abs</span>-&gt;m_Size = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;通讯录清空成功！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建通讯录结构体变量</span></span><br><span class="line">addreassbooks <span class="built_in">abs</span>;</span><br><span class="line"><span class="comment">//初始化通讯录中当前人员的个数</span></span><br><span class="line"><span class="built_in">abs</span>.m_Size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> select = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">mainMenu();</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; select;</span><br><span class="line"><span class="keyword">switch</span> (select)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:<span class="comment">//添加联系人</span></span><br><span class="line">addPerson(&amp;<span class="built_in">abs</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:<span class="comment">//显示联系人</span></span><br><span class="line">printPerson(&amp;<span class="built_in">abs</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:<span class="comment">//删除联系人</span></span><br><span class="line">deletePerson(&amp;<span class="built_in">abs</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:<span class="comment">//查找联系人</span></span><br><span class="line">findPerson(&amp;<span class="built_in">abs</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:<span class="comment">//修改联系人</span></span><br><span class="line">modifyPerson(&amp;<span class="built_in">abs</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:<span class="comment">//清空联系人</span></span><br><span class="line">cleanPerson(&amp;<span class="built_in">abs</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:<span class="comment">//退出通讯录</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;欢迎下次使用&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;相关视频——&lt;a href=&quot;https://www.bilibili.com/video/BV1et411b73Z?p=1&quot;&gt;黑马程序员匠心之作|C++教程从0到1入门编程,学习编程不再难_哔哩哔哩_bilibili&lt;/a&gt;（1-83）&lt;/p&gt;
&lt;p&gt;我知道这个</summary>
      
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="-C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题(6)【栈】有效的括号(C语言)</title>
    <link href="http://example.com/2021/06/09/LeetCode%E5%88%B7%E9%A2%98(6)%E3%80%90%E6%A0%88%E3%80%91%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7(C%E8%AF%AD%E8%A8%80)/"/>
    <id>http://example.com/2021/06/09/LeetCode%E5%88%B7%E9%A2%98(6)%E3%80%90%E6%A0%88%E3%80%91%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7(C%E8%AF%AD%E8%A8%80)/</id>
    <published>2021-06-09T12:46:18.000Z</published>
    <updated>2021-06-11T13:01:21.137Z</updated>
    
    <content type="html"><![CDATA[<p><strong>有效的括号</strong></p><p><a href="https://leetcode-cn.com/problems/valid-parentheses/">20. 有效的括号 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p>思路：是左括号，就入栈，是右括号，就与栈顶的左括号判断是否匹配，如果匹配，继续，不匹配就终止。</p><p><strong>从第79行开始，前面都是实现栈以及其功能接口。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> StackDataType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    StackDataType* arry;</span><br><span class="line">    <span class="keyword">int</span> top;<span class="comment">//指向栈顶</span></span><br><span class="line">    <span class="keyword">int</span> capacity;<span class="comment">//栈的容量——能放几个数据</span></span><br><span class="line">&#125;Stack;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StackInit</span><span class="params">(Stack* ps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(ps);</span><br><span class="line">    ps-&gt;arry = (StackDataType*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackDataType)*<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> (ps-&gt;arry == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;malloc fail&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ps-&gt;capacity = <span class="number">4</span>;</span><br><span class="line">    ps-&gt;top = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//销毁</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StackDestory</span><span class="params">(Stack* ps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(ps);</span><br><span class="line">    <span class="built_in">free</span>(ps-&gt;arry);</span><br><span class="line">    ps-&gt;arry = <span class="literal">NULL</span>;</span><br><span class="line">    ps-&gt;top = ps-&gt;capacity =<span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StackPush</span><span class="params">(Stack* ps, StackDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(ps);</span><br><span class="line">    <span class="comment">//满了</span></span><br><span class="line">    <span class="keyword">if</span> (ps-&gt;top == ps-&gt;capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        StackDataType* tmp = (StackDataType*)<span class="built_in">realloc</span>(ps-&gt;arry, ps-&gt;capacity * <span class="number">2</span> * <span class="keyword">sizeof</span>(StackDataType));</span><br><span class="line">        <span class="keyword">if</span> (tmp == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;realloc fail&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ps-&gt;arry = tmp;</span><br><span class="line">            ps-&gt;capacity *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ps-&gt;arry[ps-&gt;top] = x;</span><br><span class="line">    ps-&gt;top++;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StackPop</span><span class="params">(Stack* ps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(ps);</span><br><span class="line">    <span class="comment">//如果栈空了调用top，直接终止程序报错</span></span><br><span class="line">    assert(ps-&gt;top &gt; <span class="number">0</span>);</span><br><span class="line">    ps-&gt;top--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回栈顶元素</span></span><br><span class="line"><span class="function">StackDataType <span class="title">StackTop</span><span class="params">(Stack* ps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(ps);</span><br><span class="line">    assert(ps-&gt;top &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ps-&gt;arry[ps-&gt;top - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回栈中元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StackSize</span><span class="params">(Stack* ps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(ps);</span><br><span class="line">    <span class="keyword">return</span> ps-&gt;top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StackEmpty</span><span class="params">(Stack* ps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(ps);</span><br><span class="line">    <span class="keyword">return</span> ps-&gt;top == <span class="number">0</span>;<span class="comment">//真为空，假为非空。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span> * s)</span></span>&#123;</span><br><span class="line">    Stack  st;</span><br><span class="line">    StackInit(&amp;st);</span><br><span class="line">    <span class="keyword">while</span>(*s != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span>(*s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&#123;&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;[&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">            &#123;</span><br><span class="line">                StackPush(&amp;st,*s);</span><br><span class="line">                s++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&#125;&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;]&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(StackEmpty(&amp;st))</span><br><span class="line">                &#123;</span><br><span class="line">                    StackDestory(&amp;st);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">char</span> top = StackTop(&amp;st);</span><br><span class="line">                StackPop(&amp;st);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//不匹配的三种情况  </span></span><br><span class="line">                <span class="keyword">if</span>((*s == <span class="string">&#x27;&#125;&#x27;</span>&amp;&amp; top != <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                || (*s == <span class="string">&#x27;]&#x27;</span>&amp;&amp; top != <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">                || (*s == <span class="string">&#x27;)&#x27;</span>&amp;&amp; top != <span class="string">&#x27;(&#x27;</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="comment">//不匹配返回fasle，有可能栈里面还有元素，销毁防止内存泄漏</span></span><br><span class="line">                    StackDestory(&amp;st);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//匹配就继续匹配</span></span><br><span class="line">                    s++;   </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> ret = StackEmpty(&amp;st);<span class="comment">//匹配完成了，栈应该是空的。</span></span><br><span class="line">    StackDestory(&amp;st);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;有效的括号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/valid-parentheses/&quot;&gt;20. 有效的括号 - 力扣（LeetCode） (leetcode-cn.com)&lt;/a</summary>
      
    
    
    
    
    <category term="-C语言" scheme="http://example.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="-数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="-LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
    <category term="-栈" scheme="http://example.com/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>【线性表】之队列</title>
    <link href="http://example.com/2021/06/08/%E3%80%90%E7%BA%BF%E6%80%A7%E8%A1%A8%E3%80%91%E4%B9%8B%E9%98%9F%E5%88%97(C%E8%AF%AD%E8%A8%80)/"/>
    <id>http://example.com/2021/06/08/%E3%80%90%E7%BA%BF%E6%80%A7%E8%A1%A8%E3%80%91%E4%B9%8B%E9%98%9F%E5%88%97(C%E8%AF%AD%E8%A8%80)/</id>
    <published>2021-06-08T04:27:51.000Z</published>
    <updated>2021-06-08T04:30:24.182Z</updated>
    
    <content type="html"><![CDATA[<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h2 id="队列的概念"><a href="#队列的概念" class="headerlink" title="队列的概念"></a>队列的概念</h2><p>队列只允许在一端进行插入数据操作，在另一端进行删除数据操作的特殊线性表，队列具有先进先出的FIFO(First in First Out)。</p><p>入队列：进行插入操作的一端称为队尾。</p><p>出队列：进行删除操作的一端称为队头。</p><p><img src="/images/%E7%BA%BF%E6%80%A7%E8%A1%A8-%E9%98%9F%E5%88%97.assets/image-20210607194222681.png" alt="image-20210607194222681"></p><p>同样可以使用链表或者数组</p><p>数组：不是适合，队头出数据需要挪动数据。</p><p>链表：适合单链表，单链表头删效率很高。</p><h2 id="结构定义"><a href="#结构定义" class="headerlink" title="结构定义"></a>结构定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> QueueDataType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span>* <span class="title">next</span>;</span></span><br><span class="line">QueueDataType data;</span><br><span class="line">&#125;QueueNode;</span><br><span class="line"><span class="comment">//单链表除了尾插还要尾删，所以不会加这个</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">QueueNode* tail;</span><br><span class="line">QueueNode* head;</span><br><span class="line">&#125;Queue;</span><br></pre></td></tr></table></figure><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QueueInit</span><span class="params">(Queue* pq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(pq);</span><br><span class="line">pq-&gt;tail = pq-&gt;head = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QueueDestory</span><span class="params">(Queue* pq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(pq);</span><br><span class="line">    <span class="comment">//定义一个新结点</span></span><br><span class="line">QueueNode* cur = pq-&gt;head;</span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//依次保存下一个结点，然后删除这个结点</span></span><br><span class="line">QueueNode* curNext = cur-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(cur);</span><br><span class="line">cur = curNext;</span><br><span class="line">&#125;</span><br><span class="line">pq-&gt;head = pq-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="队尾入"><a href="#队尾入" class="headerlink" title="队尾入"></a>队尾入</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QueuePush</span><span class="params">(Queue* pq, QueueDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(pq);</span><br><span class="line">    <span class="comment">//创建新结点</span></span><br><span class="line">QueueNode* newnode = (QueueNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QueueNode));</span><br><span class="line"><span class="comment">//创建失败</span></span><br><span class="line">    <span class="keyword">if</span> (newnode == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;malloc is fail\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//链接</span></span><br><span class="line">newnode-&gt;data = x;</span><br><span class="line">newnode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//如果插入前是空的</span></span><br><span class="line"><span class="keyword">if</span> (pq-&gt;tail == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">pq-&gt;head = pq-&gt;tail = newnode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">          <span class="comment">//插到后面</span></span><br><span class="line">pq-&gt;tail-&gt;next = newnode;</span><br><span class="line">        <span class="comment">//称为新的尾巴</span></span><br><span class="line">pq-&gt;tail = newnode;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="队头出"><a href="#队头出" class="headerlink" title="队头出"></a>队头出</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QueuePop</span><span class="params">(Queue* pq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(pq);</span><br><span class="line">assert(pq-&gt;head);<span class="comment">//队列是不等于空的</span></span><br><span class="line"><span class="keyword">if</span> (pq-&gt;head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(pq-&gt;head);</span><br><span class="line">pq-&gt;head = pq-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//先保存下一个结点</span></span><br><span class="line">QueueNode* nextNode = pq-&gt;head-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(pq-&gt;head);</span><br><span class="line">pq-&gt;head = nextNode;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="队头出-1"><a href="#队头出-1" class="headerlink" title="队头出"></a>队头出</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QueueDataType <span class="title">QueueFront</span><span class="params">(Queue* pq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(pq);</span><br><span class="line">assert(pq-&gt;head);</span><br><span class="line"><span class="keyword">return</span> pq-&gt;head-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="队头数据"><a href="#队头数据" class="headerlink" title="队头数据"></a>队头数据</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QueueDataType <span class="title">QueueFront</span><span class="params">(Queue* pq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(pq);</span><br><span class="line">assert(pq-&gt;head);</span><br><span class="line"><span class="keyword">return</span> pq-&gt;head-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="队尾数据"><a href="#队尾数据" class="headerlink" title="队尾数据"></a>队尾数据</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QueueDataType <span class="title">QueueBack</span><span class="params">(Queue* pq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(pq);</span><br><span class="line">assert(pq-&gt;head);</span><br><span class="line"><span class="keyword">return</span> pq-&gt;tail-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="是否为空"><a href="#是否为空" class="headerlink" title="是否为空"></a>是否为空</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QueueEmpty</span><span class="params">(Queue* pq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(pq);</span><br><span class="line"><span class="keyword">return</span> pq-&gt;head == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="返回数据个数"><a href="#返回数据个数" class="headerlink" title="返回数据个数"></a>返回数据个数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueSize</span><span class="params">(Queue* pq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(pq);</span><br><span class="line"><span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">QueueNode* cur = pq-&gt;head;</span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line">size++;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="comment">//结构定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> QueueDataType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span>* <span class="title">next</span>;</span></span><br><span class="line">QueueDataType data;</span><br><span class="line">&#125;QueueNode;</span><br><span class="line"><span class="comment">//单链表除了尾插还要尾删，所以不会加这个</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">QueueNode* tail;</span><br><span class="line">QueueNode* head;</span><br><span class="line">&#125;Queue;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QueueInit</span><span class="params">(Queue* pq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(pq);</span><br><span class="line">pq-&gt;tail = pq-&gt;head = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//销毁</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QueueDestory</span><span class="params">(Queue* pq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(pq);</span><br><span class="line">QueueNode* cur = pq-&gt;head;</span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line">QueueNode* curNext = cur-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(cur);</span><br><span class="line">cur = curNext;</span><br><span class="line">&#125;</span><br><span class="line">pq-&gt;head = pq-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//队尾入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QueuePush</span><span class="params">(Queue* pq, QueueDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(pq);</span><br><span class="line">QueueNode* newnode = (QueueNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QueueNode));</span><br><span class="line"><span class="keyword">if</span> (newnode == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;malloc is fail\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">newnode-&gt;data = x;</span><br><span class="line">newnode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pq-&gt;tail == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">pq-&gt;head = pq-&gt;tail = newnode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">pq-&gt;tail-&gt;next = newnode;</span><br><span class="line">pq-&gt;tail = newnode;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//队头出</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QueuePop</span><span class="params">(Queue* pq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(pq);</span><br><span class="line">assert(pq-&gt;head);<span class="comment">//队列是不等于空的</span></span><br><span class="line"><span class="keyword">if</span> (pq-&gt;head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(pq-&gt;head);</span><br><span class="line">pq-&gt;head = pq-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//先保存一下下一个结点</span></span><br><span class="line">QueueNode* nextNode = pq-&gt;head-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(pq-&gt;head);</span><br><span class="line">pq-&gt;head = nextNode;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//队头数据</span></span><br><span class="line"><span class="function">QueueDataType <span class="title">QueueFront</span><span class="params">(Queue* pq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(pq);</span><br><span class="line">assert(pq-&gt;head);</span><br><span class="line"><span class="keyword">return</span> pq-&gt;head-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//队尾数据</span></span><br><span class="line"><span class="function">QueueDataType <span class="title">QueueBack</span><span class="params">(Queue* pq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(pq);</span><br><span class="line">assert(pq-&gt;head);</span><br><span class="line"><span class="keyword">return</span> pq-&gt;tail-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QueueEmpty</span><span class="params">(Queue* pq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(pq);</span><br><span class="line"><span class="keyword">return</span> pq-&gt;head == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回数据个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueSize</span><span class="params">(Queue* pq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(pq);</span><br><span class="line"><span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">QueueNode* cur = pq-&gt;head;</span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line">size++;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Queue pq;</span><br><span class="line">QueueInit(&amp;pq);</span><br><span class="line">QueuePush(&amp;pq, <span class="number">1</span>);</span><br><span class="line">QueuePush(&amp;pq, <span class="number">2</span>);</span><br><span class="line">QueuePush(&amp;pq, <span class="number">3</span>);</span><br><span class="line">QueuePush(&amp;pq, <span class="number">4</span>);</span><br><span class="line">    <span class="comment">//为空是假的才成立，进入循环(不为空，进入循环)</span></span><br><span class="line"><span class="keyword">while</span> (!QueueEmpty(&amp;pq))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//取队头的数据然后删除</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, QueueFront(&amp;pq));</span><br><span class="line">QueuePop(&amp;pq);</span><br><span class="line">&#125;</span><br><span class="line">QueueDestory(&amp;pq);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Test1();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;队列&quot;&gt;&lt;a href=&quot;#队列&quot; class=&quot;headerlink&quot; title=&quot;队列&quot;&gt;&lt;/a&gt;队列&lt;/h1&gt;&lt;h2 id=&quot;队列的概念&quot;&gt;&lt;a href=&quot;#队列的概念&quot; class=&quot;headerlink&quot; title=&quot;队列的概念&quot;&gt;&lt;/a&gt;队列的概</summary>
      
    
    
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="-C语言" scheme="http://example.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="-数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="-队列" scheme="http://example.com/tags/%E9%98%9F%E5%88%97/"/>
    
    <category term="-线性表" scheme="http://example.com/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>【线性表】之栈</title>
    <link href="http://example.com/2021/06/07/%E3%80%90%E7%BA%BF%E6%80%A7%E8%A1%A8%E3%80%91%E4%B9%8B%E6%A0%88(C%E8%AF%AD%E8%A8%80)/"/>
    <id>http://example.com/2021/06/07/%E3%80%90%E7%BA%BF%E6%80%A7%E8%A1%A8%E3%80%91%E4%B9%8B%E6%A0%88(C%E8%AF%AD%E8%A8%80)/</id>
    <published>2021-06-07T11:17:07.000Z</published>
    <updated>2021-06-08T04:29:53.576Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p>顺序表和链表的区别和联系</p><p>顺序表：</p><p>​    优点：空间连续支持随机访问。</p><p>​    缺点：1.中间或前面的插入删除时间复杂度O(N)。</p><p>​               2.增容的代价比较大</p><p>链表(带头双向循环)：</p><p>​    缺点：</p><p>​        以借点为单位存储，不支持随机访问。</p><p>​    优点：</p><p>​            1.任意位置插入删除时间复杂度为O(1)</p><p>​            2.没有增容消耗，按需申请结点空间，不用了直接释放。</p><hr><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>栈也是线性表，在逻辑上还是挨着放的。</p><p>栈的概念以及结构</p><p>栈：一种特殊的线性表,其只允许在固定的一端进行插入和删除元素操作。<strong>进行数据插入和删除操作的一端称为栈顶，另一端称为栈底。</strong>栈中的数据元素遵守后进先出LIFO(Last In First Out)的原则。</p><p><strong>压栈：</strong>栈的插入操作叫做进栈/压栈/入栈，<strong>入数据在栈顶</strong>。</p><p><strong>出栈：</strong>栈的删除操作叫做出栈。<strong>出数据也在栈顶</strong>。</p><p><img src="/images/%E6%A0%88.assets/image-20210607120710677.png" alt="image-20210607120710677"></p><p><strong>实现方式：</strong></p><ol><li><p>数组实现</p><p><img src="/images/%E6%A0%88.assets/image-20210607120936928.png" alt="image-20210607120936928"></p><p>总结：</p><p>相当于之前顺序表的尾插尾删，用尾做栈顶，非常合适，唯一缺陷就是，空间不够需要增容(影响不大)。</p><p>(顺序表——<a href="https://blog.csdn.net/qq_51604330/article/details/117593583">【线性表】之顺序表_半生瓜のblog-CSDN博客</a>)</p></li><li><p>链表实现</p></li></ol><p><img src="/images/%E6%A0%88.assets/image-20210607121416245.png" alt="image-20210607121416245"></p><p>出数据得找到前一个，这样的话用双向链表更好一些。</p><p>(所以说数据结构并没有规定用什么方法实现，只要能实现就行，对比的就是效率而已。)</p><p>也可以将单链表反过来。</p><p><img src="/images/%E6%A0%88.assets/image-20210607121819132.png" alt="image-20210607121819132"></p><p>总结：</p><p>​    如果用尾插做栈顶，用双向链表更好。</p><p>​    如果用单链表实现，就用头去做栈顶，这样入栈和出栈效率都是O(1)。</p><p>​    整体来说数组的效率更优一些。</p><hr><h2 id="结构定义"><a href="#结构定义" class="headerlink" title="结构定义"></a>结构定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> StackDataType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">StackDataType* arry;</span><br><span class="line"><span class="keyword">int</span> top;<span class="comment">//指向栈顶</span></span><br><span class="line"><span class="keyword">int</span> capacity;<span class="comment">//栈的容量——能放几个数据</span></span><br><span class="line">&#125;Stack;</span><br></pre></td></tr></table></figure><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>如果初识的top给0，意味着top指向栈顶的元素的下一个，top给-1，top指向栈顶元素。</p><p>一定不能为空的东西，可以使用断言来处理。OJ题不可以使用断言。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StackInit</span><span class="params">(Stack* ps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(ps);</span><br><span class="line">ps-&gt;arry = (StackDataType*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackDataType)*<span class="number">4</span>);</span><br><span class="line"><span class="keyword">if</span> (ps-&gt;arry == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;malloc fail&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">ps-&gt;capacity = <span class="number">4</span>;</span><br><span class="line">ps-&gt;top = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StackDestory</span><span class="params">(Stack* ps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(ps);</span><br><span class="line"><span class="built_in">free</span>(ps-&gt;arry);</span><br><span class="line">ps-&gt;arry = <span class="literal">NULL</span>;</span><br><span class="line">ps-&gt;top = ps-&gt;capacity =<span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="入栈"><a href="#入栈" class="headerlink" title="入栈"></a>入栈</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StackPush</span><span class="params">(Stack* ps, StackDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(ps);</span><br><span class="line"><span class="comment">//满了</span></span><br><span class="line"><span class="keyword">if</span> (ps-&gt;top == ps-&gt;capacity)</span><br><span class="line">&#123;</span><br><span class="line">StackDataType* tmp = (StackDataType*)<span class="built_in">realloc</span>(ps-&gt;arry, ps-&gt;capacity * <span class="number">2</span> * <span class="keyword">sizeof</span>(StackDataType));</span><br><span class="line"><span class="keyword">if</span> (tmp == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;realloc fail&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">ps-&gt;arry = tmp;</span><br><span class="line">ps-&gt;capacity *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ps-&gt;arry[ps-&gt;top] = x;</span><br><span class="line">ps-&gt;top++;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StackPop</span><span class="params">(Stack* ps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(ps);</span><br><span class="line"><span class="comment">//如果栈空了调用top，直接终止程序报错</span></span><br><span class="line">assert(ps-&gt;top &gt; <span class="number">0</span>);</span><br><span class="line">ps-&gt;top--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="返回栈顶元素"><a href="#返回栈顶元素" class="headerlink" title="返回栈顶元素"></a>返回栈顶元素</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StackDataType <span class="title">StackTop</span><span class="params">(Stack* ps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(ps);</span><br><span class="line">assert(ps-&gt;top &gt; <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> ps-&gt;arry[ps-&gt;top - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="返回栈中元素个数"><a href="#返回栈中元素个数" class="headerlink" title="返回栈中元素个数"></a>返回栈中元素个数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StackSize</span><span class="params">(Stack* ps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(ps);</span><br><span class="line"><span class="keyword">return</span> ps-&gt;top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断栈是否为空"><a href="#判断栈是否为空" class="headerlink" title="判断栈是否为空"></a>判断栈是否为空</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StackEmpty</span><span class="params">(Stack* ps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(ps);</span><br><span class="line"><span class="keyword">return</span> ps-&gt;top == <span class="number">0</span>;<span class="comment">//真为空，假为非空。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>小提示:</strong></p><p>上面有的函数只有两行代码，如果直接用里面的那句代码，可以吗？<br>可以，但是不好，通过那句代码访问到，但严格来说你不应该去访问，这是一种耦合，耦合就是一种强关联，<br>调用函数，无需去想top在0还是在-1，只管用就完事了。(有点软件工程的思想)</p><hr><h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Stack ps;</span><br><span class="line">StackInit(&amp;ps);</span><br><span class="line">StackPush(&amp;ps,<span class="number">1</span>);</span><br><span class="line">StackPush(&amp;ps,<span class="number">2</span>);</span><br><span class="line">StackPush(&amp;ps,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">while</span> (!StackEmpty(&amp;ps))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, StackTop(&amp;ps));</span><br><span class="line"><span class="comment">//取完栈顶的数据，想取下一个，那就得删一下</span></span><br><span class="line">StackPop(&amp;ps);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">StackDestory(&amp;ps);</span><br><span class="line"><span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;回顾&quot;&gt;&lt;a href=&quot;#回顾&quot; class=&quot;headerlink&quot; title=&quot;回顾&quot;&gt;&lt;/a&gt;回顾&lt;/h1&gt;&lt;p&gt;顺序表和链表的区别和联系&lt;/p&gt;
&lt;p&gt;顺序表：&lt;/p&gt;
&lt;p&gt;​    优点：空间连续支持随机访问。&lt;/p&gt;
&lt;p&gt;​    缺</summary>
      
    
    
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="-C语言" scheme="http://example.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="-数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="-栈" scheme="http://example.com/tags/%E6%A0%88/"/>
    
    <category term="-线性表" scheme="http://example.com/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题(5)【链表】环形链表II(C语言)</title>
    <link href="http://example.com/2021/06/06/LeetCode%E5%88%B7%E9%A2%98(5)%E3%80%90%E9%93%BE%E8%A1%A8%E3%80%91%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II(C%E8%AF%AD%E8%A8%80)/"/>
    <id>http://example.com/2021/06/06/LeetCode%E5%88%B7%E9%A2%98(5)%E3%80%90%E9%93%BE%E8%A1%A8%E3%80%91%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II(C%E8%AF%AD%E8%A8%80)/</id>
    <published>2021-06-05T17:23:30.000Z</published>
    <updated>2021-06-11T13:01:10.448Z</updated>
    
    <content type="html"><![CDATA[<p><strong>环形链表I</strong></p><p><a href="https://blog.csdn.net/qq_51604330/article/details/117334723?spm=1001.2014.3001.5501">LeetCode刷题(3)【链表】【环形链表】&amp;扩展_半生瓜のblog-CSDN博客</a></p><hr><p><strong>环形链表</strong>II</p><p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II - 力扣（LeetCode） (leetcode-cn.com)</a></p><p>这个题写起来不难，但是证明有点麻烦。</p><p><img src="/images/leetcode%E5%88%B7%E9%A2%98-5.assets/image-20210605184927049.png" alt="image-20210605184927049"></p><p><img src="/images/leetcode%E5%88%B7%E9%A2%98-5.assets/image-20210605184933830.png" alt="image-20210605184933830"></p><hr><p>针对这个入口点怎么求，有人给出了一个结论。</p><p>结论：一个指针从meet点开始走，一个指针从链表的开始点走，它们会在入口点相遇。（看下面的过程的时候，先别想这个结论，否则会越来越乱的，就先当不知道。）</p><hr><p><img src="/images/leetcode%E5%88%B7%E9%A2%98-5.assets/image-20210606005633219.png" alt="image-20210606005633219"></p><p>fast走的路程是slow走的路程的2倍。</p><p>slow走的路程：slow进环了以后，在一圈之内，fast一定会追上slow。因为slow走了一圈，fast都走两圈了。</p><p>slow进环之前，fast有可能在环里面转了N圈，如果入环之前的长度越长，环很小，N越大， 如果入环前的长度越短，环很大，N就是1，fast只转了1圈。</p><p>fast走的路程： L + C*N + X</p><p>slow走的路程：L + X</p><p>fast = 2*slow</p><p>L + C*N + X = 2(L +X)   </p><p>化简一下得：</p><p>C* N - X = L</p><p>再化简一下得：<br>(N-1)* C + C - X = L </p><p>C - X就是meet点到入口点的距离。</p><p>再看这个结论。</p><p><strong>结论：一个指针从meet点开始走，一个指针从链表的开始点走，它们会在入口点相遇。</strong></p><p>理解一下，就是一个指针从meet点出发，转转转了N-1圈，在走了一个C-X到达入口点，发生相遇。</p><p><strong>代码实现：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct ListNode *<span class="title">detectCycle</span><span class="params">(struct ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">slow</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">fast</span> =</span> head;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        <span class="comment">//找到相遇点</span></span><br><span class="line">        <span class="keyword">if</span>(fast == slow)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//相等即为相遇点</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">meet</span> =</span>  slow;</span><br><span class="line">            <span class="comment">//一个指针从meet走，一个指针从head走，他们会在入口点相遇</span></span><br><span class="line">            <span class="keyword">while</span>(head != meet)</span><br><span class="line">            &#123;</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">                meet = meet-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> meet;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;环形链表I&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_51604330/article/details/117334723?spm=1001.2014.3001.5501&quot;&gt;LeetCode刷题(3)</summary>
      
    
    
    
    
    <category term="-C语言" scheme="http://example.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="-数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="-链表" scheme="http://example.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="-LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题(4)移除元素&amp;合并两个有序数组(C语言)</title>
    <link href="http://example.com/2021/06/05/LeetCode%E5%88%B7%E9%A2%98(4)%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0&amp;%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84(C%E8%AF%AD%E8%A8%80)/"/>
    <id>http://example.com/2021/06/05/LeetCode%E5%88%B7%E9%A2%98(4)%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0&amp;%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84(C%E8%AF%AD%E8%A8%80)/</id>
    <published>2021-06-05T08:03:54.000Z</published>
    <updated>2021-06-11T13:01:04.795Z</updated>
    
    <content type="html"><![CDATA[<p><strong>移除元素</strong></p><p>典型双指针玩法。</p><p><a href="https://leetcode-cn.com/problems/remove-element/">27. 移除元素 - 力扣（LeetCode） (leetcode-cn.com)</a></p><hr><p>我们都会想到这样的解法：从前面依次往后推，是val就将该数据后面的元素依次覆盖上来，但是这样的时间复杂度是O(n²)，最坏的结果是一个数组中大部分数据都是val。</p><p>所以我们想到另一种解法，以空间换时间 ，另开一个数组，把不是val的数据给新的数组，再把新数组的值拷贝回来。空间复杂度是O(n)。</p><p>但是这个题它不让开辟一个新的数组，所以我们还得换一个思路。</p><hr><p>该思路空间复杂度为O(n),时间复杂度为O(1)。——<strong>双指针解法</strong></p><p>定义两个指针，p1和p2，p1先动，p2后动，如果p1不等于val，就把值传给p2,直到完成一遍遍历，p2的值就是新数组元素的个数。</p><p><strong>如图所示：</strong></p><p><img src="/images/LeetCode%E5%88%B7%E9%A2%98(4)%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0&%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84.assets/image-20210605140450655.png" alt="image-20210605140450655"></p><p><img src="/images/LeetCode%E5%88%B7%E9%A2%98(4)%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0&%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84.assets/image-20210605140910200.png" alt="image-20210605140910200"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p2 = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//p1和p2都从数组左边出发</span></span><br><span class="line">    <span class="keyword">while</span>(p1 &lt; numsSize)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果p1(对应的值)不等于val</span></span><br><span class="line">        <span class="keyword">if</span>(nums[p1] != val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//将p1的值赋给p2</span></span><br><span class="line">            nums[p2] = nums[p1];</span><br><span class="line">            <span class="comment">//往后面++</span></span><br><span class="line">            p1++;</span><br><span class="line">            p2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//p1(对应的值)等于val</span></span><br><span class="line">        <span class="comment">//只有p1走</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p1++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是p1在前面开路，p2在后面跟着，同时出发，p1遇到val就跳过，p2就停住,当p1没遇到val的时候将p1的值给p2，（就把p1位置的val值覆盖了）,然后p1，p2都往后走一位……</p><p><strong>合并两个有序数组</strong></p><p><a href="https://leetcode-cn.com/problems/merge-sorted-array/">88. 合并两个有序数组 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p><img src="/images/LeetCode%E5%88%B7%E9%A2%98(4)%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0&%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84.assets/image-20210605142621467.png" alt="image-20210605142621467"></p><p>可以把num2直接放到num1后面，然后再进行升序排列，只不过效率有点低了。</p><p>所以我们采用下面这种解法。</p><p>num1和num2都从后往前走，取大的往后面放。</p><p><strong>如图所示：</strong></p><p><img src="/images/LeetCode%E5%88%B7%E9%A2%98(4)%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0&%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84.assets/image-20210605155039383.png" alt="image-20210605155039383"></p><p><img src="/images/LeetCode%E5%88%B7%E9%A2%98(4)%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0&%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84.assets/image-20210605155125941.png" alt="image-20210605155125941"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>* nums1, <span class="keyword">int</span> nums1Size, <span class="keyword">int</span> m, <span class="keyword">int</span>* nums2, <span class="keyword">int</span> nums2Size, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//题目所给的nums1Size和num2Size没用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> end1 = m<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> end2 = n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> end = m+n<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//end1和end2都还没有结束</span></span><br><span class="line">    <span class="keyword">while</span>(end1 &gt;= <span class="number">0</span> &amp;&amp; end2 &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把他们两个中大的放在后面</span></span><br><span class="line">        <span class="keyword">if</span>(nums1[end1] &gt; nums2[end2])</span><br><span class="line">        &#123;</span><br><span class="line">            nums1[end] = nums1[end1];</span><br><span class="line">            end--;</span><br><span class="line">            end1--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            nums1[end] = nums2[end2];</span><br><span class="line">            end--;</span><br><span class="line">            end2--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果end2先结束，就是num2里面已经没有元素了，那就不需要处理了，因为就是往num1里面放的</span></span><br><span class="line">    <span class="comment">//但是，如果是end1先结束了，还需要处理一下，因为此时num2里面还有元素没有放进num1里面</span></span><br><span class="line">    <span class="keyword">while</span>(end2 &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        nums1[end] = nums2[end2];</span><br><span class="line">        end--;</span><br><span class="line">        end2--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;移除元素&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;典型双指针玩法。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/remove-element/&quot;&gt;27. 移除元素 - 力扣（LeetCode） (leetcode</summary>
      
    
    
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="-C语言" scheme="http://example.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="-数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="-LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
    <category term="-数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>【线性表】之顺序表</title>
    <link href="http://example.com/2021/06/05/%E3%80%90%E7%BA%BF%E6%80%A7%E8%A1%A8%E3%80%91%E4%B9%8B%E9%A1%BA%E5%BA%8F%E8%A1%A8(C%E8%AF%AD%E8%A8%80)/"/>
    <id>http://example.com/2021/06/05/%E3%80%90%E7%BA%BF%E6%80%A7%E8%A1%A8%E3%80%91%E4%B9%8B%E9%A1%BA%E5%BA%8F%E8%A1%A8(C%E8%AF%AD%E8%A8%80)/</id>
    <published>2021-06-05T05:13:55.000Z</published>
    <updated>2021-06-05T05:34:10.310Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>线性表(linear list)是n个具有相同特性元素的有限序列 。线性表是一种在实际中广泛使用的数据结构，常见的线性表：顺序表、链表、栈、队列、字符串……</p><p>线性表在逻辑上是线性结构，也就说是连续的一条直线。但是在物理结构上并不一定是连续的，线性表在物理上存储时，通常以数组和链式结构的形式存储。</p><h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><p>它是最简单的数据结构，也是最常用的数据结构——他的作用就是将数据存起来。</p><p>概念：顺序表是用一段物理地址连续的存储单元依次存储数据元素的线性结构，一般情况下采用数组存储。在数组上完成数据的增删查改。</p><p>顺序表一般可分为：</p><p>1.静态顺序表：使用定长数据存储。</p><p>2.动态顺序表：使用动态开辟的数组存储。</p><p><strong>下面的代码实现的是动态顺序表</strong></p><h2 id="结构定义"><a href="#结构定义" class="headerlink" title="结构定义"></a>结构定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> SeqListDataType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SeqList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">SeqListDataType* arry;<span class="comment">//指向动态开辟的数组</span></span><br><span class="line"><span class="keyword">int</span> size;<span class="comment">//数组中有效数据的个数(在数组中说就是最后一个数据的下一个位置，因为数组下标是从0开始的)</span></span><br><span class="line"><span class="keyword">int</span> capacity;<span class="comment">//容量空间的大小</span></span><br><span class="line">&#125;SeqList;</span><br></pre></td></tr></table></figure><p><img src="/images/%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B9%8B%E9%A1%BA%E5%BA%8F%E8%A1%A8.assets/image-20210605131238279.png" alt="image-20210605131238279"></p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeqListInit</span><span class="params">(SeqList* ps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ps-&gt;arry = <span class="literal">NULL</span>;<span class="comment">//可以一上来就给空间，也可以不给空间</span></span><br><span class="line">ps-&gt;size = <span class="number">0</span>;</span><br><span class="line">ps-&gt;capacity = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h2><p>严格来说空间用完之后就要销毁，如果malloc开辟的空间不销毁就会存在内存泄漏。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeqListDestory</span><span class="params">(SeqList* ps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">free</span>(ps-&gt;arry);</span><br><span class="line">ps-&gt;arry = <span class="literal">NULL</span>;</span><br><span class="line">ps-&gt;capacity = ps-&gt;size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeqListPrint</span><span class="params">(SeqList* ps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ps-&gt;size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ps-&gt;arry[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展空间"><a href="#扩展空间" class="headerlink" title="扩展空间"></a>扩展空间</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeqListCheckCapacity</span><span class="params">(SeqList* ps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//如果数组满了——有效的数据个数等于空间容量的总大小</span></span><br><span class="line"><span class="keyword">if</span> (ps-&gt;size == ps-&gt;capacity)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//要注意如果满了，就进行扩容，在原来基础上*2，但是开始的空间是0，</span></span><br><span class="line"><span class="comment">//0*2还是0,所以开始插入的时候要加一个判断</span></span><br><span class="line"><span class="comment">//如果开始的空间是0，那么就给他赋值4，之后就不是0了，就给他*2</span></span><br><span class="line"><span class="keyword">int</span> newCapacity = ps-&gt;capacity == <span class="number">0</span> ? <span class="number">4</span> : ps-&gt;capacity * <span class="number">2</span>;</span><br><span class="line"><span class="comment">//realloc扩充原来开辟好的空间</span></span><br><span class="line"><span class="comment">//如果原来的空间在原来的地方是空，那就他是直接申请一个新的空间就跟malloc是一样的。</span></span><br><span class="line">SeqListDataType* tmp = (SeqListDataType*)<span class="built_in">realloc</span>(ps-&gt;arry, newCapacity * <span class="keyword">sizeof</span>(SeqListDataType));</span><br><span class="line"><span class="comment">//如果扩容失败，给予提示</span></span><br><span class="line"><span class="keyword">if</span> (tmp == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;realloc is fail!&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);<span class="comment">//退出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//把扩充好的数组传给arry</span></span><br><span class="line">ps-&gt;arry = tmp;</span><br><span class="line">ps-&gt;capacity = newCapacity;<span class="comment">//空间容量大小</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾插"><a href="#尾插" class="headerlink" title="尾插"></a>尾插</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeqListPushBack</span><span class="params">(SeqList* ps,SeqListDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SeqListCheckCapacity(ps);</span><br><span class="line">    <span class="comment">//顺序表中的数据要依次存储</span></span><br><span class="line">ps-&gt;arry[ps-&gt;size] = x;</span><br><span class="line">ps-&gt;size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="头插"><a href="#头插" class="headerlink" title="头插"></a>头插</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeqListPushFront</span><span class="params">(SeqList* ps, SeqListDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//同尾插-空间不够了需要增容</span></span><br><span class="line">SeqListCheckCapacity(ps);</span><br><span class="line"><span class="comment">//从后开始挪</span></span><br><span class="line"><span class="comment">//注意初识条件-结束条件-迭代过程</span></span><br><span class="line"><span class="comment">//先找到最后一个位置</span></span><br><span class="line"><span class="keyword">int</span> end = ps-&gt;size - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (end &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">ps-&gt;arry[end + <span class="number">1</span>] = ps-&gt;arry[end];</span><br><span class="line">end--;</span><br><span class="line">&#125;</span><br><span class="line">ps-&gt;arry[<span class="number">0</span>] = x;</span><br><span class="line">ps-&gt;size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾删"><a href="#尾删" class="headerlink" title="尾删"></a>尾删</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeqListPopBack</span><span class="params">(SeqList* ps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(ps-&gt;size &gt; <span class="number">0</span>);<span class="comment">//等于0直接报错，比较粗暴。</span></span><br><span class="line"><span class="comment">//下面这行代码没用，因为了顺序表中具体的数据个数是由size决定的</span></span><br><span class="line"><span class="comment">//把这个位置置 成0，万一这个位置本来就是0呢，或者这个位置的数据类型不是int，是double呢，置成0也不合适，没有意义。</span></span><br><span class="line"><span class="comment">//ps-&gt;arry[ps-&gt;size - 1] = 0;</span></span><br><span class="line">ps-&gt;size--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="头删"><a href="#头删" class="headerlink" title="头删"></a>头删</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeqListPopFront</span><span class="params">(SeqList* ps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//检查一下还有没有元素，没有就别删了</span></span><br><span class="line">assert(ps-&gt;size &gt; <span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> start = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//就是用后面的元素将前面的元素给覆盖了，每次消失的都是第一个，其他的依次向前推</span></span><br><span class="line"><span class="keyword">while</span> (start &lt; ps-&gt;size)</span><br><span class="line">&#123;</span><br><span class="line">ps-&gt;arry[start - <span class="number">1</span>] = ps-&gt;arry[start];</span><br><span class="line">start++;</span><br><span class="line">&#125;</span><br><span class="line">ps-&gt;size--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在指定位置插入数据"><a href="#在指定位置插入数据" class="headerlink" title="在指定位置插入数据"></a>在指定位置插入数据</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeqListInsert</span><span class="params">(SeqList* ps, <span class="keyword">int</span> pos, SeqListDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(pos &lt; ps-&gt;size);<span class="comment">//大于就报错</span></span><br><span class="line"><span class="comment">//思路：先创建空间，利用循环找到pos这个位置，将元素放入数组，size+1</span></span><br><span class="line"><span class="comment">//创建空间</span></span><br><span class="line">SeqListCheckCapacity(ps);</span><br><span class="line"><span class="comment">//找到最后一个元素</span></span><br><span class="line"><span class="keyword">int</span> end = ps-&gt;size - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (end &gt;= pos)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//依次往后推移一位，</span></span><br><span class="line">ps-&gt;arry[end + <span class="number">1</span>] = ps-&gt;arry[end];</span><br><span class="line">end--;</span><br><span class="line">&#125;</span><br><span class="line">ps-&gt;arry[pos] = x;</span><br><span class="line">ps-&gt;capacity++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除指定位置数据"><a href="#删除指定位置数据" class="headerlink" title="删除指定位置数据"></a>删除指定位置数据</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeqListErase</span><span class="params">(SeqList* ps, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(pos &lt; ps-&gt;size);</span><br><span class="line"><span class="comment">//被删除元素后面的位置</span></span><br><span class="line"><span class="keyword">int</span> start = pos + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (start &lt; ps-&gt;size)</span><br><span class="line">&#123;</span><br><span class="line">ps-&gt;arry[start - <span class="number">1</span>] = ps-&gt;arry[start];</span><br><span class="line">start++;</span><br><span class="line">&#125;</span><br><span class="line">ps-&gt;size--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SeqListFind</span><span class="params">(SeqList* ps, SeqListDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//找到返回下标，找不到返回-1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ps-&gt;size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ps-&gt;arry[i] == x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeqListModity</span><span class="params">(SeqList* ps, <span class="keyword">int</span> pos, SeqListDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(pos &lt; ps-&gt;size);</span><br><span class="line">ps-&gt;arry[pos] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;线性表&quot;&gt;&lt;a href=&quot;#线性表&quot; class=&quot;headerlink&quot; title=&quot;线性表&quot;&gt;&lt;/a&gt;线性表&lt;/h2&gt;&lt;p&gt;线性表(linear list)是n个具有相同特性元素的有限序列 。线性表是一种在实际中广泛使用的数据结构，常见的线性表：顺序表、链</summary>
      
    
    
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="-线性表" scheme="http://example.com/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>【链表】单链表的实现</title>
    <link href="http://example.com/2021/06/02/%E3%80%90%E9%93%BE%E8%A1%A8%E3%80%91%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0(C%E8%AF%AD%E8%A8%80)/"/>
    <id>http://example.com/2021/06/02/%E3%80%90%E9%93%BE%E8%A1%A8%E3%80%91%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0(C%E8%AF%AD%E8%A8%80)/</id>
    <published>2021-06-02T03:13:29.000Z</published>
    <updated>2021-06-02T03:23:49.484Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/%E3%80%90%E9%93%BE%E8%A1%A8%E3%80%91%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0.assets/image-20210602112335408.png" alt="image-20210602112335408"></p><h2 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> SLTDataType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">SLTDataType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SListNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;SLTNode;</span><br></pre></td></tr></table></figure><h2 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SLTPrint</span><span class="params">(SLTNode* phead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SLTNode* cur = phead;</span><br><span class="line"><span class="keyword">while</span> (cur !=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, cur-&gt;data);</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建结点"><a href="#创建结点" class="headerlink" title="创建结点"></a>创建结点</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SLTNode* <span class="title">SLTCreat</span><span class="params">(SLTDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SLTNode* newnode = (SLTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SLTNode));</span><br><span class="line">newnode-&gt;data = x;</span><br><span class="line">newnode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> newnode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾插"><a href="#尾插" class="headerlink" title="尾插"></a>尾插</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SLTPushBack</span><span class="params">(SLTNode** pphead, SLTDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建新结点</span></span><br><span class="line">SLTNode* newnode = SLTCreat(x);</span><br><span class="line"><span class="comment">//如果是空链表</span></span><br><span class="line"><span class="keyword">if</span> (*pphead == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">*pphead = newnode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="comment">//找到尾结点</span></span><br><span class="line">SLTNode* tail = *pphead;</span><br><span class="line"><span class="keyword">while</span> (tail-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">tail = tail-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">tail-&gt;next = newnode;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="头插"><a href="#头插" class="headerlink" title="头插"></a>头插</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SLTPushFront</span><span class="params">(SLTNode** pphead, SLTDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建新结点</span></span><br><span class="line">SLTNode* newnode = SLTCreat(x);</span><br><span class="line">newnode-&gt;next = *pphead;</span><br><span class="line">*pphead = newnode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾删"><a href="#尾删" class="headerlink" title="尾删"></a>尾删</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SLTPopBack</span><span class="params">(SLTNode** pphead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//空链表</span></span><br><span class="line"><span class="keyword">if</span> (*pphead == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//链表中只有一个结点</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((*pphead)-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(*pphead);</span><br><span class="line">*pphead = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一个以上结点</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//找到尾结点</span></span><br><span class="line">SLTNode* tail = *pphead;</span><br><span class="line"><span class="comment">//找到尾结点的前一个结点</span></span><br><span class="line">SLTNode* tailPrev = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (tail-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">tailPrev = tail;</span><br><span class="line">tail = tail-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(tail);</span><br><span class="line">tailPrev-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="头删"><a href="#头删" class="headerlink" title="头删"></a>头删</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SLTPopFront</span><span class="params">(SLTNode** pphead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//如果直接free pphead就会找不到后面的结点了</span></span><br><span class="line"><span class="comment">//先保存下一个</span></span><br><span class="line">SLTNode* ppheadNext = (*pphead)-&gt;next;<span class="comment">//这里要加一个括号，因为*和-&gt;都是解引用，*是对任意的指针都可以解引用，取它指向的这个位置的数据，什么类型的指针就取几个字节，-&gt;是结构体的，这时候他们两个的优先级是一样的。</span></span><br><span class="line"><span class="built_in">free</span>(*pphead);</span><br><span class="line"><span class="comment">//这时候第一个数据就是之前第二个数据了</span></span><br><span class="line">*pphead = ppheadNext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>下面的删除和插入都要在先在链表中找到为前提。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SLTNode* <span class="title">SLTFind</span><span class="params">(SLTNode* phead,SLTDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SLTNode* pos = phead;</span><br><span class="line"><span class="keyword">while</span> (pos != <span class="literal">NULL</span>)</span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">if</span> (pos-&gt;data == x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line">pos = pos-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在指定位置前插入某个数据"><a href="#在指定位置前插入某个数据" class="headerlink" title="在指定位置前插入某个数据"></a>在指定位置前插入某个数据</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SLTInsert</span><span class="params">(SLTNode** pphead,SLTNode* pos, SLTDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//如果在第一个结点前插入数据</span></span><br><span class="line"><span class="comment">//那就是头插，直接调用头插的函数</span></span><br><span class="line"><span class="keyword">if</span> (pos == *pphead)</span><br><span class="line">&#123;</span><br><span class="line">SLTPushFront(pphead,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//创建一个新结点来存放新的数据</span></span><br><span class="line">SLTNode* newnode = SLTCreat(x);</span><br><span class="line"><span class="comment">//要在pos前面插入newnode,就得先找到pos前面的内个结点</span></span><br><span class="line">SLTNode* posPrev = *pphead;</span><br><span class="line"><span class="keyword">while</span> (posPrev-&gt;next != pos)</span><br><span class="line">&#123;</span><br><span class="line">posPrev = posPrev-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//链接起来</span></span><br><span class="line">posPrev-&gt;next = newnode;</span><br><span class="line">newnode-&gt;next = pos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除指定位置数据"><a href="#删除指定位置数据" class="headerlink" title="删除指定位置数据"></a>删除指定位置数据</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SLTErase</span><span class="params">(SLTNode** pphead, SLTNode*pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//当删除第一个结点的时候，无法找到他的前一个结点</span></span><br><span class="line"><span class="keyword">if</span> (pos == *pphead)</span><br><span class="line">&#123;</span><br><span class="line">SLTPopFront(pphead);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//单链表每次老是要寻找前一个结点</span></span><br><span class="line">SLTNode* posPrev = *pphead;</span><br><span class="line"><span class="keyword">while</span> (posPrev-&gt;next != pos)</span><br><span class="line">&#123;</span><br><span class="line">posPrev = posPrev-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">posPrev-&gt;next = pos-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(pos);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//定义结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> SLTDataType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">SLTDataType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SListNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;SLTNode;</span><br><span class="line"><span class="comment">//改变头结点的传2级指针，不改变的传1级指针</span></span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SLTPrint</span><span class="params">(SLTNode* phead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SLTNode* cur = phead;</span><br><span class="line"><span class="keyword">while</span> (cur !=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, cur-&gt;data);</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建结点</span></span><br><span class="line"><span class="function">SLTNode* <span class="title">SLTCreat</span><span class="params">(SLTDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SLTNode* newnode = (SLTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SLTNode));</span><br><span class="line">newnode-&gt;data = x;</span><br><span class="line">newnode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> newnode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//尾插</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SLTPushBack</span><span class="params">(SLTNode** pphead, SLTDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建新结点</span></span><br><span class="line">SLTNode* newnode = SLTCreat(x);</span><br><span class="line"><span class="comment">//如果是空链表</span></span><br><span class="line"><span class="keyword">if</span> (*pphead == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">*pphead = newnode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="comment">//找到尾结点</span></span><br><span class="line">SLTNode* tail = *pphead;</span><br><span class="line"><span class="keyword">while</span> (tail-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">tail = tail-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">tail-&gt;next = newnode;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//头插</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SLTPushFront</span><span class="params">(SLTNode** pphead, SLTDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建新结点</span></span><br><span class="line">SLTNode* newnode = SLTCreat(x);</span><br><span class="line">newnode-&gt;next = *pphead;</span><br><span class="line">*pphead = newnode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//尾删</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SLTPopBack</span><span class="params">(SLTNode** pphead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//空链表</span></span><br><span class="line"><span class="keyword">if</span> (*pphead == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//链表中只有一个结点</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((*pphead)-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(*pphead);</span><br><span class="line">*pphead = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一个以上结点</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//找到尾结点</span></span><br><span class="line">SLTNode* tail = *pphead;</span><br><span class="line"><span class="comment">//找到尾结点的前一个结点</span></span><br><span class="line">SLTNode* tailPrev = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (tail-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">tailPrev = tail;</span><br><span class="line">tail = tail-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(tail);</span><br><span class="line">tailPrev-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//头删</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SLTPopFront</span><span class="params">(SLTNode** pphead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//如果直接free pphead就会找不到后面的结点了</span></span><br><span class="line"><span class="comment">//先保存下一个</span></span><br><span class="line">SLTNode* ppheadNext = (*pphead)-&gt;next;<span class="comment">//这里要加一个括号，因为*和-&gt;都是解引用，*是对任意的指针都可以解引用，取它指向的这个位置的数据，什么类型的指针就取几个字节，-&gt;是结构体的，这时候他们两个的优先级是一样的。</span></span><br><span class="line"><span class="built_in">free</span>(*pphead);</span><br><span class="line"><span class="comment">//这时候第一个数据就是之前第二个数据了</span></span><br><span class="line">*pphead = ppheadNext;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line"><span class="function">SLTNode* <span class="title">SLTFind</span><span class="params">(SLTNode* phead,SLTDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SLTNode* pos = phead;</span><br><span class="line"><span class="keyword">while</span> (pos != <span class="literal">NULL</span>)</span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">if</span> (pos-&gt;data == x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line">pos = pos-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在pos前插入某个数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SLTInsert</span><span class="params">(SLTNode** pphead,SLTNode* pos, SLTDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//如果在第一个结点前插入数据</span></span><br><span class="line"><span class="comment">//那就是头插，直接调用头插的函数</span></span><br><span class="line"><span class="keyword">if</span> (pos == *pphead)</span><br><span class="line">&#123;</span><br><span class="line">SLTPushFront(pphead,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//创建一个新结点来存放新的数据</span></span><br><span class="line">SLTNode* newnode = SLTCreat(x);</span><br><span class="line"><span class="comment">//要在pos前面插入newnode,就得先找到pos前面的内个结点</span></span><br><span class="line">SLTNode* posPrev = *pphead;</span><br><span class="line"><span class="keyword">while</span> (posPrev-&gt;next != pos)</span><br><span class="line">&#123;</span><br><span class="line">posPrev = posPrev-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//链接起来</span></span><br><span class="line">posPrev-&gt;next = newnode;</span><br><span class="line">newnode-&gt;next = pos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除pos位置的数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SLTErase</span><span class="params">(SLTNode** pphead, SLTNode*pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//当删除第一个结点的时候，无法找到他的前一个结点</span></span><br><span class="line"><span class="keyword">if</span> (pos == *pphead)</span><br><span class="line">&#123;</span><br><span class="line">SLTPopFront(pphead);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//单链表每次老是要寻找前一个结点</span></span><br><span class="line">SLTNode* posPrev = *pphead;</span><br><span class="line"><span class="keyword">while</span> (posPrev-&gt;next != pos)</span><br><span class="line">&#123;</span><br><span class="line">posPrev = posPrev-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">posPrev-&gt;next = pos-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(pos);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SLTNode* plist = <span class="literal">NULL</span>;</span><br><span class="line">SLTPushBack(&amp;plist, <span class="number">0</span>);</span><br><span class="line">SLTPushBack(&amp;plist, <span class="number">2</span>);</span><br><span class="line">SLTPushBack(&amp;plist, <span class="number">3</span>);</span><br><span class="line">SLTPushBack(&amp;plist, <span class="number">4</span>);</span><br><span class="line">SLTPrint(plist);</span><br><span class="line"></span><br><span class="line">SLTNode* pos = SLTFind(plist, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (pos != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//说明找到了</span></span><br><span class="line">SLTErase(&amp;plist, pos);</span><br><span class="line">&#125;</span><br><span class="line">SLTPrint(plist);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Test1();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/%E3%80%90%E9%93%BE%E8%A1%A8%E3%80%91%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0.assets/image-202106021123354</summary>
      
    
    
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="-链表" scheme="http://example.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>【链表】带头双向循环链表</title>
    <link href="http://example.com/2021/06/01/%E3%80%90%E9%93%BE%E8%A1%A8%E3%80%91%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8(C%E8%AF%AD%E8%A8%80)/"/>
    <id>http://example.com/2021/06/01/%E3%80%90%E9%93%BE%E8%A1%A8%E3%80%91%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8(C%E8%AF%AD%E8%A8%80)/</id>
    <published>2021-06-01T11:20:42.000Z</published>
    <updated>2021-06-02T03:14:17.499Z</updated>
    
    <content type="html"><![CDATA[<hr><p>单链表存在的缺陷：</p><p>不能从后往前走,</p><p>找不到他的前驱,</p><p>指定位置 删除  增加 尾删 都要找前一个，时间复杂度都是O(n)</p><hr><p>针对上面的这些缺陷的解决方案——<strong>双向链表</strong>。</p><hr><p>实际中要实现的链表的结构非常多样，以下情况组合起来就有8种链表结构：</p><ol><li>单向、双向</li><li>带头、不带头——带哨兵位的头结点，这个结点不存储有效数据，好处是什么？尾插的判断更方便简单，带头就不需要二级指针了，（带头结点，不需要改变穿过来的指针，也就是意味着不需要传二级指针了。）</li><li>循环、非循环</li></ol><hr><ol><li>无头单向非循环：结构简单，一般不会单独用来存数据，实际中更多是作为其他数据结构的子结构，如哈希桶，图的邻接表等，另外这种数据结构在笔试面试中出现很多。</li><li>带头双向循环链表：结构最复杂，一般用在单独存储数据。实际中使用的链表数据结构，都是带头循环双向链表，另外，这个结构虽然复杂，但是使用代码代码实现的以后会发现结构带来许多优势，实现反而简单了。</li></ol><hr><h1 id="带头双向循环链表"><a href="#带头双向循环链表" class="headerlink" title="带头双向循环链表"></a>带头双向循环链表</h1><p><img src="/images/%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.assets/image-20210530182401579.png" alt="image-20210530182401579"></p><h2 id="结构体创建"><a href="#结构体创建" class="headerlink" title="结构体创建"></a>结构体创建</h2><p><strong>结构体创建：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> LSTNodeData;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">LSTNodeData data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">next</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">prev</span>;</span></span><br><span class="line">&#125;LSTNode;</span><br></pre></td></tr></table></figure><h2 id="创建结点"><a href="#创建结点" class="headerlink" title="创建结点"></a>创建结点</h2><p><strong>创建结点：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DBLSTNode* <span class="title">DBLSTCreat</span><span class="params">(DoubleListDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DBLSTNode* newnode = (DBLSTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DBLSTNode));</span><br><span class="line">newnode-&gt;data = x;</span><br><span class="line">newnode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">newnode-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> newnode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p><strong>初始化：</strong></p><p>有个小哨兵位的头结点，并且是一个循环状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DBLSTNode* <span class="title">DBLSTInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//用一个返回值可以 替代二级指针</span></span><br><span class="line">DBLSTNode* phead = DBLSTCreat(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//循环</span></span><br><span class="line">phead-&gt;next = phead;</span><br><span class="line">phead-&gt;prev = phead;</span><br><span class="line"><span class="keyword">return</span> phead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h2><p><strong>销毁：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBLSTDestory</span><span class="params">(DBLSTNode* phead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//找到第一个结点</span></span><br><span class="line">DBLSTNode* cur = phead-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (cur !=phead)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//保存下一个结点</span></span><br><span class="line">DBLSTNode* curNext = cur-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(cur);</span><br><span class="line">cur = curNext;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(phead);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>画图有利于双向链表的理解。</p><p><img src="/images/%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.assets/image-20210531122103491.png" alt="image-20210531122103491"></p><hr><h2 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h2><p><strong>打印：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBLSTPrint</span><span class="params">(DBLSTNode* phead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//如果链表是空的会发生错误吗?</span></span><br><span class="line"><span class="comment">//不会。因为phead-&gt;next还是自己。</span></span><br><span class="line">DBLSTNode* cur = phead-&gt;next;<span class="comment">//这里我容易忘记指向next</span></span><br><span class="line"><span class="keyword">while</span> (cur != phead)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, cur-&gt;data);</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾插"><a href="#尾插" class="headerlink" title="尾插"></a>尾插</h2><p><strong>尾插：</strong></p><p>双向带头循环链表，结构虽然复杂了，但是更容易操作了。</p><p>这就是结构设计的优势。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBLSTPushBack</span><span class="params">(DBLSTNode* phead, DoubleListDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建新结点</span></span><br><span class="line">DBLSTNode* newnode = DBLSTCreat(x);</span><br><span class="line"><span class="comment">//找到尾结点</span></span><br><span class="line">DBLSTNode* tail = phead-&gt;prev;</span><br><span class="line"><span class="comment">//插入-链接</span></span><br><span class="line">tail-&gt;next = newnode;</span><br><span class="line">newnode-&gt;prev = tail;</span><br><span class="line">newnode-&gt;next = phead;</span><br><span class="line">phead-&gt;prev = newnode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="头插"><a href="#头插" class="headerlink" title="头插"></a>头插</h2><p> <strong>头插：</strong></p><p>如果插入的时候链表是空的同样不会有影响。</p><p>有first这几个指针先动谁都行，没有first也可以，就是会有顺序要求。</p><p>示例：</p><p><img src="/images/%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.assets/image-20210531170125744.png" alt="image-20210531170125744"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">newnode-&gt;next = phead-&gt;next;</span><br><span class="line">phead-&gt;next-&gt;prev = newnode;</span><br><span class="line">phead-&gt;next = newnode;</span><br><span class="line">newnode-&gt;prev = phead;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBLSTPushFront</span><span class="params">(DBLSTNode* phead,DoubleListDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建新结点</span></span><br><span class="line">DBLSTNode* newnode = DBLSTCreat(x);</span><br><span class="line"><span class="comment">//拿到第一个结点</span></span><br><span class="line">DBLSTNode* first = phead-&gt;next;</span><br><span class="line"><span class="comment">//插入-链接</span></span><br><span class="line">phead-&gt;next = newnode;</span><br><span class="line">newnode-&gt;prev = phead;</span><br><span class="line">newnode-&gt;next = first;</span><br><span class="line">first-&gt;prev = newnode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="头删"><a href="#头删" class="headerlink" title="头删"></a>头删</h2><p><strong>头删：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBLSTPopFront</span><span class="params">(DBLSTNode* phead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//保存第一个和第二个结点</span></span><br><span class="line">DBLSTNode* first = phead-&gt;next;</span><br><span class="line">DBLSTNode* second = first-&gt;next;</span><br><span class="line">phead-&gt;next = second;</span><br><span class="line">second-&gt;prev = phead;</span><br><span class="line"><span class="built_in">free</span>(first);</span><br><span class="line">first = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾删"><a href="#尾删" class="headerlink" title="尾删"></a>尾删</h2><p><strong>尾删：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBLSTPopBack</span><span class="params">(DBLSTNode* phead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//找到最后的一个结点</span></span><br><span class="line">DBLSTNode* tail = phead-&gt;prev;</span><br><span class="line"><span class="comment">//找到最后一个结点的前一个结点</span></span><br><span class="line">DBLSTNode* tailPrev = tail-&gt;prev;</span><br><span class="line">tailPrev-&gt;next = phead;</span><br><span class="line">phead-&gt;prev = tailPrev;</span><br><span class="line"><span class="built_in">free</span>(tail);</span><br><span class="line">tail = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找位置"><a href="#查找位置" class="headerlink" title="查找位置"></a>查找位置</h2><p><strong>查找位置：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DBLSTNode* <span class="title">DBLSTFind</span><span class="params">(DBLSTNode* phead,DoubleListDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//从第一个结点开始往下寻找，找到返回结点</span></span><br><span class="line">DBLSTNode* cur = phead-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (cur != phead)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;data == x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DBLSTNode* pos = DBLSTFind(phead,x);</span><br><span class="line"><span class="keyword">if</span>(pos)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;找到了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;没找到&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除pos位置的值"><a href="#删除pos位置的值" class="headerlink" title="删除pos位置的值"></a>删除pos位置的值</h2><p><strong>删除pos位置的值：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBLSTErase</span><span class="params">(DBLSTNode* pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//找到pos的前一个</span></span><br><span class="line">DBLSTNode* posPrev = pos-&gt;prev;</span><br><span class="line"><span class="comment">//找到pos的后一个</span></span><br><span class="line">DBLSTNode* posNext = pos-&gt;next;</span><br><span class="line"><span class="comment">//链接pos的前一个和pos的后一个</span></span><br><span class="line">posPrev-&gt;next = posNext;</span><br><span class="line">posNext-&gt;prev = posPrev;</span><br><span class="line"><span class="comment">//释放pos</span></span><br><span class="line"><span class="built_in">free</span>(pos);</span><br><span class="line">pos = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在pos前插入x"><a href="#在pos前插入x" class="headerlink" title="在pos前插入x"></a>在pos前插入x</h2><p><strong>在pos前插入x：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBLSTInsert</span><span class="params">(DBLSTNode* pos, DoubleListDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//知道pos前的一个结点</span></span><br><span class="line">DBLSTNode* posPrev = pos-&gt;prev;</span><br><span class="line"><span class="comment">//创建新的结点</span></span><br><span class="line">DBLSTNode* newnode = DBLSTCreat(x);</span><br><span class="line"><span class="comment">//将新的结点插入</span></span><br><span class="line">newnode-&gt;data = x;</span><br><span class="line">newnode-&gt;prev = posPrev;</span><br><span class="line">posPrev-&gt;next = newnode;</span><br><span class="line">newnode-&gt;next = pos;</span><br><span class="line">pos-&gt;prev = newnode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="返回链表的结点数量"><a href="#返回链表的结点数量" class="headerlink" title="返回链表的结点数量"></a>返回链表的结点数量</h2><p><strong>返回链表的结点数量：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DBLSTSize</span><span class="params">(DBLSTNode* phead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//其实就是遍历一遍，找一个计数的</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">DBLSTNode* cur = phead-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (cur != phead)</span><br><span class="line">&#123;</span><br><span class="line">count++;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断链表是否为空"><a href="#判断链表是否为空" class="headerlink" title="判断链表是否为空"></a>判断链表是否为空</h2><p><strong>判断链表是否为空：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DBLSTEmpty</span><span class="params">(DBLSTNode* phead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//定义一个cur指向第一个结点，如果第一个结点就是phead,说明链表为空</span></span><br><span class="line">DBLSTNode* cur = phead-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (phead == cur)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//空</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//不为空</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p><strong>为了更快的实现一个双向循环的带头链表，我们可以直接利用Insert和Erase。</strong></p><p>如果Erase的pos位置是第一个结点，那就代表着头删，如图：</p><p><img src="/images/%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.assets/image-20210601185722567.png" alt="image-20210601185722567"></p><p>所以头删还可以这样写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBLSTPopFront</span><span class="params">(DBLSTNode* phead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DBLSTErase(phead-&gt;next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尾删同理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBLSTPopBack</span><span class="params">(DBLSTNode* phead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DBLSTErase(phead-&gt;prev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>头插：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBLSTPushFront</span><span class="params">(DBLSTNode* phead,DoubleListDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DBLSTInsert(phead-&gt;next,x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尾插：</p><p>其实就是插到头结点phead的前面。</p><p><img src="/images/%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.assets/image-20210601191026935.png" alt="image-20210601191026935"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBLSTPushBack</span><span class="params">(DBLSTNode* phead, DoubleListDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DBLSTInsert(phead, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>带头双向循环链表，任意位置插入和删除数据，时间复杂度都是O(1)。</p><p>查找最优的结构不是这个，查找就得遍历，时间复杂度还是O(N)。</p><p>查找的最优结构有三种：</p><ul><li>平衡搜索树（AVL树和红黑树）</li><li>哈希表</li><li>B树 &amp; B+树系列 (数据库底层核心引擎)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;单链表存在的缺陷：&lt;/p&gt;
&lt;p&gt;不能从后往前走,&lt;/p&gt;
&lt;p&gt;找不到他的前驱,&lt;/p&gt;
&lt;p&gt;指定位置 删除  增加 尾删 都要找前一个，时间复杂度都是O(n)&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;针对上面的这些缺陷的解决方案——&lt;strong&gt;双向链表&lt;/strong&gt;</summary>
      
    
    
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="-链表" scheme="http://example.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="-双向链表" scheme="http://example.com/tags/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题(3)【链表】环形链表(C语言)</title>
    <link href="http://example.com/2021/05/27/LeetCode%E5%88%B7%E9%A2%98(3)%E3%80%90%E9%93%BE%E8%A1%A8%E3%80%91%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8(C%E8%AF%AD%E8%A8%80)/"/>
    <id>http://example.com/2021/05/27/LeetCode%E5%88%B7%E9%A2%98(3)%E3%80%90%E9%93%BE%E8%A1%A8%E3%80%91%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8(C%E8%AF%AD%E8%A8%80)/</id>
    <published>2021-05-27T10:21:19.000Z</published>
    <updated>2021-06-11T13:00:50.007Z</updated>
    
    <content type="html"><![CDATA[<p><strong>环形链表</strong></p><p><a href="https://leetcode-cn.com/problems/linked-list-cycle/">141. 环形链表 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p>什么是链表带环：链表的最后一个元素不指向空而指向前面的某个结点。</p><p>思路：<strong>快慢指针</strong>，慢指针走一步，快指针走两步，二者先后 进入环内进行追逐，最终会在某个点相遇。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(struct ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">slow</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">fast</span> =</span> head;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(slow == fast)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>扩展：</strong></p><p>请证明：</p><p>**(1)**slow和fast一定会在环里面相遇呢？有没有可能永远追不上？</p><p>当slow 走1步，fast走2步时，<strong>一定可以</strong>追上。</p><p>若slow和fast已经进入环中，追逐已经开始了，假设他们之间的距离是N,slow走1步，fast走2步，二者的距离每次缩减1，N,N-1,N-2,……0,直到相遇。</p><p>**(2)**slow一次走1步，fast一次走3不行不行？4不行不行？    </p><p><strong>不一定可以追上，甚至有可能会进入死循环。</strong>我比你快不一定追上，因为存在错过。若开始追逐，假设二者距离为N，假设slow走1步，fast走3步，距离每次缩减2，N,N-2,N-4,N-6……。如果N是偶数最后会减到0，如果N是偶数则减到-1，距离为0代表相遇，距离为-1代表反超了，进入新的追逐，他们之间的距离是 C-1(假设C 是环的长度)，如果C-1是偶数，就可以追上，如果C-1是奇数，就永远追不上，因为是奇数的时候又像开始那样反超，距离又是C-1，就永远追不上。</p><p>其他fast步数同理。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;环形链表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/linked-list-cycle/&quot;&gt;141. 环形链表 - 力扣（LeetCode） (leetcode-cn.com)&lt;/a&gt;</summary>
      
    
    
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="-C语言" scheme="http://example.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="-数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="-链表" scheme="http://example.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="-LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题(2)【链表】合并链表&amp;返回中间链表(C语言)</title>
    <link href="http://example.com/2021/05/26/LeetCode%E5%88%B7%E9%A2%98(2)%E3%80%90%E9%93%BE%E8%A1%A8%E3%80%91%E5%90%88%E5%B9%B6%E9%93%BE%E8%A1%A8&amp;%E8%BF%94%E5%9B%9E%E4%B8%AD%E9%97%B4%E9%93%BE%E8%A1%A8(C%E8%AF%AD%E8%A8%80)/"/>
    <id>http://example.com/2021/05/26/LeetCode%E5%88%B7%E9%A2%98(2)%E3%80%90%E9%93%BE%E8%A1%A8%E3%80%91%E5%90%88%E5%B9%B6%E9%93%BE%E8%A1%A8&amp;%E8%BF%94%E5%9B%9E%E4%B8%AD%E9%97%B4%E9%93%BE%E8%A1%A8(C%E8%AF%AD%E8%A8%80)/</id>
    <published>2021-05-26T13:21:37.000Z</published>
    <updated>2021-06-11T13:00:37.419Z</updated>
    
    <content type="html"><![CDATA[<p><strong>快慢指针问题：</strong></p><p>思路：定义一个快指针和一个慢指针，快指针走到结束的时候，慢指针刚好走到一半。</p><p><strong>链表的中间结点。</strong></p><p><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/">876. 链表的中间结点 - 力扣（LeetCode） (leetcode-cn.com)</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     struct ListNode *next;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct ListNode* middleNode(struct ListNode* head)&#123;</span><br><span class="line">    struct ListNode* slow &#x3D; head;</span><br><span class="line">    struct ListNode* fast &#x3D; head;</span><br><span class="line">    while(fast !&#x3D; NULL &amp;&amp; fast-&gt;next !&#x3D; NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        slow &#x3D; slow-&gt;next;</span><br><span class="line">        fast &#x3D; fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>合并两个有有序链表：</strong></p><p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p>思路：从头开始取两个链表中小的那个尾插到新链表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">mergeTwoLists</span><span class="params">(struct ListNode* l1, struct ListNode* l2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果有一个链表是空的，那么直接返回另个一个链表</span></span><br><span class="line">    <span class="keyword">if</span>(l1 == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l2 == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义一个头指针head和尾指针tail</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">tail</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//如果来个两边都不是空链表进入迭代循环 </span></span><br><span class="line">    <span class="keyword">while</span>(l1 != <span class="literal">NULL</span> &amp;&amp; l2 != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果取出来的值l1的小于l2的</span></span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果新链表是第一次插入</span></span><br><span class="line">            <span class="keyword">if</span>(tail == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//头尾指针都是l1的这一个元素</span></span><br><span class="line">                head = tail = l1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果新链表不是第一次插入</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//新链表的下一个结点是l1这个与元素</span></span><br><span class="line">                tail-&gt;next = l1;</span><br><span class="line">                <span class="comment">//现在的尾巴是传入的这个元素</span></span><br><span class="line">                tail = tail-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//链表l1的第一个元素往后推移一个</span></span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果l1的第一个元素大于等于l2的第一个元素</span></span><br><span class="line">        <span class="comment">//下面同上</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(tail == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                head = tail = l2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                tail-&gt;next = l2;</span><br><span class="line">                tail = tail-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//循环结束</span></span><br><span class="line">    <span class="comment">//如果链表l1或者链表l2其中的一个还有元素，那么就直接插到后面</span></span><br><span class="line">    <span class="keyword">if</span>(l1 != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tail-&gt;next = l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l2 != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tail-&gt;next = l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;快慢指针问题：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;思路：定义一个快指针和一个慢指针，快指针走到结束的时候，慢指针刚好走到一半。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;链表的中间结点。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-</summary>
      
    
    
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="-C语言" scheme="http://example.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="-数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="-链表" scheme="http://example.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="-LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题(1)【链表】反转链表(C语言)</title>
    <link href="http://example.com/2021/05/23/LeetCode%E5%88%B7%E9%A2%98(1)%E3%80%90%E9%93%BE%E8%A1%A8%E3%80%91%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8(C%E8%AF%AD%E8%A8%80)/"/>
    <id>http://example.com/2021/05/23/LeetCode%E5%88%B7%E9%A2%98(1)%E3%80%90%E9%93%BE%E8%A1%A8%E3%80%91%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8(C%E8%AF%AD%E8%A8%80)/</id>
    <published>2021-05-23T07:25:29.000Z</published>
    <updated>2021-06-11T13:00:30.804Z</updated>
    
    <content type="html"><![CDATA[<hr><p>题目链接——<a href="https://leetcode-cn.com/problems/reverse-linked-list/submissions/">206. 反转链表 - 力扣（LeetCode） (leetcode-cn.com)</a>**</p><hr><p><strong>反转链表</strong></p><p><strong>思路一:反转指针</strong>。</p><p><img src="/images/LeetCode%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.assets/image-20210523125459086.png" alt="image-20210523125459086"></p><p>本质上就是调转指针的方向。</p><p>首先我们定义两个指针,一个叫n1，一个叫n2。(Node1,Node2)</p><p><img src="/images/LeetCode%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.assets/image-20210523125823700.png" alt="image-20210523125823700"></p><p>让n2指向第一个结点，让n1指向空。</p><p><img src="/images/LeetCode%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.assets/image-20210523125932679.png" alt="image-20210523125932679"></p><p>n2-&gt;next指向n1。</p><p><img src="/images/LeetCode%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.assets/image-20210523130017978.png" alt="image-20210523130017978"></p><p>但是，两个指针是反不转的。因为：</p><p>这里让n2-&gt;next指向n1，就是把n1的值存到n2的next上，n2-&gt;next原来存的是2的地址，现在存的是NULL，但是继续往后走的时候，我们发现找不到2了 。</p><p>所以要反转指针，两个指针是反不动的，要用3个。</p><p>前两个指针 反转，最后一个指针负责记录下一个位置。</p><p><img src="/images/LeetCode%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.assets/image-20210523130643211.png" alt="image-20210523130643211"></p><p><img src="/images/LeetCode%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.assets/image-20210523131751386.png" alt="image-20210523131751386"></p><p><img src="/images/LeetCode%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.assets/image-20210523131821728.png" alt="image-20210523131821728"></p><p><img src="/images/LeetCode%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.assets/image-20210523131916171.png" alt="image-20210523131916171"></p><p>什么时候结束</p><p>n2 == NULL；</p><hr><p>重复的条件用循环解决</p><ol><li>初始条件</li><li>迭代过程</li><li>结束条件</li></ol><p>画图看起来很浪费时间，但提升了写代码的体验，更好的解决问题。</p><hr><p><strong>代码实现：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">reverseList</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化条件</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">n1</span> =</span> <span class="literal">NULL</span>,*n2 = head,*n3 = n2-&gt;next;</span><br><span class="line">    <span class="comment">//结束条件</span></span><br><span class="line">    <span class="keyword">while</span>(n2 != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//迭代过程</span></span><br><span class="line">        n2-&gt;next = n1;</span><br><span class="line">        <span class="comment">//往后推移</span></span><br><span class="line">        <span class="comment">//两个相等就是往后推移</span></span><br><span class="line">        n1 = n2;</span><br><span class="line">        n2 = n3;</span><br><span class="line">        <span class="keyword">if</span>(n3 != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;   </span><br><span class="line">            n3 = n3-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n1;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p><strong>思路二：头插法</strong></p><p>取结点头插到新链表中。cur是当前操作结点，用一个next来保存下一个结点(同上)。</p><p>文字简单描述：</p><p>​    从原链表去一个点下来，放到新的链表中，当做新链表的头结点cur = newhead,</p><p>迭代往后走，取下一个结点……</p><p><strong>代码实现：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">reverseList</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">cur</span> =</span> head;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">newHead</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">   <span class="keyword">while</span>(cur != <span class="literal">NULL</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">next</span> =</span> cur-&gt;next;</span><br><span class="line">        <span class="comment">//头插法</span></span><br><span class="line">        cur-&gt;next =newHead;</span><br><span class="line">        newHead = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;题目链接——&lt;a href=&quot;https://leetcode-cn.com/problems/reverse-linked-list/submissions/&quot;&gt;206. 反转链表 - 力扣（LeetCode） (leetcode-cn.com)&lt;/a&gt;**&lt;/</summary>
      
    
    
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="-C语言" scheme="http://example.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="-数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="-链表" scheme="http://example.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="-LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>C语言实现学生成绩管理系统</title>
    <link href="http://example.com/2021/05/19/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    <id>http://example.com/2021/05/19/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-05-19T11:41:46.000Z</published>
    <updated>2021-05-19T11:45:07.052Z</updated>
    
    <content type="html"><![CDATA[<hr><p>相关视频——<a href="https://www.bilibili.com/video/BV13z4y117qC?p=8">【C/C++课程设计】史上最全最详细的学生成绩管理系统上线啦，完成大学课程设计不是问题！_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili</a></p><hr><p><strong>代码实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;conio.h&gt;//从键盘接收一个按键，无序按回车的那种</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">//定义学生</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">int</span> stuNum;<span class="comment">//学号</span></span><br><span class="line"><span class="keyword">int</span> score;<span class="comment">//成绩</span></span><br><span class="line">&#125;Student;</span><br><span class="line"><span class="comment">//定义链表的结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">Student stu;<span class="comment">//学生-数据域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Node</span>* <span class="title">pNext</span>;</span><span class="comment">//指向下一个结点的指针</span></span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="comment">//定义头结点</span></span><br><span class="line">Node* g_pHead = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//录入学生信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inputStudent</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建一个结点-动态开辟</span></span><br><span class="line">Node* pNewNode = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">pNewNode-&gt;pNext = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//头插法</span></span><br><span class="line"><span class="keyword">if</span> (g_pHead == <span class="literal">NULL</span>)<span class="comment">//原来什么也没有</span></span><br><span class="line">&#123;</span><br><span class="line">g_pHead = pNewNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">pNewNode-&gt;pNext = g_pHead;</span><br><span class="line">g_pHead = pNewNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入学生姓名:\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, pNewNode-&gt;stu.name);<span class="comment">//name是数组名，不用加&amp;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入学生年龄:\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;pNewNode-&gt;stu.age);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入学生的学号:\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;pNewNode-&gt;stu.stuNum);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入学生的成绩:\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;pNewNode-&gt;stu.score);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;录入完成！\n&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);<span class="comment">//清屏</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印学生信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStudent</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;——————————————------——————————————------\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*\t————————欢迎使用高校学生管理系统——————----\t\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;——————————————------——————————————------\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*\t学号\t*\t姓名\t*\t年龄\t*\t成绩*\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;——————————————------——————————————------\n&quot;</span>);</span><br><span class="line"><span class="comment">//遍历链表</span></span><br><span class="line">Node* p = g_pHead;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t%d\t\t%s\t\t%d\t\t%d\t\n&quot;</span>,p-&gt;stu.stuNum,p-&gt;stu.name,p-&gt;stu.age,p-&gt;stu.score);</span><br><span class="line">p = p-&gt;pNext;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;——————————————------——————————————------\n&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//保存学生信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saveStudent</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="comment">//打开文件</span></span><br><span class="line">FILE* fp = fopen(<span class="string">&quot;文件路径&quot;</span>,<span class="string">&quot;w&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;打开文件失败。\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历链表</span></span><br><span class="line">Node* p = g_pHead;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">fwrite(&amp;p-&gt;stu, <span class="number">1</span>,<span class="keyword">sizeof</span>(Student),fp);</span><br><span class="line">p = p-&gt;pNext;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭文件</span></span><br><span class="line">fclose(fp);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;保存数据成功。\n&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读取学生信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">browerStudent</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//打开文件</span></span><br><span class="line">FILE* fp = fopen(<span class="string">&quot;C:\\Users\\xuanxuan\\Desktop\\test.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;打开文件失败。\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读文件</span></span><br><span class="line">Student stu;</span><br><span class="line"><span class="keyword">while</span> (fread(&amp;stu, <span class="number">1</span>, <span class="keyword">sizeof</span>(Student), fp))<span class="comment">//只要不是文件末尾就继续读</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//创建一个新结点</span></span><br><span class="line">Node* pNewNode = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">pNewNode-&gt;pNext = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">memcpy</span>(pNewNode,&amp;stu,<span class="keyword">sizeof</span>(Student));</span><br><span class="line"></span><br><span class="line"><span class="comment">//头插法</span></span><br><span class="line"><span class="keyword">if</span> (g_pHead == <span class="literal">NULL</span>)<span class="comment">//原来什么也没有</span></span><br><span class="line">&#123;</span><br><span class="line">g_pHead = pNewNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">pNewNode-&gt;pNext = g_pHead;</span><br><span class="line">g_pHead = pNewNode;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭文件</span></span><br><span class="line">fclose(fp);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;加载数据成功。\n&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//统计所有学生人数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countStudent</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> nCount = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//遍历链表</span></span><br><span class="line">Node* p = g_pHead;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">nCount++;</span><br><span class="line">p = p-&gt;pNext;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nCount;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找学生</span></span><br><span class="line"><span class="function">Node* <span class="title">findStudent</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> nStudent;</span><br><span class="line"><span class="keyword">char</span> nName[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入要查找的学生学号:\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;nStudent);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入要查找的学生姓名:\n&quot;</span>, nName);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,nName);</span><br><span class="line"><span class="comment">//遍历链表</span></span><br><span class="line">Node* p = g_pHead;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;stu.stuNum == nStudent || <span class="number">0</span> == <span class="built_in">strcmp</span>(p-&gt;stu.name , nName))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line">p = p-&gt;pNext;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修改学生信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modifyStudent</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> nStunum;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入要修改学生的学号:\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;nStunum);</span><br><span class="line">Node* p = g_pHead;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;stu.stuNum == nStunum)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入修改学生的姓名 年龄 成绩：\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s %d %d&quot;</span>, p-&gt;stu.name, &amp;p-&gt;stu.age, &amp;p-&gt;stu.score);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;修改成功。\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">p = p-&gt;pNext;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;没有找到该学生信息。\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除学生信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteStudent</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> nStunum;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入要删除的学生学号。\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;nStunum);</span><br><span class="line"></span><br><span class="line">Node* p1,*p2;</span><br><span class="line"><span class="comment">//判断是不是头结点</span></span><br><span class="line"><span class="keyword">if</span> (g_pHead-&gt;stu.stuNum == nStunum)</span><br><span class="line">&#123;</span><br><span class="line">p1 = g_pHead;</span><br><span class="line">g_pHead = g_pHead-&gt;pNext;</span><br><span class="line"><span class="built_in">free</span>(p1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;删除成功。\n&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不是头结点</span></span><br><span class="line">Node* p = g_pHead;</span><br><span class="line"><span class="keyword">while</span> (p-&gt;pNext != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;pNext-&gt;stu.stuNum == nStunum)</span><br><span class="line">&#123;</span><br><span class="line">p2 = p-&gt;pNext;</span><br><span class="line">p-&gt;pNext = p-&gt;pNext-&gt;pNext;</span><br><span class="line"><span class="built_in">free</span>(p2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;删除成功。\n&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">p = p-&gt;pNext;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;pNext == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;pNext ==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;查无此人。\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主菜单</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mainMenu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;——————————————------\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*\t欢迎使用高校学生管理系统*\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;——————————————------\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*\t1.录入学生信息\t\t*\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*\t2.打印学生信息\t\t*\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*\t3.保存学生信息\t\t*\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*\t4.读取学生信息\t\t*\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*\t5.统计所有学生人数\t*\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*\t6.查找学生信息\t\t*\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*\t7.修改修生信息\t\t*\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*\t8.删除学生信息\t\t*\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*\t0.退出系统\t\t*\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;——————————————------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//键盘输入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">keyDown</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">char</span> ch = _getch();</span><br><span class="line"><span class="keyword">switch</span> (ch)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>:<span class="comment">//录入</span></span><br><span class="line">inputStudent();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;2&#x27;</span>:<span class="comment">//打印</span></span><br><span class="line">printStudent();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;3&#x27;</span>:<span class="comment">//保存</span></span><br><span class="line">saveStudent();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;4&#x27;</span>:<span class="comment">//读取</span></span><br><span class="line">browerStudent();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;5&#x27;</span>:<span class="comment">//统计</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;学生总人数为:%d\n&quot;</span>, countStudent());</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;6&#x27;</span>:<span class="comment">//查找</span></span><br><span class="line">&#123;</span><br><span class="line">Node* p = findStudent();</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;学号:%d\t姓名:%s\t年龄:%d\t成绩:%d\n&quot;</span>, p-&gt;stu.stuNum, p-&gt;stu.name, p-&gt;stu.age, p-&gt;stu.score);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;没有找到该学生。\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;7&#x27;</span>:<span class="comment">//修改</span></span><br><span class="line">modifyStudent();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;8&#x27;</span>:<span class="comment">//删除</span></span><br><span class="line">deleteStudent();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span>:<span class="comment">//退出</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入错误，请重新输入。\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">mainMenu();</span><br><span class="line">keyDown();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;相关视频——&lt;a href=&quot;https://www.bilibili.com/video/BV13z4y117qC?p=8&quot;&gt;【C/C++课程设计】史上最全最详细的学生成绩管理系统上线啦，完成大学课程设计不是问题！_哔哩哔哩 (゜-゜)つロ 干杯~-bilibi</summary>
      
    
    
    
    <category term="C语言" scheme="http://example.com/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="-C语言" scheme="http://example.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C语言文件操作</title>
    <link href="http://example.com/2021/05/18/C%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <id>http://example.com/2021/05/18/C%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</id>
    <published>2021-05-18T08:37:38.000Z</published>
    <updated>2021-05-18T08:44:09.503Z</updated>
    
    <content type="html"><![CDATA[<hr><p>相关视频——<a href="https://www.bilibili.com/video/BV1F54y1r7ww?from=search&seid=15927253292233017726">C语言精华——C语言文件操作，文件打开、关闭、读取、定位如何操作？为你逐一讲解文件操作标准库函数_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili</a></p><hr><p><strong>文件分类：</strong></p><p>一种是文本文件，一种是二进制文件。</p><ul><li>文本文件：保存的时候，没一个字符对应一个字节。</li><li>二进制文件：按照二进制编码保存的文件。</li></ul><p><strong>文件操作：</strong></p><h1 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a><strong>打开文件</strong></h1><p> 打开文件fopen(“文件路径”，”打开方式”)</p><p>参数：-(百度百科)</p><p><img src="/images/C%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C.assets/20210517213436.png"></p><p>(选中函数按F1打开msdn文档）</p><p>打开文件成功返回一个文件指针，打不开返回 NULL。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FILE* fp = fopen(<span class="string">&quot;C:\\Users\\XX\\Desktop\\test.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;打开文件失败\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> ch = fgetc(fp);</span><br><span class="line"><span class="keyword">while</span> ((ch = fgetc(fp)) != EOF)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,ch);</span><br><span class="line">&#125;</span><br><span class="line">fclose(fp);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fclose();</span><br></pre></td></tr></table></figure><h1 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h1><h2 id="fgetc"><a href="#fgetc" class="headerlink" title="fgetc"></a>fgetc</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch  = fgetc();<span class="comment">//返回一个字符，一个字符一个字符的读取。</span></span><br></pre></td></tr></table></figure><p> 打开文件之后，到关闭文件之前操作，会有一个文件指针定位到你当前操作到哪里了，读取了一个字节，文件指针就会继续往后偏移。</p><hr><p><strong>读取完会将文件指针移动到下一个字符。</strong></p><hr><p>可以使用循环将全部文本全部内容读取。</p><h2 id="fgets"><a href="#fgets" class="headerlink" title="fgets"></a>fgets</h2><p>读取一行fgets()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">200</span>];</span><br><span class="line">fgets(str,<span class="number">200</span>,fp);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,str);</span><br></pre></td></tr></table></figure><p>也可以通过循环将内容一行一行的读取出来。</p><h2 id="fread"><a href="#fread" class="headerlink" title="fread"></a>fread</h2><p>fread想读多少读多少</p><p>fread(str存到哪,每个元素大小，读几个，文件)；</p><p>返回实际读取的大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fread(str,<span class="number">1</span>,<span class="number">10</span>,fp);</span><br></pre></td></tr></table></figure><hr><p>清零</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">200</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//初始化</span></span><br><span class="line">   或</span><br><span class="line"><span class="built_in">memset</span>(str,<span class="number">0</span>,<span class="keyword">sizeof</span>(str);</span><br><span class="line">       或</span><br><span class="line"><span class="keyword">int</span> n = fread(str,<span class="number">1</span>,<span class="number">10</span>,fp);</span><br><span class="line">str[n] = <span class="string">&#x27;\0&#x27;</span>;</span><br></pre></td></tr></table></figure><h1 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h1><h2 id="fputc"><a href="#fputc" class="headerlink" title="fputc"></a>fputc</h2><p>fputc(‘内容’,文件);</p><h2 id="fputs"><a href="#fputs" class="headerlink" title="fputs"></a>fputs</h2><p>写入一个字符串</p><p>fputs();</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* str = <span class="string">&quot;xxxxxxxxxxxxxxxxxxxxxxx\r\n&quot;</span>;</span><br><span class="line">\r\n回车</span><br><span class="line"><span class="built_in">fputs</span>(str,fp);</span><br></pre></td></tr></table></figure><h2 id="fwrite"><a href="#fwrite" class="headerlink" title="fwrite"></a>fwrite</h2><p>fwrite想写多少写多少</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">123124</span>;</span><br><span class="line">fwrite(&amp;num,<span class="keyword">sizeof</span>(num),<span class="number">1</span>,fp);</span><br><span class="line">第一个参数类型是<span class="keyword">void</span>* 可以转化为任意类型</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">char</span> sex[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;_Person;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FILE* fp = fopen(<span class="string">&quot;C:\\Users\\XX\\Desktop\\test.txt&quot;</span>, <span class="string">&quot;r+&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;打开文件失败\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">Person p1 = &#123;<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;男&quot;</span>,<span class="number">20</span>&#125;;</span><br><span class="line">fwrite(&amp;p1, <span class="number">1</span>, <span class="keyword">sizeof</span>(p1), fp);</span><br><span class="line">fclose(fp);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/C%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C.assets/image-20210518120745992.png" alt="image-20210518120745992"></p><h1 id="文件定位"><a href="#文件定位" class="headerlink" title="文件定位"></a>文件定位</h1><p>文件指针定位</p><h2 id="fseek"><a href="#fseek" class="headerlink" title="fseek"></a>fseek</h2><p>fseek(fp,0,SEEK_SET)</p><p>能够移动文件指针</p><p>可以指定文件从哪里开始读取</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">200</span>];</span><br><span class="line">fseek(fp, <span class="number">10</span>, SEEK_SET);</span><br><span class="line">fread(str,<span class="number">1</span>,<span class="number">100</span>,fp);</span><br></pre></td></tr></table></figure><p>在当前位置再往后移动x个位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fseek(fp,<span class="number">10</span>,SEEK_CUR);</span><br></pre></td></tr></table></figure><p>读取文件最后一行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fseek(fp,<span class="number">0</span>,SEEK_END);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">char</span> sex[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;_Person;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FILE* fp = fopen(<span class="string">&quot;C:\\Users\\XX\\Desktop\\test.txt&quot;</span>, <span class="string">&quot;r+&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;打开文件失败\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读取文件最后一行</span></span><br><span class="line">fseek(fp,<span class="number">0</span>,SEEK_END);</span><br><span class="line"><span class="comment">//反着读</span></span><br><span class="line">fseek(fp, <span class="number">-1</span>, SEEK_END);</span><br><span class="line"><span class="keyword">char</span> ch = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (fread(&amp;ch, <span class="number">1</span>, <span class="number">1</span>, fp))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">fseek(fp,<span class="number">-2</span>,SEEK_CUR);</span><br><span class="line">length++;<span class="comment">//统计退了多少格</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;length = %d\n&quot;</span>, length);</span><br><span class="line">fseek(fp, -length, SEEK_END);</span><br><span class="line"><span class="keyword">char</span>* buffer = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * length + <span class="number">1</span>);<span class="comment">//多一个空间存储字符串终止符</span></span><br><span class="line"><span class="built_in">memset</span>(buffer,<span class="number">0</span>,length+<span class="number">1</span>);</span><br><span class="line">fread(buffer, <span class="number">1</span>, length,fp);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buffer);</span><br><span class="line">fclose(fp);</span><br><span class="line"><span class="comment">//释放内存</span></span><br><span class="line"><span class="built_in">free</span>(buffer);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="rewind"><a href="#rewind" class="headerlink" title="rewind"></a>rewind</h2><p>重置文件指针，返回到文件的开头。</p><h2 id="ftell"><a href="#ftell" class="headerlink" title="ftell"></a>ftell</h2><p>返回当前指针位置。</p><hr><p>文件指针移动了多少个字节，该文件的大小就是多少。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rewind(fp);<span class="comment">//重置文件指针到开头</span></span><br><span class="line">fseek(fp, <span class="number">0</span>, SEEK_END);<span class="comment">//将文件指针定位到结尾</span></span><br><span class="line"><span class="keyword">int</span> nSize = ftell(fp);<span class="comment">//文件指针偏移量</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, nSize);</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;相关视频——&lt;a href=&quot;https://www.bilibili.com/video/BV1F54y1r7ww?from=search&amp;seid=15927253292233017726&quot;&gt;C语言精华——C语言文件操作，文件打开、关闭、读取、定位如何操作？为</summary>
      
    
    
    
    <category term="C语言" scheme="http://example.com/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="-C语言" scheme="http://example.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>计算机二级考试公共基础知识部分——-数据库</title>
    <link href="http://example.com/2021/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BA%8C%E7%BA%A7%E8%80%83%E8%AF%95%E5%85%AC%E5%85%B1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E9%83%A8%E5%88%86%E2%80%94%E2%80%94-%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://example.com/2021/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BA%8C%E7%BA%A7%E8%80%83%E8%AF%95%E5%85%AC%E5%85%B1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E9%83%A8%E5%88%86%E2%80%94%E2%80%94-%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2021-05-18T03:12:32.000Z</published>
    <updated>2021-05-18T03:19:57.152Z</updated>
    
    <content type="html"><![CDATA[<hr><p>相关视频——<a href="https://www.bilibili.com/video/BV1Hb411G7bV?p=23&spm_id_from=pageDriver">【极客学院】计算机等级考试二级c语言：公共基础知识部分（下）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili</a></p><p>我的小站——[半生瓜のblog](<a href="http://doraemon2.xyz/">半生瓜のblog (doraemon2.xyz)</a>)</p><p>现在是不是就只有河北和重庆还没考试了T_T。</p><hr><h1 id="数据库系统的基本概念"><a href="#数据库系统的基本概念" class="headerlink" title="数据库系统的基本概念"></a>数据库系统的基本概念</h1><ul><li>数据：描述事物的符号记录。</li><li>数据的特点：有一定的结构，有型与值之分，如整型、实型、字符型等。而数据的值给出了符合定性的值，如整形值15。</li><li>数据库(DB):是数据的集合，具有统一的结构形式并存放于统一的存储介质内，是多种应用数据的集成，并可被各个应用程序共享。</li></ul><p>数据库存放数据是按 <strong>数据所提供的数据模式存放的，具有集成与共享的特点。</strong></p><ul><li>数据库管理系统(DBMS):一种系统软件，负责数据库中的数据组织、数据操纵、数据维护、控制及保护和数据服务等，是<strong>数据库的核心。</strong></li><li>数据库管理系统的功能：<ul><li>数据模式定义；</li><li>数据存取的物理构建；</li><li>数据操纵；</li><li>数据的完整性、安全性定义与检查；</li><li>数据的并发控制与故障恢复；</li><li>数据的服务：如拷贝、转存、重组、性能监测、分析等。</li></ul></li><li>为了完成上述六个功能，数据库管理系统提供以下的数据语言：<ul><li>数据定义语言(DDL):负责数据的模式定义与数据的物理存取构建；</li><li>数据操纵语言(DML):负责数据的操纵，如增删查改等；</li><li>数据的控制语言(DCL):负责数据完整性、安全性的定义与检查以及并发控制、故障恢复等。</li></ul></li><li>数据语言按使用方式有两种结构形式：<ul><li>交互式命令( 又称自含型或自主型语言)；</li><li>宿主型命令(一般可嵌入某些宿主语言中)。</li></ul></li><li>数据库管理员(DBA):对数据库进行规划、设计、维护、监视等专业管理人员。</li><li>数据库系统(DBS):由数据库(数据)、数据库管理软件(软件)、数据库管理员(r人员)、硬件平台(硬件)、软件平台(软件)五个部分构成的运行实体。</li><li>数据库应用系统(DBAS):由数据库系统、应用软件及应用界面三者组成。</li></ul><h1 id="数据库系统的发展"><a href="#数据库系统的发展" class="headerlink" title="数据库系统的发展"></a>数据库系统的发展</h1><ul><li>数据库系统的发展：<ul><li>文件系统阶段:提供了简单的数据共享与数据管理能力，但是它无法提供完整的、统一的、管理和数据共享的能力。</li><li>层次数据库与网状数据库系统阶段:为统一与共享数据提供了有力支撑。</li><li>关系数据库系统阶段:结构简单,使用方便,逻辑性强,物理性少,使用广泛。</li></ul></li><li>数据库的<strong>根本目的</strong>：解决<strong>数据的共享</strong>问题。</li></ul><h1 id="数据库系统的基本特点"><a href="#数据库系统的基本特点" class="headerlink" title="数据库系统的基本特点"></a>数据库系统的基本特点</h1><ul><li>数据库系统的基本特点：<ul><li>数据的集成性；</li><li>数据的高共享性与低冗余性；</li><li>数据的独立性(物理独立性和逻辑独立性)；</li><li>数据的统一管理与控制。</li></ul></li></ul><h1 id="数据库系统的内部结构体系"><a href="#数据库系统的内部结构体系" class="headerlink" title="数据库系统的内部结构体系"></a>数据库系统的内部结构体系</h1><ul><li><p>数据库系统的三级模式：</p><ul><li>概念模式：数据库系统中全局数据逻辑结构的描述，全体用户公共数据视图；</li><li>外模式:也称子模式与用户模式。是用户的数据视图，也就是用户所见到的数据模式；</li><li>内模式:又称物理模式,它给出了<strong>数据库物理存储结构与物理存取方法。</strong></li></ul></li><li><p>数据库系统的两级映射</p><ul><li>概念模式到内模式映射；</li><li>外模式到概念模式的映射。</li></ul></li><li><p>示意图：</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BA%8C%E7%BA%A7%E8%80%83%E8%AF%95%E5%85%AC%E5%85%B1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E9%83%A8%E5%88%86%E2%80%94%E2%80%94-%E6%95%B0%E6%8D%AE%E5%BA%93.assets/image-20210518104351969.png" alt="image-20210518104351969"></p></li></ul><h1 id="数据库的设计与管理"><a href="#数据库的设计与管理" class="headerlink" title="数据库的设计与管理"></a>数据库的设计与管理</h1><ul><li>数据库设计概述<ul><li><strong>数据库设计是数据应用的核心</strong>。</li><li>数据库设计的两种方法：<ul><li>面向数据:以信息需求为主，兼顾处理需求；</li><li>面向过程:以处理需求为主，兼顾信息需求。 </li></ul></li><li>数据库的生命周期:需求分析阶段、概念设计阶段、逻辑设计阶段、物理设计阶段、编码阶段、测试阶段、运行阶段、进一步修改阶段。</li></ul></li><li>数据设计的需求分析<ul><li>需求分析:主要任务是收集和分析数据，这一阶段收集的基础数据和数据流图是下一阶段的基础。</li><li>需求分析常用结构化分析方法和面向对象的方法。<ul><li>结构化分析(SA）方法用自顶向下、逐层分解的方式分析系统。用数据流图表达数据和处理过程的关系。对数据库设计来讲，数据字典是进行详细的数据收集和数据分析所获得的主要结果。</li><li>数据字典是各类数据描述的集合,包括5个部分:数据项数据结构、数据流（可以是数据项,也可以是数据结构)、数据存储、处理过程。</li></ul></li></ul></li><li>数据库概念设计<ul><li>数据库<strong>概念设计</strong>的目的是<strong>分析数据内在的语义关系</strong>，建立数据的抽象模型，即E-R图。</li><li>设计的方法有两种：<ul><li>集中式模式设计法(适用于小型或并不复杂的单位或部门)；</li><li>视图集成设计法。</li></ul></li><li> E-R模型与视图集成</li><li>视图设计一般有三种设计次序:自顶向下、由底向上、由内向外。</li><li>视图集成的几种冲突:命名冲突、概念冲突、域冲突、约束冲突。</li></ul></li><li>数据库的逻辑设计<ul><li><strong>逻辑设计</strong>:将E-R图转化为制定RDBMS中的关系模式。</li><li>关系视图设计:关系视图的设计又称外模式设计。</li><li>关系视图的主要作用:<ul><li>提供数据逻辑独立性；</li><li>能适应用户对数据的不同需求；</li><li>有一定数据保密功能。 </li></ul></li></ul></li><li>数据库的物理设计<ul><li>数据库的物理设计主要目标是对数据内部物理结构作调整并选择合理的存取路径,以提高数据库访问速度有效利用存储空间。</li><li>一般RDBMS中留给用户参与物理设计的内容大致有索引设计、集成簇设计和分区设计。</li></ul></li><li>数据库管理<ul><li>数据库的建立；</li><li>数据库的调整；</li><li>数据库的重组；</li><li>数据库安全性与完整性控制；</li><li>数据库的故障恢复；</li><li>数据库监控。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;相关视频——&lt;a href=&quot;https://www.bilibili.com/video/BV1Hb411G7bV?p=23&amp;spm_id_from=pageDriver&quot;&gt;【极客学院】计算机等级考试二级c语言：公共基础知识部分（下）_哔哩哔哩 (゜-゜)つロ </summary>
      
    
    
    
    
    <category term="-计算机" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="-二级" scheme="http://example.com/tags/%E4%BA%8C%E7%BA%A7/"/>
    
    <category term="-数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>C语言的灵魂——-指针</title>
    <link href="http://example.com/2021/05/16/C%E8%AF%AD%E8%A8%80%E7%9A%84%E7%81%B5%E9%AD%82%E2%80%94%E2%80%94-%E6%8C%87%E9%92%88/"/>
    <id>http://example.com/2021/05/16/C%E8%AF%AD%E8%A8%80%E7%9A%84%E7%81%B5%E9%AD%82%E2%80%94%E2%80%94-%E6%8C%87%E9%92%88/</id>
    <published>2021-05-16T12:00:28.000Z</published>
    <updated>2021-05-17T11:20:48.687Z</updated>
    
    <content type="html"><![CDATA[<hr><p>相关视频——强烈推荐<a href="https://www.bilibili.com/video/BV1bo4y1Z7xf?p=1">【强烈推荐】4小时彻底掌握C指针 - 顶尖程序员图文讲解 - UP主亲自翻译校对 (已完结)_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili</a></p><hr><p>在学习这个之前，你需要了解函数、循环、数组等C语言知识</p><hr><h1 id="指针基本介绍"><a href="#指针基本介绍" class="headerlink" title="指针基本介绍"></a>指针基本介绍</h1><hr><p>计算机的每一个字节都有一个地址。</p><p>int a,当代码运行的时候，计算机会在内存中开辟一些空间给a。分配多少空间，取决有具体的数据类型。</p><hr><p>指针是一个变量，他存放这另一个变量的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;<span class="comment">//定义一个整型变零a</span></span><br><span class="line">    <span class="keyword">int</span>* p;<span class="comment">//定义一个指针变量p</span></span><br><span class="line">    p = &amp;a;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>p是一个指针变量，换句话说p是一个可以存放整型变量地址的变量。</p><p>&amp;叫做取地址符，放在一个变量的前面，我们就得到了那个变量的地址，它返回一个指针，指向那个特定的变量。</p><p>*叫做解引用操作符，操作指针所指向的那个地址的内容（值）。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面的结果是什么？</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,&amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,p;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,&amp;p);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);<span class="comment">//a的值</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*p);<span class="comment">//a的值</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,&amp;a);<span class="comment">//a的地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,p;<span class="comment">//a的地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,&amp;p);<span class="comment">//p的地址</span></span><br></pre></td></tr></table></figure><hr><p>int* a;意味着指向整型的指针然后写出变量名。</p><h2 id="指针的算数运算"><a href="#指针的算数运算" class="headerlink" title="指针的算数运算"></a>指针的算数运算</h2><p>步长：与是指向什么类型的指针有关系，就是走一步能跨过几个字节的距离。</p><p>下面两个输出，相差4个字节。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span>* p;</span><br><span class="line">p = &amp;a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里输出的是一个垃圾值，因为我们根本就没有对这个地址分配一个整型变量，所以解引用会出现一个随机值（垃圾值）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*(p+<span class="number">1</span>));</span><br></pre></td></tr></table></figure><h1 id="指针的类型"><a href="#指针的类型" class="headerlink" title="指针的类型"></a>指针的类型</h1><p>指针是强类型的，你需要一个特定类型的指针变量来存放特定类型变量的地址，</p><p>例如对于int*来说，你就需要一个指向整型类型的指针，来存放整型数据的地址。</p><p><strong>为什么指针是强类型的？</strong></p><p><strong>因为，</strong>我们不仅使用指针来存储内存地址，同时也用来解引用他所存储的地址所对应的内容，这样我们就能访问并且修改这些地址对应的值了。</p><p><strong>不同</strong>的数据有不同的大小，例如整型在内存中占四个字节，字符型占一个字节。</p><p>假设int a = 1021;</p><p>在内存中占4个字节，32个比特位，如图：</p><p><img src="/images/C%E8%AF%AD%E8%A8%80%E7%9A%84%E7%81%B5%E9%AD%82%E2%80%94%E2%80%94-%E6%8C%87%E9%92%88.assets/image-20210511175536148.png" alt="image-20210511175536148"></p><p>​    </p><p>其中，最左边的位来表示符号位，0为正，1位负，剩下的32位来存储值。</p><p>现在声明一个整型指针来指向a,</p><p>int* p = &a;</p><p>现在打印p——printf（”%d\n”,p）;</p><p>得到的结果200，也就是说该整型变量在内存中的起始地址是200。</p><p>现在打印p所指向地址所对应的值——pintf(“%d\n”,*p);</p><p>从200开始，int类型占4个字节，到203，提取这个整型的值，得到的结果1025。</p><p><strong>代码示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1025</span>;</span><br><span class="line"><span class="keyword">int</span>* p;</span><br><span class="line">p = &amp;a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;整型所占字节数是%d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p所指向的地址是%d\np所指向的地址对应的值是%d\n&quot;</span>,p,*p);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="/images/C%E8%AF%AD%E8%A8%80%E7%9A%84%E7%81%B5%E9%AD%82%E2%80%94%E2%80%94-%E6%8C%87%E9%92%88.assets/image-20210511185807926.png" alt="image-20210511185807926"></p><p><strong>接着我们在上面的基础上生命一个字符型指针,并且将整型指针的值赋给该字符型指针。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* p0;</span><br><span class="line">p0 = p;</span><br></pre></td></tr></table></figure><p>这会提示一个编译错误，因为p0是一个字符型指针，而p是一个整型指针。</p><p><strong>下面我们进行强制类型转换,并进行输出。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p0  = (<span class="keyword">char</span>*)p;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;字符型所占的字节数是%d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p0所指向的地址是%d\np0所在指向的地址对应的值是%d\n&quot;</span>, p0, *p0);</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="/images/C%E8%AF%AD%E8%A8%80%E7%9A%84%E7%81%B5%E9%AD%82%E2%80%94%E2%80%94-%E6%8C%87%E9%92%88.assets/image-20210511190049581.png" alt="image-20210511190049581"></p><p>我们发现所对应的内存地址变了，因为程序在每次运行的时候，都会重新为变量分配内存地址。</p><p>这里p0所指向的地址所对应的值也变了，我们发现跟p并不一样，这是为什么呢？</p><p>同上面的图，这是1025作为整型在内存中的分部，整型在内存中占4个字节，32个比特位，而我们这里将他强制存进了字符型指针中，字符型在内存中占1个字节，8个比特位，</p><p><img src="/images/C%E8%AF%AD%E8%A8%80%E7%9A%84%E7%81%B5%E9%AD%82%E2%80%94%E2%80%94-%E6%8C%87%E9%92%88.assets/image-20210511190200850.png" alt="image-20210511190200850"></p><p>所以只获得了最左边的一个字节，也就是1。</p><p><img src="/images/C%E8%AF%AD%E8%A8%80%E7%9A%84%E7%81%B5%E9%AD%82%E2%80%94%E2%80%94-%E6%8C%87%E9%92%88.assets/image-20210511190512584.png" alt="image-20210511190512584"></p><h2 id="算数运算"><a href="#算数运算" class="headerlink" title="算数运算"></a>算数运算</h2><p>这里我们再次进行指针的算数运算，将p0+1获得新地址，并且对他进行解引用得到该地址所对应的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p0+1所指向的地址是%d\np0+1所指向的地址对应的值是%d\n&quot;</span>, p0+<span class="number">1</span>, *(p0+<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>结果如下图表示。</p><p><img src="/images/C%E8%AF%AD%E8%A8%80%E7%9A%84%E7%81%B5%E9%AD%82%E2%80%94%E2%80%94-%E6%8C%87%E9%92%88.assets/image-20210511191001194.png" alt="image-20210511191001194"></p><p>因为char类型所占字节数是1，所以步长(+1跳过的字节数)是1，该地址所对应的值是，</p><p><img src="/images/C%E8%AF%AD%E8%A8%80%E7%9A%84%E7%81%B5%E9%AD%82%E2%80%94%E2%80%94-%E6%8C%87%E9%92%88.assets/image-20210511191301868.png" alt="image-20210511191301868"></p><p>二进制转化为十进制表示得4(0*2^0+0 *2^1+ 1 * 2^2 = 4)。</p><hr><p>进制转化忘了的同学可以来看一下我的这篇笔记——<a href="http://doraemon2.xyz/2021/03/08/%E8%BF%9B%E5%88%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/">进制之间的转换 | 半生瓜のblog (doraemon2.xyz)</a></p><hr><h2 id="void空指针"><a href="#void空指针" class="headerlink" title="void空指针"></a>void空指针</h2><p>现在我们讨论一种通用的指针类型，它不针对某个特定的数据类型，这种类型的指针被称为void类型的指针，我们使用void来声明这种特定的指针类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* p1;p1 = p;</span><br></pre></td></tr></table></figure><p>这里我们不需要显式的类型转换,p1 = p是合法的，不会有编译错误。</p><p>但是它没有映射到特定的类型，所以我们不能对它进行解引用，*p1是违法的。</p><p>我们只能打印出地址。（p0+1也是不行的，也会有编译错误）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,p1);</span><br></pre></td></tr></table></figure><h1 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h1><p>直接上代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;int main(void)&#123;int x = 5;int* p = &amp;x;*p = 6;int** q = &amp;p;int*** r = &amp;q;return 0; &#125;</span></span></span><br></pre></td></tr></table></figure><p><strong>接下来让我们打印一些东西</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p);<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*q);<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*(*q));<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*(*r));<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*(*(*r)));</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><p><img src="/images/C%E8%AF%AD%E8%A8%80%E7%9A%84%E7%81%B5%E9%AD%82%E2%80%94%E2%80%94-%E6%8C%87%E9%92%88.assets/image-20210511200806837.png" alt="image-20210511200806837"></p><p><strong>解释：</strong></p><p><strong>第一次没读懂一定要多读几次。</strong></p><p>​    p存的是x的地址，对x进行解引用得到x的值。<br>​    q存的是p的地址，p存的是x的地址,对q进行解引用得到x的地址，再进行一次解引用就是通过x的地址寻找对应的值，那就是x的值。</p><p>​    r存的是q的地址，q存的是p的地址，第一次解引用操作就是通过q的地址找到q所存的p的地址，p存的是x的地址，再对r进行一次解引用操作，就是p的地址里面存的是x的地址，结果得到x的地址，再对r进行一次解引用操作，就是通过x的地址寻找对应的值，那就是x的值。</p><p><strong>我们通过三级指针可以直接修改x的值</strong></p><p>就是通过对指针变量的解引用来修改对应地址所对应值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">***r = <span class="number">10</span>;<span class="comment">//此时x的值由5变成了10</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**q = *p + <span class="number">2</span>;<span class="comment">//此时x的值由10变成了12</span></span><br></pre></td></tr></table></figure><h1 id="函数传值-amp-传-址-引用"><a href="#函数传值-amp-传-址-引用" class="headerlink" title="函数传值&amp;传(址)引用"></a>函数传值&amp;传(址)引用</h1><p>函数与指针。</p><p><strong>传值。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;void Increment(int a)&#123;a += 1;&#125;int main(void)&#123;int a = 10;Increment(a);printf(&quot;a = %d\n&quot;, a);return 0;&#125;</span></span></span><br></pre></td></tr></table></figure><p>我们发现值并没有改变，我们打印下两个地址看一下，</p><p><img src="/images/C%E8%AF%AD%E8%A8%80%E7%9A%84%E7%81%B5%E9%AD%82%E2%80%94%E2%80%94-%E6%8C%87%E9%92%88.assets/image-20210512111430844.png" alt="image-20210512111430844"></p><p>是两个<strong>不同的内存空间</strong>，所以值没被修改。</p><p><strong>解释：</strong></p><p>main()是主调函数，Increment()是被调函数，当我们在主调函数中调用其他函数时，这个参数叫做实参，这个被调函数的参数叫做形参，实参会被映射到形参，当这个函数被调用的时候，主函数中的实参’a’会被映射到Increment函数的形参’a’里面，当我们进行这样的调用的时候，基本上就是把一个变量拷贝到另一个变量，这种形式的函数掉用也被称为，<strong>传值调用。</strong></p><p>如果修改成功的话，这两个应该是一个地址，<strong>引出传(址)引用。</strong></p><p><strong>传(址)引用，只需要一点点的修改。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;void Increment(int* a)&#123;*a = *a + 1;&#125;int main(void)&#123;int a = 10;Increment(&amp;a);printf(&quot;%d\n&quot;,a);return 0;&#125;</span></span></span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><p>这样的函数调用不是传值，而是将变量的地址传了过去，我们可以引用这个变量，解引用并且进行一些操作，这就是传(址)引用，传(址)引用可以节省很多内存空间，相比之下引用所占的内存也会小得多，避免复杂的数据类型的拷贝，可以让我们节省内存。</p><h1 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h1><p>二者之间有很强的联系。</p><p><strong>数组名就是一个指针。</strong></p><p> 如果使用数组名,会得到一个指向数组首元素的指针。</p><p><strong>例如：</strong></p><p>int* p = a；我们甚至都不需要在a前写&amp;。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;int main(void)&#123;int a[] = &#123; 1,2,3,4,5,6 &#125;;int* p = a;return 0;&#125;</span></span></span><br></pre></td></tr></table></figure><p>如果我们打印a，会得到数组a的首元素地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);</span><br></pre></td></tr></table></figure><p>如果对它解引用会得到他首元素的值，1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*a);</span><br></pre></td></tr></table></figure><p>如果打印a+1,则会打印数组a第二个元素的地址。</p><p>同理对他解引用也会得到该地址所对应的元素值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);</span><br></pre></td></tr></table></figure><p>完整代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;int main(void)&#123;int a[] = &#123; 1,2,3,4,5,6 &#125;;printf(&quot;%d\n&quot;,a );//首元素地址printf(&quot;%d\n&quot;,&amp;a );//首元素地址printf(&quot;%d\n&quot;,*a );//首元素printf(&quot;%d\n&quot;,a[0]);//首元素return 0;&#125;</span></span></span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="/images/C%E8%AF%AD%E8%A8%80%E7%9A%84%E7%81%B5%E9%AD%82%E2%80%94%E2%80%94-%E6%8C%87%E9%92%88.assets/image-20210512204028411.png" alt="image-20210512204028411"></p><p>需要注意的是，当把数组名字作为指针的时候，不能对它进行自增操作，会报错。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;<span class="keyword">int</span>* p = a;p++;<span class="comment">//可以a++;//不可以</span></span><br></pre></td></tr></table></figure><h2 id="数组作为函数参数"><a href="#数组作为函数参数" class="headerlink" title="数组作为函数参数"></a>数组作为函数参数</h2><p>数组作为函数参数传入。</p><p><strong>代码示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;int SumOfElement(int a[],int size)&#123;int sum = 0;for (int i = 0; i &lt; size; i++)&#123;sum += a[i];&#125;return sum;&#125;int main(void)&#123;int a[] = &#123; 1,2,3,4,5,6 &#125;;//得到数组中元素个数int size = sizeof(a) / sizeof(a[0]);int Sum = SumOfElement(a,size);printf(&quot;%d\n&quot;, Sum);//得到结果21return 0;&#125;</span></span></span><br></pre></td></tr></table></figure><p>现在我们将求元素个数的代码放入SumOfElement函数中。代码如下，我们发现此时结果变成了1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;int SumOfElement(int a[])&#123;int sum = 0;int size = sizeof(a) / sizeof(a[0]);for (int i = 0; i &lt; size; i++)&#123;sum += a[i];&#125;return sum;&#125;int main(void)&#123;int a[] = &#123; 1,2,3,4,5,6 &#125;;int Sum = SumOfElement(a);printf(&quot;%d\n&quot;, Sum);return 0;&#125;</span></span></span><br></pre></td></tr></table></figure><p>结果：</p><p>​    <img src="/images/C%E8%AF%AD%E8%A8%80%E7%9A%84%E7%81%B5%E9%AD%82%E2%80%94%E2%80%94-%E6%8C%87%E9%92%88.assets/image-20210512205738054.png" alt="image-20210512205738054"></p><p><strong>这是为什么呢？</strong></p><p>当编译器看到数组作为函数参数的时候，他不会拷贝整个数组，而是仅仅创建一个同名的指针，我们这里就是创建了一个整型指针，编译器只是拷贝了主调函数的数组首元素地址。</p><p>不管你在被调函数的参数中写int a[],还是int *a,结果都是一样的，它都只是一个整形指针而已。</p><p>这里我们不是拷贝变量的值，而仅仅拷贝了一个变量的地址，所以这里是传(址)引用，这个很有意义，因为数组可以很大， 每次拷贝整个数组没有意义，他会消耗大量的内存，一次对于数组来说不使用传值引用，而是传(址)引用。</p><p>这就是为什么我们这次数组的结果是1了， 因为被调函数中的a是个整型指针，而在主函数中a是一个数组。</p><p>所以计算数组元素个数的代码，还是应该放到主函数中。</p><hr><h2 id="指针和字符数组"><a href="#指针和字符数组" class="headerlink" title="指针和字符数组"></a>指针和字符数组</h2><p><strong>字符数组</strong></p><p>在C语言中为了更高效的操作字符串，我们需要理解一些事情，</p><p>我们如何把字符串存入和字符数组，</p><p>为了能够在字符数组中存储字符串，首要的需求就是字符数组必须要足够大，大到能够容纳字符串，字符数组的大小要大于等于字符的数量+1，</p><p>C语言的字符串必须以null结尾，这就是为什么我们需要一个额外的空间，是用来存放null的。</p><p><strong>代码示例：</strong></p><p>错误例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;int main(void)&#123;char c[4];c[0] = &#x27;N&#x27;;c[1] = &#x27;S&#x27;;c[2] = &#x27;S&#x27;;c[3] = &#x27;B&#x27;;printf(&quot;%s\n&quot;, c);return 0;&#125;</span></span></span><br></pre></td></tr></table></figure><p>我们发现字母后面出现了几个乱码，这是因为我们破坏了printf的默认规则,也就是字符串必须是以null结尾吧，这就是发生<strong>未定义</strong>行为的原因。</p><p><strong>下面我们进行一下修改</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;int main(void)&#123;char c[5];c[0] = &#x27;N&#x27;;c[1] = &#x27;S&#x27;;c[2] = &#x27;S&#x27;;c[3] = &#x27;B&#x27;;c[4] = &#x27;\0&#x27;;printf(&quot;%s\n&quot;, c);return 0;&#125;</span></span></span><br></pre></td></tr></table></figure><p>结果就正常了</p><p><img src="/images/C%E8%AF%AD%E8%A8%80%E7%9A%84%E7%81%B5%E9%AD%82%E2%80%94%E2%80%94-%E6%8C%87%E9%92%88.assets/image-20210513123554138.png" alt="image-20210513123554138"></p><p><strong>其他的字符操作函数也同样需要遵守这个固定，以null为结尾。</strong></p><p>写在同一行，系统会隐式的自动添加null为结尾</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c[<span class="number">5</span>] = <span class="string">&quot;NSSB&quot;</span>;</span><br></pre></td></tr></table></figure><p> 不声明字符数组的个数也是可以的，系统会自动分配对应的字节数，例如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c[] = <span class="string">&quot;ABCD&quot;</span>;<span class="keyword">sizeof</span>(c);<span class="comment">//sizeof的结果就是5，它刚好同来存放ABCDstrlen(c);//长度是4，不包括null</span></span><br></pre></td></tr></table></figure><p>如果我们这么声明，代码如下，这时我们需要显式的声明它的结束。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c[<span class="number">5</span>] = &#123;<span class="string">&#x27;A&#x27;</span>，<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><p><strong>引入指针</strong></p><p>声明一个字符数组和一个字符指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c1[<span class="number">5</span>] = <span class="string">&quot;hello&quot;</span>;<span class="keyword">char</span>* c2;</span><br></pre></td></tr></table></figure><p>我们使用这个数组的名字和这个字符指针的名字放到等式中是成立的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">但是，将换个位置，    c1 = c2;是非法的</span><br></pre></td></tr></table></figure><p>c2中存的就是字符数组c1中首元素的地址(同上面的整型数组)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c2 =c1;</span><br></pre></td></tr></table></figure><p>解引用操作同上面的数组。</p><p><strong>代码示例：打印数组中的所有元素。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;void print(char* c)&#123;int  i = 0;//*(c+i)同理while (c[i] != &#x27;\0&#x27;)&#123;printf(&quot;%c&quot;, c[i]);i++;&#125;&#125;int main(void)&#123;char c[20] = &quot;ABCDEF&quot;;print(c);return 0;&#125;</span></span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span>* c)</span></span>&#123;<span class="keyword">while</span> (*c!= <span class="string">&#x27;\0&#x27;</span>)&#123;<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, *c);c++;&#125;&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：此时的字符数组就是一个指针，存的就是元素的地址，从首元素开始只要不是null就进入循环，然后元素地址进行自增，因为是字符型指针，所以步长就是1，遍历每个元素，直到null。</p><h2 id="指针和二维数组"><a href="#指针和二维数组" class="headerlink" title="指针和二维数组"></a>指针和二维数组</h2><p>简单复习一下什么是多维数组。</p><p><strong>就是在数组中储存数组。</strong></p><p>学习此部分之前，可以再复习一下上面指针和一维数组。</p><p><strong>个人理解</strong>：<strong>当多维数组名被当做指针的时候，多维数组就是指向指针的指针。</strong></p><p><strong>代码示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;int main(void)&#123;int B[2][3] = &#123; &#123;1,2,3&#125;,&#123;4,5,6,&#125; &#125;;int(*p)[3] = B;//打印首元素地址B[0][0]printf(&quot;%d\n&quot;, &amp;B[0][0]);printf(&quot;%d\n&quot;,B );printf(&quot;%d\n&quot;,p );printf(&quot;%d\n&quot;,*B );printf(&quot;%d\n&quot;,*p);return  0;&#125;</span></span></span><br></pre></td></tr></table></figure><p><strong>为什么我这么说呢？</strong></p><p><strong>对比理解</strong></p><p> 就是，一个二级指针，存的是一个一级指针的地址（首元素地址），然后再对该一级指针的地址进行解引用，得到该一级指针所存地址的值。</p><p><strong>例如：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,**B);<span class="comment">//当数组名被作为指针的时候，B和*B意思一样。</span></span><br></pre></td></tr></table></figure><p>当二维数组的数组B被当成指针的时候，他里面存的是B [0] [0]的地址，再对他进行解引用得到的是对应的值，1。</p><p>（<strong>（同上）</strong>因为直接使用数组名会返回该数组的首元素的指针，是二维数组中的第一个一维数组的首元素地址，然后对这个首元素进行解引用操作，得到的是第一个元素的值。）</p><p><strong>不同点：</strong></p><p>B返回一个指向一个一维数组的指针，而*B返回一个指向整型的指针，当我们只是打印地址的时候，一维数组B[0]和B[0]的首元素的起始地址是一样的，所以打印的地址是相同的，指针类型会在你尝试解引用时或者尝试做指针算术的时候起作用。</p><hr><p>B [I] [J]可以写成 *（B[i]+j）  或者 *( *(B +i)+j )。—就是把B[i]写成 *(B+i)</p><p><strong>解释：</strong>直接用 数组名返回一个指向首元素的指针，（该二维数组中对应的哪个一维数组）,然后+j是对应一位数组中的，跳过的元素个数，也就是往后跳过几个字节，得到新的元素地址，最后，解引用得到该元素的值。</p><h2 id="指针和多维数组"><a href="#指针和多维数组" class="headerlink" title="指针和多维数组"></a>指针和多维数组</h2><p>（如何理解多维数组，最左边的维数就是一共划分了几块，第二位就是在每一块中继续分为几块，依次类推。）</p><p>（定义多维数组的指针的时候，后面的参数是该数组除去一个参数的几个参数）</p><p>多维数组-例如：三维数组就是二维数组的数组。     </p><p><strong>代码示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;int main(void)&#123;int C[3][2][2] = &#123; &#123;&#123;1,2&#125;,&#123;3,4&#125;&#125;,&#123;&#123;5,6&#125;,&#123;7,8&#125;&#125;,&#123;&#123;9,10&#125;,&#123;10,11&#125;&#125; &#125;;int (*p)[2][2] = C;//首元素地址printf(&quot;%d\n&quot;, &amp;C[0][0][0]);printf(&quot;%d\n&quot;,p);printf(&quot;%d\n&quot;, *p);printf(&quot;%d\n&quot;, C[0]);//打印首元素printf(&quot;%d\n&quot;, C[0][0][0]);printf(&quot;%d\n&quot;, ***p);return 0;&#125;</span></span></span><br></pre></td></tr></table></figure><p>同上面指针和二维数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C[i][j][k] = *(C[i][j]+k) = *(*(C[i][j]+k))</span><br></pre></td></tr></table></figure><p>如果你已经理解了，请问下面这个结果是多少？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *(C[<span class="number">0</span>][<span class="number">1</span>] + <span class="number">1</span>));<span class="comment">//结果是4，上面示例中的代码。</span></span><br></pre></td></tr></table></figure><h2 id="多维数组作为参数传给函数"><a href="#多维数组作为参数传给函数" class="headerlink" title="多维数组作为参数传给函数"></a><strong>多维数组作为参数传给函数</strong></h2><p> （是几维数组,使用数组名作为指针就返回几维度-1的指针）</p><p>（例如：一维数组返回指向整型的指针，二维数组返回指向一维数组的指针，三维数组返回指二维数组的指针……）</p><p>多维数组作为函数参数的时候，数组的第一个维度可以省略，但是其余的维度需要指定。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;void Func (int (*C)[2][2])&#123;&#125;int main(void)&#123;int C[3][2][2] = &#123;&#123;&#123;1,2&#125;,&#123;3,4&#125;&#125;,&#123;&#123;5,6&#125;,&#123;7,8&#125;&#125;,&#123;&#123;9,10&#125;,&#123;10,11&#125;&#125; &#125;;Func(C);return 0;&#125;</span></span></span><br></pre></td></tr></table></figure><h1 id="指针和动态内存"><a href="#指针和动态内存" class="headerlink" title="指针和动态内存"></a>指针和动态内存</h1><hr><p>内存是机器中很关键的资源。</p><p>也可以看看我的这篇笔记——<a href="http://doraemon2.xyz/2021/04/22/C%E8%AF%AD%E8%A8%80%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%BC%80%E8%BE%9F/">C语言动态内存开辟 | 半生瓜のblog (doraemon2.xyz)</a></p><hr><p><strong>相关函数：</strong></p><p>堆上分配内存的相关函数malloc calloc realloc</p><p>释放内存free</p><hr><h2 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a><strong>malloc</strong></h2><p><strong>malloc</strong>返回一个void指针，这个指针指向了分配给我们的内存块的第一个字节的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>*p = <span class="built_in">malloc</span>(n*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure><p>我们不能解引用一个void指针，通常需要将它<strong>转化为一个特定类型的指针</strong>，然后再使用它。</p><p>因为malloc只是个通用的函数，在堆上分配一些内存，它并不关心你用这块内存存什么，它只是简单返回指向开辟出来的内存起始地址的指针。</p><p>为了使用这块内存我们需要进行<strong>指针类型转换</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* p = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(n*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure><p>动态内存的操作都是基于指针的，你拥有一个基地址指针。</p><hr><h2 id="calloc"><a href="#calloc" class="headerlink" title="calloc"></a><strong>calloc</strong></h2><p><strong>calloc</strong> 和malloc类似，callo也是返回一个void型指针， 但是calloc接收两个参数，第一个参数是特定的元素数量，第二个参数是类型的大小。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *p = (<span class="keyword">int</span> *)<span class="built_in">calloc</span>(<span class="number">3</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>))</span><br></pre></td></tr></table></figure><p>还有一个区别是，calloc在分配完内存之后会对其进行初始化，而malloc不会。</p><h2 id="realloc"><a href="#realloc" class="headerlink" title="realloc"></a><strong>realloc</strong></h2><p>如果你有一块内存，动态分配的内存，你想修改内存块的大小，那你就可以使用realloc，realloc接收两个参数，第一个参数是指向已分配内存的起始地址的指针，第二个参数是新的内存块的大小。</p><p><strong>如果去掉第一个参数，那么他和malloc是一样的效果</strong></p><p>这时会创建一个空的内存块，而不会从之前的内存块拷贝任何数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *b = (<span class="keyword">int</span> *)<span class="built_in">realloc</span>(<span class="literal">NULL</span>,n*<span class="keyword">sizeof</span>(<span class="keyword">int</span>)); </span><br></pre></td></tr></table></figure><p> <strong>第二个参数是0,那么他和free是一样的效果</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *b = (<span class="keyword">int</span>*)<span class="built_in">realloc</span>(A,<span class="number">0</span>);<span class="comment">//将A释放 = free(A)</span></span><br></pre></td></tr></table></figure><p>reallo可能会有多种场景</p><ul><li>比如我们想要的新内存块可能比原来的内存要大，这种情况下机器可能会创建一块新的内存然后把原来的值拷贝过去，然后释放之前的内存，如果之前的那块内存的相邻处，还有还有连续的内存可用，那么可能会直接扩展之前的那块内存。</li></ul><h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><p>free()将开辟出来的内存空间释放。</p><h2 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a><strong>代码示例</strong></h2><p>数组的个数不能是个变量，这时候我们就能用到动态内存开辟</p><p><strong>创建一个大小为n的数组</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main(void)&#123;int n = 0;scanf(&quot;%d&quot;, &amp;n);int* p = (int*)malloc(n * sizeof(int));    //int* p = (int *)calloc(n,sizeof(int));    //修改开辟内存大小    int* p1 = realloc(p,2*n*sizeof(int));return 0;&#125;</span></span></span><br></pre></td></tr></table></figure><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>这种情况是由于不正确的使用动态内存引起的。</p><p><strong>内存泄漏就是在堆上增长垃圾。</strong></p><p>不正确的动态内存(堆)的使用引起。由于程序中已动态分配的没有释放，造成的系统内存浪费，导致系统运行减慢或者崩溃。——百度百科。</p><h1 id="函数返回指针"><a href="#函数返回指针" class="headerlink" title="函数返回指针"></a>函数返回指针</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;int* Add(int* a,int* b)&#123;int c = *a + *b;return &amp;c;&#125;int main(void)&#123;int a = 3;int b = 5;int* z = Add(&amp;a,&amp;b);    printf(&quot;%d\n&quot;, *z);return 0;&#125;</span></span></span><br></pre></td></tr></table></figure><p>加入一个简单的函数并且调用之后，我们发现程序运行错误</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;void Print()&#123;printf(&quot;Hello world\n&quot;);&#125;int* Add(int* a,int* b)&#123;int c = *a + *b;return &amp;c;&#125;int main(void)&#123;int a = 3;int b = 5;int* z = Add(&amp;a,&amp;b);Print();printf(&quot;%d\n&quot;, *z);return 0;&#125;</span></span></span><br></pre></td></tr></table></figure><p>如图：</p><p><img src="/images/C%E8%AF%AD%E8%A8%80%E7%9A%84%E7%81%B5%E9%AD%82%E2%80%94%E2%80%94-%E6%8C%87%E9%92%88.assets/image-20210515211156453.png" alt="image-20210515211156453"></p><p><strong>这是为什么呢？</strong></p><p>栈，先进后出，先进的被压倒栈底， 当Add函数调用完成，返回一个指向结果的指针（地址），然后内存被释放，所指向的地址对应的值就是个垃圾值，尽管他指向这个地址，但是他的值是不能被保证的，因为内存被释放了，为后面的函数分配空间。</p><p>之后为Print函数分配栈空间，覆盖之前的空间。</p><hr><p>如果我们尝试将返回一个被调函数的局部变量给主函数，就像我们要返回一个Add函数的局部变量给main函数，当被调函数结束控制返回给主函数的时候，那块内存已经释放了，因此从栈顶向上传参数是可以的。</p><p>但是，</p><p>从栈顶向下传一个局部变量或者一个局部变量的地址是不可以的，</p><p>那么，什么情况下我们想要从函数返回一个指针呢？</p><p>如果我们在堆上有一个内存地址或者，在全局区有一个变量，那么我们就可以安全地返回他们的地址，因为堆上分配内存需要显示释放，由我们来控制他的释放。</p><hr><p>修改后的代码</p><p>malloc是在堆上开辟的空间不会被显式的释放。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;#include&lt;stdlib.h&gt;void Print()&#123;printf(&quot;Hello world\n&quot;);&#125;int* Add(int* a,int* b)&#123;int* c = (int*)malloc(sizeof(int));*c = *a + *b;return c;&#125;int main(void)&#123;int a = 3;int b = 5;int* z = Add(&amp;a,&amp;b);Print();printf(&quot;%d\n&quot;, *z);return 0;&#125;</span></span></span><br></pre></td></tr></table></figure><p>因此，从函数返回指针的时候，我们需要小心它的作用范围，我们必须保证地址没有被重用（用来存储其他东西），以及那个地址的数据没有被清除。</p><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>用来存储函数的地址</p><p>它指向或引用内存中的数据，这里的数据未必一定指变量，也可以是常量。</p><p>可以使用这样的指针来解引用和执行函数。</p><p>当我们说函数指针存放函数地址的时候， 我们是在说函数指针存放了函数在内存中的起始地址或者入口点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;int Add(int a, int b)&#123;return a + b;&#125;int main(void)&#123;int c = 0;    //函数返回类型 参数类型 参数类型int (*p)(int, int);p = &amp;Add;//不使用&amp;也可以，只使用函数名会返回函数的地址    //p = Add;    //p(2,3)c = (*p)(2, 3);printf(&quot;%d\n&quot;, c);return 0;&#125;  </span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;void Print()&#123;printf(&quot;Hello&quot;);&#125;int main(void)&#123;void (*p)();p = Print;p();return 0;&#125;</span></span></span><br></pre></td></tr></table></figure><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>函数指针可以被用来作为函数参数，接收函数指针的这个函数，可以回调函数指针所指向的那个函数，</p><p><strong>就是一个函数作为参数传递给另外一个函数。</strong></p><p>格式-返回类型(*函数名)(参数类型，参数类型，……)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;int compare(int a, int b)&#123;if (a &gt; b)return 1;elsereturn -1;&#125;void maopaoSort(int *a,int n,int(*compare)(int,int))&#123;int temp = 0;for (int i = 0; i &lt; n; i++)&#123;for (int j = 0; j &lt; n - 1; j++)&#123;if (compare(a[j] ,a[j+1])&gt;0)&#123;temp = a[j];a[j] = a[j + 1];a[j + 1] = temp;&#125;&#125;&#125;&#125;int main(void)&#123;int a[5] = &#123; 2,5,4,8,9 &#125;;maopaoSort(a, 5,compare);for (int i = 0; i &lt; 5; i++)&#123;printf(&quot;%d &quot;, a[i]);&#125;return  0;&#125;</span></span></span><br></pre></td></tr></table></figure><p>可以根据情况的不同写不同的回调函数</p><p>例如：比较绝对值后的大小，升序排列</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">absSort</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">if</span> (<span class="built_in">abs</span>(a) &gt; <span class="built_in">abs</span>(b))<span class="keyword">return</span> <span class="number">1</span>;<span class="keyword">else</span><span class="keyword">return</span> <span class="number">-1</span>;&#125;</span><br></pre></td></tr></table></figure><p>调用库函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int compare(const void*a,const void* b)&#123;int A = *((int*)a);int B = *((int*)b);return A - B;//值越大排名越高&#125;int main(void)&#123;int a[5] = &#123; 5,-6,-2,3,7 &#125;;qsort(a,5,sizeof(int),compare);for (int i = 0; i &lt; 5; i++)&#123;printf(&quot;%d &quot;,a[i]);&#125;return 0;&#125;</span></span></span><br></pre></td></tr></table></figure><p><img src="/images/C%E8%AF%AD%E8%A8%80%E7%9A%84%E7%81%B5%E9%AD%82%E2%80%94%E2%80%94-%E6%8C%87%E9%92%88.assets/image-20210516122128095.png" alt="image-20210516122128095"></p><p>qsort能对任何数组进行排序，不仅仅是整形数组。只是你需要给出比较逻辑。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;相关视频——强烈推荐&lt;a href=&quot;https://www.bilibili.com/video/BV1bo4y1Z7xf?p=1&quot;&gt;【强烈推荐】4小时彻底掌握C指针 - 顶尖程序员图文讲解 - UP主亲自翻译校对 (已完结)_哔哩哔哩 (゜-゜)つロ 干杯~-</summary>
      
    
    
    
    <category term="C语言" scheme="http://example.com/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="-C语言" scheme="http://example.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="-指针" scheme="http://example.com/tags/%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>初识EasyX图形编程</title>
    <link href="http://example.com/2021/05/09/%E5%88%9D%E8%AF%86EasyX%E5%9B%BE%E5%BD%A2%E7%BC%96%E7%A8%8B/"/>
    <id>http://example.com/2021/05/09/%E5%88%9D%E8%AF%86EasyX%E5%9B%BE%E5%BD%A2%E7%BC%96%E7%A8%8B/</id>
    <published>2021-05-09T05:01:35.000Z</published>
    <updated>2021-05-09T05:18:17.692Z</updated>
    
    <content type="html"><![CDATA[<hr><p>相关视频——<a href="https://www.bilibili.com/video/BV11p4y1i74A?p=1">【C/C++/EasyX】学编程，做游戏，小白快速入门图形编程，零基础入门到精通，学习就是这么快乐_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili</a></p><hr><h1 id="1-基本说明"><a href="#1-基本说明" class="headerlink" title="1.基本说明"></a>1.基本说明</h1><ul><li>EasyX是针对C++的图形库，可以帮助C/C++初学者快速上手图形和游戏编程。</li><li>比如 ,可以基于EasyX图形库很快用几何图形画一个房子，或者一辆移动的小车，可以编写俄罗斯方块 、贪吃蛇、黑白棋等小游戏。</li><li>许多人学编程是从C语言入门的，而目前的现状是“<ul><li>学校值只教基础语法，一直在黑窗口练习，同学们学的很乏味。、</li><li>即使有的学校教图形编程，也是使用一些难度较高的， 比如Win32,OpenlGl门槛依然很高，初学者容易收到打击。</li><li>开始引出我们的EasyX。</li></ul></li></ul><h1 id="2-原理"><a href="#2-原理" class="headerlink" title="2.原理"></a>2.原理</h1><p>​        基于Windows图形编程，将Windows下的复杂程序过程进行封装,将Windows下的编程过程隐藏，给用户提供一个简单熟悉的接口。用户对于图形库中函数的调用，最终都会由Windows的底层API实现。</p><h1 id="3-安装"><a href="#3-安装" class="headerlink" title="3.安装"></a>3.安装</h1><ul><li>Easyx图形库支持Vs各种版本，下载解压后，直接执行安装程序即可。</li><li>头文件graphics.h</li><li>帮助文档<a href="https://docs.easyx.cn/zh-cn/intro">EasyX 文档 - 基本说明</a></li><li>下载<a href="https://easyx.cn/">EasyX Graphics Library for C++</a></li></ul><h1 id="4-颜色"><a href="#4-颜色" class="headerlink" title="4.颜色"></a>4.颜色</h1><p>​    用RGB宏合成颜色，实际上合成出来的颜色是一个十六进制的的整数。</p><p>​    <strong>每个颜色部分的值都是0~255</strong></p><h1 id="5-坐标和设备"><a href="#5-坐标和设备" class="headerlink" title="5.坐标和设备"></a>5.坐标和设备</h1><ul><li>坐标默认的原点在窗口的左上角，X轴向右为正，Y 轴向下为正，度量单位是像素点。</li><li>设备：简单来说，就是绘图表面。<ul><li>在EasyX中,设备分两种，一种是默认的绘图窗口另一种是IMAGE对象。通过SetWorkinglmage()函数可以设置当前用于绘图的设备。设置当前用于绘图的设备后,所有的绘图函数都会绘制在该设备上。(后面再去理解)</li></ul></li></ul><h1 id="6-窗口函数"><a href="#6-窗口函数" class="headerlink" title="6.窗口函数"></a>6.窗口函数</h1><p>​    窗口函数用于窗口的一些操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">initgraph(<span class="keyword">int</span> width,<span class="keyword">int</span> height,<span class="keyword">int</span> flag = <span class="literal">NULL</span>);<span class="comment">//用于初始化绘图窗口</span></span><br><span class="line"><span class="comment">//width 指定窗口的宽度</span></span><br><span class="line"><span class="comment">//height 指定窗口的高度</span></span><br><span class="line"><span class="comment">//flag 窗口的样式默认为NULL</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">closegraph();<span class="comment">//关闭绘图窗口</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleardevice();<span class="comment">//清空绘图设备</span></span><br></pre></td></tr></table></figure><h1 id="7-图形绘制函数"><a href="#7-图形绘制函数" class="headerlink" title="7.图形绘制函数"></a>7.图形绘制函数</h1><ul><li><p>图形绘制函数用于在窗口上绘制各种图形。</p></li><li><p>绘图函数从填充样式分类可以分为无填充，有边框填充，无边框三种。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">以画圆为例</span><br><span class="line">    circle()无填充</span><br><span class="line">    fillcircle()有边框填充</span><br><span class="line">    solidcircle()无边框填充</span><br></pre></td></tr></table></figure><p>区别：</p><p><img src="/images/%E5%88%9D%E8%AF%86EasyX%E5%9B%BE%E5%BD%A2%E7%BC%96%E7%A8%8B.assets/image-20210508202623558.png" alt="image-20210508202623558"></p><ul><li>从形状来分，常用的可以分为八种。</li></ul><p><img src="/images/%E5%88%9D%E8%AF%86EasyX%E5%9B%BE%E5%BD%A2%E7%BC%96%E7%A8%8B.assets/image-20210508201228945.png" alt="image-20210508201228945"></p><ul><li>设置填充颜色setfillcolor()；</li><li>设置线条颜色setlinecolor();</li><li>设置线条样式setlinestyle();高，宽，字体</li></ul><h1 id="8-文字绘制函数"><a href="#8-文字绘制函数" class="headerlink" title="8.文字绘制函数"></a>8.文字绘制函数</h1><ul><li>文字绘制函数用于在窗口上绘制文字</li></ul><p><img src="/images/%E5%88%9D%E8%AF%86EasyX%E5%9B%BE%E5%BD%A2%E7%BC%96%E7%A8%8B.assets/image-20210508202106822.png" alt="image-20210508202106822"></p><h1 id="9-图像处理函数"><a href="#9-图像处理函数" class="headerlink" title="9.图像处理函数"></a>9.图像处理函数</h1><ul><li>图像处理函数用于在窗口上显示图片</li></ul><p><img src="/images/%E5%88%9D%E8%AF%86EasyX%E5%9B%BE%E5%BD%A2%E7%BC%96%E7%A8%8B.assets/image-20210508202202224.png" alt="image-20210508202202224"></p><h1 id="10-鼠标消息函数"><a href="#10-鼠标消息函数" class="headerlink" title="10.鼠标消息函数"></a>10.鼠标消息函数</h1><ul><li>鼠标消息函数用于获取鼠标的信息</li></ul><p><img src="/images/%E5%88%9D%E8%AF%86EasyX%E5%9B%BE%E5%BD%A2%E7%BC%96%E7%A8%8B.assets/image-20210509115406258.png" alt="image-20210509115406258"></p><h1 id="11-键盘消息函数"><a href="#11-键盘消息函数" class="headerlink" title="11.键盘消息函数"></a>11.键盘消息函数</h1><ul><li>键盘消息函数用于获取键盘按键消息</li></ul><p><img src="/images/%E5%88%9D%E8%AF%86EasyX%E5%9B%BE%E5%BD%A2%E7%BC%96%E7%A8%8B.assets/image-20210509121713266.png" alt="image-20210509121713266"></p><h1 id="12-其他函数"><a href="#12-其他函数" class="headerlink" title="12.其他函数"></a>12.其他函数</h1><p><img src="/images/%E5%88%9D%E8%AF%86EasyX%E5%9B%BE%E5%BD%A2%E7%BC%96%E7%A8%8B.assets/image-20210509122340561.png" alt="image-20210509122340561"></p><h1 id="13-音乐播放"><a href="#13-音乐播放" class="headerlink" title="13.音乐播放"></a>13.音乐播放</h1><p><img src="/images/%E5%88%9D%E8%AF%86EasyX%E5%9B%BE%E5%BD%A2%E7%BC%96%E7%A8%8B.assets/image-20210509123501332.png" alt="image-20210509123501332"></p><h1 id="易错集锦"><a href="#易错集锦" class="headerlink" title="易错集锦"></a>易错集锦</h1><ol><li><p>源文件问题： fata1 error c1189: #error : EasyXis only for C++。</p><p><strong>后缀要是cpp</strong></p></li><li><p>参数错误，找不到对应的函数：error C2665： “outtextxy”:2个重载中没有一个可以转换所有参数类型。</p><p>是由于字符集导致的，1.在字符串前面加上大写的L，2.用TEXT(_T())把字符串包起起来。</p><p>不需要添加任何代码，项目-属性-常规-字符集-使用多字节字符集</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;相关视频——&lt;a href=&quot;https://www.bilibili.com/video/BV11p4y1i74A?p=1&quot;&gt;【C/C++/EasyX】学编程，做游戏，小白快速入门图形编程，零基础入门到精通，学习就是这么快乐_哔哩哔哩 (゜-゜)つロ 干杯~-b</summary>
      
    
    
    
    <category term="图形编程" scheme="http://example.com/categories/%E5%9B%BE%E5%BD%A2%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="-C语言" scheme="http://example.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="-EasyX" scheme="http://example.com/tags/EasyX/"/>
    
    <category term="-图形编程" scheme="http://example.com/tags/%E5%9B%BE%E5%BD%A2%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
