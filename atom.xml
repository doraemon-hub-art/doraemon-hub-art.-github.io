<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>半生瓜のblog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-05-27T10:24:17.886Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Do2eM0N</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode刷题(3)【链表】环形链表</title>
    <link href="http://example.com/2021/05/27/LeetCode%E5%88%B7%E9%A2%98(3)%E3%80%90%E9%93%BE%E8%A1%A8%E3%80%91%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2021/05/27/LeetCode%E5%88%B7%E9%A2%98(3)%E3%80%90%E9%93%BE%E8%A1%A8%E3%80%91%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</id>
    <published>2021-05-27T10:21:19.000Z</published>
    <updated>2021-05-27T10:24:17.886Z</updated>
    
    <content type="html"><![CDATA[<p><strong>环形链表</strong></p><p><a href="https://leetcode-cn.com/problems/linked-list-cycle/">141. 环形链表 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p>什么是链表带环：链表的最后一个元素不指向空而指向前面的某个结点。</p><p>思路：<strong>快慢指针</strong>，慢指针走一步，快指针走两步，二者先后 进入环内进行追逐，最终会在某个点相遇。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(struct ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">slow</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">fast</span> =</span> head;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(slow == fast)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>扩展：</strong></p><p>请证明：</p><p>**(1)**slow和fast一定会在环里面相遇呢？有没有可能永远追不上？</p><p>当slow 走1步，fast走2步时，<strong>一定可以</strong>追上。</p><p>若slow和fast已经进入环中，追逐已经开始了，假设他们之间的距离是N,slow走1步，fast走2步，二者的距离每次缩减1，N,N-1,N-2,……0,直到相遇。</p><p>**(2)**slow一次走1步，fast一次走3不行不行？4不行不行？    </p><p><strong>不一定可以追上，甚至有可能会进入死循环。</strong>我比你快不一定追上，因为存在错过。若开始追逐，假设二者距离为N，假设slow走1步，fast走3步，距离每次缩减2，N,N-2,N-4,N-6……。如果N是偶数最后会减到0，如果N是偶数则减到-1，距离为0代表相遇，距离为-1代表反超了，进入新的追逐，他们之间的距离是 C-1(假设C 是环的长度)，如果C-1是偶数，就可以追上，如果C-1是奇数，就永远追不上，因为是奇数的时候又像开始那样反超，距离又是C-1，就永远追不上。</p><p>其他fast步数同理。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;环形链表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/linked-list-cycle/&quot;&gt;141. 环形链表 - 力扣（LeetCode） (leetcode-cn.com)&lt;/a&gt;</summary>
      
    
    
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="-数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="-链表" scheme="http://example.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题(2)【链表】合并链表&amp;返回中间链表</title>
    <link href="http://example.com/2021/05/26/LeetCode%E5%88%B7%E9%A2%98(2)%E3%80%90%E9%93%BE%E8%A1%A8%E3%80%91%E5%90%88%E5%B9%B6%E9%93%BE%E8%A1%A8&amp;%E8%BF%94%E5%9B%9E%E4%B8%AD%E9%97%B4%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2021/05/26/LeetCode%E5%88%B7%E9%A2%98(2)%E3%80%90%E9%93%BE%E8%A1%A8%E3%80%91%E5%90%88%E5%B9%B6%E9%93%BE%E8%A1%A8&amp;%E8%BF%94%E5%9B%9E%E4%B8%AD%E9%97%B4%E9%93%BE%E8%A1%A8/</id>
    <published>2021-05-26T13:21:37.000Z</published>
    <updated>2021-05-27T09:09:49.757Z</updated>
    
    <content type="html"><![CDATA[<p><strong>快慢指针问题：</strong></p><p>思路：定义一个快指针和一个慢指针，快指针走到结束的时候，慢指针刚好走到一半。</p><p><strong>链表的中间结点。</strong></p><p><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/">876. 链表的中间结点 - 力扣（LeetCode） (leetcode-cn.com)</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     struct ListNode *next;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct ListNode* middleNode(struct ListNode* head)&#123;</span><br><span class="line">    struct ListNode* slow &#x3D; head;</span><br><span class="line">    struct ListNode* fast &#x3D; head;</span><br><span class="line">    while(fast !&#x3D; NULL &amp;&amp; fast-&gt;next !&#x3D; NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        slow &#x3D; slow-&gt;next;</span><br><span class="line">        fast &#x3D; fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>合并两个有有序链表：</strong></p><p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p>思路：从头开始取两个链表中小的那个尾插到新链表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">mergeTwoLists</span><span class="params">(struct ListNode* l1, struct ListNode* l2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果有一个链表是空的，那么直接返回另个一个链表</span></span><br><span class="line">    <span class="keyword">if</span>(l1 == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l2 == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义一个头指针head和尾指针tail</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">tail</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//如果来个两边都不是空链表进入迭代循环 </span></span><br><span class="line">    <span class="keyword">while</span>(l1 != <span class="literal">NULL</span> &amp;&amp; l2 != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果取出来的值l1的小于l2的</span></span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果新链表是第一次插入</span></span><br><span class="line">            <span class="keyword">if</span>(tail == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//头尾指针都是l1的这一个元素</span></span><br><span class="line">                head = tail = l1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果新链表不是第一次插入</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//新链表的下一个结点是l1这个与元素</span></span><br><span class="line">                tail-&gt;next = l1;</span><br><span class="line">                <span class="comment">//现在的尾巴是传入的这个元素</span></span><br><span class="line">                tail = tail-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//链表l1的第一个元素往后推移一个</span></span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果l1的第一个元素大于等于l2的第一个元素</span></span><br><span class="line">        <span class="comment">//下面同上</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(tail == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                head = tail = l2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                tail-&gt;next = l2;</span><br><span class="line">                tail = tail-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//循环结束</span></span><br><span class="line">    <span class="comment">//如果链表l1或者链表l2其中的一个还有元素，那么就直接插到后面</span></span><br><span class="line">    <span class="keyword">if</span>(l1 != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tail-&gt;next = l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l2 != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tail-&gt;next = l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;快慢指针问题：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;思路：定义一个快指针和一个慢指针，快指针走到结束的时候，慢指针刚好走到一半。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;链表的中间结点。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-</summary>
      
    
    
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="-C语言" scheme="http://example.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="-数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="-链表" scheme="http://example.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题(1)【链表】反转链表</title>
    <link href="http://example.com/2021/05/23/LeetCode%E5%88%B7%E9%A2%98(1)%E3%80%90%E9%93%BE%E8%A1%A8%E3%80%91%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2021/05/23/LeetCode%E5%88%B7%E9%A2%98(1)%E3%80%90%E9%93%BE%E8%A1%A8%E3%80%91%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</id>
    <published>2021-05-23T07:25:29.000Z</published>
    <updated>2021-05-27T09:09:24.235Z</updated>
    
    <content type="html"><![CDATA[<hr><p>题目链接——<a href="https://leetcode-cn.com/problems/reverse-linked-list/submissions/">206. 反转链表 - 力扣（LeetCode） (leetcode-cn.com)</a>**</p><hr><p><strong>反转链表</strong></p><p><strong>思路一:反转指针</strong>。</p><p><img src="/images/LeetCode%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.assets/image-20210523125459086.png" alt="image-20210523125459086"></p><p>本质上就是调转指针的方向。</p><p>首先我们定义两个指针,一个叫n1，一个叫n2。(Node1,Node2)</p><p><img src="/images/LeetCode%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.assets/image-20210523125823700.png" alt="image-20210523125823700"></p><p>让n2指向第一个结点，让n1指向空。</p><p><img src="/images/LeetCode%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.assets/image-20210523125932679.png" alt="image-20210523125932679"></p><p>n2-&gt;next指向n1。</p><p><img src="/images/LeetCode%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.assets/image-20210523130017978.png" alt="image-20210523130017978"></p><p>但是，两个指针是反不转的。因为：</p><p>这里让n2-&gt;next指向n1，就是把n1的值存到n2的next上，n2-&gt;next原来存的是2的地址，现在存的是NULL，但是继续往后走的时候，我们发现找不到2了 。</p><p>所以要反转指针，两个指针是反不动的，要用3个。</p><p>前两个指针 反转，最后一个指针负责记录下一个位置。</p><p><img src="/images/LeetCode%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.assets/image-20210523130643211.png" alt="image-20210523130643211"></p><p><img src="/images/LeetCode%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.assets/image-20210523131751386.png" alt="image-20210523131751386"></p><p><img src="/images/LeetCode%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.assets/image-20210523131821728.png" alt="image-20210523131821728"></p><p><img src="/images/LeetCode%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.assets/image-20210523131916171.png" alt="image-20210523131916171"></p><p>什么时候结束</p><p>n2 == NULL；</p><hr><p>重复的条件用循环解决</p><ol><li>初始条件</li><li>迭代过程</li><li>结束条件</li></ol><p>画图看起来很浪费时间，但提升了写代码的体验，更好的解决问题。</p><hr><p><strong>代码实现：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">reverseList</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化条件</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">n1</span> =</span> <span class="literal">NULL</span>,*n2 = head,*n3 = n2-&gt;next;</span><br><span class="line">    <span class="comment">//结束条件</span></span><br><span class="line">    <span class="keyword">while</span>(n2 != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//迭代过程</span></span><br><span class="line">        n2-&gt;next = n1;</span><br><span class="line">        <span class="comment">//往后推移</span></span><br><span class="line">        <span class="comment">//两个相等就是往后推移</span></span><br><span class="line">        n1 = n2;</span><br><span class="line">        n2 = n3;</span><br><span class="line">        <span class="keyword">if</span>(n3 != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;   </span><br><span class="line">            n3 = n3-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n1;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p><strong>思路二：头插法</strong></p><p>取结点头插到新链表中。cur是当前操作结点，用一个next来保存下一个结点(同上)。</p><p>文字简单描述：</p><p>​    从原链表去一个点下来，放到新的链表中，当做新链表的头结点cur = newhead,</p><p>迭代往后走，取下一个结点……</p><p><strong>代码实现：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">reverseList</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">cur</span> =</span> head;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">newHead</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">   <span class="keyword">while</span>(cur != <span class="literal">NULL</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">next</span> =</span> cur-&gt;next;</span><br><span class="line">        <span class="comment">//头插法</span></span><br><span class="line">        cur-&gt;next =newHead;</span><br><span class="line">        newHead = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;题目链接——&lt;a href=&quot;https://leetcode-cn.com/problems/reverse-linked-list/submissions/&quot;&gt;206. 反转链表 - 力扣（LeetCode） (leetcode-cn.com)&lt;/a&gt;**&lt;/</summary>
      
    
    
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="-数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="-链表" scheme="http://example.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>C语言实现学生成绩管理系统</title>
    <link href="http://example.com/2021/05/19/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    <id>http://example.com/2021/05/19/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-05-19T11:41:46.000Z</published>
    <updated>2021-05-19T11:45:07.052Z</updated>
    
    <content type="html"><![CDATA[<hr><p>相关视频——<a href="https://www.bilibili.com/video/BV13z4y117qC?p=8">【C/C++课程设计】史上最全最详细的学生成绩管理系统上线啦，完成大学课程设计不是问题！_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili</a></p><hr><p><strong>代码实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;conio.h&gt;//从键盘接收一个按键，无序按回车的那种</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">//定义学生</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">int</span> stuNum;<span class="comment">//学号</span></span><br><span class="line"><span class="keyword">int</span> score;<span class="comment">//成绩</span></span><br><span class="line">&#125;Student;</span><br><span class="line"><span class="comment">//定义链表的结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">Student stu;<span class="comment">//学生-数据域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Node</span>* <span class="title">pNext</span>;</span><span class="comment">//指向下一个结点的指针</span></span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="comment">//定义头结点</span></span><br><span class="line">Node* g_pHead = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//录入学生信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inputStudent</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建一个结点-动态开辟</span></span><br><span class="line">Node* pNewNode = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">pNewNode-&gt;pNext = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//头插法</span></span><br><span class="line"><span class="keyword">if</span> (g_pHead == <span class="literal">NULL</span>)<span class="comment">//原来什么也没有</span></span><br><span class="line">&#123;</span><br><span class="line">g_pHead = pNewNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">pNewNode-&gt;pNext = g_pHead;</span><br><span class="line">g_pHead = pNewNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入学生姓名:\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, pNewNode-&gt;stu.name);<span class="comment">//name是数组名，不用加&amp;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入学生年龄:\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;pNewNode-&gt;stu.age);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入学生的学号:\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;pNewNode-&gt;stu.stuNum);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入学生的成绩:\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;pNewNode-&gt;stu.score);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;录入完成！\n&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);<span class="comment">//清屏</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印学生信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStudent</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;——————————————------——————————————------\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*\t————————欢迎使用高校学生管理系统——————----\t\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;——————————————------——————————————------\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*\t学号\t*\t姓名\t*\t年龄\t*\t成绩*\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;——————————————------——————————————------\n&quot;</span>);</span><br><span class="line"><span class="comment">//遍历链表</span></span><br><span class="line">Node* p = g_pHead;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t%d\t\t%s\t\t%d\t\t%d\t\n&quot;</span>,p-&gt;stu.stuNum,p-&gt;stu.name,p-&gt;stu.age,p-&gt;stu.score);</span><br><span class="line">p = p-&gt;pNext;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;——————————————------——————————————------\n&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//保存学生信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saveStudent</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="comment">//打开文件</span></span><br><span class="line">FILE* fp = fopen(<span class="string">&quot;文件路径&quot;</span>,<span class="string">&quot;w&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;打开文件失败。\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历链表</span></span><br><span class="line">Node* p = g_pHead;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">fwrite(&amp;p-&gt;stu, <span class="number">1</span>,<span class="keyword">sizeof</span>(Student),fp);</span><br><span class="line">p = p-&gt;pNext;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭文件</span></span><br><span class="line">fclose(fp);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;保存数据成功。\n&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读取学生信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">browerStudent</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//打开文件</span></span><br><span class="line">FILE* fp = fopen(<span class="string">&quot;C:\\Users\\xuanxuan\\Desktop\\test.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;打开文件失败。\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读文件</span></span><br><span class="line">Student stu;</span><br><span class="line"><span class="keyword">while</span> (fread(&amp;stu, <span class="number">1</span>, <span class="keyword">sizeof</span>(Student), fp))<span class="comment">//只要不是文件末尾就继续读</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//创建一个新结点</span></span><br><span class="line">Node* pNewNode = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">pNewNode-&gt;pNext = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">memcpy</span>(pNewNode,&amp;stu,<span class="keyword">sizeof</span>(Student));</span><br><span class="line"></span><br><span class="line"><span class="comment">//头插法</span></span><br><span class="line"><span class="keyword">if</span> (g_pHead == <span class="literal">NULL</span>)<span class="comment">//原来什么也没有</span></span><br><span class="line">&#123;</span><br><span class="line">g_pHead = pNewNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">pNewNode-&gt;pNext = g_pHead;</span><br><span class="line">g_pHead = pNewNode;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭文件</span></span><br><span class="line">fclose(fp);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;加载数据成功。\n&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//统计所有学生人数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countStudent</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> nCount = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//遍历链表</span></span><br><span class="line">Node* p = g_pHead;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">nCount++;</span><br><span class="line">p = p-&gt;pNext;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nCount;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找学生</span></span><br><span class="line"><span class="function">Node* <span class="title">findStudent</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> nStudent;</span><br><span class="line"><span class="keyword">char</span> nName[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入要查找的学生学号:\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;nStudent);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入要查找的学生姓名:\n&quot;</span>, nName);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,nName);</span><br><span class="line"><span class="comment">//遍历链表</span></span><br><span class="line">Node* p = g_pHead;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;stu.stuNum == nStudent || <span class="number">0</span> == <span class="built_in">strcmp</span>(p-&gt;stu.name , nName))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line">p = p-&gt;pNext;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修改学生信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modifyStudent</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> nStunum;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入要修改学生的学号:\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;nStunum);</span><br><span class="line">Node* p = g_pHead;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;stu.stuNum == nStunum)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入修改学生的姓名 年龄 成绩：\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s %d %d&quot;</span>, p-&gt;stu.name, &amp;p-&gt;stu.age, &amp;p-&gt;stu.score);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;修改成功。\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">p = p-&gt;pNext;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;没有找到该学生信息。\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除学生信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteStudent</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> nStunum;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入要删除的学生学号。\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;nStunum);</span><br><span class="line"></span><br><span class="line">Node* p1,*p2;</span><br><span class="line"><span class="comment">//判断是不是头结点</span></span><br><span class="line"><span class="keyword">if</span> (g_pHead-&gt;stu.stuNum == nStunum)</span><br><span class="line">&#123;</span><br><span class="line">p1 = g_pHead;</span><br><span class="line">g_pHead = g_pHead-&gt;pNext;</span><br><span class="line"><span class="built_in">free</span>(p1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;删除成功。\n&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不是头结点</span></span><br><span class="line">Node* p = g_pHead;</span><br><span class="line"><span class="keyword">while</span> (p-&gt;pNext != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;pNext-&gt;stu.stuNum == nStunum)</span><br><span class="line">&#123;</span><br><span class="line">p2 = p-&gt;pNext;</span><br><span class="line">p-&gt;pNext = p-&gt;pNext-&gt;pNext;</span><br><span class="line"><span class="built_in">free</span>(p2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;删除成功。\n&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">p = p-&gt;pNext;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;pNext == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;pNext ==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;查无此人。\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主菜单</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mainMenu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;——————————————------\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*\t欢迎使用高校学生管理系统*\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;——————————————------\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*\t1.录入学生信息\t\t*\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*\t2.打印学生信息\t\t*\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*\t3.保存学生信息\t\t*\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*\t4.读取学生信息\t\t*\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*\t5.统计所有学生人数\t*\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*\t6.查找学生信息\t\t*\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*\t7.修改修生信息\t\t*\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*\t8.删除学生信息\t\t*\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*\t0.退出系统\t\t*\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;——————————————------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//键盘输入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">keyDown</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">char</span> ch = _getch();</span><br><span class="line"><span class="keyword">switch</span> (ch)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>:<span class="comment">//录入</span></span><br><span class="line">inputStudent();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;2&#x27;</span>:<span class="comment">//打印</span></span><br><span class="line">printStudent();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;3&#x27;</span>:<span class="comment">//保存</span></span><br><span class="line">saveStudent();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;4&#x27;</span>:<span class="comment">//读取</span></span><br><span class="line">browerStudent();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;5&#x27;</span>:<span class="comment">//统计</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;学生总人数为:%d\n&quot;</span>, countStudent());</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;6&#x27;</span>:<span class="comment">//查找</span></span><br><span class="line">&#123;</span><br><span class="line">Node* p = findStudent();</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;学号:%d\t姓名:%s\t年龄:%d\t成绩:%d\n&quot;</span>, p-&gt;stu.stuNum, p-&gt;stu.name, p-&gt;stu.age, p-&gt;stu.score);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;没有找到该学生。\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;7&#x27;</span>:<span class="comment">//修改</span></span><br><span class="line">modifyStudent();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;8&#x27;</span>:<span class="comment">//删除</span></span><br><span class="line">deleteStudent();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span>:<span class="comment">//退出</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入错误，请重新输入。\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">mainMenu();</span><br><span class="line">keyDown();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;相关视频——&lt;a href=&quot;https://www.bilibili.com/video/BV13z4y117qC?p=8&quot;&gt;【C/C++课程设计】史上最全最详细的学生成绩管理系统上线啦，完成大学课程设计不是问题！_哔哩哔哩 (゜-゜)つロ 干杯~-bilibi</summary>
      
    
    
    
    <category term="C语言" scheme="http://example.com/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="-C语言" scheme="http://example.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C语言文件操作</title>
    <link href="http://example.com/2021/05/18/C%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <id>http://example.com/2021/05/18/C%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</id>
    <published>2021-05-18T08:37:38.000Z</published>
    <updated>2021-05-18T08:44:09.503Z</updated>
    
    <content type="html"><![CDATA[<hr><p>相关视频——<a href="https://www.bilibili.com/video/BV1F54y1r7ww?from=search&seid=15927253292233017726">C语言精华——C语言文件操作，文件打开、关闭、读取、定位如何操作？为你逐一讲解文件操作标准库函数_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili</a></p><hr><p><strong>文件分类：</strong></p><p>一种是文本文件，一种是二进制文件。</p><ul><li>文本文件：保存的时候，没一个字符对应一个字节。</li><li>二进制文件：按照二进制编码保存的文件。</li></ul><p><strong>文件操作：</strong></p><h1 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a><strong>打开文件</strong></h1><p> 打开文件fopen(“文件路径”，”打开方式”)</p><p>参数：-(百度百科)</p><p><img src="/images/C%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C.assets/20210517213436.png"></p><p>(选中函数按F1打开msdn文档）</p><p>打开文件成功返回一个文件指针，打不开返回 NULL。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FILE* fp = fopen(<span class="string">&quot;C:\\Users\\XX\\Desktop\\test.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;打开文件失败\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> ch = fgetc(fp);</span><br><span class="line"><span class="keyword">while</span> ((ch = fgetc(fp)) != EOF)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,ch);</span><br><span class="line">&#125;</span><br><span class="line">fclose(fp);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fclose();</span><br></pre></td></tr></table></figure><h1 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h1><h2 id="fgetc"><a href="#fgetc" class="headerlink" title="fgetc"></a>fgetc</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch  = fgetc();<span class="comment">//返回一个字符，一个字符一个字符的读取。</span></span><br></pre></td></tr></table></figure><p> 打开文件之后，到关闭文件之前操作，会有一个文件指针定位到你当前操作到哪里了，读取了一个字节，文件指针就会继续往后偏移。</p><hr><p><strong>读取完会将文件指针移动到下一个字符。</strong></p><hr><p>可以使用循环将全部文本全部内容读取。</p><h2 id="fgets"><a href="#fgets" class="headerlink" title="fgets"></a>fgets</h2><p>读取一行fgets()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">200</span>];</span><br><span class="line">fgets(str,<span class="number">200</span>,fp);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,str);</span><br></pre></td></tr></table></figure><p>也可以通过循环将内容一行一行的读取出来。</p><h2 id="fread"><a href="#fread" class="headerlink" title="fread"></a>fread</h2><p>fread想读多少读多少</p><p>fread(str存到哪,每个元素大小，读几个，文件)；</p><p>返回实际读取的大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fread(str,<span class="number">1</span>,<span class="number">10</span>,fp);</span><br></pre></td></tr></table></figure><hr><p>清零</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">200</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//初始化</span></span><br><span class="line">   或</span><br><span class="line"><span class="built_in">memset</span>(str,<span class="number">0</span>,<span class="keyword">sizeof</span>(str);</span><br><span class="line">       或</span><br><span class="line"><span class="keyword">int</span> n = fread(str,<span class="number">1</span>,<span class="number">10</span>,fp);</span><br><span class="line">str[n] = <span class="string">&#x27;\0&#x27;</span>;</span><br></pre></td></tr></table></figure><h1 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h1><h2 id="fputc"><a href="#fputc" class="headerlink" title="fputc"></a>fputc</h2><p>fputc(‘内容’,文件);</p><h2 id="fputs"><a href="#fputs" class="headerlink" title="fputs"></a>fputs</h2><p>写入一个字符串</p><p>fputs();</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* str = <span class="string">&quot;xxxxxxxxxxxxxxxxxxxxxxx\r\n&quot;</span>;</span><br><span class="line">\r\n回车</span><br><span class="line"><span class="built_in">fputs</span>(str,fp);</span><br></pre></td></tr></table></figure><h2 id="fwrite"><a href="#fwrite" class="headerlink" title="fwrite"></a>fwrite</h2><p>fwrite想写多少写多少</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">123124</span>;</span><br><span class="line">fwrite(&amp;num,<span class="keyword">sizeof</span>(num),<span class="number">1</span>,fp);</span><br><span class="line">第一个参数类型是<span class="keyword">void</span>* 可以转化为任意类型</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">char</span> sex[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;_Person;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FILE* fp = fopen(<span class="string">&quot;C:\\Users\\XX\\Desktop\\test.txt&quot;</span>, <span class="string">&quot;r+&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;打开文件失败\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">Person p1 = &#123;<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;男&quot;</span>,<span class="number">20</span>&#125;;</span><br><span class="line">fwrite(&amp;p1, <span class="number">1</span>, <span class="keyword">sizeof</span>(p1), fp);</span><br><span class="line">fclose(fp);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/C%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C.assets/image-20210518120745992.png" alt="image-20210518120745992"></p><h1 id="文件定位"><a href="#文件定位" class="headerlink" title="文件定位"></a>文件定位</h1><p>文件指针定位</p><h2 id="fseek"><a href="#fseek" class="headerlink" title="fseek"></a>fseek</h2><p>fseek(fp,0,SEEK_SET)</p><p>能够移动文件指针</p><p>可以指定文件从哪里开始读取</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">200</span>];</span><br><span class="line">fseek(fp, <span class="number">10</span>, SEEK_SET);</span><br><span class="line">fread(str,<span class="number">1</span>,<span class="number">100</span>,fp);</span><br></pre></td></tr></table></figure><p>在当前位置再往后移动x个位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fseek(fp,<span class="number">10</span>,SEEK_CUR);</span><br></pre></td></tr></table></figure><p>读取文件最后一行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fseek(fp,<span class="number">0</span>,SEEK_END);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">char</span> sex[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;_Person;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FILE* fp = fopen(<span class="string">&quot;C:\\Users\\XX\\Desktop\\test.txt&quot;</span>, <span class="string">&quot;r+&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;打开文件失败\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读取文件最后一行</span></span><br><span class="line">fseek(fp,<span class="number">0</span>,SEEK_END);</span><br><span class="line"><span class="comment">//反着读</span></span><br><span class="line">fseek(fp, <span class="number">-1</span>, SEEK_END);</span><br><span class="line"><span class="keyword">char</span> ch = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (fread(&amp;ch, <span class="number">1</span>, <span class="number">1</span>, fp))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">fseek(fp,<span class="number">-2</span>,SEEK_CUR);</span><br><span class="line">length++;<span class="comment">//统计退了多少格</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;length = %d\n&quot;</span>, length);</span><br><span class="line">fseek(fp, -length, SEEK_END);</span><br><span class="line"><span class="keyword">char</span>* buffer = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * length + <span class="number">1</span>);<span class="comment">//多一个空间存储字符串终止符</span></span><br><span class="line"><span class="built_in">memset</span>(buffer,<span class="number">0</span>,length+<span class="number">1</span>);</span><br><span class="line">fread(buffer, <span class="number">1</span>, length,fp);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buffer);</span><br><span class="line">fclose(fp);</span><br><span class="line"><span class="comment">//释放内存</span></span><br><span class="line"><span class="built_in">free</span>(buffer);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="rewind"><a href="#rewind" class="headerlink" title="rewind"></a>rewind</h2><p>重置文件指针，返回到文件的开头。</p><h2 id="ftell"><a href="#ftell" class="headerlink" title="ftell"></a>ftell</h2><p>返回当前指针位置。</p><hr><p>文件指针移动了多少个字节，该文件的大小就是多少。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rewind(fp);<span class="comment">//重置文件指针到开头</span></span><br><span class="line">fseek(fp, <span class="number">0</span>, SEEK_END);<span class="comment">//将文件指针定位到结尾</span></span><br><span class="line"><span class="keyword">int</span> nSize = ftell(fp);<span class="comment">//文件指针偏移量</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, nSize);</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;相关视频——&lt;a href=&quot;https://www.bilibili.com/video/BV1F54y1r7ww?from=search&amp;seid=15927253292233017726&quot;&gt;C语言精华——C语言文件操作，文件打开、关闭、读取、定位如何操作？为</summary>
      
    
    
    
    <category term="C语言" scheme="http://example.com/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="-C语言" scheme="http://example.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>计算机二级考试公共基础知识部分——-数据库</title>
    <link href="http://example.com/2021/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BA%8C%E7%BA%A7%E8%80%83%E8%AF%95%E5%85%AC%E5%85%B1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E9%83%A8%E5%88%86%E2%80%94%E2%80%94-%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://example.com/2021/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BA%8C%E7%BA%A7%E8%80%83%E8%AF%95%E5%85%AC%E5%85%B1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E9%83%A8%E5%88%86%E2%80%94%E2%80%94-%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2021-05-18T03:12:32.000Z</published>
    <updated>2021-05-18T03:19:57.152Z</updated>
    
    <content type="html"><![CDATA[<hr><p>相关视频——<a href="https://www.bilibili.com/video/BV1Hb411G7bV?p=23&spm_id_from=pageDriver">【极客学院】计算机等级考试二级c语言：公共基础知识部分（下）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili</a></p><p>我的小站——[半生瓜のblog](<a href="http://doraemon2.xyz/">半生瓜のblog (doraemon2.xyz)</a>)</p><p>现在是不是就只有河北和重庆还没考试了T_T。</p><hr><h1 id="数据库系统的基本概念"><a href="#数据库系统的基本概念" class="headerlink" title="数据库系统的基本概念"></a>数据库系统的基本概念</h1><ul><li>数据：描述事物的符号记录。</li><li>数据的特点：有一定的结构，有型与值之分，如整型、实型、字符型等。而数据的值给出了符合定性的值，如整形值15。</li><li>数据库(DB):是数据的集合，具有统一的结构形式并存放于统一的存储介质内，是多种应用数据的集成，并可被各个应用程序共享。</li></ul><p>数据库存放数据是按 <strong>数据所提供的数据模式存放的，具有集成与共享的特点。</strong></p><ul><li>数据库管理系统(DBMS):一种系统软件，负责数据库中的数据组织、数据操纵、数据维护、控制及保护和数据服务等，是<strong>数据库的核心。</strong></li><li>数据库管理系统的功能：<ul><li>数据模式定义；</li><li>数据存取的物理构建；</li><li>数据操纵；</li><li>数据的完整性、安全性定义与检查；</li><li>数据的并发控制与故障恢复；</li><li>数据的服务：如拷贝、转存、重组、性能监测、分析等。</li></ul></li><li>为了完成上述六个功能，数据库管理系统提供以下的数据语言：<ul><li>数据定义语言(DDL):负责数据的模式定义与数据的物理存取构建；</li><li>数据操纵语言(DML):负责数据的操纵，如增删查改等；</li><li>数据的控制语言(DCL):负责数据完整性、安全性的定义与检查以及并发控制、故障恢复等。</li></ul></li><li>数据语言按使用方式有两种结构形式：<ul><li>交互式命令( 又称自含型或自主型语言)；</li><li>宿主型命令(一般可嵌入某些宿主语言中)。</li></ul></li><li>数据库管理员(DBA):对数据库进行规划、设计、维护、监视等专业管理人员。</li><li>数据库系统(DBS):由数据库(数据)、数据库管理软件(软件)、数据库管理员(r人员)、硬件平台(硬件)、软件平台(软件)五个部分构成的运行实体。</li><li>数据库应用系统(DBAS):由数据库系统、应用软件及应用界面三者组成。</li></ul><h1 id="数据库系统的发展"><a href="#数据库系统的发展" class="headerlink" title="数据库系统的发展"></a>数据库系统的发展</h1><ul><li>数据库系统的发展：<ul><li>文件系统阶段:提供了简单的数据共享与数据管理能力，但是它无法提供完整的、统一的、管理和数据共享的能力。</li><li>层次数据库与网状数据库系统阶段:为统一与共享数据提供了有力支撑。</li><li>关系数据库系统阶段:结构简单,使用方便,逻辑性强,物理性少,使用广泛。</li></ul></li><li>数据库的<strong>根本目的</strong>：解决<strong>数据的共享</strong>问题。</li></ul><h1 id="数据库系统的基本特点"><a href="#数据库系统的基本特点" class="headerlink" title="数据库系统的基本特点"></a>数据库系统的基本特点</h1><ul><li>数据库系统的基本特点：<ul><li>数据的集成性；</li><li>数据的高共享性与低冗余性；</li><li>数据的独立性(物理独立性和逻辑独立性)；</li><li>数据的统一管理与控制。</li></ul></li></ul><h1 id="数据库系统的内部结构体系"><a href="#数据库系统的内部结构体系" class="headerlink" title="数据库系统的内部结构体系"></a>数据库系统的内部结构体系</h1><ul><li><p>数据库系统的三级模式：</p><ul><li>概念模式：数据库系统中全局数据逻辑结构的描述，全体用户公共数据视图；</li><li>外模式:也称子模式与用户模式。是用户的数据视图，也就是用户所见到的数据模式；</li><li>内模式:又称物理模式,它给出了<strong>数据库物理存储结构与物理存取方法。</strong></li></ul></li><li><p>数据库系统的两级映射</p><ul><li>概念模式到内模式映射；</li><li>外模式到概念模式的映射。</li></ul></li><li><p>示意图：</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BA%8C%E7%BA%A7%E8%80%83%E8%AF%95%E5%85%AC%E5%85%B1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E9%83%A8%E5%88%86%E2%80%94%E2%80%94-%E6%95%B0%E6%8D%AE%E5%BA%93.assets/image-20210518104351969.png" alt="image-20210518104351969"></p></li></ul><h1 id="数据库的设计与管理"><a href="#数据库的设计与管理" class="headerlink" title="数据库的设计与管理"></a>数据库的设计与管理</h1><ul><li>数据库设计概述<ul><li><strong>数据库设计是数据应用的核心</strong>。</li><li>数据库设计的两种方法：<ul><li>面向数据:以信息需求为主，兼顾处理需求；</li><li>面向过程:以处理需求为主，兼顾信息需求。 </li></ul></li><li>数据库的生命周期:需求分析阶段、概念设计阶段、逻辑设计阶段、物理设计阶段、编码阶段、测试阶段、运行阶段、进一步修改阶段。</li></ul></li><li>数据设计的需求分析<ul><li>需求分析:主要任务是收集和分析数据，这一阶段收集的基础数据和数据流图是下一阶段的基础。</li><li>需求分析常用结构化分析方法和面向对象的方法。<ul><li>结构化分析(SA）方法用自顶向下、逐层分解的方式分析系统。用数据流图表达数据和处理过程的关系。对数据库设计来讲，数据字典是进行详细的数据收集和数据分析所获得的主要结果。</li><li>数据字典是各类数据描述的集合,包括5个部分:数据项数据结构、数据流（可以是数据项,也可以是数据结构)、数据存储、处理过程。</li></ul></li></ul></li><li>数据库概念设计<ul><li>数据库<strong>概念设计</strong>的目的是<strong>分析数据内在的语义关系</strong>，建立数据的抽象模型，即E-R图。</li><li>设计的方法有两种：<ul><li>集中式模式设计法(适用于小型或并不复杂的单位或部门)；</li><li>视图集成设计法。</li></ul></li><li> E-R模型与视图集成</li><li>视图设计一般有三种设计次序:自顶向下、由底向上、由内向外。</li><li>视图集成的几种冲突:命名冲突、概念冲突、域冲突、约束冲突。</li></ul></li><li>数据库的逻辑设计<ul><li><strong>逻辑设计</strong>:将E-R图转化为制定RDBMS中的关系模式。</li><li>关系视图设计:关系视图的设计又称外模式设计。</li><li>关系视图的主要作用:<ul><li>提供数据逻辑独立性；</li><li>能适应用户对数据的不同需求；</li><li>有一定数据保密功能。 </li></ul></li></ul></li><li>数据库的物理设计<ul><li>数据库的物理设计主要目标是对数据内部物理结构作调整并选择合理的存取路径,以提高数据库访问速度有效利用存储空间。</li><li>一般RDBMS中留给用户参与物理设计的内容大致有索引设计、集成簇设计和分区设计。</li></ul></li><li>数据库管理<ul><li>数据库的建立；</li><li>数据库的调整；</li><li>数据库的重组；</li><li>数据库安全性与完整性控制；</li><li>数据库的故障恢复；</li><li>数据库监控。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;相关视频——&lt;a href=&quot;https://www.bilibili.com/video/BV1Hb411G7bV?p=23&amp;spm_id_from=pageDriver&quot;&gt;【极客学院】计算机等级考试二级c语言：公共基础知识部分（下）_哔哩哔哩 (゜-゜)つロ </summary>
      
    
    
    
    
    <category term="-计算机" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="-二级" scheme="http://example.com/tags/%E4%BA%8C%E7%BA%A7/"/>
    
    <category term="-数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>C语言的灵魂——-指针</title>
    <link href="http://example.com/2021/05/16/C%E8%AF%AD%E8%A8%80%E7%9A%84%E7%81%B5%E9%AD%82%E2%80%94%E2%80%94-%E6%8C%87%E9%92%88/"/>
    <id>http://example.com/2021/05/16/C%E8%AF%AD%E8%A8%80%E7%9A%84%E7%81%B5%E9%AD%82%E2%80%94%E2%80%94-%E6%8C%87%E9%92%88/</id>
    <published>2021-05-16T12:00:28.000Z</published>
    <updated>2021-05-17T11:20:48.687Z</updated>
    
    <content type="html"><![CDATA[<hr><p>相关视频——强烈推荐<a href="https://www.bilibili.com/video/BV1bo4y1Z7xf?p=1">【强烈推荐】4小时彻底掌握C指针 - 顶尖程序员图文讲解 - UP主亲自翻译校对 (已完结)_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili</a></p><hr><p>在学习这个之前，你需要了解函数、循环、数组等C语言知识</p><hr><h1 id="指针基本介绍"><a href="#指针基本介绍" class="headerlink" title="指针基本介绍"></a>指针基本介绍</h1><hr><p>计算机的每一个字节都有一个地址。</p><p>int a,当代码运行的时候，计算机会在内存中开辟一些空间给a。分配多少空间，取决有具体的数据类型。</p><hr><p>指针是一个变量，他存放这另一个变量的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;<span class="comment">//定义一个整型变零a</span></span><br><span class="line">    <span class="keyword">int</span>* p;<span class="comment">//定义一个指针变量p</span></span><br><span class="line">    p = &amp;a;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>p是一个指针变量，换句话说p是一个可以存放整型变量地址的变量。</p><p>&amp;叫做取地址符，放在一个变量的前面，我们就得到了那个变量的地址，它返回一个指针，指向那个特定的变量。</p><p>*叫做解引用操作符，操作指针所指向的那个地址的内容（值）。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面的结果是什么？</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,&amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,p;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,&amp;p);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);<span class="comment">//a的值</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*p);<span class="comment">//a的值</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,&amp;a);<span class="comment">//a的地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,p;<span class="comment">//a的地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,&amp;p);<span class="comment">//p的地址</span></span><br></pre></td></tr></table></figure><hr><p>int* a;意味着指向整型的指针然后写出变量名。</p><h2 id="指针的算数运算"><a href="#指针的算数运算" class="headerlink" title="指针的算数运算"></a>指针的算数运算</h2><p>步长：与是指向什么类型的指针有关系，就是走一步能跨过几个字节的距离。</p><p>下面两个输出，相差4个字节。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span>* p;</span><br><span class="line">p = &amp;a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里输出的是一个垃圾值，因为我们根本就没有对这个地址分配一个整型变量，所以解引用会出现一个随机值（垃圾值）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*(p+<span class="number">1</span>));</span><br></pre></td></tr></table></figure><h1 id="指针的类型"><a href="#指针的类型" class="headerlink" title="指针的类型"></a>指针的类型</h1><p>指针是强类型的，你需要一个特定类型的指针变量来存放特定类型变量的地址，</p><p>例如对于int*来说，你就需要一个指向整型类型的指针，来存放整型数据的地址。</p><p><strong>为什么指针是强类型的？</strong></p><p><strong>因为，</strong>我们不仅使用指针来存储内存地址，同时也用来解引用他所存储的地址所对应的内容，这样我们就能访问并且修改这些地址对应的值了。</p><p><strong>不同</strong>的数据有不同的大小，例如整型在内存中占四个字节，字符型占一个字节。</p><p>假设int a = 1021;</p><p>在内存中占4个字节，32个比特位，如图：</p><p><img src="/images/C%E8%AF%AD%E8%A8%80%E7%9A%84%E7%81%B5%E9%AD%82%E2%80%94%E2%80%94-%E6%8C%87%E9%92%88.assets/image-20210511175536148.png" alt="image-20210511175536148"></p><p>​    </p><p>其中，最左边的位来表示符号位，0为正，1位负，剩下的32位来存储值。</p><p>现在声明一个整型指针来指向a,</p><p>int* p = &a;</p><p>现在打印p——printf（”%d\n”,p）;</p><p>得到的结果200，也就是说该整型变量在内存中的起始地址是200。</p><p>现在打印p所指向地址所对应的值——pintf(“%d\n”,*p);</p><p>从200开始，int类型占4个字节，到203，提取这个整型的值，得到的结果1025。</p><p><strong>代码示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1025</span>;</span><br><span class="line"><span class="keyword">int</span>* p;</span><br><span class="line">p = &amp;a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;整型所占字节数是%d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p所指向的地址是%d\np所指向的地址对应的值是%d\n&quot;</span>,p,*p);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="/images/C%E8%AF%AD%E8%A8%80%E7%9A%84%E7%81%B5%E9%AD%82%E2%80%94%E2%80%94-%E6%8C%87%E9%92%88.assets/image-20210511185807926.png" alt="image-20210511185807926"></p><p><strong>接着我们在上面的基础上生命一个字符型指针,并且将整型指针的值赋给该字符型指针。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* p0;</span><br><span class="line">p0 = p;</span><br></pre></td></tr></table></figure><p>这会提示一个编译错误，因为p0是一个字符型指针，而p是一个整型指针。</p><p><strong>下面我们进行强制类型转换,并进行输出。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p0  = (<span class="keyword">char</span>*)p;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;字符型所占的字节数是%d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p0所指向的地址是%d\np0所在指向的地址对应的值是%d\n&quot;</span>, p0, *p0);</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="/images/C%E8%AF%AD%E8%A8%80%E7%9A%84%E7%81%B5%E9%AD%82%E2%80%94%E2%80%94-%E6%8C%87%E9%92%88.assets/image-20210511190049581.png" alt="image-20210511190049581"></p><p>我们发现所对应的内存地址变了，因为程序在每次运行的时候，都会重新为变量分配内存地址。</p><p>这里p0所指向的地址所对应的值也变了，我们发现跟p并不一样，这是为什么呢？</p><p>同上面的图，这是1025作为整型在内存中的分部，整型在内存中占4个字节，32个比特位，而我们这里将他强制存进了字符型指针中，字符型在内存中占1个字节，8个比特位，</p><p><img src="/images/C%E8%AF%AD%E8%A8%80%E7%9A%84%E7%81%B5%E9%AD%82%E2%80%94%E2%80%94-%E6%8C%87%E9%92%88.assets/image-20210511190200850.png" alt="image-20210511190200850"></p><p>所以只获得了最左边的一个字节，也就是1。</p><p><img src="/images/C%E8%AF%AD%E8%A8%80%E7%9A%84%E7%81%B5%E9%AD%82%E2%80%94%E2%80%94-%E6%8C%87%E9%92%88.assets/image-20210511190512584.png" alt="image-20210511190512584"></p><h2 id="算数运算"><a href="#算数运算" class="headerlink" title="算数运算"></a>算数运算</h2><p>这里我们再次进行指针的算数运算，将p0+1获得新地址，并且对他进行解引用得到该地址所对应的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p0+1所指向的地址是%d\np0+1所指向的地址对应的值是%d\n&quot;</span>, p0+<span class="number">1</span>, *(p0+<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>结果如下图表示。</p><p><img src="/images/C%E8%AF%AD%E8%A8%80%E7%9A%84%E7%81%B5%E9%AD%82%E2%80%94%E2%80%94-%E6%8C%87%E9%92%88.assets/image-20210511191001194.png" alt="image-20210511191001194"></p><p>因为char类型所占字节数是1，所以步长(+1跳过的字节数)是1，该地址所对应的值是，</p><p><img src="/images/C%E8%AF%AD%E8%A8%80%E7%9A%84%E7%81%B5%E9%AD%82%E2%80%94%E2%80%94-%E6%8C%87%E9%92%88.assets/image-20210511191301868.png" alt="image-20210511191301868"></p><p>二进制转化为十进制表示得4(0*2^0+0 *2^1+ 1 * 2^2 = 4)。</p><hr><p>进制转化忘了的同学可以来看一下我的这篇笔记——<a href="http://doraemon2.xyz/2021/03/08/%E8%BF%9B%E5%88%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/">进制之间的转换 | 半生瓜のblog (doraemon2.xyz)</a></p><hr><h2 id="void空指针"><a href="#void空指针" class="headerlink" title="void空指针"></a>void空指针</h2><p>现在我们讨论一种通用的指针类型，它不针对某个特定的数据类型，这种类型的指针被称为void类型的指针，我们使用void来声明这种特定的指针类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* p1;p1 = p;</span><br></pre></td></tr></table></figure><p>这里我们不需要显式的类型转换,p1 = p是合法的，不会有编译错误。</p><p>但是它没有映射到特定的类型，所以我们不能对它进行解引用，*p1是违法的。</p><p>我们只能打印出地址。（p0+1也是不行的，也会有编译错误）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,p1);</span><br></pre></td></tr></table></figure><h1 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h1><p>直接上代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;int main(void)&#123;int x = 5;int* p = &amp;x;*p = 6;int** q = &amp;p;int*** r = &amp;q;return 0; &#125;</span></span></span><br></pre></td></tr></table></figure><p><strong>接下来让我们打印一些东西</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p);<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*q);<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*(*q));<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*(*r));<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*(*(*r)));</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><p><img src="/images/C%E8%AF%AD%E8%A8%80%E7%9A%84%E7%81%B5%E9%AD%82%E2%80%94%E2%80%94-%E6%8C%87%E9%92%88.assets/image-20210511200806837.png" alt="image-20210511200806837"></p><p><strong>解释：</strong></p><p><strong>第一次没读懂一定要多读几次。</strong></p><p>​    p存的是x的地址，对x进行解引用得到x的值。<br>​    q存的是p的地址，p存的是x的地址,对q进行解引用得到x的地址，再进行一次解引用就是通过x的地址寻找对应的值，那就是x的值。</p><p>​    r存的是q的地址，q存的是p的地址，第一次解引用操作就是通过q的地址找到q所存的p的地址，p存的是x的地址，再对r进行一次解引用操作，就是p的地址里面存的是x的地址，结果得到x的地址，再对r进行一次解引用操作，就是通过x的地址寻找对应的值，那就是x的值。</p><p><strong>我们通过三级指针可以直接修改x的值</strong></p><p>就是通过对指针变量的解引用来修改对应地址所对应值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">***r = <span class="number">10</span>;<span class="comment">//此时x的值由5变成了10</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**q = *p + <span class="number">2</span>;<span class="comment">//此时x的值由10变成了12</span></span><br></pre></td></tr></table></figure><h1 id="函数传值-amp-传-址-引用"><a href="#函数传值-amp-传-址-引用" class="headerlink" title="函数传值&amp;传(址)引用"></a>函数传值&amp;传(址)引用</h1><p>函数与指针。</p><p><strong>传值。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;void Increment(int a)&#123;a += 1;&#125;int main(void)&#123;int a = 10;Increment(a);printf(&quot;a = %d\n&quot;, a);return 0;&#125;</span></span></span><br></pre></td></tr></table></figure><p>我们发现值并没有改变，我们打印下两个地址看一下，</p><p><img src="/images/C%E8%AF%AD%E8%A8%80%E7%9A%84%E7%81%B5%E9%AD%82%E2%80%94%E2%80%94-%E6%8C%87%E9%92%88.assets/image-20210512111430844.png" alt="image-20210512111430844"></p><p>是两个<strong>不同的内存空间</strong>，所以值没被修改。</p><p><strong>解释：</strong></p><p>main()是主调函数，Increment()是被调函数，当我们在主调函数中调用其他函数时，这个参数叫做实参，这个被调函数的参数叫做形参，实参会被映射到形参，当这个函数被调用的时候，主函数中的实参’a’会被映射到Increment函数的形参’a’里面，当我们进行这样的调用的时候，基本上就是把一个变量拷贝到另一个变量，这种形式的函数掉用也被称为，<strong>传值调用。</strong></p><p>如果修改成功的话，这两个应该是一个地址，<strong>引出传(址)引用。</strong></p><p><strong>传(址)引用，只需要一点点的修改。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;void Increment(int* a)&#123;*a = *a + 1;&#125;int main(void)&#123;int a = 10;Increment(&amp;a);printf(&quot;%d\n&quot;,a);return 0;&#125;</span></span></span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><p>这样的函数调用不是传值，而是将变量的地址传了过去，我们可以引用这个变量，解引用并且进行一些操作，这就是传(址)引用，传(址)引用可以节省很多内存空间，相比之下引用所占的内存也会小得多，避免复杂的数据类型的拷贝，可以让我们节省内存。</p><h1 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h1><p>二者之间有很强的联系。</p><p><strong>数组名就是一个指针。</strong></p><p> 如果使用数组名,会得到一个指向数组首元素的指针。</p><p><strong>例如：</strong></p><p>int* p = a；我们甚至都不需要在a前写&amp;。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;int main(void)&#123;int a[] = &#123; 1,2,3,4,5,6 &#125;;int* p = a;return 0;&#125;</span></span></span><br></pre></td></tr></table></figure><p>如果我们打印a，会得到数组a的首元素地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);</span><br></pre></td></tr></table></figure><p>如果对它解引用会得到他首元素的值，1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*a);</span><br></pre></td></tr></table></figure><p>如果打印a+1,则会打印数组a第二个元素的地址。</p><p>同理对他解引用也会得到该地址所对应的元素值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);</span><br></pre></td></tr></table></figure><p>完整代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;int main(void)&#123;int a[] = &#123; 1,2,3,4,5,6 &#125;;printf(&quot;%d\n&quot;,a );//首元素地址printf(&quot;%d\n&quot;,&amp;a );//首元素地址printf(&quot;%d\n&quot;,*a );//首元素printf(&quot;%d\n&quot;,a[0]);//首元素return 0;&#125;</span></span></span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="/images/C%E8%AF%AD%E8%A8%80%E7%9A%84%E7%81%B5%E9%AD%82%E2%80%94%E2%80%94-%E6%8C%87%E9%92%88.assets/image-20210512204028411.png" alt="image-20210512204028411"></p><p>需要注意的是，当把数组名字作为指针的时候，不能对它进行自增操作，会报错。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;<span class="keyword">int</span>* p = a;p++;<span class="comment">//可以a++;//不可以</span></span><br></pre></td></tr></table></figure><h2 id="数组作为函数参数"><a href="#数组作为函数参数" class="headerlink" title="数组作为函数参数"></a>数组作为函数参数</h2><p>数组作为函数参数传入。</p><p><strong>代码示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;int SumOfElement(int a[],int size)&#123;int sum = 0;for (int i = 0; i &lt; size; i++)&#123;sum += a[i];&#125;return sum;&#125;int main(void)&#123;int a[] = &#123; 1,2,3,4,5,6 &#125;;//得到数组中元素个数int size = sizeof(a) / sizeof(a[0]);int Sum = SumOfElement(a,size);printf(&quot;%d\n&quot;, Sum);//得到结果21return 0;&#125;</span></span></span><br></pre></td></tr></table></figure><p>现在我们将求元素个数的代码放入SumOfElement函数中。代码如下，我们发现此时结果变成了1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;int SumOfElement(int a[])&#123;int sum = 0;int size = sizeof(a) / sizeof(a[0]);for (int i = 0; i &lt; size; i++)&#123;sum += a[i];&#125;return sum;&#125;int main(void)&#123;int a[] = &#123; 1,2,3,4,5,6 &#125;;int Sum = SumOfElement(a);printf(&quot;%d\n&quot;, Sum);return 0;&#125;</span></span></span><br></pre></td></tr></table></figure><p>结果：</p><p>​    <img src="/images/C%E8%AF%AD%E8%A8%80%E7%9A%84%E7%81%B5%E9%AD%82%E2%80%94%E2%80%94-%E6%8C%87%E9%92%88.assets/image-20210512205738054.png" alt="image-20210512205738054"></p><p><strong>这是为什么呢？</strong></p><p>当编译器看到数组作为函数参数的时候，他不会拷贝整个数组，而是仅仅创建一个同名的指针，我们这里就是创建了一个整型指针，编译器只是拷贝了主调函数的数组首元素地址。</p><p>不管你在被调函数的参数中写int a[],还是int *a,结果都是一样的，它都只是一个整形指针而已。</p><p>这里我们不是拷贝变量的值，而仅仅拷贝了一个变量的地址，所以这里是传(址)引用，这个很有意义，因为数组可以很大， 每次拷贝整个数组没有意义，他会消耗大量的内存，一次对于数组来说不使用传值引用，而是传(址)引用。</p><p>这就是为什么我们这次数组的结果是1了， 因为被调函数中的a是个整型指针，而在主函数中a是一个数组。</p><p>所以计算数组元素个数的代码，还是应该放到主函数中。</p><hr><h2 id="指针和字符数组"><a href="#指针和字符数组" class="headerlink" title="指针和字符数组"></a>指针和字符数组</h2><p><strong>字符数组</strong></p><p>在C语言中为了更高效的操作字符串，我们需要理解一些事情，</p><p>我们如何把字符串存入和字符数组，</p><p>为了能够在字符数组中存储字符串，首要的需求就是字符数组必须要足够大，大到能够容纳字符串，字符数组的大小要大于等于字符的数量+1，</p><p>C语言的字符串必须以null结尾，这就是为什么我们需要一个额外的空间，是用来存放null的。</p><p><strong>代码示例：</strong></p><p>错误例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;int main(void)&#123;char c[4];c[0] = &#x27;N&#x27;;c[1] = &#x27;S&#x27;;c[2] = &#x27;S&#x27;;c[3] = &#x27;B&#x27;;printf(&quot;%s\n&quot;, c);return 0;&#125;</span></span></span><br></pre></td></tr></table></figure><p>我们发现字母后面出现了几个乱码，这是因为我们破坏了printf的默认规则,也就是字符串必须是以null结尾吧，这就是发生<strong>未定义</strong>行为的原因。</p><p><strong>下面我们进行一下修改</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;int main(void)&#123;char c[5];c[0] = &#x27;N&#x27;;c[1] = &#x27;S&#x27;;c[2] = &#x27;S&#x27;;c[3] = &#x27;B&#x27;;c[4] = &#x27;\0&#x27;;printf(&quot;%s\n&quot;, c);return 0;&#125;</span></span></span><br></pre></td></tr></table></figure><p>结果就正常了</p><p><img src="/images/C%E8%AF%AD%E8%A8%80%E7%9A%84%E7%81%B5%E9%AD%82%E2%80%94%E2%80%94-%E6%8C%87%E9%92%88.assets/image-20210513123554138.png" alt="image-20210513123554138"></p><p><strong>其他的字符操作函数也同样需要遵守这个固定，以null为结尾。</strong></p><p>写在同一行，系统会隐式的自动添加null为结尾</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c[<span class="number">5</span>] = <span class="string">&quot;NSSB&quot;</span>;</span><br></pre></td></tr></table></figure><p> 不声明字符数组的个数也是可以的，系统会自动分配对应的字节数，例如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c[] = <span class="string">&quot;ABCD&quot;</span>;<span class="keyword">sizeof</span>(c);<span class="comment">//sizeof的结果就是5，它刚好同来存放ABCDstrlen(c);//长度是4，不包括null</span></span><br></pre></td></tr></table></figure><p>如果我们这么声明，代码如下，这时我们需要显式的声明它的结束。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c[<span class="number">5</span>] = &#123;<span class="string">&#x27;A&#x27;</span>，<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><p><strong>引入指针</strong></p><p>声明一个字符数组和一个字符指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c1[<span class="number">5</span>] = <span class="string">&quot;hello&quot;</span>;<span class="keyword">char</span>* c2;</span><br></pre></td></tr></table></figure><p>我们使用这个数组的名字和这个字符指针的名字放到等式中是成立的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">但是，将换个位置，    c1 = c2;是非法的</span><br></pre></td></tr></table></figure><p>c2中存的就是字符数组c1中首元素的地址(同上面的整型数组)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c2 =c1;</span><br></pre></td></tr></table></figure><p>解引用操作同上面的数组。</p><p><strong>代码示例：打印数组中的所有元素。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;void print(char* c)&#123;int  i = 0;//*(c+i)同理while (c[i] != &#x27;\0&#x27;)&#123;printf(&quot;%c&quot;, c[i]);i++;&#125;&#125;int main(void)&#123;char c[20] = &quot;ABCDEF&quot;;print(c);return 0;&#125;</span></span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span>* c)</span></span>&#123;<span class="keyword">while</span> (*c!= <span class="string">&#x27;\0&#x27;</span>)&#123;<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, *c);c++;&#125;&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：此时的字符数组就是一个指针，存的就是元素的地址，从首元素开始只要不是null就进入循环，然后元素地址进行自增，因为是字符型指针，所以步长就是1，遍历每个元素，直到null。</p><h2 id="指针和二维数组"><a href="#指针和二维数组" class="headerlink" title="指针和二维数组"></a>指针和二维数组</h2><p>简单复习一下什么是多维数组。</p><p><strong>就是在数组中储存数组。</strong></p><p>学习此部分之前，可以再复习一下上面指针和一维数组。</p><p><strong>个人理解</strong>：<strong>当多维数组名被当做指针的时候，多维数组就是指向指针的指针。</strong></p><p><strong>代码示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;int main(void)&#123;int B[2][3] = &#123; &#123;1,2,3&#125;,&#123;4,5,6,&#125; &#125;;int(*p)[3] = B;//打印首元素地址B[0][0]printf(&quot;%d\n&quot;, &amp;B[0][0]);printf(&quot;%d\n&quot;,B );printf(&quot;%d\n&quot;,p );printf(&quot;%d\n&quot;,*B );printf(&quot;%d\n&quot;,*p);return  0;&#125;</span></span></span><br></pre></td></tr></table></figure><p><strong>为什么我这么说呢？</strong></p><p><strong>对比理解</strong></p><p> 就是，一个二级指针，存的是一个一级指针的地址（首元素地址），然后再对该一级指针的地址进行解引用，得到该一级指针所存地址的值。</p><p><strong>例如：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,**B);<span class="comment">//当数组名被作为指针的时候，B和*B意思一样。</span></span><br></pre></td></tr></table></figure><p>当二维数组的数组B被当成指针的时候，他里面存的是B [0] [0]的地址，再对他进行解引用得到的是对应的值，1。</p><p>（<strong>（同上）</strong>因为直接使用数组名会返回该数组的首元素的指针，是二维数组中的第一个一维数组的首元素地址，然后对这个首元素进行解引用操作，得到的是第一个元素的值。）</p><p><strong>不同点：</strong></p><p>B返回一个指向一个一维数组的指针，而*B返回一个指向整型的指针，当我们只是打印地址的时候，一维数组B[0]和B[0]的首元素的起始地址是一样的，所以打印的地址是相同的，指针类型会在你尝试解引用时或者尝试做指针算术的时候起作用。</p><hr><p>B [I] [J]可以写成 *（B[i]+j）  或者 *( *(B +i)+j )。—就是把B[i]写成 *(B+i)</p><p><strong>解释：</strong>直接用 数组名返回一个指向首元素的指针，（该二维数组中对应的哪个一维数组）,然后+j是对应一位数组中的，跳过的元素个数，也就是往后跳过几个字节，得到新的元素地址，最后，解引用得到该元素的值。</p><h2 id="指针和多维数组"><a href="#指针和多维数组" class="headerlink" title="指针和多维数组"></a>指针和多维数组</h2><p>（如何理解多维数组，最左边的维数就是一共划分了几块，第二位就是在每一块中继续分为几块，依次类推。）</p><p>（定义多维数组的指针的时候，后面的参数是该数组除去一个参数的几个参数）</p><p>多维数组-例如：三维数组就是二维数组的数组。     </p><p><strong>代码示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;int main(void)&#123;int C[3][2][2] = &#123; &#123;&#123;1,2&#125;,&#123;3,4&#125;&#125;,&#123;&#123;5,6&#125;,&#123;7,8&#125;&#125;,&#123;&#123;9,10&#125;,&#123;10,11&#125;&#125; &#125;;int (*p)[2][2] = C;//首元素地址printf(&quot;%d\n&quot;, &amp;C[0][0][0]);printf(&quot;%d\n&quot;,p);printf(&quot;%d\n&quot;, *p);printf(&quot;%d\n&quot;, C[0]);//打印首元素printf(&quot;%d\n&quot;, C[0][0][0]);printf(&quot;%d\n&quot;, ***p);return 0;&#125;</span></span></span><br></pre></td></tr></table></figure><p>同上面指针和二维数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C[i][j][k] = *(C[i][j]+k) = *(*(C[i][j]+k))</span><br></pre></td></tr></table></figure><p>如果你已经理解了，请问下面这个结果是多少？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *(C[<span class="number">0</span>][<span class="number">1</span>] + <span class="number">1</span>));<span class="comment">//结果是4，上面示例中的代码。</span></span><br></pre></td></tr></table></figure><h2 id="多维数组作为参数传给函数"><a href="#多维数组作为参数传给函数" class="headerlink" title="多维数组作为参数传给函数"></a><strong>多维数组作为参数传给函数</strong></h2><p> （是几维数组,使用数组名作为指针就返回几维度-1的指针）</p><p>（例如：一维数组返回指向整型的指针，二维数组返回指向一维数组的指针，三维数组返回指二维数组的指针……）</p><p>多维数组作为函数参数的时候，数组的第一个维度可以省略，但是其余的维度需要指定。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;void Func (int (*C)[2][2])&#123;&#125;int main(void)&#123;int C[3][2][2] = &#123;&#123;&#123;1,2&#125;,&#123;3,4&#125;&#125;,&#123;&#123;5,6&#125;,&#123;7,8&#125;&#125;,&#123;&#123;9,10&#125;,&#123;10,11&#125;&#125; &#125;;Func(C);return 0;&#125;</span></span></span><br></pre></td></tr></table></figure><h1 id="指针和动态内存"><a href="#指针和动态内存" class="headerlink" title="指针和动态内存"></a>指针和动态内存</h1><hr><p>内存是机器中很关键的资源。</p><p>也可以看看我的这篇笔记——<a href="http://doraemon2.xyz/2021/04/22/C%E8%AF%AD%E8%A8%80%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%BC%80%E8%BE%9F/">C语言动态内存开辟 | 半生瓜のblog (doraemon2.xyz)</a></p><hr><p><strong>相关函数：</strong></p><p>堆上分配内存的相关函数malloc calloc realloc</p><p>释放内存free</p><hr><h2 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a><strong>malloc</strong></h2><p><strong>malloc</strong>返回一个void指针，这个指针指向了分配给我们的内存块的第一个字节的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>*p = <span class="built_in">malloc</span>(n*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure><p>我们不能解引用一个void指针，通常需要将它<strong>转化为一个特定类型的指针</strong>，然后再使用它。</p><p>因为malloc只是个通用的函数，在堆上分配一些内存，它并不关心你用这块内存存什么，它只是简单返回指向开辟出来的内存起始地址的指针。</p><p>为了使用这块内存我们需要进行<strong>指针类型转换</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* p = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(n*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure><p>动态内存的操作都是基于指针的，你拥有一个基地址指针。</p><hr><h2 id="calloc"><a href="#calloc" class="headerlink" title="calloc"></a><strong>calloc</strong></h2><p><strong>calloc</strong> 和malloc类似，callo也是返回一个void型指针， 但是calloc接收两个参数，第一个参数是特定的元素数量，第二个参数是类型的大小。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *p = (<span class="keyword">int</span> *)<span class="built_in">calloc</span>(<span class="number">3</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>))</span><br></pre></td></tr></table></figure><p>还有一个区别是，calloc在分配完内存之后会对其进行初始化，而malloc不会。</p><h2 id="realloc"><a href="#realloc" class="headerlink" title="realloc"></a><strong>realloc</strong></h2><p>如果你有一块内存，动态分配的内存，你想修改内存块的大小，那你就可以使用realloc，realloc接收两个参数，第一个参数是指向已分配内存的起始地址的指针，第二个参数是新的内存块的大小。</p><p><strong>如果去掉第一个参数，那么他和malloc是一样的效果</strong></p><p>这时会创建一个空的内存块，而不会从之前的内存块拷贝任何数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *b = (<span class="keyword">int</span> *)<span class="built_in">realloc</span>(<span class="literal">NULL</span>,n*<span class="keyword">sizeof</span>(<span class="keyword">int</span>)); </span><br></pre></td></tr></table></figure><p> <strong>第二个参数是0,那么他和free是一样的效果</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *b = (<span class="keyword">int</span>*)<span class="built_in">realloc</span>(A,<span class="number">0</span>);<span class="comment">//将A释放 = free(A)</span></span><br></pre></td></tr></table></figure><p>reallo可能会有多种场景</p><ul><li>比如我们想要的新内存块可能比原来的内存要大，这种情况下机器可能会创建一块新的内存然后把原来的值拷贝过去，然后释放之前的内存，如果之前的那块内存的相邻处，还有还有连续的内存可用，那么可能会直接扩展之前的那块内存。</li></ul><h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><p>free()将开辟出来的内存空间释放。</p><h2 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a><strong>代码示例</strong></h2><p>数组的个数不能是个变量，这时候我们就能用到动态内存开辟</p><p><strong>创建一个大小为n的数组</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main(void)&#123;int n = 0;scanf(&quot;%d&quot;, &amp;n);int* p = (int*)malloc(n * sizeof(int));    //int* p = (int *)calloc(n,sizeof(int));    //修改开辟内存大小    int* p1 = realloc(p,2*n*sizeof(int));return 0;&#125;</span></span></span><br></pre></td></tr></table></figure><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>这种情况是由于不正确的使用动态内存引起的。</p><p><strong>内存泄漏就是在堆上增长垃圾。</strong></p><p>不正确的动态内存(堆)的使用引起。由于程序中已动态分配的没有释放，造成的系统内存浪费，导致系统运行减慢或者崩溃。——百度百科。</p><h1 id="函数返回指针"><a href="#函数返回指针" class="headerlink" title="函数返回指针"></a>函数返回指针</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;int* Add(int* a,int* b)&#123;int c = *a + *b;return &amp;c;&#125;int main(void)&#123;int a = 3;int b = 5;int* z = Add(&amp;a,&amp;b);    printf(&quot;%d\n&quot;, *z);return 0;&#125;</span></span></span><br></pre></td></tr></table></figure><p>加入一个简单的函数并且调用之后，我们发现程序运行错误</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;void Print()&#123;printf(&quot;Hello world\n&quot;);&#125;int* Add(int* a,int* b)&#123;int c = *a + *b;return &amp;c;&#125;int main(void)&#123;int a = 3;int b = 5;int* z = Add(&amp;a,&amp;b);Print();printf(&quot;%d\n&quot;, *z);return 0;&#125;</span></span></span><br></pre></td></tr></table></figure><p>如图：</p><p><img src="/images/C%E8%AF%AD%E8%A8%80%E7%9A%84%E7%81%B5%E9%AD%82%E2%80%94%E2%80%94-%E6%8C%87%E9%92%88.assets/image-20210515211156453.png" alt="image-20210515211156453"></p><p><strong>这是为什么呢？</strong></p><p>栈，先进后出，先进的被压倒栈底， 当Add函数调用完成，返回一个指向结果的指针（地址），然后内存被释放，所指向的地址对应的值就是个垃圾值，尽管他指向这个地址，但是他的值是不能被保证的，因为内存被释放了，为后面的函数分配空间。</p><p>之后为Print函数分配栈空间，覆盖之前的空间。</p><hr><p>如果我们尝试将返回一个被调函数的局部变量给主函数，就像我们要返回一个Add函数的局部变量给main函数，当被调函数结束控制返回给主函数的时候，那块内存已经释放了，因此从栈顶向上传参数是可以的。</p><p>但是，</p><p>从栈顶向下传一个局部变量或者一个局部变量的地址是不可以的，</p><p>那么，什么情况下我们想要从函数返回一个指针呢？</p><p>如果我们在堆上有一个内存地址或者，在全局区有一个变量，那么我们就可以安全地返回他们的地址，因为堆上分配内存需要显示释放，由我们来控制他的释放。</p><hr><p>修改后的代码</p><p>malloc是在堆上开辟的空间不会被显式的释放。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;#include&lt;stdlib.h&gt;void Print()&#123;printf(&quot;Hello world\n&quot;);&#125;int* Add(int* a,int* b)&#123;int* c = (int*)malloc(sizeof(int));*c = *a + *b;return c;&#125;int main(void)&#123;int a = 3;int b = 5;int* z = Add(&amp;a,&amp;b);Print();printf(&quot;%d\n&quot;, *z);return 0;&#125;</span></span></span><br></pre></td></tr></table></figure><p>因此，从函数返回指针的时候，我们需要小心它的作用范围，我们必须保证地址没有被重用（用来存储其他东西），以及那个地址的数据没有被清除。</p><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>用来存储函数的地址</p><p>它指向或引用内存中的数据，这里的数据未必一定指变量，也可以是常量。</p><p>可以使用这样的指针来解引用和执行函数。</p><p>当我们说函数指针存放函数地址的时候， 我们是在说函数指针存放了函数在内存中的起始地址或者入口点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;int Add(int a, int b)&#123;return a + b;&#125;int main(void)&#123;int c = 0;    //函数返回类型 参数类型 参数类型int (*p)(int, int);p = &amp;Add;//不使用&amp;也可以，只使用函数名会返回函数的地址    //p = Add;    //p(2,3)c = (*p)(2, 3);printf(&quot;%d\n&quot;, c);return 0;&#125;  </span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;void Print()&#123;printf(&quot;Hello&quot;);&#125;int main(void)&#123;void (*p)();p = Print;p();return 0;&#125;</span></span></span><br></pre></td></tr></table></figure><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>函数指针可以被用来作为函数参数，接收函数指针的这个函数，可以回调函数指针所指向的那个函数，</p><p><strong>就是一个函数作为参数传递给另外一个函数。</strong></p><p>格式-返回类型(*函数名)(参数类型，参数类型，……)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;int compare(int a, int b)&#123;if (a &gt; b)return 1;elsereturn -1;&#125;void maopaoSort(int *a,int n,int(*compare)(int,int))&#123;int temp = 0;for (int i = 0; i &lt; n; i++)&#123;for (int j = 0; j &lt; n - 1; j++)&#123;if (compare(a[j] ,a[j+1])&gt;0)&#123;temp = a[j];a[j] = a[j + 1];a[j + 1] = temp;&#125;&#125;&#125;&#125;int main(void)&#123;int a[5] = &#123; 2,5,4,8,9 &#125;;maopaoSort(a, 5,compare);for (int i = 0; i &lt; 5; i++)&#123;printf(&quot;%d &quot;, a[i]);&#125;return  0;&#125;</span></span></span><br></pre></td></tr></table></figure><p>可以根据情况的不同写不同的回调函数</p><p>例如：比较绝对值后的大小，升序排列</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">absSort</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">if</span> (<span class="built_in">abs</span>(a) &gt; <span class="built_in">abs</span>(b))<span class="keyword">return</span> <span class="number">1</span>;<span class="keyword">else</span><span class="keyword">return</span> <span class="number">-1</span>;&#125;</span><br></pre></td></tr></table></figure><p>调用库函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int compare(const void*a,const void* b)&#123;int A = *((int*)a);int B = *((int*)b);return A - B;//值越大排名越高&#125;int main(void)&#123;int a[5] = &#123; 5,-6,-2,3,7 &#125;;qsort(a,5,sizeof(int),compare);for (int i = 0; i &lt; 5; i++)&#123;printf(&quot;%d &quot;,a[i]);&#125;return 0;&#125;</span></span></span><br></pre></td></tr></table></figure><p><img src="/images/C%E8%AF%AD%E8%A8%80%E7%9A%84%E7%81%B5%E9%AD%82%E2%80%94%E2%80%94-%E6%8C%87%E9%92%88.assets/image-20210516122128095.png" alt="image-20210516122128095"></p><p>qsort能对任何数组进行排序，不仅仅是整形数组。只是你需要给出比较逻辑。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;相关视频——强烈推荐&lt;a href=&quot;https://www.bilibili.com/video/BV1bo4y1Z7xf?p=1&quot;&gt;【强烈推荐】4小时彻底掌握C指针 - 顶尖程序员图文讲解 - UP主亲自翻译校对 (已完结)_哔哩哔哩 (゜-゜)つロ 干杯~-</summary>
      
    
    
    
    <category term="C语言" scheme="http://example.com/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="-C语言" scheme="http://example.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="-指针" scheme="http://example.com/tags/%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>初识EasyX图形编程</title>
    <link href="http://example.com/2021/05/09/%E5%88%9D%E8%AF%86EasyX%E5%9B%BE%E5%BD%A2%E7%BC%96%E7%A8%8B/"/>
    <id>http://example.com/2021/05/09/%E5%88%9D%E8%AF%86EasyX%E5%9B%BE%E5%BD%A2%E7%BC%96%E7%A8%8B/</id>
    <published>2021-05-09T05:01:35.000Z</published>
    <updated>2021-05-09T05:18:17.692Z</updated>
    
    <content type="html"><![CDATA[<hr><p>相关视频——<a href="https://www.bilibili.com/video/BV11p4y1i74A?p=1">【C/C++/EasyX】学编程，做游戏，小白快速入门图形编程，零基础入门到精通，学习就是这么快乐_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili</a></p><hr><h1 id="1-基本说明"><a href="#1-基本说明" class="headerlink" title="1.基本说明"></a>1.基本说明</h1><ul><li>EasyX是针对C++的图形库，可以帮助C/C++初学者快速上手图形和游戏编程。</li><li>比如 ,可以基于EasyX图形库很快用几何图形画一个房子，或者一辆移动的小车，可以编写俄罗斯方块 、贪吃蛇、黑白棋等小游戏。</li><li>许多人学编程是从C语言入门的，而目前的现状是“<ul><li>学校值只教基础语法，一直在黑窗口练习，同学们学的很乏味。、</li><li>即使有的学校教图形编程，也是使用一些难度较高的， 比如Win32,OpenlGl门槛依然很高，初学者容易收到打击。</li><li>开始引出我们的EasyX。</li></ul></li></ul><h1 id="2-原理"><a href="#2-原理" class="headerlink" title="2.原理"></a>2.原理</h1><p>​        基于Windows图形编程，将Windows下的复杂程序过程进行封装,将Windows下的编程过程隐藏，给用户提供一个简单熟悉的接口。用户对于图形库中函数的调用，最终都会由Windows的底层API实现。</p><h1 id="3-安装"><a href="#3-安装" class="headerlink" title="3.安装"></a>3.安装</h1><ul><li>Easyx图形库支持Vs各种版本，下载解压后，直接执行安装程序即可。</li><li>头文件graphics.h</li><li>帮助文档<a href="https://docs.easyx.cn/zh-cn/intro">EasyX 文档 - 基本说明</a></li><li>下载<a href="https://easyx.cn/">EasyX Graphics Library for C++</a></li></ul><h1 id="4-颜色"><a href="#4-颜色" class="headerlink" title="4.颜色"></a>4.颜色</h1><p>​    用RGB宏合成颜色，实际上合成出来的颜色是一个十六进制的的整数。</p><p>​    <strong>每个颜色部分的值都是0~255</strong></p><h1 id="5-坐标和设备"><a href="#5-坐标和设备" class="headerlink" title="5.坐标和设备"></a>5.坐标和设备</h1><ul><li>坐标默认的原点在窗口的左上角，X轴向右为正，Y 轴向下为正，度量单位是像素点。</li><li>设备：简单来说，就是绘图表面。<ul><li>在EasyX中,设备分两种，一种是默认的绘图窗口另一种是IMAGE对象。通过SetWorkinglmage()函数可以设置当前用于绘图的设备。设置当前用于绘图的设备后,所有的绘图函数都会绘制在该设备上。(后面再去理解)</li></ul></li></ul><h1 id="6-窗口函数"><a href="#6-窗口函数" class="headerlink" title="6.窗口函数"></a>6.窗口函数</h1><p>​    窗口函数用于窗口的一些操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">initgraph(<span class="keyword">int</span> width,<span class="keyword">int</span> height,<span class="keyword">int</span> flag = <span class="literal">NULL</span>);<span class="comment">//用于初始化绘图窗口</span></span><br><span class="line"><span class="comment">//width 指定窗口的宽度</span></span><br><span class="line"><span class="comment">//height 指定窗口的高度</span></span><br><span class="line"><span class="comment">//flag 窗口的样式默认为NULL</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">closegraph();<span class="comment">//关闭绘图窗口</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleardevice();<span class="comment">//清空绘图设备</span></span><br></pre></td></tr></table></figure><h1 id="7-图形绘制函数"><a href="#7-图形绘制函数" class="headerlink" title="7.图形绘制函数"></a>7.图形绘制函数</h1><ul><li><p>图形绘制函数用于在窗口上绘制各种图形。</p></li><li><p>绘图函数从填充样式分类可以分为无填充，有边框填充，无边框三种。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">以画圆为例</span><br><span class="line">    circle()无填充</span><br><span class="line">    fillcircle()有边框填充</span><br><span class="line">    solidcircle()无边框填充</span><br></pre></td></tr></table></figure><p>区别：</p><p><img src="/images/%E5%88%9D%E8%AF%86EasyX%E5%9B%BE%E5%BD%A2%E7%BC%96%E7%A8%8B.assets/image-20210508202623558.png" alt="image-20210508202623558"></p><ul><li>从形状来分，常用的可以分为八种。</li></ul><p><img src="/images/%E5%88%9D%E8%AF%86EasyX%E5%9B%BE%E5%BD%A2%E7%BC%96%E7%A8%8B.assets/image-20210508201228945.png" alt="image-20210508201228945"></p><ul><li>设置填充颜色setfillcolor()；</li><li>设置线条颜色setlinecolor();</li><li>设置线条样式setlinestyle();高，宽，字体</li></ul><h1 id="8-文字绘制函数"><a href="#8-文字绘制函数" class="headerlink" title="8.文字绘制函数"></a>8.文字绘制函数</h1><ul><li>文字绘制函数用于在窗口上绘制文字</li></ul><p><img src="/images/%E5%88%9D%E8%AF%86EasyX%E5%9B%BE%E5%BD%A2%E7%BC%96%E7%A8%8B.assets/image-20210508202106822.png" alt="image-20210508202106822"></p><h1 id="9-图像处理函数"><a href="#9-图像处理函数" class="headerlink" title="9.图像处理函数"></a>9.图像处理函数</h1><ul><li>图像处理函数用于在窗口上显示图片</li></ul><p><img src="/images/%E5%88%9D%E8%AF%86EasyX%E5%9B%BE%E5%BD%A2%E7%BC%96%E7%A8%8B.assets/image-20210508202202224.png" alt="image-20210508202202224"></p><h1 id="10-鼠标消息函数"><a href="#10-鼠标消息函数" class="headerlink" title="10.鼠标消息函数"></a>10.鼠标消息函数</h1><ul><li>鼠标消息函数用于获取鼠标的信息</li></ul><p><img src="/images/%E5%88%9D%E8%AF%86EasyX%E5%9B%BE%E5%BD%A2%E7%BC%96%E7%A8%8B.assets/image-20210509115406258.png" alt="image-20210509115406258"></p><h1 id="11-键盘消息函数"><a href="#11-键盘消息函数" class="headerlink" title="11.键盘消息函数"></a>11.键盘消息函数</h1><ul><li>键盘消息函数用于获取键盘按键消息</li></ul><p><img src="/images/%E5%88%9D%E8%AF%86EasyX%E5%9B%BE%E5%BD%A2%E7%BC%96%E7%A8%8B.assets/image-20210509121713266.png" alt="image-20210509121713266"></p><h1 id="12-其他函数"><a href="#12-其他函数" class="headerlink" title="12.其他函数"></a>12.其他函数</h1><p><img src="/images/%E5%88%9D%E8%AF%86EasyX%E5%9B%BE%E5%BD%A2%E7%BC%96%E7%A8%8B.assets/image-20210509122340561.png" alt="image-20210509122340561"></p><h1 id="13-音乐播放"><a href="#13-音乐播放" class="headerlink" title="13.音乐播放"></a>13.音乐播放</h1><p><img src="/images/%E5%88%9D%E8%AF%86EasyX%E5%9B%BE%E5%BD%A2%E7%BC%96%E7%A8%8B.assets/image-20210509123501332.png" alt="image-20210509123501332"></p><h1 id="易错集锦"><a href="#易错集锦" class="headerlink" title="易错集锦"></a>易错集锦</h1><ol><li><p>源文件问题： fata1 error c1189: #error : EasyXis only for C++。</p><p><strong>后缀要是cpp</strong></p></li><li><p>参数错误，找不到对应的函数：error C2665： “outtextxy”:2个重载中没有一个可以转换所有参数类型。</p><p>是由于字符集导致的，1.在字符串前面加上大写的L，2.用TEXT(_T())把字符串包起起来。</p><p>不需要添加任何代码，项目-属性-常规-字符集-使用多字节字符集</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;相关视频——&lt;a href=&quot;https://www.bilibili.com/video/BV11p4y1i74A?p=1&quot;&gt;【C/C++/EasyX】学编程，做游戏，小白快速入门图形编程，零基础入门到精通，学习就是这么快乐_哔哩哔哩 (゜-゜)つロ 干杯~-b</summary>
      
    
    
    
    <category term="图形编程" scheme="http://example.com/categories/%E5%9B%BE%E5%BD%A2%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="-C语言" scheme="http://example.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="-EasyX" scheme="http://example.com/tags/EasyX/"/>
    
    <category term="-图形编程" scheme="http://example.com/tags/%E5%9B%BE%E5%BD%A2%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>QQ轰炸器</title>
    <link href="http://example.com/2021/05/08/QQ%E8%BD%B0%E7%82%B8%E5%99%A8/"/>
    <id>http://example.com/2021/05/08/QQ%E8%BD%B0%E7%82%B8%E5%99%A8/</id>
    <published>2021-05-08T09:25:20.000Z</published>
    <updated>2021-05-08T10:07:51.752Z</updated>
    
    <content type="html"><![CDATA[<hr><p>相关视频——<a href="https://www.bilibili.com/video/BV1Vf4y1W7aj?t=3">【C/C++技术教程】QQ轰炸机（两种版本）！程序员带你实现腾讯QQ消息轰炸，瞬间99+让对面防不胜防！_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili</a></p><hr><p><strong>注意：群体轰炸，当轰完(群发)完你所选中的分组后，它会继续往下进行，对下一个分组进行发送,连QQ的各种服务号都算上。</strong></p><hr><p><strong>代码实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;//使用windows的资源</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;1.单独轰炸\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;2.群体轰炸\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;3.退出\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c);</span><br><span class="line"><span class="keyword">if</span> (c == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> times = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入你要轰炸的对象-&gt;\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入你要轰炸的次数-&gt;\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;times);</span><br><span class="line"><span class="comment">//HWND-窗口句柄</span></span><br><span class="line"><span class="comment">//窗口的id-编号 每一个窗口对应一个编号</span></span><br><span class="line">HWND qqhwnd;<span class="comment">//定义一个变量存储一个窗口的id</span></span><br><span class="line">qqhwnd = FindWindowA(<span class="literal">NULL</span>,name);<span class="comment">//两个信息，一个类名称，一个标题</span></span><br><span class="line"><span class="comment">//发送消息</span></span><br><span class="line"><span class="comment">//向某一个窗口发送消息 鼠标-键盘-消息</span></span><br><span class="line"><span class="comment">//将要发送的消息复制到全局剪贴板</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times; i++)</span><br><span class="line">&#123;</span><br><span class="line">SendMessageA(qqhwnd, WM_PASTE,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">SendMessageA(qqhwnd, WM_KEYDOWN,VK_RETURN,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在吗？</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//群体轰炸</span></span><br><span class="line">HWND qqhwnd;</span><br><span class="line"><span class="comment">//得到QQ主界面的窗口ID</span></span><br><span class="line">qqhwnd = FindWindowA(<span class="literal">NULL</span>, <span class="string">&quot;QQ&quot;</span>);</span><br><span class="line">MoveWindow(qqhwnd, <span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">800</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">//1.选中主界面</span></span><br><span class="line"><span class="comment">//2.TAB TAB</span></span><br><span class="line"><span class="comment">//3.不断的按回车和下-打开一个对话框</span></span><br><span class="line"><span class="comment">//4.粘贴</span></span><br><span class="line"><span class="comment">//5.发送</span></span><br><span class="line"><span class="comment">//5.关闭对话框</span></span><br><span class="line"></span><br><span class="line">SetForegroundWindow(qqhwnd);<span class="comment">//设置某一个窗口为最前-就是选中主界面</span></span><br><span class="line">keybd_event(VK_TAB, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//按下TAB键</span></span><br><span class="line">Sleep(<span class="number">50</span>);<span class="comment">//慢一点</span></span><br><span class="line">keybd_event(VK_TAB, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);<span class="comment">//弹起TAB键</span></span><br><span class="line">Sleep(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">keybd_event(VK_TAB, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//按下TAB键</span></span><br><span class="line">Sleep(<span class="number">50</span>);<span class="comment">//慢一点</span></span><br><span class="line">keybd_event(VK_TAB, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);<span class="comment">//弹起TAB键</span></span><br><span class="line">Sleep(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//不断的按回车和下 打开对话框</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//回车</span></span><br><span class="line">keybd_event(VK_RETURN, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">Sleep(<span class="number">50</span>);</span><br><span class="line">keybd_event(VK_RETURN, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">Sleep(<span class="number">50</span>);</span><br><span class="line"><span class="comment">//下键</span></span><br><span class="line">keybd_event(VK_DOWN, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">Sleep(<span class="number">50</span>);</span><br><span class="line">keybd_event(VK_DOWN, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">Sleep(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (qqhwnd != GetForegroundWindow())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//粘贴</span></span><br><span class="line">keybd_event(VK_CONTROL, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">Sleep(<span class="number">50</span>);</span><br><span class="line">keybd_event(<span class="string">&#x27;V&#x27;</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">Sleep(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">keybd_event(<span class="string">&#x27;V&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">Sleep(<span class="number">50</span>);</span><br><span class="line">keybd_event(VK_CONTROL, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">Sleep(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送</span></span><br><span class="line">keybd_event(VK_RETURN, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">Sleep(<span class="number">50</span>);</span><br><span class="line">keybd_event(VK_RETURN, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">Sleep(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭对话框</span></span><br><span class="line">keybd_event(VK_ESCAPE,<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">Sleep(<span class="number">50</span>);</span><br><span class="line">keybd_event(VK_ESCAPE,<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">Sleep(<span class="number">50</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;相关视频——&lt;a href=&quot;https://www.bilibili.com/video/BV1Vf4y1W7aj?t=3&quot;&gt;【C/C++技术教程】QQ轰炸机（两种版本）！程序员带你实现腾讯QQ消息轰炸，瞬间99+让对面防不胜防！_哔哩哔哩 (゜-゜)つロ 干杯</summary>
      
    
    
    
    <category term="C语言" scheme="http://example.com/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="-C语言" scheme="http://example.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C语言实现图书管理系统</title>
    <link href="http://example.com/2021/05/07/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    <id>http://example.com/2021/05/07/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-05-07T13:05:35.000Z</published>
    <updated>2021-05-07T13:53:49.866Z</updated>
    
    <content type="html"><![CDATA[<hr><p>相关视频——<a href="https://www.bilibili.com/video/BV1E64y1171r">C语言课程设计实战：图书管理系统！计算机专业同学的一大难题，今天用代码实战演示，手把手带你完成！_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili</a></p><hr><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><p>在开始之前我们要解决三个问题。</p><ol><li><p>指针如何变成变量</p><ol><li><p>用变量的地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">p = &amp;a;</span><br><span class="line">*p = <span class="number">1001</span>;</span><br></pre></td></tr></table></figure></li><li><p>动态内存申请</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(sizeiof(<span class="keyword">int</span>));</span><br><span class="line">*p = <span class="number">10033</span>;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>什么是结构体？</p><p>就是一种类型，将几段内存组合成一段内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> A;</span><br><span class="line">    <span class="keyword">float</span> B;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如何访问？</p><ol><li><p>变量——.成员， </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span> <span class="title">C</span>;</span></span><br><span class="line">C.A = <span class="number">1001</span>;</span><br></pre></td></tr></table></figure></li><li><p>指针——-&gt;，指针指向运算符,C-&gt;A</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span> *<span class="title">sb</span> =</span> &amp;C;</span><br><span class="line">sb-&gt;A = <span class="number">1002</span>;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>什么是链表？</p></li></ol><p>多个结构体变量链接在一起的线性结构。就是一个变量。</p><h1 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2.代码实现"></a>2.代码实现</h1><p><strong>缺陷：</strong></p><p><strong>不包括用户信息</strong></p><p><strong>借出和归还没有放到文件操作里面</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//图书管理系统 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">//3.数据的设计</span></span><br><span class="line"><span class="comment">// 3.1程序用什么东西处理数据  -数组 -链表 ——无非就是去考虑用什么容器来装数据</span></span><br><span class="line"><span class="comment">// 3.2数据的结构 --- 图书的信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bookInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">20</span>];<span class="comment">//书名</span></span><br><span class="line"><span class="keyword">float</span> price;<span class="comment">//价格</span></span><br><span class="line"><span class="keyword">int</span> num;<span class="comment">//数量</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">//链表的第一个结点不存放数据，叫做有表头链表。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bookInfo</span> <span class="title">data</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">list</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//创建表头 表头就是一个结构体变量</span></span><br><span class="line"><span class="function">struct Node* <span class="title">creatHead</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//动态内存申请</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">headNode</span> =</span> (struct Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));</span><br><span class="line"><span class="comment">//变量的基本规则——使用前必须初始化</span></span><br><span class="line">headNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> headNode;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//创建结点——为插入做准备</span></span><br><span class="line"><span class="comment">//把用户的数据编程结构体变量</span></span><br><span class="line"><span class="function">struct Node* <span class="title">creatNode</span><span class="params">(struct bookInfo data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">newNode</span> =</span> (struct Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));</span><br><span class="line">newNode-&gt;data = data;</span><br><span class="line">newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> newNode;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//插入-只需要一种插入方法-表头法插入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertNodeByHead</span><span class="params">(struct Node* headNode,struct bookInfo data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">newNode</span> =</span> creatNode(data);</span><br><span class="line"><span class="comment">//必须先链接后断开</span></span><br><span class="line">newNode-&gt;next = headNode-&gt;next;</span><br><span class="line">headNode-&gt;next = newNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//尾插法</span></span><br><span class="line"><span class="comment">//void insertNodeByTail(struct Node* headNode, int data)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//struct Node* pMove = headNode;</span></span><br><span class="line"><span class="comment">//while (pMove-&gt;next != NULL)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//pMove = pMove-&gt;next;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//struct Node* newNode = creatNode(data);</span></span><br><span class="line"><span class="comment">//pMove-&gt;next = newNode;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//指定位置删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteNodeByName</span><span class="params">(struct Node* headNode, <span class="keyword">char</span>* bookName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">posLeftNode</span> =</span> headNode;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">posNode</span> =</span> headNode-&gt;next;</span><br><span class="line"><span class="comment">//书籍名字是字符串，所以要采用字符串比较函数来处理。</span></span><br><span class="line"><span class="keyword">while</span> (posNode != <span class="literal">NULL</span> &amp;&amp; <span class="built_in">strcmp</span>(posNode-&gt;data.name,bookName))</span><br><span class="line">&#123;</span><br><span class="line">posLeftNode = posNode;</span><br><span class="line">posNode = posLeftNode-&gt;next;</span><br><span class="line">posNode = posLeftNode-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//讨论查找的结果</span></span><br><span class="line"><span class="keyword">if</span> (posNode == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;delete successful\n&quot;</span>);</span><br><span class="line">posLeftNode-&gt;next = posNode-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(posNode);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">struct Node* <span class="title">searchByName</span><span class="params">(struct Node* headNode, <span class="keyword">char</span>* bookName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">posNode</span> =</span> headNode-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (posNode != <span class="literal">NULL</span> &amp;&amp; <span class="built_in">strcmp</span>(posNode-&gt;data.name,bookName))</span><br><span class="line">&#123;</span><br><span class="line">posNode = posNode-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> posNode; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(struct Node* headNode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//定义一个指针，从第二个开始打印</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pMove</span> =</span> headNode-&gt;next;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;书名\t价格\t数量\n&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (pMove != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//打印数据——剥洋葱</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\t%.1f\t%d\n&quot;</span>, pMove-&gt;data.name,pMove-&gt;data.price,pMove-&gt;data.num);</span><br><span class="line">pMove = pMove-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.写界面---菜单---模块</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mainMenu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;——————————————\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;-Libraty manangement system-\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;————0.exit———————-\n&quot;</span>);<span class="comment">//退出</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;————1.resiger——————\n&quot;</span>);<span class="comment">//登记</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;————2.browse————-----\n&quot;</span>);<span class="comment">//浏览</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;————3.borrow————-----\n&quot;</span>);<span class="comment">//借</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;————4.back————-------\n&quot;</span>);<span class="comment">//还</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;————5.sort————-------\n&quot;</span>);<span class="comment">//排序</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;————6.delete————-----\n&quot;</span>);<span class="comment">//删除</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;————7.seek————-------\n&quot;</span>);<span class="comment">//查找</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;——————————————\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;——please input 0 to 7------\n&quot;</span>);<span class="comment">//提示</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//直接文件操作</span></span><br><span class="line"><span class="comment">//所有的文件都在这个容器里面，做文件操作就是对这个List进行文件操作</span></span><br><span class="line"><span class="comment">//运行的时候把文件的信息读到List里面</span></span><br><span class="line"><span class="comment">//结束的时候把List里面的信息同步到文件里面</span></span><br><span class="line"><span class="comment">//文件存（写）操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saveInfoToFile</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* fileName, struct Node* headNode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FILE* fp = fopen(fileName, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pMove</span> =</span> headNode-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (pMove != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(fp,<span class="string">&quot;%s\t%.1f\t%d\n&quot;</span>,pMove-&gt;data.name,pMove-&gt;data.price,pMove-&gt;data.num);</span><br><span class="line">pMove = pMove-&gt;next; </span><br><span class="line">&#125;</span><br><span class="line">fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//文件读操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readInfoFromFile</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* fileName, struct Node* headNode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FILE* fp = fopen(fileName, <span class="string">&quot;r&quot;</span>);<span class="comment">//第一次打开文件肯定是不存在的</span></span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//不存在就把文件创建出来</span></span><br><span class="line"><span class="comment">//如果第一次打开文件是空的，用w+方式打开文件，可读可写。</span></span><br><span class="line">fp = fopen(fileName, <span class="string">&quot;w+&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bookInfo</span> <span class="title">tempData</span>;</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">fscanf</span>(fp, <span class="string">&quot;%s\t%f\t%d\n&quot;</span>, tempData.name, &amp;tempData.price, &amp;tempData.num) != EOF);</span><br><span class="line">&#123;</span><br><span class="line">insertNodeByHead(<span class="built_in">list</span>, tempData);</span><br><span class="line">&#125;</span><br><span class="line">fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//算法是一种思想</span></span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSortList</span><span class="params">(struct Node* headNode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (struct Node* p = headNode-&gt;next; p != <span class="literal">NULL</span>; p = p-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (struct Node* q = headNode-&gt;next; q-&gt;next != <span class="literal">NULL</span>; q = q-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (q-&gt;data.price &gt; q-&gt;next-&gt;data.price)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//交换值</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bookInfo</span> <span class="title">tempData</span> =</span> q-&gt;data;</span><br><span class="line">q-&gt;data = q-&gt;next-&gt;data; </span><br><span class="line">q-&gt;next-&gt;data = tempData; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printList(headNode);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.交互-按键处理-跳转</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">keyDown</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> userKey = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bookInfo</span> <span class="title">tempbook</span>;</span><span class="comment">//产生一个临时的变量存储书籍信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">result</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;userKey);</span><br><span class="line"><span class="keyword">switch</span>(userKey)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;【exit】\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;successful\n&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">//关闭整个程序</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;【resiger】\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;input your book&#x27;s information(name,price,num):&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s%f%d&quot;</span>,tempbook.name, &amp;tempbook.price, &amp;tempbook.num);</span><br><span class="line"><span class="comment">//第一个temobook.name是字符串 不用取地址</span></span><br><span class="line">insertNodeByHead(<span class="built_in">list</span>, tempbook);</span><br><span class="line">saveInfoToFile(<span class="string">&quot;bookinfo.txt&quot;</span>,<span class="built_in">list</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;【browse】\n&quot;</span>);</span><br><span class="line">printList(<span class="built_in">list</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;【borrow】\n&quot;</span>);</span><br><span class="line"><span class="comment">//书籍存在可以借阅，存在书的数量-1，不存在借阅失败</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;please input book name\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, tempbook.name);</span><br><span class="line">result = searchByName(<span class="built_in">list</span>,tempbook.name);</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (result == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;without the book\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (result-&gt;data.num &gt;= <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">result-&gt;data.num--;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;borrow successful\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;the book it&#x27;s not here\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;【back】\n&quot;</span>);</span><br><span class="line"><span class="comment">//把当前书籍的数量+1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;please input book name\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, tempbook.name);</span><br><span class="line">result = searchByName(<span class="built_in">list</span>, tempbook.name);</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (result == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;illegal book\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">result-&gt;data.num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>; </span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;【sort】\n&quot;</span>);</span><br><span class="line">bubbleSortList(<span class="built_in">list</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;【delete】\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;please input book name\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, tempbook.name);</span><br><span class="line">deleteNodeByName(<span class="built_in">list</span>, tempbook.name);</span><br><span class="line">saveInfoToFile(<span class="string">&quot;bookinfo.txt&quot;</span>, <span class="built_in">list</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;【seek】\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;please input book name\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,tempbook.name);</span><br><span class="line">result = searchByName(<span class="built_in">list</span>, tempbook.name);</span><br><span class="line"><span class="keyword">if</span> (result == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t find\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;name\tprice\tnum\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\t%.1f\t%d\n&quot;</span>, result-&gt;data.name, result-&gt;data.price, result-&gt;data.num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;【error】\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">list</span>  = creatHead();</span><br><span class="line">readInfoFromFile(<span class="string">&quot;bookinfo.txt&quot;</span>,<span class="built_in">list</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">mainMenu();</span><br><span class="line">keyDown();</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);<span class="comment">//防闪退</span></span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);<span class="comment">//清除</span></span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;相关视频——&lt;a href=&quot;https://www.bilibili.com/video/BV1E64y1171r&quot;&gt;C语言课程设计实战：图书管理系统！计算机专业同学的一大难题，今天用代码实战演示，手把手带你完成！_哔哩哔哩 (゜-゜)つロ 干杯~-bilibi</summary>
      
    
    
    
    <category term="C语言" scheme="http://example.com/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="-C语言" scheme="http://example.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C语言编写Web服务器</title>
    <link href="http://example.com/2021/05/06/C%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://example.com/2021/05/06/C%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99Web%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2021-05-06T13:39:01.000Z</published>
    <updated>2021-05-08T10:11:44.835Z</updated>
    
    <content type="html"><![CDATA[<hr><p>相关视频——<a href="https://www.bilibili.com/video/BV1uA411u7kD">C/C++技术教学：web 网络服务器开发！纯C语言手写web服务器，仅需 80 行代码，制作出你的专属服务器_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili</a></p><hr><h1 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h1><ol><li><p>什么是端口？</p><p>物理端口：电脑网口、USB、看的见的接口。</p><p>虚拟端口：程序和网络进行通信的端口。</p><p>端口就好比一个房子的门，是初入这个房子的必经之路。</p></li><li><p>端口号</p><p>端口是通过端口号来标记的，端口号只有整数，范围是从0到65535。</p><p>（为什么最大是65535？）</p></li><li><p>端口号怎么分配的</p><p>端口号不是随意使用的，而是按照一定的规定进行分配。</p></li><li><p>知名端口</p><p>知名端口是众所周知的端口号，范围从0到1023，</p><p> 80端口分配给HTTP服务，</p><p>21端口分配给FTP服务。</p></li><li><p>动态端口</p><p>动态端口的范围是从1024到65535，由操作系统进行分配。    </p><p>之所以称为动态端口，是因为它一般不固定分配某种服务，而是动态分配。</p><p>动态分配是指当一个系统进程或应用程序进程需要网络通信时，</p><p>它向主机申请一个端口，主机从可用的端口号中分配一个供它使用。</p><p>当这个进程关闭时，同时也就释放啦它所占用的端口号。</p></li></ol><h1 id="Tcp服务器"><a href="#Tcp服务器" class="headerlink" title="Tcp服务器"></a>Tcp服务器</h1><p>如同接电话的过程一样，在程序中，如果想要完成一个tcp服务器的功能，需要的流程如下：</p><ol><li>socket创建一个套接字</li><li>bind绑定ip和port</li><li>listen使套接字变为可以被动链接</li><li>accept等待客户端的链接</li><li>recv/send接收发送数据</li></ol><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//web Server</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;WinSock2.h&gt;//包含网络编程的头文件，引入静态库</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"><span class="keyword">bool</span> isok;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merror</span><span class="params">(<span class="keyword">int</span> redata,<span class="keyword">int</span> error,<span class="keyword">char</span>* showinfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (redata == error)</span><br><span class="line">&#123;</span><br><span class="line">perror(showinfo);</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendhtml</span><span class="params">(SOCKET s, <span class="keyword">char</span>* filename)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;weclome to my WebServer\n&quot;</span>);</span><br><span class="line">WSADATA wsdata;</span><br><span class="line">WSAStartup(MAKEWORD(<span class="number">2</span>,<span class="number">2</span>),&amp;wsdata);<span class="comment">//确定socket版本信息</span></span><br><span class="line"><span class="comment">//short两个字节2.2</span></span><br><span class="line">merror(isok,WSAEINVAL,<span class="string">&quot;申请socket失败&quot;</span>);</span><br><span class="line"><span class="comment">//第一个参数-协议族，决定socket的地址类型</span></span><br><span class="line"><span class="comment">//第二个参数-传输类型,SOCK_STREAM流传输</span></span><br><span class="line"><span class="comment">//第三个参数-指定的传输协议，tcp</span></span><br><span class="line">SOCKET server = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);<span class="comment">//使用af-inet,ipv4地址</span></span><br><span class="line">merror(server, INVALID_SOCKET, <span class="string">&quot;创建socker失败&quot;</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">seraddr</span>;</span></span><br><span class="line">seraddr.sin_family = AF_INET;<span class="comment">//和创建的时候一样，使用了Ipv4</span></span><br><span class="line">seraddr.sin_port = htons(<span class="number">80</span>);<span class="comment">//注意网络中的数据和电脑上的数据存储是有区别的，网络是大端存储，pc是小端存储</span></span><br><span class="line">seraddr.sin_addr.s_addr = INADDR_ANY;<span class="comment">//监听任意的地址</span></span><br><span class="line">isok  = bind(server,&amp;seraddr,<span class="keyword">sizeof</span>(seraddr));</span><br><span class="line">merror(isok, SOCKET_ERROR, <span class="string">&quot;绑定失败...\n&quot;</span>);</span><br><span class="line">isok = listen(server, <span class="number">5</span>);</span><br><span class="line">merror(isok, SOCKET_ERROR, <span class="string">&quot;监听失败...\n&quot;</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">claddr</span>;</span></span><br><span class="line"><span class="keyword">int</span> cllen = <span class="keyword">sizeof</span>(claddr);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">SOCKET client = accept(server, &amp;claddr, &amp;cllen);<span class="comment">//谁连进来了，发了多少数据</span></span><br><span class="line">merror(client, INVALID_SOCKET, <span class="string">&quot;连接失败...\n&quot;</span>);</span><br><span class="line"><span class="keyword">char</span> revdata[<span class="number">1024</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">recv(client,revdata,<span class="number">1024</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s 共接收到%d字节数据\n&quot;</span>, revdata,<span class="built_in">strlen</span>(revdata));</span><br><span class="line"><span class="comment">//如果下面这两行显示文字，测试发送成功。</span></span><br><span class="line"><span class="keyword">char</span> sendata[<span class="number">1024</span>] = <span class="string">&quot;&lt;h1 style =\&quot; color:pink;\&quot;&gt;hello,i&#x27;m sb&lt;/h1&gt;&quot;</span>;</span><br><span class="line">send(client,sendata,<span class="built_in">strlen</span>(sendata),<span class="number">0</span>);</span><br><span class="line"><span class="keyword">char</span>* filename = <span class="string">&quot;/&quot;</span>;<span class="comment">//填入文件名称xxx.html</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendhtml</span><span class="params">(client, filenama)</span></span>;</span><br><span class="line">closesocket(client);</span><br><span class="line">&#125;</span><br><span class="line">closesocket(server);</span><br><span class="line">WSACleanup();</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打开文件-网页</span></span><br><span class="line"><span class="comment">//将文件放入项目文件夹下</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendhtml</span><span class="params">(SOCKET s, <span class="keyword">char</span>* filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FILE* pfile = fopen(filename, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pfile == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;文件打开失败&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> temp[<span class="number">1024</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">fgets(temp, <span class="number">1024</span>, pfile);</span><br><span class="line">send(s, temp, <span class="built_in">strlen</span>(temp), <span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">while</span> (!feof(pfile));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;相关视频——&lt;a href=&quot;https://www.bilibili.com/video/BV1uA411u7kD&quot;&gt;C/C++技术教学：web 网络服务器开发！纯C语言手写web服务器，仅需 80 行代码，制作出你的专属服务器_哔哩哔哩 (゜-゜)つロ 干杯~</summary>
      
    
    
    
    <category term="网络编程" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="-C语言" scheme="http://example.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="-网络编程" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    <category term="-服务器" scheme="http://example.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>认识各种图</title>
    <link href="http://example.com/2021/05/06/%E8%AE%A4%E8%AF%86%E5%90%84%E7%A7%8D%E5%9B%BE/"/>
    <id>http://example.com/2021/05/06/%E8%AE%A4%E8%AF%86%E5%90%84%E7%A7%8D%E5%9B%BE/</id>
    <published>2021-05-06T10:13:06.000Z</published>
    <updated>2021-05-06T10:34:33.495Z</updated>
    
    <content type="html"><![CDATA[<hr><p>相关视频——<a href="https://www.bilibili.com/video/BV1jW411K7yg?p=55">【C语言描述】《数据结构和算法》_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili</a></p><p>相关书籍——《大话数据结构》</p><ul><li><p>图按照有无方向分为<strong>无向图</strong>和有向图。</p><ul><li>无向图由定点和边构成。</li></ul><p><img src="/images/%E8%AE%A4%E8%AF%86%E5%90%84%E7%A7%8D%E5%9B%BE.assets/image-20210506162522098.png" alt="image-20210506162522098"></p><ul><li>有向图由定点和弧构成，弧有弧尾和弧头之分。</li></ul><p><img src="/images/%E8%AE%A4%E8%AF%86%E5%90%84%E7%A7%8D%E5%9B%BE.assets/image-20210506162528354.png" alt="image-20210506162528354"></p></li><li><p>如果任意两个顶点之间都存在边叫做<strong>完全图</strong>。</p><ul><li>无向的叫做<strong>无向完全图</strong>。</li></ul><p><img src="/images/%E8%AE%A4%E8%AF%86%E5%90%84%E7%A7%8D%E5%9B%BE.assets/image-20210506162751354.png" alt="image-20210506162751354"></p><ul><li>有向的叫做<strong>有向完全图</strong>。</li></ul><p><img src="/images/%E8%AE%A4%E8%AF%86%E5%90%84%E7%A7%8D%E5%9B%BE.assets/image-20210506170101163.png" alt="image-20210506170101163"></p></li><li><p>图按照边或弧的多少分为<strong>稀疏图</strong>和稠密图。</p><ul><li>都是相对而言的多少。</li></ul></li><li><p>若无重复的变到自身的边叫做<strong>简单图</strong>。</p><p><strong>反例</strong>：下面这两个图都不是简单图。</p><p><img src="/images/%E8%AE%A4%E8%AF%86%E5%90%84%E7%A7%8D%E5%9B%BE.assets/image-20210506163031340.png" alt="image-20210506163031340"></p><p><img src="/images/%E8%AE%A4%E8%AF%86%E5%90%84%E7%A7%8D%E5%9B%BE.assets/image-20210506163047070.png" alt="image-20210506163047070"></p></li><li><p>图和顶点之间有邻接点、依附的概念。</p></li><li><p>无向图顶点的边数叫做度，有向图顶点分入度和出度。</p><p>（入度：有几个箭头指向这个顶点，出度：指向几个顶点。）</p></li><li><p>图上的边或弧上带权则称为网。</p></li></ul><p><img src="/images/%E8%AE%A4%E8%AF%86%E5%90%84%E7%A7%8D%E5%9B%BE.assets/image-20210506163216486.png" alt="image-20210506163216486"></p><ul><li><p>图中顶点间存在路径，两顶点存在路径则说明是连通的。</p><ul><li>例如：由B到D在无向图上有四种不同的路径。</li></ul><p><img src="/images/%E8%AE%A4%E8%AF%86%E5%90%84%E7%A7%8D%E5%9B%BE.assets/image-20210506163830914.png" alt="image-20210506163830914"></p></li><li><p>在有向图上由B到D有两种路径。</p></li></ul><p><img src="/images/%E8%AE%A4%E8%AF%86%E5%90%84%E7%A7%8D%E5%9B%BE.assets/image-20210506164007180.png" alt="image-20210506164007180"></p><ul><li><p>如果路径最终回到起始点则称为环，当中不重复叫简单环。</p><ul><li>简单环</li></ul><p><img src="/images/%E8%AE%A4%E8%AF%86%E5%90%84%E7%A7%8D%E5%9B%BE.assets/image-20210506164241631.png" alt="image-20210506164241631"></p><ul><li>不是简单环，顶点C重复了。</li></ul><p><img src="/images/%E8%AE%A4%E8%AF%86%E5%90%84%E7%A7%8D%E5%9B%BE.assets/image-20210506164329827.png" alt="image-20210506164329827"></p></li><li><p>若任意两顶点都是连通的，则图就是<strong>连通图</strong>。</p><p><img src="/images/%E8%AE%A4%E8%AF%86%E5%90%84%E7%A7%8D%E5%9B%BE.assets/image-20210506164424476.png" alt="image-20210506164424476"></p><ul><li>不连通图</li></ul><p><img src="/images/%E8%AE%A4%E8%AF%86%E5%90%84%E7%A7%8D%E5%9B%BE.assets/image-20210506164831080.png" alt="image-20210506164831080"></p><ul><li>有向则称为强连通图。</li></ul><p><img src="/images/%E8%AE%A4%E8%AF%86%E5%90%84%E7%A7%8D%E5%9B%BE.assets/image-20210506165613351.png" alt="image-20210506165613351"></p><p><img src="/images/%E8%AE%A4%E8%AF%86%E5%90%84%E7%A7%8D%E5%9B%BE.assets/image-20210506170130769.png" alt="image-20210506170130769"></p><p><strong>（结合上面的有向完全图，我们不难发现，有向完全图就是强连通图，因为它任意两个定点间都有是连通的，但是强连通图不一定是有完全向图，因为有向完全图需要任意两个顶点间有相反的两条路径。）</strong></p><ul><li><p>连通分量强调：</p><ul><li>要是子图；</li><li>子图是连通的；</li><li>连通子图含有极大顶点数；<strong>极大顶点数就是最大连通子图上的顶点数量。</strong></li><li>具有极大顶点数的连通子图包含依附于这些顶点的所有边。</li></ul></li><li><p>无向图中的极大连通子图称为连通分量，有向的则称为<strong>强连通分量</strong>。</p><ul><li>非连通图的连通分量。</li></ul><p><img src="/images/%E8%AE%A4%E8%AF%86%E5%90%84%E7%A7%8D%E5%9B%BE.assets/image-20210506172939981.png" alt="image-20210506172939981"></p><p>​    它的连通分量</p><p><img src="/images/%E8%AE%A4%E8%AF%86%E5%90%84%E7%A7%8D%E5%9B%BE.assets/image-20210506173010623.png" alt="image-20210506173010623"></p><ul><li>有向但是非强连通图的(极大)强连通分量。</li></ul><p><img src="/images/%E8%AE%A4%E8%AF%86%E5%90%84%E7%A7%8D%E5%9B%BE.assets/image-20210506173231860.png" alt="image-20210506173231860"></p><p>它的强连通分量。</p><p><img src="/images/%E8%AE%A4%E8%AF%86%E5%90%84%E7%A7%8D%E5%9B%BE.assets/image-20210506173330999.png" alt="image-20210506173330999"></p></li></ul></li><li><p><strong>连通生成树。</strong></p><ul><li>所谓的连通图的生成树是一个极小的连通子图，它含有图中全部的n个顶点，但只有足以构成一个树的n-1条边。</li><li>无向图的连通生成树。</li></ul><p><img src="/images/%E8%AE%A4%E8%AF%86%E5%90%84%E7%A7%8D%E5%9B%BE.assets/image-20210506180115966.png" alt="image-20210506180115966"></p><ul><li><p>有向图恰<strong>有一个顶点的入度为0，其余顶点的入度为1，</strong>则是一棵有向树。</p><p>例如下面这两棵有向树。</p></li></ul><p><img src="/images/%E8%AE%A4%E8%AF%86%E5%90%84%E7%A7%8D%E5%9B%BE.assets/image-20210506174842218.png" alt="image-20210506174842218"></p><p><img src="/images/%E8%AE%A4%E8%AF%86%E5%90%84%E7%A7%8D%E5%9B%BE.assets/image-20210506174924663.png" alt="image-20210506174924663"></p></li><li><p>一个有向图由若干棵有向树构成生成<strong>森林</strong>。</p><ul><li>一个有向图的生成森林由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧</li><li>例如：一下三张图，图1是一棵有向图。去掉一些弧之后，它可以分解为两课有向树，如图2和图3，这两棵就是图1有向图的生成森林。</li></ul><p><img src="/images/%E8%AE%A4%E8%AF%86%E5%90%84%E7%A7%8D%E5%9B%BE.assets/image-20210506181019760.png" alt="image-20210506181019760"></p><p><img src="/images/%E8%AE%A4%E8%AF%86%E5%90%84%E7%A7%8D%E5%9B%BE.assets/image-20210506181102303.png" alt="image-20210506181102303"></p></li></ul><p><img src="/images/%E8%AE%A4%E8%AF%86%E5%90%84%E7%A7%8D%E5%9B%BE.assets/image-20210506181109968.png" alt="image-20210506181109968"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;相关视频——&lt;a href=&quot;https://www.bilibili.com/video/BV1jW411K7yg?p=55&quot;&gt;【C语言描述】《数据结构和算法》_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;相关书籍——《大话数据结构</summary>
      
    
    
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="-数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="-树" scheme="http://example.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>赫夫曼树及其应用</title>
    <link href="http://example.com/2021/05/06/%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"/>
    <id>http://example.com/2021/05/06/%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/</id>
    <published>2021-05-06T02:48:47.000Z</published>
    <updated>2021-05-06T02:54:31.460Z</updated>
    
    <content type="html"><![CDATA[<p>前言:</p><p>最基本的压缩编码方法——赫夫曼(huffman)编码。</p><p>在了解赫夫曼编码之前，我们必须了解一下赫夫曼树，赫夫曼编码就是基于赫夫曼树实现的。</p><p>相关视频——<a href="https://www.bilibili.com/video/BV1jW411K7yg?p=52">【C语言描述】《数据结构和算法》_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili</a></p><p>相关书籍——《大话数据结构》</p><hr><h1 id="1-赫夫曼树的定义与原理"><a href="#1-赫夫曼树的定义与原理" class="headerlink" title="1.赫夫曼树的定义与原理"></a>1.赫夫曼树的定义与原理</h1><ul><li><p>结点的路径长度</p><ul><li>-从根节点到该结点的路径上的连接数。</li></ul></li><li><p>数的路径长度</p><ul><li>-树中每个叶子结点的路径长度之和。</li></ul></li><li><p>结点带权路径长度</p><ul><li>-结点的路径长度与结点权值的乘积。</li></ul></li><li><p>树的带权路径长度(WPL)</p><ul><li>-是树中所有叶子结点的带权路径长度之和。</li></ul></li><li><p>(数结点间的连线相关的数叫做权，Weight)</p></li></ul><hr><p><strong>其中：带权路径长度（WPL）最小的二叉树叫做赫夫曼树。</strong></p><p><strong>带权路径长度(WPL)的值越小，说明构造出来的二叉树性越优。</strong></p><hr><h1 id="2-构造赫夫曼树的过程"><a href="#2-构造赫夫曼树的过程" class="headerlink" title="2.构造赫夫曼树的过程"></a>2.构造赫夫曼树的过程</h1><p>初识森林</p><p><img src="/images/%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8.assets/image-20210505204148343.png" alt="image-20210505204148343"></p><p>在森林中选出两棵根节点的权值最小的二叉树，小的放左边，大的放右边。</p><p><img src="/images/%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8.assets/image-20210505204302270.png" alt="image-20210505204302270"></p><p>合并两颗选出的二叉树，增加一个新结点作为新二叉树的根，权值为左右孩子的权值之和。</p><p><img src="/images/%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8.assets/image-20210505204501617.png" alt="image-20210505204501617"></p><p>再从剩下的森林里面选出权值最小的二叉树，如果比第一次合并的结点权值小就放左边，反之，放右边。</p><p><img src="/images/%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8.assets/image-20210505204621908.png" alt="image-20210505204621908"></p><p>再次进行合并。</p><p><img src="/images/%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8.assets/image-20210505204703975.png" alt="image-20210505204703975"></p><p>第二次合并完成，第三次合并同理。</p><p><img src="/images/%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8.assets/image-20210505204752864.png" alt="image-20210505204752864"></p><p>合并完成，这个二叉树就是赫夫曼树。</p><h1 id="3-赫夫曼编码原理"><a href="#3-赫夫曼编码原理" class="headerlink" title="3.赫夫曼编码原理"></a>3.赫夫曼编码原理</h1><hr><p>补充：</p><p>赫夫曼研究这种最优树的目的是为了解决当年远距通信(主要是电报)的数据传输的最优化问题。</p><hr><p><strong>名词解释：</strong></p><ul><li>定长编码<ul><li>-像ASCII编码，用八位二进制数来表示一个字符。</li></ul></li><li>变长编码<ul><li>-单个编码的长度不一致，可以根据整体频率来调节。</li></ul></li><li>前缀码<ul><li>-所谓的前缀码，就是没有任何码字是其他码字的前缀。</li></ul></li></ul><hr><p><strong>编码过程（encode）：</strong>还是利用上面的赫夫曼二叉树。</p><p>上图为构造赫夫曼树的过程权值显示。</p><p>下图为将权值左支改为0，右支改为1后的赫夫曼树。</p><p><img src="/images/%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8.assets/image-20210505210353927.png" alt="image-20210505210353927"></p><p><img src="/images/%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8.assets/image-20210505210746239.png" alt="image-20210505210746239"></p><p>我们对这4个字母(ABCD)用其从树根到叶子所经过路径0或1来进行编码。</p><p>例如原文字内容是ABCD。</p><p><strong>原编码二进制串：000001010011</strong>(共12个字符)</p><p><strong>新编码二进制串：010110111</strong>(共9 个字符)</p><p>也就是说我们的数据被压缩了，节约了25%的存储空间或者传输成本，随着字符的增加和字符权重的不同，这种压缩会更加显出其优势。</p><hr><p><strong>解码过程（decode）：</strong></p><p>发送方和接收方必须要约定好同样的赫夫曼编码规则，由约定好的赫夫曼树可以成功解码。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前言:&lt;/p&gt;
&lt;p&gt;最基本的压缩编码方法——赫夫曼(huffman)编码。&lt;/p&gt;
&lt;p&gt;在了解赫夫曼编码之前，我们必须了解一下赫夫曼树，赫夫曼编码就是基于赫夫曼树实现的。&lt;/p&gt;
&lt;p&gt;相关视频——&lt;a href=&quot;https://www.bilibili.com/vi</summary>
      
    
    
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="-数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="-树" scheme="http://example.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>二叉树理论基础</title>
    <link href="http://example.com/2021/04/29/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2021/04/29/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/</id>
    <published>2021-04-29T11:55:53.000Z</published>
    <updated>2021-04-29T12:17:41.464Z</updated>
    
    <content type="html"><![CDATA[<hr><p>推荐视频——<a href="https://www.bilibili.com/video/BV1Hy4y1t7ij">关于二叉树，你该了解这些！| 二叉树理论基础一网打尽，二叉树的种类、二叉树的存储方式、二叉树节点定义、二叉树的遍历顺序_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili</a></p><p>理论基础，这些都是我们平时刷题应该掌握的内容。</p><p>把基础打牢了，有了逻辑基础，学的才会更好一些。</p><hr><h1 id="1-二叉树的种类"><a href="#1-二叉树的种类" class="headerlink" title="1.二叉树的种类"></a>1.二叉树的种类</h1><h2 id="1-满二叉树"><a href="#1-满二叉树" class="headerlink" title="1.满二叉树:"></a>1.满二叉树:</h2><ul><li>在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树叫做满二叉树。</li><li>结点数量2^k-1</li><li><img src="/images/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.assets/image-20210429175608363.png" alt="image-20210429175608363"></li></ul><h2 id="2-完全二叉树"><a href="#2-完全二叉树" class="headerlink" title="2.完全二叉树"></a>2.完全二叉树</h2><ul><li>除了底层以外，其它层都是满的，底层是从左到右连续的。</li><li>这个是二叉树</li><li><img src="/images/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.assets/image-20210429180224698.png" alt="image-20210429180224698"></li><li>这个就不是二叉树，底层不连续。</li><li><img src="/images/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.assets/image-20210429180259535.png" alt="image-20210429180259535"></li></ul><hr><p><strong>满二叉树一定是一棵完全二叉树，但完全而二叉树不一定是满的。</strong></p><hr><h2 id="3-二叉搜索树"><a href="#3-二叉搜索树" class="headerlink" title="3.二叉搜索树"></a>3.二叉搜索树</h2><ul><li><p>在它里面的结点顺序，左子树的所有结点都小于中间结点，右子树的所有结点都大于中间结点。</p></li><li><p><img src="/images/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.assets/image-20210429181442803-1619691288466.png" alt="image-20210429181442803"></p></li><li><p>二叉搜索树对结点的布局是没有要求的，元素有顺序就可以。</p></li><li><p>平衡二叉搜索树</p><ul><li>左子树和右子树的高度差不能超过1。</li></ul></li></ul><h1 id="2-二叉树的存储方式"><a href="#2-二叉树的存储方式" class="headerlink" title="2.二叉树的存储方式"></a>2.二叉树的存储方式</h1><h2 id="1-顺序存储"><a href="#1-顺序存储" class="headerlink" title="1.顺序存储"></a>1.顺序存储</h2><p><img src="/images/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.assets/image-20210429184344211.png" alt="image-20210429184344211"></p><p>用这个字符数组来保存二叉树。</p><p><img src="/images/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.assets/image-20210429184437352.png" alt="image-20210429184437352"></p><p>*<em>2</em>i+1——左孩子，2 <em>i+2——右孩子。</em>*</p><h2 id="2-链式存储"><a href="#2-链式存储" class="headerlink" title="2.链式存储"></a>2.链式存储</h2><p>一般用的都是链式存储。</p><p><img src="/images/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.assets/image-20210429185353229.png" alt="image-20210429185353229"></p><h1 id="3-二叉树的遍历"><a href="#3-二叉树的遍历" class="headerlink" title="3.二叉树的遍历"></a>3.二叉树的遍历</h1><hr><p><strong>扩展：</strong></p><ul><li>深度优先搜索：一般都是用递归的方式来实现的，前序遍历，中序遍历，后序遍历，都是深度优先搜索。(迭代法也可以实现前中后序，非递归的方式。)</li><li>广度优先搜索：一层一层的去遍历，或者是一圈一圈的去遍历。层序遍历就是广度优先搜索的一种。</li></ul><hr><p><img src="/images/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.assets/image-20210429193726478.png" alt="image-20210429193726478"></p><p>前序遍历：<strong>中左右。</strong>5412678</p><p>中序遍历：左中右。4125768</p><p>后序遍历：左右中。1247865</p><h1 id="4-二叉树结点的定义"><a href="#4-二叉树结点的定义" class="headerlink" title="4.二叉树结点的定义"></a>4.二叉树结点的定义</h1><p><strong>将二叉树理解为一个链表就会简单很多。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">int</span> val;<span class="comment">//放数值</span></span><br><span class="line">   TreeNode* left;</span><br><span class="line">   TreeNode* right;</span><br><span class="line">    <span class="comment">//实现一个构造函数，在new一个结点的时候，方便对其进行初始化。</span></span><br><span class="line">   TreeNode(t):val:t,left(<span class="literal">NULL</span>),right(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;推荐视频——&lt;a href=&quot;https://www.bilibili.com/video/BV1Hy4y1t7ij&quot;&gt;关于二叉树，你该了解这些！| 二叉树理论基础一网打尽，二叉树的种类、二叉树的存储方式、二叉树节点定义、二叉树的遍历顺序_哔哩哔哩 (゜-゜)つロ</summary>
      
    
    
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="-数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="-树" scheme="http://example.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>KMP算法</title>
    <link href="http://example.com/2021/04/28/KMP%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2021/04/28/KMP%E7%AE%97%E6%B3%95/</id>
    <published>2021-04-28T04:07:37.000Z</published>
    <updated>2021-04-28T15:40:18.636Z</updated>
    
    <content type="html"><![CDATA[<hr><p><strong>强烈推荐Carl老哥的视频！！！</strong></p><p>多看几遍肯定是可以学会的。</p><p>理论篇——<a href="https://www.bilibili.com/video/BV1PD4y1o7nd">帮你把KMP算法学个通透！（理论篇）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili</a></p><p>求Next数组代码篇——<a href="https://www.bilibili.com/video/BV1M5411j7Xx?t=133">帮你把KMP算法学个通透！（求next数组代码篇）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili</a></p><hr><h1 id="1-什么是KMP算法"><a href="#1-什么是KMP算法" class="headerlink" title="1.什么是KMP算法"></a>1.什么是KMP算法</h1><p>​        KMP算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt提出的，因此人们称它为克努特—莫里斯—普拉特操作（简称KMP算法）。(百度百科)</p><h1 id="2-KMP算法能解决哪些问题"><a href="#2-KMP算法能解决哪些问题" class="headerlink" title="2.KMP算法能解决哪些问题"></a>2.KMP算法能解决哪些问题</h1><p><strong>解决字符串匹配问题</strong>    </p><p>给出文本串和模式串，用两层for循环进行匹配，进行暴力匹配，时间复杂度是O(m,n).其中m是模式串长度，n是文本串长度。</p><h1 id="3-KMP算法是如何运行的"><a href="#3-KMP算法是如何运行的" class="headerlink" title="3.KMP算法是如何运行的"></a>3.KMP算法是如何运行的</h1><p>给出两个要匹配的串，<strong>文本串和模式串。</strong></p><p><img src="/images/KMP%E7%AE%97%E6%B3%95.assets/image-20210427205533964.png" alt="image-20210427205533964"></p><p><strong>第一次匹配</strong></p><p><img src="/images/KMP%E7%AE%97%E6%B3%95.assets/image-20210427205812823.png" alt="image-20210427205812823"></p><p><strong>第二次匹配</strong></p><p><img src="/images/KMP%E7%AE%97%E6%B3%95.assets/image-20210427210037607.png" alt="image-20210427210037607"></p><p><strong>跳到b处继续进行匹配</strong>。</p><p><strong>这就是KMP算法。</strong></p><h1 id="4-KMP算法是如何进行跳的"><a href="#4-KMP算法是如何进行跳的" class="headerlink" title="4.KMP算法是如何进行跳的"></a>4.KMP算法是如何进行跳的</h1><p>用到了很重要的表——<strong>前缀表。</strong></p><p>那么，KMP算法为什么不用hash表或者其它表呢?</p><hr><p><strong>前缀表的特性：</strong></p><ul><li><p><strong>如何实现：当进行到不匹配的元素时，找到该元素前面的字串，找到一组相等的前后缀，在该前缀的后面进行第二次匹配，就跳过去了。其实就是找最长相等前后缀的长度，从这个以这个长度为下标的元素开始进行匹配。</strong></p></li><li><p><strong>前缀：包括首元素不包括尾元素的所有字串，都称为前缀。</strong></p></li><li><p><strong>后缀：包括尾元素不包括首元素的所有字串，都称为后缀。</strong></p></li></ul><hr><h1 id="5-如何求取前缀表"><a href="#5-如何求取前缀表" class="headerlink" title="5.如何求取前缀表"></a>5.如何求取前缀表</h1><ul><li><p>  求最长相等(公共)前后缀</p></li><li><p>a的最长相等(公共)前后缀是0</p><p>aa的最长相等(公共)前后缀是1</p><p>aab的最长相等(公共)前后缀是0</p></li></ul><p>  ​    aaba的最长相等(公共)前后缀是1</p><p>  ​    aabaa的最长相等(公共)前后缀是2</p><p>  ​    aabaaf的最长相等(公共)前后缀是0</p><p>  ​    <strong>所以得出此模式串的前缀表是010120</strong></p><ul><li>得到最长相等(公共)前后缀是2<ul><li>2意味着：这里有一个后缀aa,前面有一个与其相等的前缀aa。</li><li>在后缀(aa)的后面(是f)后面不匹配(冲突)了。</li><li>就找与其相等的前缀(前面那个aa)后面那个元素(b)开始匹配。</li><li>(其实就是从最长相等前后缀的长度下标开始。)</li><li>(此模式串最长相等前后缀是2，就从该模式串下标为2的元素开始匹配。)</li><li>(2表示的是最长相等前后缀的长度，我们要跳到前缀的后面，前缀的后面的下标正好是前缀的长度，因为串的下标是从0开始的。)</li></ul></li><li>匹配成功,完成匹配过程。</li></ul><hr><p><strong>流程图:</strong></p><p><img src="/images/KMP%E7%AE%97%E6%B3%95.assets/kmpsuanfa.png"></p><hr><h1 id="6-KMP算法的实现"><a href="#6-KMP算法的实现" class="headerlink" title="6.KMP算法的实现"></a>6.KMP算法的实现</h1><p>有的做法会将前缀表进行一些调整，但总的思想是相同的。</p><p>有的用next数组，有的用perfix，这里用的Next数组。</p><p><strong>碰到了冲突的位置，我们要向前回退，这是Next数组的核心所在。</strong></p><p>对于实现，不同的人有不同的方法。</p><p>这里就用前缀表作为我们的Next数组。</p><p>求出来的Next数组就是该模式串的前缀表。</p><p>那么具体的代码应该怎么写呢？</p><hr><p><strong>明确求Next数组有几个步骤<br>    1.初始化<br>    2.处理前后缀不同的情况<br>    3.处理前后缀不相同的情况<br>    4.更新Next数组的值</strong></p><hr><p>**j指向前缀末尾位置(还代表着i之前包括i,字串的最长相等前后缀的长度)**。</p><p><strong>i指向后缀末尾位置。</strong></p><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span>* next,<span class="keyword">const</span> <span class="built_in">string</span>&amp;S)</span><span class="comment">//S为模式串，（此代码类似于伪代码）</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">//1.初始化</span></span><br><span class="line">   <span class="keyword">int</span> j = <span class="number">0</span>;<span class="comment">//j初始化为0，前缀一开始是从开始的位置开始。</span></span><br><span class="line">    next[<span class="number">0</span>];<span class="comment">//next数组初始位置也是0。</span></span><br><span class="line">    <span class="comment">//初始化完成</span></span><br><span class="line">    <span class="comment">//i的初始化就进入到我们的循环遍历里了</span></span><br><span class="line">    <span class="comment">//因为要比较前后缀所对应的字符是否相等，那i就应该是从1开始，这样i和j才能进行比较</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;S.size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//2.处理前后缀不相同情况</span></span><br><span class="line">        <span class="comment">//遇到不匹配看前一位 </span></span><br><span class="line">        <span class="comment">//这里的while容易写成if，我们回退的过程并不是一步就完事的</span></span><br><span class="line">        <span class="comment">//要判断前一位所以j&gt;0 </span></span><br><span class="line">        <span class="comment">//否则产生负数会造成数组越界</span></span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; S[i] != S[j])</span><br><span class="line">        &#123;</span><br><span class="line">            j = next[j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.处理前后缀相同的情况</span></span><br><span class="line">        <span class="comment">//这时候j应该+1，因为j不仅代表着前缀末尾的位置，还代表着i以及i之前这个字串的最长相等前后缀的长度。</span></span><br><span class="line">        <span class="keyword">if</span>(S[i] == S[j])</span><br><span class="line">        &#123;</span><br><span class="line">            j++;        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新Next数组</span></span><br><span class="line">        next[i] = j;</span><br><span class="line">        <span class="comment">//在循环里面,i++，向后面走一位</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;强烈推荐Carl老哥的视频！！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;多看几遍肯定是可以学会的。&lt;/p&gt;
&lt;p&gt;理论篇——&lt;a href=&quot;https://www.bilibili.com/video/BV1PD4y1o7nd&quot;&gt;帮你把KMP算法学个通</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="-笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="-算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>JAVA基础知识总结</title>
    <link href="http://example.com/2021/04/27/JAVA%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2021/04/27/JAVA%E5%9F%BA%E7%A1%80/</id>
    <published>2021-04-27T08:33:32.000Z</published>
    <updated>2021-04-27T10:01:35.431Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-JAVA基础"><a href="#1-JAVA基础" class="headerlink" title="1.JAVA基础"></a>1.JAVA基础</h1><h2 id="1-Hello-world"><a href="#1-Hello-world" class="headerlink" title="1. Hello world"></a>1. Hello world</h2><p><strong>psvm自动生成方法</strong></p><p>**sout自动生成system out **</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello sb!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-注释"><a href="#2-注释" class="headerlink" title="2. 注释"></a>2. 注释</h2><p><strong>单行注释：</strong>//</p><p><strong>多行注释：</strong>  /**/</p><p><strong>文档注释：</strong>JavaDoc /** * * * */(用处不大)</p><h2 id="3-标识符和关键字"><a href="#3-标识符和关键字" class="headerlink" title="3.标识符和关键字"></a>3.标识符和关键字</h2><p><strong>Java所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。</strong></p><p><img src="/images/JAVA%E5%9F%BA%E7%A1%80.assets/image-20210412205124735.png" alt="image-20210412205124735"></p><ul><li>所有的字标识符都应该以字母(A-Z,a-z)、美元符($)、或者下划线(_)开始。</li><li>首字符之后可以是(A-Z,a-z)、美元符($)、下划线(_)或数字的任何字符组合</li><li><strong>不能使用关键字作为变量名或方法名</strong></li><li>标识符是大小敏感的(<strong>区分大小写</strong>)</li><li>可以使用中文命名，但是一般不建议，也不建议使用拼音，sb</li></ul><h2 id="4-数据类型"><a href="#4-数据类型" class="headerlink" title="4.数据类型"></a>4.数据类型</h2><p><strong>强类型语言：</strong>要求变量的使用要严格符合规定，所有变量必须先定义之后才能使用。</p><p>(安全、严谨、避免很多错误)</p><p><strong>弱类型语言：</strong>随便定义</p><p><strong>Java的数据类型分为两大类：</strong></p><ul><li><p>基本类型 -数值类型-整数类型-byte-short-int-long</p><p>​                                    -浮点类型-float-double</p><p>​                                    -字符类型-char</p><p>​                 -boolean类型//默认true（if）</p></li><li><p>引用类型 - 类</p><p>​                 -接口</p><p>​                 -数组</p></li></ul><p><strong>数据类型+变量名+值     可以使用逗号隔开来声明多个同类型的变量。</strong></p><p><strong>转义字符：</strong></p><p><strong>变量：</strong>就是可以变化的量</p><p>​            Java是一种强类型语言，每个变量都必须声明其类型</p><p>​            Java变量程序中最基本的存储单元，其要素包括变量名，变量类型和作用域。</p><hr><h2 id="5-类型转换"><a href="#5-类型转换" class="headerlink" title="5.类型转换"></a>5.类型转换</h2><p>由于Java是强类型语言，所以要进行有些运算的时候，需要用到类型转换。</p><p><strong>运算中，不同类型的数据先转化为同一类型，然后进行运算。</strong></p><ul><li>强制类型转换</li></ul><p><strong>从高-低</strong></p><p><strong>(要转换的类型)变量名</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">128</span>;</span><br><span class="line">        <span class="keyword">byte</span> b = (<span class="keyword">byte</span>) i;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>自动类型转换</li><li><strong>从低-高</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">128</span>;</span><br><span class="line"><span class="keyword">double</span> b =  i;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li>不能对bool类型进行转换。</li><li>不能把对象的类型转换为不相干的类型。</li><li>高容量转化为低容量的时候，强制类型转换。</li><li>转化的时候可能存在内存溢出，或者精度问题。</li></ol><p>精度问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">18.3</span>);<span class="comment">//18.7</span></span><br><span class="line">System.out.println((<span class="keyword">int</span>)-<span class="number">45.89f</span>);<span class="comment">//45</span></span><br></pre></td></tr></table></figure><p>溢出问题</p><p>操作比较大的数的时候</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> year = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> money = <span class="number">10_0000_0000</span>;</span><br><span class="line"><span class="keyword">long</span> total = money*year;</span><br><span class="line"><span class="comment">//得到的结果溢出，默认是int，在转换之前就出现问题了。</span></span><br><span class="line"><span class="keyword">long</span> total2 = money*(<span class="keyword">long</span>(year));</span><br></pre></td></tr></table></figure><h2 id="6-变量"><a href="#6-变量" class="headerlink" title="6.变量"></a>6.变量</h2><p><strong>什么是变量：</strong>就是可以变化的量。</p><p>Java是一种强类型语言，每个变量都必须声明其类型。</p><p>Java变量是程序中最基本的存储单元，其要素包括变量名，变量类型和作用域。</p><p><strong>数据类型  变量名 =  值</strong></p><p><strong>注意：</strong></p><ul><li>每个变量都有类型，类型可以是基本的类型，也可以是引用类型。</li><li>变量名必须是合法的标识符。</li><li>变量声明是一条完整的语句，因此每个声明都必须以分号结束。</li></ul><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">sb</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> allClicks = <span class="number">0</span>; <span class="comment">//类变量</span></span><br><span class="line">    String str = <span class="string">&quot;hello sb&quot;</span>; <span class="comment">//实例变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">//局部变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">sb</span></span>&#123;</span><br><span class="line">    <span class="comment">//类变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> salary = <span class="number">2500</span>;<span class="comment">//2500默认是int类型 自动转换成了double</span></span><br><span class="line">    <span class="comment">//属性:简单理解为变量</span></span><br><span class="line">    <span class="comment">//实例变量：从属于对象,如果不进行初始化，这个数值类型的默认值</span></span><br><span class="line">    <span class="comment">//布尔值：默认是false</span></span><br><span class="line">    <span class="comment">//除了基本类型：其余默认值都是null</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//mian方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//局部变量:必须声明和初始化值</span></span><br><span class="line">        <span class="keyword">int</span>  i = <span class="number">23</span>;</span><br><span class="line">        System.out.println(i); </span><br><span class="line">        sb sb1 = <span class="keyword">new</span> sb1();</span><br><span class="line">        System.<span class="function">out <span class="title">println</span><span class="params">(sb1.age)</span></span>;</span><br><span class="line">        <span class="comment">//类变量static </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其他方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="变量的命名规范"><a href="#变量的命名规范" class="headerlink" title="变量的命名规范"></a>变量的命名规范</h3><p>​    <img src="/images/JAVA%E5%9F%BA%E7%A1%80.assets/image-20210413204212919.png" alt="image-20210413204212919"></p><h2 id="7-常量"><a href="#7-常量" class="headerlink" title="7.常量"></a>7.常量</h2><p>常量：初始化之后不能变动的值。</p><p><strong>可以理解为一个特殊的变量。</strong></p><p><strong>final</strong> 常量名 = 值；(<strong>final是个修饰符，不区分前后。</strong>)</p><p>常量名一般使用大写字符。</p><h2 id="8-运算符"><a href="#8-运算符" class="headerlink" title="8.运算符"></a>8.运算符</h2><p><img src="/images/JAVA%E5%9F%BA%E7%A1%80.assets/image-20210413204342365.png" alt="image-20210413204342365"></p><p><strong>()括号的优先级高</strong></p><p>**关系运算符的结果是: 正确 错误  布尔值 **</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自增++ 自减--</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> b = a++;<span class="comment">//执行完这段代码之后先将3赋值给b，然后再自增。</span></span><br><span class="line"><span class="keyword">int</span> c = ++a;<span class="comment">//执行这行代码前，先给a自增然后再给c赋值。</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//很多运算我们会使用工具类运算double Pow = Math.pow(3,2);System.out.println(Pow);//9.0</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;&amp;——逻辑与 两个都为真 结果为真||——逻辑或 其中一个为 结果为真！——取反 真变假 假变真</span><br></pre></td></tr></table></figure><p><strong>位运算——看二进制位</strong></p><p>&amp;、|、类似于上面的逻辑操作符</p><p>^相同为0 不相同为1</p><p>~按位取反 </p><p>左移&lt;&lt; ——相当于把数字乘2、</p><p>右移 &gt;&gt;——相当于把数字除2、</p><p><strong>字符串连接符</strong></p><p>在+号后出现string类型，就会把操作数转化为字符串然后再连接。</p><p>在后面的就会正常进行运算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="keyword">int</span> a = <span class="number">10</span>;        <span class="keyword">int</span> b = <span class="number">20</span>;        System.out.println(<span class="string">&quot; &quot;</span>+a+b);        System.out.println(a+b+<span class="string">&quot; &quot;</span>);        <span class="comment">//输出 1020//    30     &#125;    &#125;</span></span><br></pre></td></tr></table></figure><p><strong>三元运算符</strong></p><p>x?a:b</p><p>x为真 结果为a</p><p>x为假 结果为b</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;       <span class="keyword">int</span> score = <span class="number">20</span>;       String type = score &gt; <span class="number">60</span>?<span class="string">&quot;及格&quot;</span>:<span class="string">&quot;不及格&quot;</span>;        System.out.println(type);    &#125;    &#125;</span><br></pre></td></tr></table></figure><h2 id="9-包机制"><a href="#9-包机制" class="headerlink" title="9.包机制"></a>9.包机制</h2><ul><li>为了更好的组织类，JAVA提供了包机制，用于区别类名的命名空间。</li></ul><p>(基本就是新建一个文件夹将两个名称相同的文件分开放，<strong>包的本质就是一个文件夹</strong>。)</p><ul><li><p>包机制的语法格式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pk1[.pk2[.pk3...]];</span><br></pre></td></tr></table></figure></li><li><p>一般利用公司域名倒置作为包名(<a href="http://www.baidu.com/">www.baidu.com</a> - com.baidu.www)</p></li><li><p>为了能够使用某一个包的成员，我们需要在Java程序明确导入该包。使用import语句可以完成此功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> package1[.package2...].(classname|*);</span><br></pre></td></tr></table></figure></li></ul><h2 id="10-JavaDoc"><a href="#10-JavaDoc" class="headerlink" title="10.JavaDoc"></a>10.JavaDoc</h2><p>是用来生成自己API文档的。</p><p><strong>参数信息：</strong></p><p><img src="/images/JAVA%E5%9F%BA%E7%A1%80.assets/image-20210414210704599.png" alt="image-20210414210704599"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sb;<span class="comment">/*** <span class="doctag">@author</span>  zhaoyuxuan* <span class="doctag">@version</span>  1.0 * <span class="doctag">@since</span>  1.8 * * */</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DocJava</span> </span>&#123;    String name;    <span class="comment">/**     * <span class="doctag">@author</span> zhaoyuxuan      * <span class="doctag">@param</span> name     * <span class="doctag">@return</span>     * <span class="doctag">@throws</span>  Exception     */</span>    <span class="function"><span class="keyword">public</span> String  <span class="title">test</span><span class="params">(String  name)</span> <span class="keyword">throws</span> Exception</span>&#123;        <span class="keyword">return</span>  name;    &#125;&#125;</span><br></pre></td></tr></table></figure><p>IDEA、命令行都可以生成javadoc文件。</p><h1 id="2-JAVA流程控制"><a href="#2-JAVA流程控制" class="headerlink" title="2.JAVA流程控制"></a>2.JAVA流程控制</h1><h2 id="1-用户交互Scanner"><a href="#1-用户交互Scanner" class="headerlink" title="1.用户交互Scanner"></a>1.用户交互Scanner</h2><p><strong>Scanner获取用户的输入</strong></p><p><strong>基本语法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scanner s = <span class="keyword">new</span> Scanner(System.in);</span><br></pre></td></tr></table></figure><p>通过next()和nextLine()方法获取输入的字符串，在读取前我们一般需要视同hasNext() 与hasNextLine()判断是否还有输入的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo1</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>    </span>&#123;        <span class="comment">//创建一个扫描器对象        Scanner scanner = new Scanner(System.in);        System.out.println(&quot;使用next的方式接收：&quot;);        //判断用户有没有输入字符串        if(scanner.hasNext())&#123;            //使用next方式接收            String str = scanner.next();            System.out.println(&quot;输出的内容为：&quot;+str);        &#125;        //凡是IO流的类如果不关闭会一直占用资源，要养成良好的习惯用完就关掉        scanner.close();    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p><strong>next():</strong></p><ul><li>一定要读取到有效字符后才可以结束输入。</li><li>对输入有效字符之前遇到的空白，next()方法会自动将其去掉。</li><li>只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。</li><li>next()不能得到带有空格的字符串。</li></ul><p><strong>nextLine():</strong></p><ul><li>以Enter为结束符，也就是说nextLine()方法返回的是输入回车之前的所有字符。</li><li>可以获得空白。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo2</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);        <span class="comment">//从键盘接收数据        int i = 0 ;        float f = 0.0f;        System.out.println(&quot;请输入整数：&quot;);        if(scanner.hasNextInt())        &#123;            i= scanner.nextInt();            System.out.println(&quot;整数数据：&quot;+i);        &#125;        else&#123;            System.out.println(&quot;输入的不是整数数据&quot;);        &#125;        System.out.println(&quot;请输入小数数据：&quot;);        if(scanner.hasNextFloat())        &#123;            f = scanner.nextInt();            System.out.println(&quot;小数数据：&quot;+f);        &#125;        else&#123;            System.out.println(&quot;输入的不是小数数据&quot;);        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>  java.util.Scanner;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo3</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="comment">//我们可以输入多个数字，并求其总和 每输入一个数字用回车确认，用过输入非数字来结束        //输入并输出执行结果。        Scanner scanner = new Scanner(System.in);        //和        double sum = 0;        //计算输入了多少个数字        int m = 0;        while(scanner.hasNextDouble())        &#123;            double x = scanner.nextDouble();            m = m  + 1;            sum = sum +x;            System.out.println(&quot;你输入了第&quot;+m+&quot;个数据当前结果sum&quot;+sum);        &#125;        System.out.println(m + &quot;个数字的总和是：&quot;+ sum);        System.out.println(m + &quot;个数字平均数是：&quot;+ (sum/m));        scanner.close();    &#125;&#125;</span></span><br></pre></td></tr></table></figure><h2 id="2-顺序结构"><a href="#2-顺序结构" class="headerlink" title="2.顺序结构"></a>2.顺序结构</h2><ul><li>JAVA的基本结构就是顺序结构，除非特别指明，否则就按照顺序一句一句执行。</li><li>顺序结构是最简单的算法结构。</li><li>语句和语句之间，框与框之间是按从上到下的顺序进行的，它是由若干个依次执行的处理步骤组成的， <strong>它是任何一种算法都离不开的一种基本算法结构。</strong></li></ul><h2 id="3-选择结构"><a href="#3-选择结构" class="headerlink" title="3.选择结构"></a>3.选择结构</h2><h3 id="1-if单选择结构"><a href="#1-if单选择结构" class="headerlink" title="1.if单选择结构"></a>1.if单选择结构</h3><ul><li>判断是否可行，然后再去执行</li><li>语法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式)&#123;<span class="comment">//如果布尔表达式为True将执行的语句&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> struct;<span class="keyword">import</span>  java.util.Scanner;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo1</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        Scanner scanner  = <span class="keyword">new</span> Scanner(System.in);        System.out.println(<span class="string">&quot;请输入内容：&quot;</span>);        String s = scanner.nextLine();        <span class="keyword">if</span>(s.equals(<span class="string">&quot;Hello&quot;</span>))        &#123;            System.out.println(s);        &#125;        System.out.println(<span class="string">&quot;sb&quot;</span>);        scanner.close();    &#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="2-if双选择结构"><a href="#2-if双选择结构" class="headerlink" title="2.if双选择结构"></a>2.if双选择结构</h3><ul><li>if-else</li><li>语法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式)&#123;<span class="comment">//如果布尔表达式的值为true&#125;else&#123;    //如果布尔表达式的值为false&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> struct;<span class="keyword">import</span> java.util.Scanner;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">if_else</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        System.out.println(<span class="string">&quot;请输入你的成绩&quot;</span>);        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);        <span class="comment">//大于等于60分及格，否则不及格        int score = scanner.nextInt();        if(score &gt;= 60)        &#123;            System.out.println(&quot;及格&quot;);        &#125;        else        &#123;            System.out.println(&quot;不及格&quot;);        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="3-if多选择语句"><a href="#3-if多选择语句" class="headerlink" title="3.if多选择语句"></a>3.if多选择语句</h3><ul><li>if-else if - else - if </li><li>语法 ……</li></ul><h3 id="4-嵌套的if语句"><a href="#4-嵌套的if语句" class="headerlink" title="4.嵌套的if语句"></a>4.嵌套的if语句</h3><p>……</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>()&#123;    <span class="keyword">if</span>()&#125;</span><br></pre></td></tr></table></figure><h3 id="5-Switch多选择结构"><a href="#5-Switch多选择结构" class="headerlink" title="5.Switch多选择结构"></a>5.Switch多选择结构</h3><ul><li>switch case</li><li>switch case语句判断一个变量与一系列值中的某个值是否相等，每个值称为一个分支</li><li>语法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(expression)&#123;    <span class="keyword">case</span> value:        <span class="comment">//语句        break;    case value:        //语句        break;    ......    default:       // &#125;</span></span><br></pre></td></tr></table></figure><p><strong>switch语句中的变量类型可以是：</strong></p><ul><li>byte、short、int或者char。</li><li>从Java SE 7开始。</li><li>switch 支持字符串String类型了</li><li>同时case标签必须为字符串常量或者字面量。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> struct;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Switch</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="keyword">char</span> grade = <span class="string">&#x27;D&#x27;</span>;        <span class="keyword">switch</span>(grade)        &#123;            <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:                System.out.println(<span class="string">&quot;优秀&quot;</span>);                <span class="keyword">break</span>;            <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:                System.out.println(<span class="string">&quot;良好&quot;</span>);                <span class="keyword">break</span>;            <span class="keyword">default</span>:                System.out.println(<span class="string">&quot;sb&quot;</span>);        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure><p><strong>（不加break会发生case穿透现象。）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK7的新特性，表达式的结果可以是字符串//字符的本质还是数字//反编译//java——class(字节码文件)//——反编译(IDEA)//每一个对象都有自己的一个hashcodepackage struct;public class Switch2 &#123;    public static void main(String[] args) &#123;        String name = &quot;sb&quot;;        switch (name)        &#123;            case &quot;sb&quot;:                System.out.println(&quot;大sb&quot;);                break;            default:                System.out.println(123);        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p><strong>反编译</strong></p><p><strong>看原码</strong></p><p><img src="/images/JAVA%E5%9F%BA%E7%A1%80.assets/image-20210415170423339.png" alt="image-20210415170423339"></p><h2 id="4-循环结构"><a href="#4-循环结构" class="headerlink" title="4.循环结构"></a>4.循环结构</h2><h3 id="1-while循环"><a href="#1-while循环" class="headerlink" title="1.while循环"></a>1.while循环</h3><ul><li>while是最基本的循环</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(布尔表达式)&#123;    <span class="comment">//循环内容&#125;</span></span><br></pre></td></tr></table></figure><ul><li>只要布尔表达式为true，循环就会一直执行下去。</li><li>我们大多数情况是会让循环停下来的，我们需要让一个表达式失效的方式来结束循环。</li><li>少部分情况需要循环一直执行，比如服务器的请求响应监听等。</li><li>循环条件为true就会造成无限循环【死循环】，我们正常的业务编程中应该尽量避免死循环。会影响程序性能或者造成程序卡死崩溃。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> struct;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">While01</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="comment">//输出1~100        int num = 1;        while(num &lt;101)        &#123;            System.out.println(num);            num++;        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> struct;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Whiledemo2</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;     <span class="comment">//计算1+。。。。100        int sum = 0;        int num = 1;        while(num &lt;=100)        &#123;            sum += num;            num ++;        &#125;        System.out.println(sum);    &#125;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="2-do-while循环"><a href="#2-do-while循环" class="headerlink" title="2.do-while循环"></a>2.do-while循环</h3><ul><li>对于while语句而言，如果不满足条件，就不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。</li><li>do…while循环和while循环相似，不同的是，do..while循环至少会执行一次</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;    <span class="comment">//语句&#125;while(布尔表达式)</span></span><br></pre></td></tr></table></figure><ul><li><strong>while和do-while的区别</strong><ul><li>while先判断在执行，do-while先执行后判断。</li><li>do-while总是保证循环体被会至少被执行一次，这是他们的主要差别。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> struct;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dowhile</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="keyword">int</span> num = <span class="number">1</span>;        <span class="keyword">int</span> sum = <span class="number">0</span>;        <span class="keyword">do</span>&#123;            sum += num;            num ++;        &#125;<span class="keyword">while</span>(num &lt;= <span class="number">100</span>);        System.out.println(sum);    &#125;&#125;</span><br></pre></td></tr></table></figure><p><strong>区别</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> struct;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dowhile</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;         <span class="keyword">int</span> a = <span class="number">0</span>;         <span class="keyword">while</span>(a &lt; <span class="number">0</span>)         &#123;             System.out.println(a);             a++;         &#125;        System.out.println(<span class="string">&quot;``````````````````````````&quot;</span>);         <span class="keyword">do</span>&#123;             System.out.println(a);             a++;         &#125;<span class="keyword">while</span> (a&lt; <span class="number">0</span>);    &#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="3-for循环"><a href="#3-for循环" class="headerlink" title="3.for循环"></a>3.for循环</h3><ul><li>for循环是一种支持迭代的一种通用结构，是最有效、最灵活的循环结构。</li><li>for循环的执行次数是在执行之前就确定的。</li><li>语法</li><li>IDEA快捷键100.for</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化;布尔表达式;更新)&#123;<span class="comment">//代码语句&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> struct;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FOr</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;         <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">100</span>; i++)         &#123;             System.out.println(i);         &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> struct;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FOr</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="keyword">int</span> oddSum = <span class="number">0</span>;        <span class="keyword">int</span> evenSum = <span class="number">0</span>;        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++)        &#123;            <span class="keyword">if</span>(i%<span class="number">2</span> != <span class="number">0</span>)            &#123;                evenSum += i;            &#125;            <span class="keyword">else</span>            &#123;                oddSum += i;            &#125;        &#125;        System.out.println(<span class="string">&quot;偶数的和&quot;</span>+evenSum);        System.out.println(<span class="string">&quot;奇数的和&quot;</span>+oddSum);    &#125;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> struct;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FOR2</span> </span>&#123;    <span class="comment">//练习2，输入1~1000之间的能被5整除的数，并且每行输出3个    public static void main(String[] args) &#123;        for (int i = 1; i &lt; 1000; i++) &#123;            if(i % 5 == 0)            &#123;                System.out.print(i+&quot;\t&quot;);            &#125;            if(i %(3*5) == 0)            &#123;                //都可以System.out.println();                System.out.println(&quot;\n&quot;);            &#125;        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p><strong>println(自动换行)和print</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//九九乘法表package struct;public class Chengfa &#123;    public static void main(String[] args) &#123;        for (int j = 0; j &lt;= 9; j++) &#123;            for(int i =1; i &lt;=j ; i++)            &#123;                System.out.print(j+&quot;*&quot;+i+&quot;=&quot;+(j*i) + &quot;\t&quot;);            &#125;            System.out.println(&quot;&quot;);//换行        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p><strong>增强for——主要用于数组或集合</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> struct;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chengfa</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="keyword">int</span>[] numbers = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;;        <span class="comment">//增强型for        for(int x:numbers)        &#123;            System.out.println(x);        &#125;        System.out.println(&quot;123456789&quot;);        //或者        for(int i = 0; i &lt; 5 ; i++)        &#123;            System.out.println(numbers[i]);        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="4-break、continue、goto"><a href="#4-break、continue、goto" class="headerlink" title="4.break、continue、goto"></a>4.break、continue、goto</h3><ul><li><p>break语句在任何循环语句的主题部分，均可用break控制循环的流程。break用于强行退出循环，不执行循环中剩余的语句。(break语句也在switch语句中使用)</p></li><li><p>continue语句用在循环语句体中，用于终止某次循环过程，即跳过循环体尚未执行的语句，接着进行下一次是否执行循环的判定。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> struct;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Break</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="keyword">int</span> i = <span class="number">0</span>;        <span class="keyword">while</span>(i&lt;<span class="number">100</span>)        &#123;            <span class="keyword">if</span>(i == <span class="number">30</span>)            &#123;                <span class="keyword">break</span>;            &#125;            System.out.println(i);            i++;        &#125;    &#125;&#125;<span class="comment">////////////////////////////////package struct;public class Break &#123;    public static void main(String[] args) &#123;        int i = 0;        while(i&lt;10)        &#123;            i++;            if(i == 3)            &#123;               continue;            &#125;            System.out.println(i);        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><ul><li>关于goto关键字</li></ul><p>(JAVA没有)但是有标签</p><h2 id="5-流程控制练习"><a href="#5-流程控制练习" class="headerlink" title="5.流程控制练习"></a>5.流程控制练习</h2><p><strong>打印三角形5行</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> struct;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sanjiao</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++)        &#123;            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">5</span> ; j &gt;= i; j--)            &#123;                System.out.print(<span class="string">&quot; &quot;</span>);            &#125;            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= i; j++)            &#123;                System.out.print(<span class="string">&quot;+&quot;</span>);            &#125;            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; i; j++)            &#123;                System.out.print(<span class="string">&quot;+&quot;</span>);            &#125;            System.out.println(<span class="string">&quot;&quot;</span>);        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure><h1 id="3-JAVA方法"><a href="#3-JAVA方法" class="headerlink" title="3.JAVA方法"></a>3.JAVA方法</h1><h2 id="1-什么是方法"><a href="#1-什么是方法" class="headerlink" title="1.什么是方法"></a>1.什么是方法</h2><p><strong>就是其他语言的函数。</strong></p><ul><li>JAVA方法是语句的集合，它们在一起执行一个功能。<ul><li>方法是解决一类问题的步骤的有序组合。</li><li>方法包含于类或对象中。</li><li>方法在程序中被创建，在其他地方被引用。</li></ul></li><li>设计方法的原则：方法的本意是功能快，就是实现某个功能的语句块的集合。我们设计方法的时候，最好保持方法的原子性，就是一个方法只完成一个功能，这样有利于我们后期的扩展。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Method;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo1</span> </span>&#123;    <span class="comment">//main方法    public static void main(String[] args) &#123;        int sum = add(1,2);        System.out.println(sum);    &#125;    //加法    public static int add(int a,int b)    &#123;        return a+b;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><h2 id="2-方法的定义"><a href="#2-方法的定义" class="headerlink" title="2.方法的定义"></a>2.方法的定义</h2><ul><li>结构</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型  方法名(参数类型 参数名)&#123;    \\\    方法体        \\\    <span class="keyword">return</span> 返回值；&#125;</span><br></pre></td></tr></table></figure><ul><li><p>方法包含一个方法头和方法体</p><ul><li>修饰符：修饰符，这是可选的，告诉编译器如何调用方法。定义了该方法的访问类型。</li><li>返回值：方法可能会有返回值。returnValueType是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。这种情况下，returnValueType是关键字void。</li><li>方法名：是方法的实际名称。方法和参数表共同构成方法签名。</li><li>参数类型：参数像一个占位符。放方法被调用的时 ，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。<ul><li>形式参数：在方法被调用的时用于接收外界输入的数据。</li><li>实参：调用方法时实际传给方法的数据。</li></ul></li><li>方法体：方法体包含具体的语句，定义该方法的功能</li></ul><p><strong>return可以终止方法。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Method;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo1</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="keyword">int</span> result = Max(<span class="number">10</span>,<span class="number">10</span>);        System.out.println(result);    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span>    </span>&#123;        <span class="keyword">int</span> max = <span class="number">0</span>;        <span class="keyword">if</span>(num1 == num2)        &#123;            System.out.println(<span class="string">&quot;num1 = num2&quot;</span>);            <span class="keyword">return</span> <span class="number">0</span>;        &#125;        <span class="keyword">if</span>(num1 &gt; num2)        &#123;            max = num1;        &#125;        <span class="keyword">else</span>        &#123;            max = num2;        &#125;        <span class="keyword">return</span> max;    &#125;&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-方法的重载"><a href="#3-方法的重载" class="headerlink" title="3.方法的重载"></a>3.方法的重载</h2><ul><li>重载就是在同一个类中，有相同的函数名称，但形参不同的函数。</li><li>方法重载的规则：<ul><li>方法名必须相同。</li><li>参数列表必须不同(个数不同、或类型不同、参数排列顺序不同等)。</li><li>方法的返回类型可以相同也可以不相同。</li><li>仅仅返回类型不同不足以成为方法的重载。</li></ul></li><li>实现理论：<ul><li>方法名称相同时，编译器会根据调用方法的参数个数、参数类型等去逐个匹配，以选择对应的方法，如果匹配失败，则编译器报错。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Method;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo1</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="keyword">double</span> result = Max(<span class="number">10.0</span>,<span class="number">20.0</span>);        System.out.println(result);    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span>    </span>&#123;        <span class="keyword">int</span> max = <span class="number">0</span>;        <span class="keyword">if</span>(num1 == num2)        &#123;            System.out.println(<span class="string">&quot;num1 = num2&quot;</span>);            <span class="keyword">return</span> <span class="number">0</span>;        &#125;        <span class="keyword">if</span>(num1 &gt; num2)        &#123;            max = num1;        &#125;        <span class="keyword">else</span>        &#123;            max = num2;        &#125;        <span class="keyword">return</span> max;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">Max</span><span class="params">(<span class="keyword">double</span> num1,<span class="keyword">double</span> num2)</span>    </span>&#123;        <span class="keyword">double</span> max = <span class="number">0</span>;        <span class="keyword">if</span>(num1 == num2)        &#123;            System.out.println(<span class="string">&quot;num1 = num2&quot;</span>);            <span class="keyword">return</span> <span class="number">0</span>;        &#125;        <span class="keyword">if</span>(num1 &gt; num2)        &#123;            max = num1;        &#125;        <span class="keyword">else</span>        &#123;            max = num2;        &#125;        <span class="keyword">return</span> max;    &#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="4-命令行传参"><a href="#4-命令行传参" class="headerlink" title="4.命令行传参"></a>4.命令行传参</h2><p>有时你希望运行一个程序的时候再传递给它消息。这要靠传递命令行参数给main()函数实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Method;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo2</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="comment">//args.Length数组长度        for(int i = 0;i &lt;args.length;i++)        &#123;            System.out.println(&quot;args[&quot;+1+&quot;]:&quot;+args[i]);        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><h2 id="5-可变参数"><a href="#5-可变参数" class="headerlink" title="5.可变参数"></a>5.可变参数</h2><ul><li>从JKD1.5开始，JAVA支持传递同类型的可变参数给一个方法。</li><li>在方法声明中，在指定参数类型后面加一个省略号(…)。</li><li>一个方法只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在他前面声明。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Method;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Kbian</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="comment">//这个东西的本质就是即将要讲的数组        Kbian kbian = new Kbian();        kbian.test(1,23,4,5,3,2);    &#125;    public void test(int...i)    &#123;        System.out.println(i[0]);        System.out.println(i[1]);        System.out.println(i[2]);        System.out.println(i[3]);        System.out.println(i[4]);        System.out.println(i[5]);    &#125;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Method;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Diaoyongkebian</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="comment">//调用可变参数方法        printMax(34, 2, 5, 4, 8, 1, 5, 6, 55, 45);        printMax(new double[]&#123;1, 2, 3&#125;);    &#125;    public static void printMax(double... numbers) &#123;        if (numbers.length == 0) &#123;            System.out.println(&quot;这里什么也没有&quot;);            return;        &#125;        double result = 0;        for (int i = 0; i &lt; numbers.length; i++) &#123;            if (numbers[i] &gt; result) &#123;                result = numbers[i];            &#125;        &#125;        System.out.println(&quot;最大的数是&quot;+result);    &#125;&#125;</span></span><br></pre></td></tr></table></figure><h2 id="6-递归"><a href="#6-递归" class="headerlink" title="6.递归"></a>6.递归</h2><ul><li>递归就是A方法调用A方法，自己调用自己。</li><li>利用递归可以用简单的程序来解决一些复杂的问题。它通常把一个大型复杂的问题层层转化为一个与原问题相似规模较小的问题来求解，递归策略只需要少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合。</li><li>递归结构包括两个部分<ul><li>递归头:什么时候不调用自身方法 。如果没有头，将陷入死循环。</li><li>递归体:什么时候需要调用自身方法。</li></ul></li><li>注意：<ul><li>对于一些嵌套比较深的，递归就有些力不从心了，依次压在栈上面，物理上会造成内存崩溃。</li><li>一般小计算我们可以用一些递归，大计算还是用一些其他的算法吧。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算阶乘//依次类推，就是将这个的结果传递给下一个，学了C语言之后，在学JAVA的，会感觉简单很多，很容易理解的。package Method;public class Self &#123;    public static void main(String[] args) &#123;        System.out.println(f(3));    &#125;    public static int f(int n)    &#123;        if(n == 1) &#123;            return 1;        &#125;        else        &#123;            return n*f(n-1);        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><h1 id="4-数组"><a href="#4-数组" class="headerlink" title="4.数组"></a>4.数组</h1><p>（基础部分的最后一个东西）</p><p>（JAVA的学习，说白了就是学习一个又一个的类。）</p><h2 id="1-什么是数组"><a href="#1-什么是数组" class="headerlink" title="1.什么是数组"></a>1.什么是数组</h2><ul><li>数组是相同类型数据的有序集合。</li><li>数组描述的是相同类型的若干个数据，按照一定的先后次序排列组合而成。</li><li>其中，每一个数据称作一个数组元素，每个数组元素可以通过一个下标来访问它们。</li></ul><h2 id="2-数组的声明创建"><a href="#2-数组的声明创建" class="headerlink" title="2.数组的声明创建"></a>2.数组的声明创建</h2><ul><li>首先必须声明数组变量，才能在程序中使用数组。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataType[] arrayRefVar;<span class="comment">//首选的方法或者dataType[] arrayRefVar[];//效果相同，但不是首选方法//这个是C和C++的写法，早些年为了上程序员更好的熟悉java。</span></span><br></pre></td></tr></table></figure><ul><li>JAVA语言使用new操作符来创建数组。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataType[] arrayRefVar = <span class="keyword">new</span> dataType[arraySize];<span class="comment">//定义了一个什么类型的数组，就new一个什么类型的数组。</span></span><br></pre></td></tr></table></figure><ul><li>数组元素是通过索引访问的，数组索引从0开始。</li><li>获取数组长度:<strong>arrays.length</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Array;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo01</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="comment">//变量的类型 变量的名字 = 变量的值；        //数组类型；        int[] nums ;//定义        nums = new int[10];//这里面可以存放10个int类型的数字。        //给数组中的元素赋值        nums[0] = 1;        nums[1] = 2;        nums[2] = 3;        nums[3] = 4;        nums[4] = 5;        nums[5] = 6;        nums[6] = 7;        nums[7] = 8;        nums[8] = 9;        nums[9] = 10;       //计算所有元素的和        int sum =0;        for(int i= 0 ; i &lt; nums.length ; i++)        &#123;            sum +=  nums[i];        &#125;        System.out.println(&quot;数组nums的和是&quot;+sum);    &#125;&#125;</span></span><br></pre></td></tr></table></figure><h2 id="3-内存分析"><a href="#3-内存分析" class="headerlink" title="3.内存分析"></a>3.内存分析</h2><ul><li>JAVA内存分析：<ul><li>堆：<ul><li>可以存放new的对象和数组</li><li>可以被所有的线程共享，不会存放别的对象引用。</li></ul></li><li>栈：<ul><li>存放基本变量类型(会包含这个基本类型的具体数值)</li><li>引用对象的变量(会存放这个引用在堆里面的具体地址)</li></ul></li><li>方法区：<ul><li>可以被所有线程共享</li><li>包含了所有的class和static变量</li></ul></li></ul></li></ul><h2 id="4-初始化"><a href="#4-初始化" class="headerlink" title="4.初始化"></a>4.初始化</h2><ul><li>静态初始化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;Man[] mans = &#123;<span class="keyword">new</span> Man(<span class="number">1</span>,<span class="number">1</span>),<span class="keyword">new</span> Man(<span class="number">2</span>,<span class="number">2</span>));</span><br></pre></td></tr></table></figure><ul><li>动态初始化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];a[<span class="number">0</span>] = <span class="number">1</span>;a[<span class="number">1</span>] = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><ul><li>数组的默认初始化<ul><li>数组是引用类型，它的元素相当于类的实例变量，因此数组一经分配空间，其中的每个元素也被按照实例变量同样的方式被隐式初始化。</li></ul></li></ul><h2 id="5-数组特点"><a href="#5-数组特点" class="headerlink" title="5.数组特点"></a>5.数组特点</h2><ul><li><p>数组的长度时确定的。数组一但被创建，它的大小就是不可以改变的。</p></li><li><p>其元素必须是相同类型，不允许出现混合类型。</p></li><li><p>数组中的元素可以是任何数据类型，包括基本类型和引用类型。</p></li><li><p>数组变量属于引用类型，数组也可以看成是对象，数组中的每个元素相当于该对象的成员变量。</p><p>数组本身就是对象，JAVA中对象是在堆中的，因此数组无论保存原始类型还是其他对象类型，<strong>数组对象本身是在堆中的</strong>。</p></li></ul><h2 id="6-数组边界"><a href="#6-数组边界" class="headerlink" title="6.数组边界"></a>6.数组边界</h2><ul><li>下标的合法区间：[0,length-1],如果越界就会报错：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    <span class="keyword">int</span>[] a  = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];        System.out.printlen(a[<span class="number">2</span>]);    &#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>ArrayIndexOutOfBoundsException:数组下标越界异常！</strong></p></li><li><p>小结</p><ul><li><p>数组是相同数据类型(数据类型可以为任意类型)的有序集合。</p></li><li><p>数组也是对象。数组元素相当于对象的成变量。</p></li><li><p>数组长度是确定的，不可变的。如果越界，则报</p><p>​    ArrayIndexOutOfBoundsException。 </p></li></ul></li></ul><h2 id="7-数组的使用"><a href="#7-数组的使用" class="headerlink" title="7.数组的使用"></a>7.数组的使用</h2><ul><li>for-each循环</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Array;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo03</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="keyword">int</span>[] nums = &#123;<span class="number">10</span>,<span class="number">2</span>,<span class="number">33</span>,<span class="number">4</span>,<span class="number">55</span>,<span class="number">6</span>&#125;;        <span class="comment">//计算数组nums的元素之和        int Sum = 0;        for(int i = 0; i &lt;nums.length;i++)        &#123;            Sum += nums[i];        &#125;           System.out.println(&quot;数组nums的和是&quot;+Sum);        System.out.println(&quot;#####################&quot;);        //找出数组中的 最大值        int Max = 0;        for(int i = 0; i &lt; nums.length;i++)        &#123;            if(nums[i]&gt; Max)            &#123;                Max = nums[i];            &#125;        &#125;        System.out.println(&quot;数组nums的最大值是&quot;+Max);    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p> <strong>增强型for-主要用于打印数组中的各个元素，如果要操作其中的元素就没那么适合了。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Array;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo04</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="keyword">int</span>[] nums = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;        <span class="keyword">for</span>(<span class="keyword">int</span> x : nums)        &#123;            System.out.println(x);        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure><ul><li>数组做方法入参&amp;数组作为返回值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Array;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo04</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="keyword">int</span>[] nums = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;        <span class="comment">//打印数组元素        printfA(nums);        System.out.println();        //反转数组        int[] nums2 = reverse(nums);        printfA(nums2);    &#125;    public static void printfA(int[] Array)    &#123;        for(int i = 0 ; i&lt; Array.length;i++)        &#123;            System.out.print(Array[i]+&quot; &quot;);        &#125;    &#125;    //反转数组    public static int[] reverse(int[] arrays) &#123;        int[] result = new int[arrays.length];        for(int i  = 0 , j = result.length-1; i &lt;arrays.length;i++,j--)        &#123;            result[j] = arrays[i];        &#125;        return result;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>​    </p><h2 id="8-多维数组"><a href="#8-多维数组" class="headerlink" title="8. 多维数组"></a>8. 多维数组</h2><ul><li>多维数组可以看成是数组的数组，比如二维数组就是一个特殊的一维数组，其每个元素都是一个一维数组(在数组中存放数组)。</li><li>二维数组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] a = <span class="keyword">new</span><span class="keyword">int</span>[<span class="number">4</span>][<span class="number">2</span>];</span><br></pre></td></tr></table></figure><ul><li><p>解析：以上二维数组a，可以看成一个4行2列的数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Array;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo05</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="comment">//[4][2]        int[][] arrays = &#123;&#123;1,2&#125;,&#123;2,3&#125;,&#123;3,4&#125;,&#123;4,5&#125;&#125;;        for(int i = 0; i &lt;arrays.length; i++)        &#123;            for(int j = 0; j &lt; arrays[i].length; j ++)            &#123;                System.out.print(arrays[i][j]);            &#125;            System.out.println(&quot;&quot;);        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><h2 id="9-Arrays类"><a href="#9-Arrays类" class="headerlink" title="9.Arrays类"></a>9.Arrays类</h2><ul><li><p>数组的工具类java.util.Arrays</p></li><li><p>由于数组对象本身并没有什么方法可以供我们调用，但API中提供了一个工具类Arrays供我们使用，从而可以对数据对象进行一些基本的操作。</p></li><li><p>Arrays类中的方法都是static修饰的静态方法，在使用的时候可以直接使用类名进行调用，而”不用”使用对象来调用(注意是”不用”而不是”不能”。)</p></li><li><p>具有一下常用功能：</p><ul><li><p>给数组赋值：通过fill方法。</p></li><li><p>对数组排序：通过sor方法，按升序。</p></li><li><p>比较数组：通过equals方法比较数组中元素是否相等。</p></li><li><p>查找数组元素：通过binarySearch方法能对排序好的数组进行二分查找法操作。</p><h2 id="9-冒泡排序"><a href="#9-冒泡排序" class="headerlink" title="9.冒泡排序"></a>9.冒泡排序</h2></li></ul></li><li><p>冒泡排序无疑是最出名的排序算法之一，总共有八大排序。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> arrays;<span class="keyword">import</span> java.util.Arrays;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo02</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="comment">//冒泡排序：比较相邻的两个数，如果第 一个数比第二个数大，就交换他们俩个，        int[] nums = &#123;1,23,323,35,2&#125;;        //输出原本的数组顺序        System.out.println(Arrays.toString(nums));        int[] sort = sort(nums); //调用完我们自己写的排序方法之后，返回一个排序后的数组        //打印输出nums数组        System.out.println(Arrays.toString(nums));    &#125;    public static int[] sort(int[] arrays)    &#123;        int temp = 0;        //如果数组已经排列好了，我们就没有必要再进行排列了        boolean flag = false;//通过flag标识位来减少没有意义的比较        //外层循环-判断我们要走多少次        for(int i = 0; i &lt; arrays.length-1;i++)        &#123;            //内层循环，比较两个数            for(int j = 0; j &lt; arrays.length-1-i;j++)            &#123;                if(arrays[j] &gt; arrays[j+1])                &#123;                    temp = arrays[j];                    arrays[j] = arrays[j+1];                    arrays[j+1] = temp;                    flag = true;                &#125;                if(flag == false)                &#123;                    break;                &#125;            &#125;        &#125;        return arrays;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><h2 id="9-稀疏数组"><a href="#9-稀疏数组" class="headerlink" title="9.稀疏数组"></a>9.稀疏数组</h2><ul><li><p>需求:编写五子棋游戏中，有存盘退出和续上盘的功能。</p></li><li><p>分析问题：因为该二维数组的很多值是默认值0，因此记录了很多没有意义的数据。</p></li><li><p>解决:稀疏数组。</p></li><li><p>什么是稀疏数组：</p><ul><li>当一个数组中大部分元素为0，或者为同一值的数组时，可以使用稀疏数组来保存该数组。</li></ul></li><li><p>稀疏数组的处理方式是：</p><ul><li>记录数组有几行几列，有多少个不同值。</li><li>把具有不同值的元素和行列及值记录在一个小规模数组中，从而缩小程序的规模。</li><li>例如：左边为原始数组，右边为稀疏数组。</li></ul><p><img src="/images/JAVA%E5%9F%BA%E7%A1%80.assets/image-20210417192808182.png" alt="image-20210417192808182"></p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> arrays;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo08</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;            <span class="comment">//创建一个 11*11的数组 0-没棋 1-黑棋 2-白棋        int[][] arrays1 = new int[11][11];        arrays1[1][2] = 1;        arrays1[2][3] = 2;        //输出原始的数组        System.out.println(&quot;原始的数组是&quot;);        for(int[] ints:arrays1)        &#123;            for(int anInt:ints)            &#123;                System.out.print(anInt+&quot;\t&quot;);            &#125;            System.out.println();        &#125;        //转化为稀疏数组保存        //获取有效值的个数        int numbers = 0;        for(int i = 0 ; i&lt;11; i++)        &#123;            for(int j = 0; j &lt; 11; j++)            &#123;                if(arrays1[i][j] != 0)                numbers++;            &#125;        &#125;        System.out.println(&quot;数组中的有效值一共有&quot;+numbers+&quot;个&quot;);        //创建一个稀疏数组的数组        int[][] arrays2 = new int[numbers+1][3];        arrays2[0][0] = 11;        arrays2[0][1] = 11;        arrays2[0][2] = numbers;        //遍历二维数组，将非零的值存进稀疏数组        int count = 0 ;        for(int i = 0; i &lt; arrays1.length;i++)        &#123;            for(int j = 0; j &lt;arrays1[i].length;j++) &#123;                if (arrays1[i][j] != 0)                &#123;                    count++;                    arrays2[count][0] = i;                    arrays2[count][1] = j;                    arrays2[count][2] = arrays1[i][j];                &#125;            &#125;        &#125;        //输出稀疏数组        System.out.println(&quot;输出稀疏数组&quot;);        for(int i = 0; i &lt; arrays2.length;i++)        &#123;            System.out.println(arrays2[i][0]+&quot;\t&quot;+ arrays2[i][1]+&quot;\t&quot;+arrays2[i][2]+&quot;\t&quot;);        &#125;        System.out.println(&quot;========&quot;);        System.out.println(&quot;还原&quot;);        //读取稀疏数组        int[][] arrays3 = new int[arrays2[0][0]][arrays2[0][1]];        //给其中的元素还原它的值        for(int i = 1; i &lt;arrays2.length;i++)        &#123;            arrays3[arrays2[i][0]][arrays2[i][1]] = arrays2[i][2];        &#125;        //打印        System.out.println(&quot;输出原始的数组&quot;);        for(int[] ints:arrays3)        &#123;            for(int anInt:ints)            &#123;                System.out.print(anInt+&quot;\t&quot;);            &#125;            System.out.println();        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><h1 id="5-面向对象编程"><a href="#5-面向对象编程" class="headerlink" title="5.面向对象编程"></a>5.面向对象编程</h1><h2 id="1-面向过程-amp-面向对象"><a href="#1-面向过程-amp-面向对象" class="headerlink" title="1.面向过程&amp;面向对象"></a>1.面向过程&amp;面向对象</h2><ul><li>面向过程思想<ul><li>步骤清晰简单，第一步做什么，第二步做什么……(线性思维)</li><li>面对过程适合处理一些较为简单的问题。</li></ul></li><li>面向对象思想<ul><li>物以聚类，分类的思维模式，思考问题首先会解决问题需要哪些分类，然后对这些分类进行单独思考。最后，才对某个分类下的细节进行面向过程的思索。</li><li>面向对象适合处理复杂的问题，适合处理需要多人协作的问题。</li></ul></li><li><strong>对于描述复杂的的事物，为了从宏观上把握，从整体上合理分析，我们需要使用面向对象的思路来分析整个系统。但是具体到微观操作 ，仍然需要面向过程的思路去处理。</strong></li></ul><p><strong>面向对象编程的本质就是：以类的方式组织代码，以对象的组织(封装)数据。</strong></p><ul><li>抽象——将事物的共性特点抽取出来。</li><li>三大特性：<ul><li>封装</li><li>继承——父类、子类</li><li>多态</li></ul></li><li>从认识论角度考虑是先有对象后有类。对象，是具体的事物。类，是抽象的，是对对象的抽象。</li><li>从代码运行角度考虑是先有类后有对象。类是对象的模板。</li></ul><h2 id="2-方法的回顾及加深"><a href="#2-方法的回顾及加深" class="headerlink" title="2.方法的回顾及加深"></a>2.方法的回顾及加深</h2><ul><li><p>方法的定义</p><ul><li>修饰符</li><li>返回类型</li><li><strong>break和return的区别</strong><ul><li>break跳出循环</li><li>return结束方法，返回一个结果，可以为空也可以为任意的其他类型</li></ul></li><li>方法名-注意规范</li><li>参数列表-(参数类型、参数名)</li><li>异常抛出</li></ul></li><li><p>方法的调用</p><ul><li>静态方法-static</li><li>非静态方法-</li><li>形参和实参</li><li>值传递和引用传递</li><li>this关键字</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> FACE;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo02</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="comment">//函数调用的两种方法        System.out.println(new demo02().Add(3,4));//非静态        System.out.println(Bdd(3,4));//静态    &#125;    public static int Bdd(int a ,int b)    &#123;        return a+b;    &#125;    public int Add(int a ,int b)    &#123;        return a+b;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> FACE;<span class="comment">//值传递 无法改变public class demo03 &#123;    public static void main(String[] args) &#123;        int a = 1;        System.out.println(a);        new demo03().change(a);        System.out.println(a);    &#125;    public void change(int a )    &#123;        a = 10;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> FACE;<span class="comment">//引用传递：传递一个对象，本质还是值传递。public class demo04 &#123;    public static void main(String[] args) &#123;        Person person =  new Person();        System.out.println(person.name);        demo04.Change(person);        System.out.println(person.name);    &#125;    public static void Change(Person person) &#123;        //person是一个具体的类 指向一个人 Person person =  new Person();这是一个具体的人 可以改变属性        person.name = &quot;傻逼&quot;;    &#125;&#125;class Person&#123;    String name;//默认为Null&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="3-类与对象的创建"><a href="#3-类与对象的创建" class="headerlink" title="3.类与对象的创建"></a>3.类与对象的创建</h2><p>(一个对象就相当于C语言里面的结构体)</p><ul><li><strong>类是一种抽象的数据类型，它是对某一类事物整体描述/定义，但是并不能代表某一个具体的事物。</strong><ul><li>动物、植物、手机、电脑……</li><li>Persoin类、Pet类、Car类等，这些类都是用来描述/定义某一类具体的事物应该具备的特点和行为。</li></ul></li><li><strong>对象是抽象概念的具体实例</strong><ul><li>张三就是一个人的具体实例，张三家里的旺财就是狗的一个具体实例。</li><li>能够体现出特点，展现出功能的是具体的实例，而不是一个抽象的概念。</li></ul></li></ul><h2 id="4-创建与初始化对象"><a href="#4-创建与初始化对象" class="headerlink" title="4.创建与初始化对象"></a>4.创建与初始化对象</h2><ul><li><strong>使用new关键字创建对象。</strong></li><li>使用ne关键字创建的时候，除了分配内存空间之外，还会给创建好的对象进行默认的初始化及对类中构造器的调用。</li><li><strong>构造器必须要掌握</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类是一个抽象的模板， 通过给它赋值来将它具体化package FACE;public class demo05 &#123;   //属性：字段    String name ; //null     int age ; //0//方法    public void study()    &#123;        System.out.println(this.name+&quot;在学习&quot;);    &#125;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具体化package FACE;//一个项目应该只存一个main方法public class demo06 &#123;    public static void main(String[] args) &#123;        //类：抽象的，实例化。        //类实例化后会返回一个自己得对象        //demo05对象就是一个student类的具体实例！        demo05 xiaoming = new demo05();        demo05 xiaohong = new demo05();        xiaoming.name = &quot;sb&quot;;        System.out.println(xiaoming.name);        System.out.println(xiaoming.age);    &#125;&#125;</span></span><br></pre></td></tr></table></figure><h2 id="5-构造器详解"><a href="#5-构造器详解" class="headerlink" title="5.构造器详解"></a>5.构造器详解</h2><ul><li>类中的构造器也称为构造方法，是在进行创建对象的时候必须要调用的。并且构造器有以下两个特点：<ul><li>1.必须和类的名字相同</li><li>2.必须没有返回类型，也不能写void</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> opp;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;    <span class="comment">//一个类即使什么都不写，也会存在一个方法    //显式定义的构造器    String name;    //实例化初始值    //使用new关键字，本质上实在调用构造器    public Person()    &#123;    &#125;    //有参构造:一旦定义了有参构造，无参定义就必须显示定义    public Person(String name)    &#123;        this.name = name;    &#125;&#125;/**构造器：* 1必须和类名相同* 2没有返回值* 作用* 1new本质在调用构造方法* 2,初始化对象的值* 注意点：* 1.定义有参构造之后，如果想使用无参构造，显示的定义一个无参的构造* Alt+insert*/</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> opp;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="comment">//使用new关键词实例化了一个对象        Person person = new Person(&quot;sb&quot;);        System.out.println(person.name);    &#125;&#125;</span></span><br></pre></td></tr></table></figure><h2 id="6-创建对象内存分析"><a href="#6-创建对象内存分析" class="headerlink" title="6.创建对象内存分析"></a>6.创建对象内存分析</h2><p><img src="/images/JAVA%E5%9F%BA%E7%A1%80.assets/image-20210420110303023.png" alt="image-20210420110303023"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> opp;<span class="keyword">import</span> opp.Pet;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        Pet dog = <span class="keyword">new</span> Pet();        dog.name = <span class="string">&quot;旺财&quot;</span>;        dog.age =  <span class="number">3</span>;        dog.shout();        System.out.println(dog.name);        System.out.println(dog.age);    &#125;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> opp;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pet</span> </span>&#123;    <span class="keyword">public</span> String name;    <span class="keyword">public</span> <span class="keyword">int</span> age;    <span class="comment">//无参构造    public void shout()    &#123;        System.out.println(&quot;叫了一声&quot;);    &#125;&#125;</span></span><br></pre></td></tr></table></figure><h2 id="7-小结"><a href="#7-小结" class="headerlink" title="7.小结"></a>7.小结</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> opp;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Summary</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="comment">/**         * 1.类与对象         *  类是一个模板：抽象，对象是一个具体的实例         * 2.方法         *  定义、调用！         * 3.对象的引用         *  引用类型：基本类型（8）         *  对象是通过引用来操作的：栈--》堆（地址）         * 4.属性：字段：Field 成员变量         *  默认初始化值：         *      数字： 0 0.0         *      char： u0000         *      bool:false（默认）         *      引用：         *          null         *   修饰符 属性类型 属性名 = 属性值！         * 5.对象的创建和使用         * -必须使用new关键字创造对象，构造器Person sb = new Person();         * -对象的属性 sb.name;         * -对象的方法 sb.sleep();         * 6.类         *  静态的属性         *  动态的行为         */</span>        /    &#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="8-封装"><a href="#8-封装" class="headerlink" title="8.封装"></a>8.封装</h2><ul><li>该露的露，该藏的藏<ul><li>我们设计程序的要求是”高内聚，低耦合”。高内聚就是类的内部数据细节自己完成 ，不允许外部干涉；低耦合:仅暴露少量的方法给外部使用。</li></ul></li><li>封装(数据的隐藏)<ul><li>通常禁止访问一个对象中数据中的实际表示，而应通过操作接口来访问，这称为信息隐藏。</li></ul></li><li><strong>属性私有，get/set</strong></li></ul><p><strong>alt+insert</strong></p><ul><li><p>封装的意义：</p><ul><li>提高程序的安全性，保护数据</li><li>隐藏代码的实现细节</li><li>统一接口，系统的可维护性提高了</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> opp;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;    <span class="comment">//属性私有    private String name;    private int id;    private char sex;    private int age;    //提供一些可以操作这个属性的方法    //提供一些public的get、set方法    //get获得这个数据    public String getName()    &#123;        return this.name;    &#125;    //set给这个数据设置值    public void setName(String name)    &#123;        this.name =name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        if(age&gt;120 || age&lt;0)        &#123;            this.age = 3;        &#125;        else&#123;            this.age = age;        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> opp;<span class="keyword">import</span> opp.Student;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App2</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        Student s1 = <span class="keyword">new</span> Student();        s1.setName(<span class="string">&quot;sb&quot;</span>);        System.out.println(s1.getName());        s1.setAge(<span class="number">15</span>);        System.out.println(s1.getAge());    &#125;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> opp;<span class="keyword">import</span> opp.Student;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App2</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        Student s1 = <span class="keyword">new</span> Student();        s1.setName(<span class="string">&quot;sb&quot;</span>);        System.out.println(s1.getName());        s1.setAge(<span class="number">15</span>);        System.out.println(s1.getAge());    &#125;&#125;</span><br></pre></td></tr></table></figure><p><strong>判断两个方法是否相同看-方法名-参数</strong></p></li></ul><h2 id="9-继承"><a href="#9-继承" class="headerlink" title="9.继承"></a>9.继承</h2><ul><li>继承的本质是对某一批类的抽象，从而实现对现实世界更好的建模。</li><li>extands的意思是”扩展”。子类是父类的扩展。</li><li>JAVA中类只有单继承，没有多继承。(<strong>一个儿子只有一个爸爸，一个爸爸有可以有多个儿子</strong>)</li><li>继承是类和类之间的一种关系。除此之外，类和类之间的关系还有依赖、组合、聚合等。</li><li>继承关系的两个类，一个为子类(派生类)，一个为父类(基类)。子类继承父类，使用关键字extands来表示。</li><li>子类和父类之间，从意义上讲应该具有”is a”的关系。</li><li>object类</li><li>super(代表父,this代表当前)</li><li>方法重写</li></ul><p><strong>子类继承了父类就会拥有父类的全部方法。</strong></p><p><strong>父类public的方法可以继承，private的方法无法继承。</strong></p><p><strong>Ctrl+h——显示继承的关系</strong></p><p><strong>在JAVA中所有的类都默认直接或间接继承object类</strong></p><hr><p><strong>super注意点</strong></p><ul><li>super调用父类的构造方法，必须在构造方法的第一个。</li><li>super必须只能出现在子类的方法或者构造方法中。</li><li>super和this不能同时调用构造方法。</li></ul><p><strong>和this对比</strong></p><ul><li>代表的对象不同<ul><li>this:本身调用者这个对象。</li><li>super:代表父类对象的应用。</li></ul></li><li>前提：<ul><li>this:没有继承也可以使用。</li><li>super:只能在继承条件下才可以使用。</li></ul></li><li>构造方法：<ul><li>this():本类的构造。</li><li>super():父类的构造。</li></ul></li></ul><hr><p><strong>方法重写：</strong></p><p><strong>重写需要有继承关系，子类重写父类的方法</strong></p><ul><li>方法名必须相同</li><li>参数列表必须相同</li><li>修饰符:范围可以扩大，但是不能缩小public-&gt;Portected&gt;Default&gt;private</li><li>抛出异常:可以被缩小，但不能扩大ClassNotFoundException–&gt;Exception(大)</li></ul><p>重写，子类的方法和父类必要一致，方法体不同。</p><p><strong>为什么要重写？</strong></p><ul><li>父类的功能，子类不一定需要，或者不一定满足。</li></ul><p>Alt+Insert:override</p><h2 id="10-多态"><a href="#10-多态" class="headerlink" title="10.多态"></a>10.多态</h2><ul><li>即同一方法可以根据发送对象的不同而采用多种不同的行为方式。</li><li>一个对象的实际类型是确定的，但可以指向对象的引用的类型有很多。（父类、有关系的类）</li><li>多态存在的条件<ul><li>有继承关系</li><li>子类重写父类方法</li><li>父类引用指向子类对象</li></ul></li><li>注意：多态是方法的多态，属性没有多态性。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> DuoTai;    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;        <span class="meta">@java</span>.lang.<span class="function">Override        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;            System.out.println(<span class="string">&quot;son&quot;</span>);        &#125;        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;            System.out.println(<span class="string">&quot;eat&quot;</span>);        &#125;    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> DuoTai;<span class="keyword">import</span> DuoTai.Student;<span class="keyword">import</span> DuoTai.Person;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="comment">//一个对象的实际类型是确定的        //new Student();        //new Person();        //可以指向的引用类型就不确定了        //父类的引用指向子类        //Student能调用的方法都是自己的或者继承父类的        Student s1 = new Student();        Person  s2 = new Student();        Object s3 = new Student();       //子类重写了父类的方法，执行子类的方法        s2.run();        s1.run();       //对象能执行那些方法只要看对象左边的类型，和右边关系不大        ((Student)s2).eat();//强制类型转换 高转低        s1.eat();    &#125;&#125;/*1.多态是方法的多态，属性没有多态2.父类和子类有联系 类型转换异常 ClassCastException3.多态存在的条件：有继承关系，方法需要重写（否则就是调用各自的方法，那就没有任何区别了）4. 父类的引用指向子类对象 Father f1 = new Son();Static是静态方法属于类，不属于实例final常量private方法：都没有重写 哪来的多态呢 */</span></span><br></pre></td></tr></table></figure><hr><p><strong>instanceof类型转换（与JAVA基础差不多，只是这里的类型转换指的是引用类型的转换）</strong></p><p>判断一个对象是什么类型 instanceof，判断两个类之间是否存在父子关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> DuoTai;<span class="keyword">import</span> DuoTai.Student;<span class="keyword">import</span> DuoTai.Person;<span class="keyword">import</span> DuoTai.Teacher;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="comment">//System.out.println(x instanceof y);        //就是看x和y之间有没有父子，没有则报错        //Object - Person - Student        Object object = new Student();        System.out.println(object instanceof Student);        System.out.println(&quot;###########&quot;);        Student student = new Student();        System.out.println(student instanceof  Person);    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p><strong>static关键字详解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Static;<span class="comment">//static加在方法上叫静态方法，加在属性上叫静态属性public class Student &#123;        private static  int age;//静态变量        private double score;//非静态变量        public  void run()&#123;        &#125;        public static void  go()&#123;        &#125;    public static void main(String[] args) &#123;        Student s1 = new Student();        //静态可以这样调用        System.out.println(Student.age);        new Student().run();        //非静态        System.out.println(s1.age);        go();    &#125;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Static;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;    <span class="comment">//赋初始值    &#123;        //匿名代码块（不建议这么写）        System.out.println(&quot;匿名代码块&quot;);    &#125;    //只执行一次    static &#123;        //静态代码块        System.out.println(&quot;静态代码块&quot;);    &#125;    public Person()&#123;        System.out.println(&quot;构造方法&quot;);    &#125;    public static void main(String[] args) &#123;        Person person1 =  new Person();        System.out.println(&quot;##############&quot;);        Person person2 =  new Person();    &#125;&#125;/** * 静态代码块 * 匿名代码块 * 构造方法 *///输出静态代码块匿名代码块构造方法##############匿名代码块构造方法</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Static;<span class="comment">//静态导入包import static java.lang.Math.random;public class demo01 &#123;    public static void main(String[] args) &#123;        System.out.println(random());//代替Math，random    &#125;&#125;//final表示该类不能被继承</span></span><br></pre></td></tr></table></figure><h2 id="11-抽象类"><a href="#11-抽象类" class="headerlink" title="11.抽象类"></a>11.抽象类</h2><ul><li>abstract修饰符可以用来修饰方法也可以修饰类，如果修饰方法，那么该方法就是抽象方法，如果修饰类，那么该类就是抽象类。</li><li>抽象类中可以没有抽象方法，但是有抽象方法的类一定要声明为抽象类。</li><li>抽象类，不能使用new关键字类创建对象，它是用来让子类继承的。</li><li>抽象方法，只有方法的声明，没有方法的实现，它是用来让子类继承的。</li><li>子类继承抽象列，那么就必须要实现抽象类没有实现的抽象方法，否则该子类也要声明为抽象列</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Static;<span class="comment">//abstract抽象类//extends单继承 接口多继承(例如插座可以插很多个插头)public abstract class demo02 &#123;    //约束，有人帮我们实现    //抽象方法 只有方法名字 没有方法实现    //抽象类的所有方法，继承了他的子类都要实现它的方法    //除非它的子类也是abstract,那就让它的子子类去实现......    public abstract void doSomething()&#123;    &#125;    /**     *不能new这个抽象类，只能靠子类去实现它，     *抽象类中可以写普通的方法     * 抽象方法必须在抽象类中     * 抽象的抽象 约束     * 存在的意义：抽象出来 提高开发效率 后期可扩展性比较高     * /    /&#125;</span></span><br></pre></td></tr></table></figure><h2 id="12-接口"><a href="#12-接口" class="headerlink" title="12.接口"></a>12.接口</h2><ul><li>普通类:只有具体实现</li><li>抽象类：具体实现和规范(抽象方法)都有</li><li>接口:只有规范,自己无法写方法，约束和实现分离。</li><li>接口就是规范，定义的一组规则，体现了现实世界中的”如果你是… 则必须能…”的思想。如果你是天使，则必须能飞。如果你是汽车，则必须能跑。如果你是好人，则必须干掉坏人。……</li><li><strong>接口的本质是契约</strong>，就像我们人间的法律一样，制定了就必须要遵守。</li><li>OO的精髓，是对对象的抽象，最能体现这一点的就是接口，为什么我们讨论设计模式都只针具备了抽象能力的语言(C++,java,c#等)，就是因为设计模式所研究的，实际上就是如何合理的去抽象。</li></ul><p><strong>声明类的关键字是class,声明接口的关键字是interface</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dem0o01;<span class="comment">//interface定义的关键字：接口都需要实现类//抽象的思维-架构师public interface UserService &#123;    //接口中的所有定义其实都是抽象的public    //接口中定义常量    //一般来说是没有在接口中定义常量的    public static final int AGE = 99;    //返回类型+方法    //定义的方法都是public abstract    void  add(String name);    void  delete(String name);    void  update(String name);    void  query(String name);&#125;</span></span><br></pre></td></tr></table></figure><p><strong>作用:</strong></p><ul><li>约束</li><li>定义一些方法，让不同的人来实现</li><li>public abstract</li><li>public static final</li><li>接口不能被实例化-因为接口中没有构造方法</li><li>implements可以实现多个接口</li><li>必须重写接口中的方法</li></ul><h2 id="13-内部类"><a href="#13-内部类" class="headerlink" title="13.内部类"></a>13.内部类</h2><ul><li>内部类就是在一个类的内部再定义一个类，比如，A类中定义一个B类，那么B类相对A类来说就成为内部类，而A类相对B类来说就是外部类了。</li><li>成员内部类</li><li>静态内部类</li><li>局部内部类</li><li>匿名内部类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dem0o01;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;    <span class="keyword">private</span> <span class="keyword">int</span> id = <span class="number">10</span>;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span>&#123;        System.out.println(<span class="string">&quot;这是外部类的方法&quot;</span>);    &#125;    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">()</span></span>&#123;            System.out.println(<span class="string">&quot;这是内部类的方法&quot;</span>);        &#125;        <span class="comment">//获得外部类的私有属性        public void getID()&#123;            System.out.println(id);        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dem0o01;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    <span class="comment">//new-外部类        Outer outer = new Outer();        //通过这个外部类来实例化内部类        Outer.Inner inner = outer.new Inner();        inner.in();    &#125;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dem0o01;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;    <span class="comment">//局部内部类    public void method()&#123;        class Inner&#123;        &#125;    &#125;&#125;//一个java类中只能有一个public class//但能有多个class类class A&#123;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dem0o01;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="comment">// Apple apple = new Apple();        //没有名字初始化类-就是匿名初始化类        //不用将实例保存到变量中        new Apple().eat();    &#125;&#125;class Apple&#123;    public void eat()&#123;        System.out.println(&quot;1&quot;);    &#125;&#125;interface UserService&#123;  &#125;</span></span><br></pre></td></tr></table></figure><p>(上面一些奇奇怪怪的创建类的方法不推荐使用，否则这个代码就只有你能看懂啦。)</p><h1 id="6-异常"><a href="#6-异常" class="headerlink" title="6.异常"></a>6.异常</h1><h2 id="1-什么是异常"><a href="#1-什么是异常" class="headerlink" title="1.什么是异常"></a>1.什么是异常</h2><ul><li>实际工作中，遇到的情况不可能是非常完美的。比如：你写的某个模块，用户输入不一定符合你的要求、你的程序要打开某个文件，这个文件可能不存在或者文件格式不对，你要读取数据库的数据，数据可能是空的等。我们的程序再跑着，内存或者硬盘可能满了。等等。</li><li>软件程序在运行过程中，非常可能遇到刚刚提到的这些异常问题，我们叫异常，英文是:Exception,意思是例外。这些，例外情况，或者叫异常，怎么让我们写的程序做出合理的处理。而不至于程序崩溃。</li><li>异常程序在运行过程中出现的不期而遇的各种状况，如：文件找不到、网络链接失败、非法参数等。</li><li>异常发生在程序运行期间，它影响了正常的程序执行流程。</li></ul><h2 id="2-简单分类"><a href="#2-简单分类" class="headerlink" title="2.简单分类"></a>2.简单分类</h2><ul><li>要理解JAVA异常处理是如何工作的，你需要掌握以下三种类型的异常：</li><li>检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在的文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略</li><li>运行时异常：运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。</li><li>错误ERROR:错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。</li></ul><h2 id="3-异常体系结构"><a href="#3-异常体系结构" class="headerlink" title="3.异常体系结构"></a>3.异常体系结构</h2><ul><li>JAVA把异常当做对象来处理，并定义一个基类java.lang.Throwable作为所有异常的超累。</li><li>在JAVA API 中已经定义了许多异常类，这些异常类分为两大类，错误ERROR和异常Exception。</li></ul><h2 id="4-ERROR"><a href="#4-ERROR" class="headerlink" title="4.ERROR"></a>4.ERROR</h2><ul><li>ERROR类对象由java虚拟机生成并抛出，大多数错误与代码编写者所执行的操作无关。</li><li>JAVA虚拟机运行错误,当JVM不在有继续执行操作所需的内存资源时，将出现OutOfMemoryError。这些异常发生时，Java虚拟机(JVM)一般会选择线程终止；</li><li>还有发生在虚拟机试图执行应用时，如类定于(NoClassDefFoundError)、链接错误(LinkageError)。这些错误是不可查的，因为它们在应用程序的控制和处理能力之外，而却绝大多数是程序运行时不允许出现的状况。</li></ul><h2 id="5-Exception"><a href="#5-Exception" class="headerlink" title="5.Exception"></a>5.Exception</h2><p><img src="/images/JAVA%E5%9F%BA%E7%A1%80.assets/image-20210426201055911.png" alt="image-20210426201055911"></p><ul><li>这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生；</li><li>Error和Exception的区别:Error通常是灾难性的致命的错误，是程序无法控制和处理的，当出现这些异常时，Java虚拟机(JVM)一般会选择终止线程；Exception通常情况下可以被程序处理的，并且在程序中应该尽可能的去处理这些异常。</li></ul><h2 id="6-异常处理机制"><a href="#6-异常处理机制" class="headerlink" title="6.异常处理机制"></a>6.异常处理机制</h2><ul><li>抛出异常</li><li>捕获异常</li><li>异常处理五个关键字<ul><li>try、catch、finally、throw、throws </li></ul></li></ul><p>（快捷键ctrl+alt+t快速选择语句将所选中的语句包裹起来）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sun.security.mscapi.CPublicKey;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.naming.directory.AttributeInUseException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Abnormal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//监控异常</span></span><br><span class="line">        <span class="keyword">try</span> &#123;<span class="comment">//try监控区域</span></span><br><span class="line">            System.out.println(a/b);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(ArithmeticException e)&#123;<span class="comment">//捕获异常/里面的参数是捕获错误的类型</span></span><br><span class="line">            System.out.println(<span class="string">&quot;程序出现异常啦&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;<span class="comment">//处理善后工作</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//假设在这个方法中处理不了异常，在方法上抛出异常。</span></span><br><span class="line">        <span class="comment">//主动抛出异常throw throws</span></span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArithmeticException();<span class="comment">//主动抛出异常，一般在方法中使用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-自定义异常"><a href="#7-自定义异常" class="headerlink" title="7.自定义异常"></a>7.自定义异常</h2><ul><li>使用Java内置的异常类可以描述在编程时出现的大部分异常情况。除此之外，用户还可以自定义异常，只需要继承Exception类即可。</li><li>在程序中使用自定义异常类，大体可以分为一下几个步骤：</li></ul><ol><li>创建自定义异常类。</li><li>在方法中通过throw关键字抛出异常对象。</li><li>如果在抛出异常的方法中处理异常，可以使用try-catch语句捕获并处理；否则在方法的声明处通过throws关键字指明要抛出给方法调用者的异常，继续进行下一步操作。</li><li>在出现异常方法的调用者中捕获并处理异常。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo01</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//传递数字&gt;10;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> detail;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">demo01</span><span class="params">(<span class="keyword">int</span> a )</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.detail  = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//toString：异常的打印信息</span></span><br><span class="line">    <span class="comment">//实现了一个自定义的异常</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;demo01&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;detail=&quot;</span> + detail +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="comment">//可能会存在异常的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="keyword">throws</span> demo01</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;传递的参数为:&quot;</span>+a);</span><br><span class="line">        <span class="keyword">if</span>(a &gt; <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> demo01(a);<span class="comment">//抛出</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;OK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test(<span class="number">11</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (demo01 e)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MyException=&gt;&quot;</span>+e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/JAVA%E5%9F%BA%E7%A1%80.assets/image-20210427165820171.png" alt="image-20210427165820171"></p><p>视频<a href="https://www.bilibili.com/video/BV12J41137hu?t=17">【狂神说Java】Java零基础学习视频通俗易懂_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-JAVA基础&quot;&gt;&lt;a href=&quot;#1-JAVA基础&quot; class=&quot;headerlink&quot; title=&quot;1.JAVA基础&quot;&gt;&lt;/a&gt;1.JAVA基础&lt;/h1&gt;&lt;h2 id=&quot;1-Hello-world&quot;&gt;&lt;a href=&quot;#1-Hello-world&quot; c</summary>
      
    
    
    
    <category term="JAVA" scheme="http://example.com/categories/JAVA/"/>
    
    
    <category term="-计算机" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="-笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="-JAVA" scheme="http://example.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>栈的应用---四则运算表达式求值</title>
    <link href="http://example.com/2021/04/24/%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8-%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/"/>
    <id>http://example.com/2021/04/24/%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8-%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</id>
    <published>2021-04-24T05:08:24.000Z</published>
    <updated>2021-04-24T05:11:05.648Z</updated>
    
    <content type="html"><![CDATA[<p>栈的应用——四则运算表达式求值</p><h2 id="后缀表达式计算"><a href="#后缀表达式计算" class="headerlink" title="后缀表达式计算"></a>后缀表达式计算</h2><p>先将    数学表达式 用<strong>后缀(逆波兰)表示法</strong>表示。</p><p><img src="/images/%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8-%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.assets/QQ%E6%88%AA%E5%9B%BE20210423203619-1619183614531-1619240927723.png"></p><p><strong>运算规则：从左到右遍历表达式每个数字和符号，遇到数字就进栈，遇到符号，就将处于栈顶的两个数字出栈，进行运算，运算结果进栈</strong></p><p><strong>运算流程图如下：</strong></p><p><img src="/images/%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8-%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.assets/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6-1619240927723.jpg"></p><h2 id="将中缀表达式转化为后缀表达式"><a href="#将中缀表达式转化为后缀表达式" class="headerlink" title="将中缀表达式转化为后缀表达式"></a>将中缀表达式转化为后缀表达式</h2><p><strong>规则：从左到右遍历中缀表达式的每个数字和符号吗，若是数字则输出，即称为后缀表达式的一部分；若是符号，则判断其与栈顶符号的优先级，是右符号或优先级低于栈顶符号(乘除优先加减)则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止。</strong></p><p><img src="/images/%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8-%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.assets/%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F(2)-1619240927723.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;栈的应用——四则运算表达式求值&lt;/p&gt;
&lt;h2 id=&quot;后缀表达式计算&quot;&gt;&lt;a href=&quot;#后缀表达式计算&quot; class=&quot;headerlink&quot; title=&quot;后缀表达式计算&quot;&gt;&lt;/a&gt;后缀表达式计算&lt;/h2&gt;&lt;p&gt;先将    数学表达式 用&lt;strong&gt;后缀(逆波兰</summary>
      
    
    
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="-数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="-栈" scheme="http://example.com/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>C语言动态内存开辟</title>
    <link href="http://example.com/2021/04/22/C%E8%AF%AD%E8%A8%80%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%BC%80%E8%BE%9F/"/>
    <id>http://example.com/2021/04/22/C%E8%AF%AD%E8%A8%80%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%BC%80%E8%BE%9F/</id>
    <published>2021-04-22T09:04:29.000Z</published>
    <updated>2021-04-22T09:07:51.698Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-动态内存管理"><a href="#1-动态内存管理" class="headerlink" title="1.动态内存管理"></a>1.动态内存管理</h1><h2 id="1-为什么存在动态内存管理"><a href="#1-为什么存在动态内存管理" class="headerlink" title="1.为什么存在动态内存管理"></a>1.为什么存在动态内存管理</h2><p>当前我们知道的<strong>内存的使用方式</strong>主要是两种。</p><p><strong>1.创建一个变量</strong></p><p>int a = 10;//局部变量  - 在栈区中开辟空间</p><p>int g_a = 10;//全局变量 - 静态区</p><hr><p>在内存中，分为三个区域</p><p><strong>栈区</strong>-局部变量、函数的形参、</p><p><strong>堆区</strong>-动态内存分配-malloc-free-calloc-realloc</p><p><strong>静态区</strong>-全局变量、静态变量、statint int a = 10;</p><hr><p><strong>2.创建一个数组</strong></p><p>int arr[10] =  { 10 };（局部范围-栈区，全局范围-静态区）</p><p>在空间上开辟10个字节的连续空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">S</span> <span class="title">arr</span>[50];</span><span class="comment">//50个struct S类型的数据</span></span><br><span class="line">    <span class="comment">//如果只有30个学生，就会有空间上的浪费</span></span><br><span class="line">    <span class="comment">//如果有60个学生，空间又会不够</span></span><br><span class="line">    <span class="comment">//数组的元素个数，是给定的一个常量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>C语言是可以创建变长数组的 -C99中增加了（很多个编译器可能都还没有支持）</p><p>不够普遍。</p><hr><p>因为上面的两种开辟内存空间的方式比较局限，不能满足我们想用多少就开辟多少空间的需求，所以引出动态内存管理。</p><p><strong>提高内存的使用率。</strong></p><h2 id="2-相关函数"><a href="#2-相关函数" class="headerlink" title="2.相关函数"></a>2.相关函数</h2><h3 id="1-malloc和free"><a href="#1-malloc和free" class="headerlink" title="1.malloc和free"></a>1.malloc和free</h3><p><strong>头文件：#include&lt;stdlib.h&gt;</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//向内存申请10整型的空间</span></span><br><span class="line">    <span class="keyword">int</span>* p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));<span class="comment">//p里面放的就是那块地址</span></span><br><span class="line">    <span class="comment">//失败时返回空指针NULL</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//打印错误原因的一个方式</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//正常使用空间</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            *(p + i) = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++)</span><br><span class="line">        &#123; </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(p + i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当动态申请的空间不再使用的时候</span></span><br><span class="line">    <span class="comment">//就应该还给操作系统</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>malloc</strong></p><p>C语言提供了一个动态内存开辟的函数：</p><p>​    void* malloc (size_t size);</p><p>这个函数向内存申请一块连续可用的空间，并返回指向这块空间的指针。</p><ul><li>如果开辟成功，则返回一个指向开辟好空间的指针。</li><li>如果开辟失败，则返回一个NULL指针，因此malloc的返回值一定要做检查。</li><li>返回值的类型是*void，所以malloc函数并不知道开辟空间的类型，具体在使用的时候使用者自己来决定。</li><li>如果size为0，malloc的行为是标准未定义的，取决于编译器。</li></ul><hr><p><strong>free</strong></p><p>C语言提供了另外一个函数free,专门是用来做动态内存释放和回收的。</p><p>free(空间);例如：上面开辟的那个，free(p);</p><p>//就算不free，刚才开辟的空间死掉的话，也会自动还给操作系统。</p><p>free之后，指向的将内存空间被释放了还给操作系统，但是p依然有能力找到这快空间，</p><p>p = NULL，主动将p赋值给空指针，彻底断开了联系，很好的避免了它犯错误。</p><p>free函数用来释放动态开辟的内存</p><ul><li><p>如果参数ptr指向的空间不是动态开辟的，那free函数的行为是未定义的。</p></li><li><p>如果参数prt是NULL指针，咋函数什么事都不做。</p></li></ul><h3 id="2-calloc"><a href="#2-calloc" class="headerlink" title="2.calloc"></a>2.calloc</h3><p>也是一个内存开辟函数，开辟一个空间并且把元素初始化为0.</p><p>原型如下：</p><p>void* </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>*p= (<span class="keyword">int</span>*)<span class="built_in">calloc</span>(<span class="number">10</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>));  </span><br><span class="line">    <span class="keyword">if</span>( p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,(*p+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放空间</span></span><br><span class="line">    <span class="comment">//free函数是用来释放动态开辟的内存空间的</span></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>calloc和malloc一个初始化效率低一点，一个不初始化，效率高一点。</p><ul><li>函数的功能是为num个大小为size的元素开辟一块空间，并且把空间的每个字节初始化为0。</li><li>与函数malloc的区别只在于calloc会在返回地址之前把申请的空间的每个字节初始化为全0。</li></ul><h3 id="3-realloc"><a href="#3-realloc" class="headerlink" title="3.realloc"></a>3.realloc</h3><p><strong>调整动态开辟内存的大小</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">5</span>; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            *(p+i) = i;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//只是在使用malloc开辟的20个字节空间</span></span><br><span class="line">    <span class="comment">//假设这里，20个字节不能满足我们的使用要求</span></span><br><span class="line">    <span class="comment">//希望我们能够有40个字节的空间</span></span><br><span class="line">    <span class="comment">//这里就可以使用realloc来调整动态开辟的内存</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">realloc</span><span class="params">(p,<span class="number">40</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> *p2 = <span class="built_in">realloc</span>(p,<span class="number">40</span>);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*(p2+i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>realloc函数的出现让动态内存管理更加灵活。</li><li>有时我们发现过去申请的内存空间太小了，有时候又会觉得申请的空间过大了，那为了合理的使用内存，我们一定会对内存的大小做灵活的调整。那realloc函数就可以做到对动态开辟内存大小的调整。函数原型如下：</li></ul><p>void* realloc (void* ptr,size_t size);</p><ul><li>ptr是要调整的内存地址</li><li>size是调整之后的大小</li><li>返回值为调整之后的内存起始位置</li><li>这个函数调整原内存空间大小的基础上，还会将原来内存中的数据移动到新的空间</li><li>realloc在调整内存空间存在两种情况</li></ul><p><strong>注意事项：</strong></p><ol><li>如果p指向的空间之后有足够的内存空间可以追加，则直接追加，后返回p指向空间的地址。</li><li>如果p指向的空间之后没有足够的内存空间可以追加，则realloc函数会重新找一块新的内存区域，开辟一块满足需求的空间并且把原来内存中的数据拷贝回来，释放旧的内存空间。最后返回新开辟的内存空间地址。</li><li>得用一个新的变量来接收realloc的返回值。</li><li>最后都要free</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-动态内存管理&quot;&gt;&lt;a href=&quot;#1-动态内存管理&quot; class=&quot;headerlink&quot; title=&quot;1.动态内存管理&quot;&gt;&lt;/a&gt;1.动态内存管理&lt;/h1&gt;&lt;h2 id=&quot;1-为什么存在动态内存管理&quot;&gt;&lt;a href=&quot;#1-为什么存在动态内存管理&quot; c</summary>
      
    
    
    
    <category term="C语言" scheme="http://example.com/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="-C语言" scheme="http://example.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="-笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>基于C语言的计算机网络编程(初识)</title>
    <link href="http://example.com/2021/04/04/%E5%9F%BA%E4%BA%8EC%E8%AF%AD%E8%A8%80%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E5%88%9D%E8%AF%86/"/>
    <id>http://example.com/2021/04/04/%E5%9F%BA%E4%BA%8EC%E8%AF%AD%E8%A8%80%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E5%88%9D%E8%AF%86/</id>
    <published>2021-04-04T03:09:07.000Z</published>
    <updated>2021-04-04T13:01:02.746Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-计算机网络概述"><a href="#1-计算机网络概述" class="headerlink" title="1.计算机网络概述"></a>1.计算机网络概述</h1><h2 id="1-最早的广域网"><a href="#1-最早的广域网" class="headerlink" title="1.最早的广域网"></a>1.最早的广域网</h2><p>在通信双方或多方之间，通过电路交换建立电路连接的网络。</p><p><img src="/images/image-20210401162927335.png"></p><h2 id="2-电路交换网的特点"><a href="#2-电路交换网的特点" class="headerlink" title="2.电路交换网的特点"></a>2.电路交换网的特点</h2><ol><li><p>建立链接-&gt;使用链接-&gt;释放链接</p></li><li><p>物理通路被双方独占。</p><p>计算机数据是突发式出现在数据链路上的，而电路交换网的建立链接、使用链接、释放链接三个过程使得传输效率太低，故电路交换不适合传输计算机数据。</p><h2 id="3-计算机的网络要求"><a href="#3-计算机的网络要求" class="headerlink" title="3.计算机的网络要求"></a>3.计算机的网络要求</h2><ol><li><p>不是为了打电话</p></li><li><p>结构简单，可靠的传输数据</p></li><li><p>能够连接不同种类的计算机</p></li><li><p>所有网络节点同等重要</p></li><li><p>必须由冗余的路由</p><p><strong>最早的计算机网络</strong>-美国创造的ARPA，最早的ARPA无法连接不同类型的计算机和不同类型操作系统。</p><h2 id="4-分组交换"><a href="#4-分组交换" class="headerlink" title="4.分组交换"></a>4.分组交换</h2><p> <strong>分组交换——</strong>通过标有地址的分组进行路由选择传送数据，使通信通道在传送期间被占用的一种交换方式。</p><p>分组的组成：每个分组都有首部和数据段组成。</p><p><img src="/images/image-20210401163007059.png"></p><h2 id="5-交换方式"><a href="#5-交换方式" class="headerlink" title="5.交换方式"></a>5.交换方式</h2><p>交换方式——<strong>存储转发</strong></p><p>节点收到分组，先暂时存储下来，再检查其首部，按照首部中的目的地址，找到合适的节点转发出去。</p><p><img src="/images/image-20210401162904189.png"></p><p>特点：</p><ol><li><p>以分组作为传输单位</p></li><li><p>独立的选择转发路由</p></li><li><p>逐段占用，动态分配传输带宽。</p><h2 id="6-因特网的发展史"><a href="#6-因特网的发展史" class="headerlink" title="6.因特网的发展史"></a>6.因特网的发展史</h2><p>从的那个APPANET向因特网的发展过程</p><p>1983年 TCP/IP协议称为APPANET的标准协议</p><p><strong>计算机网络世界的世界语——TPC/IP协议</strong></p><p>到现在为止，只要是能够通信、上网的机器，一定用的就是TPC/IP协议族。</p><p>（TPC/IP协议是由很多协议组成的）</p><h2 id="7-三级结构的因特网"><a href="#7-三级结构的因特网" class="headerlink" title="7.三级结构的因特网"></a>7.三级结构的因特网</h2><p>（NSFNET国家科学基金网）</p><p>围绕六台大型计算机中心建设起来的计算机网络</p><p>主干网、地区网、校园网、</p><p><img src="/images/image-20210401164144400.png"></p></li></ol></li></ol></li></ol><p>现在我们国家的网络基本由移动、联通、电信，来进行下分，说白了国家把网络的一些布置，和网络的下分交给了这三大机构来实现。</p><h2 id="8-多级结构因特网"><a href="#8-多级结构因特网" class="headerlink" title="8.多级结构因特网"></a>8.多级结构因特网</h2><p>NSFNET逐步商用因特网主干网代替</p><p><img src="/images/image-20210401164451581.png"></p><h2 id="9-TCP-IP协议简介"><a href="#9-TCP-IP协议简介" class="headerlink" title="9.TCP/IP协议简介"></a>9.TCP/IP协议简介</h2><p>为了使各种不同计算机之间进可以互联，ARPANET指定了一套计算机通信协议，即TCP/IP协议(族)。 </p><p>为了减少协议设计的复杂性，大多数网络模型均采用分层的方式来组织 ，每一层利用下一层提供的服务来为上一层提供服务，本层服务的实现细节对上层屏蔽。</p><h2 id="10-分层结构"><a href="#10-分层结构" class="headerlink" title="10.分层结构"></a>10.分层结构</h2><p>为了实现不同类型的计算机和不同类型的操作系统之间的通信，引入了分层的概念。</p><p>最早的分层体系结构叫做OSI开放系统互联模型，是由国际化标准组织（ISO）指定的，由于OSI过于复杂，所以到现在为止也没有使用它，而使用的是TCP/IP协议族。</p><p>OSI一共分为7层，TPC/IP协议族一共分为4层，虽然TPC/IP协议族层次少，但是却干了OSI7层所有任务</p><p><img src="/images/image-20210401170310168.png"></p><p><strong>应用层</strong>：应用程序间沟通的层（手机电脑上用的微信QQ,用户能操纵的全都是应用层的）</p><p>​    例如：FPT（文件传输协议）、Telnet、HTTP （超文本协议）等。</p><p><strong>传输层：</strong>提供进程之间的数据传送服务</p><p>​    负责传送数据、提供应用程序端到端的逻辑通信</p><p>​    例如：TCP、UDP。</p><p><strong>网络层：</strong>提供基本的数据封包传送功能</p><p>​    最大可能的让每个数据包都能到大目的主机</p><p>​    例如：IP（网际协议）、ICMP等。</p><p><strong>链路层：</strong>负责数据帧的发送和接收</p><p>​    每层完成自己的任务，最终通过不同层次的处理完成数据的收发。</p><p><img src="/images/image-20210401172352190.png"></p><p>（U形 从我传输数据到张3）</p><h2 id="11-IP协议简介"><a href="#11-IP协议简介" class="headerlink" title="11.IP协议简介"></a>11.IP协议简介</h2><p><strong>IP协议也叫做网际协议。</strong></p><p>特指为实现在一个相互连接的网络系统上从源地址到目的地址传输数据包（互联网数据包）所提供必要功能的协议。</p><p><strong>特点：</strong></p><p>​    不可靠：它不能保证IP数据包能成功到达它的目的地，仅提供尽力而为的传输服务。</p><p>(就告诉你对方是谁，至于你怎么传输，它不管。)</p><p>​    无连接：IP并不维护任何关于后续数据包的状态信息。每个数据包的处理是相互独立的。IP数据包可以不按发送顺序接收。</p><p><strong>IP数据包中含有发送它主机的IP地址（源地址）和接收它主机的地址（目的地址）。</strong></p><p><strong>在网络中IP地址是我们主机的唯一标识。</strong></p><h2 id="12-TPC协议简介"><a href="#12-TPC协议简介" class="headerlink" title="12.TPC协议简介"></a>12.TPC协议简介</h2><p><strong>TPC协议——传输控制协议。</strong></p><p><strong>TPC是一种面向连接的，可靠的传输层通信协议。</strong></p><p><strong>功能：</strong></p><p>​    提供不同主机上 的进程间通信。</p><p><strong>特点：</strong></p><ol><li><p>建立链接-&gt;使用链接-&gt;释放链接（虚电路）。</p></li><li><p>TPC数据包中包含序号和确认序号。（保证数据传输的无误）</p></li><li><p>对包进行排序并检错，而损坏的包可以被重传。</p><p><strong>服务对象：</strong></p><p>需要高度可靠性且面向连接的服务。</p><p>如HTTP（超文本协议）、FTP（文件传输协议）、SMTP（简单邮件传输协议）等。</p><p>（如果用的不都是TCP协议，就无法保证数据可以完整可靠的到达，从而出现问题，像文件传输、邮件传输、浏览网页，一定都是建立在TCP协议的基础上的。）</p><h2 id="13-UDO协议简介"><a href="#13-UDO协议简介" class="headerlink" title="13.UDO协议简介"></a>13.UDO协议简介</h2><p><strong>UDP协议——用户数据报协议</strong>。</p><p><strong>UDP是一种面向无连接的传输层通信协议</strong>。</p><p><strong>功能：</strong></p><p>​    提供不同主机间上的进程间通信。</p><p><strong>特点：</strong></p><ol><li><p>发送数据之前不需要建立链接。</p></li><li><p>不对数据包的顺序进行检查。（可能有顺序问题，但是快啊 ）</p></li><li><p>没有错误检测和重传机制。</p><p><strong>服务对象：</strong></p><p>主要用于”查询-应答”的服务</p><p>如：NFS、NTP、DNS等</p></li></ol></li></ol><h2 id="14-MAC地址、IP地址、Netmask、端口"><a href="#14-MAC地址、IP地址、Netmask、端口" class="headerlink" title="14.MAC地址、IP地址、Netmask、端口"></a>14.MAC地址、IP地址、Netmask、端口</h2><h3 id="1-网卡"><a href="#1-网卡" class="headerlink" title="1.网卡"></a><strong>1.网卡</strong></h3><p>​    网卡又称为网络适配器或网络接口卡NIC，但是现在更多的人愿意使用更为简单的名称’网卡’，通过网卡能够使不同的计算机之间连接，从而完成数据通信等功能。</p><h3 id="2-MAC地址："><a href="#2-MAC地址：" class="headerlink" title="2.MAC地址："></a><strong>2.MAC地址：</strong></h3><p>​    每一个网卡在出厂的时候都会给它分配一个编号，这个编号就叫做<strong>MAC地址</strong>。</p><p>MAC地址，用于标识网络设备，类似于身份证，且理论上全球唯一。</p><p>（MAC地址是可以修改的，但是一般是不建议修改的。）</p><p><strong>MAC地址的组成：</strong>——以太网内的MAC地址是一个48bit的值，通常人为识别时是通过16进制数来识别的，以两个十六进制数为一组，一共分为6组，每组通过冒号隔开，前三组叫做，厂商ID，后三组叫做，设备ID.</p><p>如何查询Linux的MAC地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure><p>如何查询 Windows的MAC地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">鼠标右键点击计算机右下角电脑图标，选择网络和共享中心，选择更改适配器设置，找到联网的图标，双击打开，点击详细信息，即可找到MAC地址。</span><br></pre></td></tr></table></figure><h3 id="3-IP地址"><a href="#3-IP地址" class="headerlink" title="3.IP地址"></a>3.<strong>IP地址</strong></h3><p>IP地址是一种Intenet上的主机编址方式，也称为网际协议地址。</p><p> IP地址是任意一台主机在网络中的唯一表示。</p><p><strong>IP地址的分类：</strong></p><p>IPV4——占32位，（主要用）</p><p>IPV6占128位，</p><p>（任意一个IP地址通过路由器都可以下分一个局域网。）</p><p><strong>IP地址组成：</strong></p><p>IPV4一般使用点分十进制字符串来表示，比如192.168.6.106</p><p>（ip地址有点类似于MAC地址，MAC地址是通过冒号把两个十六进制的数放一块来表示一组，一共有六组组成，而ipv4是通过点来把ip地址分开，相当于每一个点把它间隔1个字节，这是我们认为的时候是通过点分十进制的，但是如果实在网络中计算机识别，它还是一个整型的数据，占四个字节。）</p><hr><p>使用32bit，由（网络、ID、主机 ID）两部分组成</p><p>子网ID:IP地址中由子网掩码中1覆盖的连续位。</p><p>主机ID:IP地址中由子网掩码中0覆盖的连续位。</p><hr><p>子网ID和主机ID为什么这么区分呢？</p><p>——通过主机ID的范围可以确定当前一个网段到底可以下分多少个主机。</p><p><img src="/images/image-20210401191658443.png"></p><p><strong>IP地址的特点：</strong></p><p>子网ID不同的网络不能直接通信，如果要通信则需要路由器转发。</p><p>主机ID全为0的IP地址表示网段地址。</p><p>主机ID全为1（255个）的IP地址表示该网段的广播地址。 </p><p>例如：192.168.3.10和192.168.3.111可以直接通信。</p><p>​            对192.168.3.x网段而言，192.168.3.0表示网段， 192.168.3.255表示广播地址 。</p><p><strong>IP地址分类如下:</strong></p><p><strong>ABC三类地址是最常用的</strong></p><p>IPV4地址的分类（依据前8位进行区分）</p><p>A类地址：默认8bit子网ID,第一位为0，前八位范围00000000-011111111，0.x.x.x-127.x.x.x</p><p>B类地址：默认16bit子网ID，前两位为10，前八位范围10000000-10111111,128.x.x.x-191.x.x.x</p><p>C类地址：默认24bit子网ID,前三位为110，前八位范围11000000-11011111 ，192.x.x.x-223.x.x.x</p><p>D类地址：前四位为1110，多播（组播）地址,前八位范围11100000-11101111，  224.x.x.x-239.x.x.x</p><p>E类地址：前五位为11110，保留为今后使用，前八位范围11110000-11111111,</p><p>240.x.x.x-255.x.x.x</p><hr><p><strong>公有IP：</strong>（可直接连接Internet）</p><p>​    经由InterNIC所统一规划的IP。</p><p><strong>私有IP：</strong>（不可直接连接Internet）</p><p>​    主要用于局域网内的主机连接规划。</p><p><img src="/images/image-20210401194106678.png"></p><p>​    <strong>回环IP地址：</strong></p><p>通常127.0.0.1称为回环地址。</p><p>功能：主要测试本机的网络配置，能ping通127.0.0.1说明本机的网卡和IP协议安装都没有问题。</p><p>注意：127.0.0.1-127.255.255.254中的任何地址都将回环到本地主机中，</p><p>不属于任何一个有类别地址类，它代表设备的本地虚拟接口。</p><p><strong>查询IP地址的命令：</strong></p><p>Linux——ifconfig</p><p>Windows——ipconfig</p><p><strong>判断主机是否可以连接通信：</strong></p><p>ping ip地址，</p><p>如果显示%0 packet loss，就表示可以正常通信。</p><p><strong>子网掩码：</strong></p><p>子网掩码（subnet mask）又叫做网络掩码、地址掩码是一个32bit由1和0组成的数值，并且1和0 分别连续。</p><p>作用：指明IP地址中哪些位标识的是主机所在的子网以及哪些是标识的主机号。</p><p>特点：必须结合IP地址一起使用，不能单独存在。</p><p>​            IP地址中由子网掩码中1覆盖的连续位为子网ID，其余为主机ID。</p><p>子网掩码的表现形式：</p><p>192.168.220.0/255.255.255.0</p><p>192.168.220.0/24</p><p>手动配置:</p><p>Linux——<img src="/images/image-20210401200652709.png"></p><p>默认的子网掩码：</p><p>A类IP地址的默认子网掩码-255.0.0.0</p><p>B类IP地址的默认子网掩码-255.255.0.0</p><p>C类IP地址的默认子网掩码-255.255.255.0(对应的网络ID是前三个字节，主机ID是最后一个字节，最多能给他分配256个IP地址，其中.0和.255分别表示网段和广播地址，所以一共可以分配254个IP地址)</p><h3 id="4-端口："><a href="#4-端口：" class="headerlink" title="4.端口："></a>4.<strong>端口：</strong></h3><p>端口概述</p><p>TPC/IP协议采用端口标识通信的进程</p><p>用于区分一个系统里的多个进程</p><p>特点：</p><ol><li><p>对于同一个端口，在不同系统中对应着不同的进程。</p></li><li><p>对于同一个系统，一个端口只能被一个进程拥有。</p></li><li><p>一个进程拥有一个端口后，传输层送到该端口的数据全部被该进程接收，同样，进程送交给传送层的数据也通过该端口被送出。</p><p><strong>端口号：</strong></p><p>类似pid（进程号）标识一个进程，在网络程序中，用端口号(port)来标识一个运行的网络程序。</p><p><strong>特点：</strong></p><ol><li>端口号是无符号短整型类型。</li><li>每个端口都有一个端口号。</li><li>TPC、UDP维护各自独立的端口号。</li><li>网络应用程序，至少占用一个端口号，也可以占用多个端口号。</li></ol><p><strong>知名端口</strong>号（1~1023）</p><p>由互联网数字分配机构（IANA）根据用户需要进行统一分配</p><p>例如：FTP-21,HTTP-80</p><p>服务器通常使用的范围：</p><p>若强制使用，需加root权限 。</p><p><strong>动态端口</strong>（1024~65535）</p><p>应用程序通常使用的范围。</p><p>一般我们可以使用的端口号就在这个范围，比如：6666、7777、8888、9999、10000、10001等。</p><p><strong>注意：</strong></p><p>​    端口号类似于进程号，同一时刻只能标识一个进程。</p><p>​    可以重复使用。</p></li></ol><h2 id="15-数据包的组装、拆解"><a href="#15-数据包的组装、拆解" class="headerlink" title="15.数据包的组装、拆解"></a>15.数据包的组装、拆解</h2><h3 id="1-数据包在各个层之间的传输"><a href="#1-数据包在各个层之间的传输" class="headerlink" title="1.数据包在各个层之间的传输"></a>1.数据包在各个层之间的传输</h3><p><img src="/images/image-20210402121144462.png"></p><h3 id="2-链路层封包模式"><a href="#2-链路层封包模式" class="headerlink" title="2.链路层封包模式"></a>2.链路层封包模式</h3><p><img src="/images/image-20210402121958302.png"></p><p>目的地址：目的MAC地址</p><p>源地址：源MAC地址</p><p>类型：确定以太网头后面跟的是哪个协议</p><p>​            0X0800 IP协议</p><p>​            0x0806 arp协议</p><p>​            0x0835 rarp协议</p><p><strong>注意：</strong></p><p>1、IEE802.2/802.3封装常用在无线。</p><p>2、以太网封装常用在有线局域网</p><h3 id="3-网络层、传输层封包格式"><a href="#3-网络层、传输层封包格式" class="headerlink" title="3.网络层、传输层封包格式"></a>3.网络层、传输层封包格式</h3><p><img src="/images/image-20210402122735364.png"></p><h2 id="16-网络应用程序开发流程"><a href="#16-网络应用程序开发流程" class="headerlink" title="16.网络应用程序开发流程"></a>16.网络应用程序开发流程</h2><h3 id="1-TPC——面向连接"><a href="#1-TPC——面向连接" class="headerlink" title="1.TPC——面向连接"></a>1.TPC——面向连接</h3><p>电话系统服务模式的抽象。</p><p>每一次完整的数据传输都要经过建立连接、使用连接、终止连接的过程。</p><p>本质上，连接是一个管道，收发数据不但顺序一致，而且内容相同。</p><p>保证数据传输的可靠性。</p><p><img src="/images/image-20210402143007985.png"></p><h3 id="2-UDP面向无连接"><a href="#2-UDP面向无连接" class="headerlink" title="2.UDP面向无连接"></a>2.UDP面向无连接</h3><p>邮件系统服务模式的抽象。</p><p>每个分组都携带完整的目的地地址。</p><p>不能保证分组的先后顺序。</p><p>不进行分组出错的恢复和重传。</p><p>不保证数据传输的可靠性。</p><p><img src="/images/image-20210402143326619.png"></p><hr><p>无论采用面向连接的还是无连接的，两个进程通信过程中，大多采用c/s架构（客户端 服务器架构）,</p><p>client向server发送请求，server接收到后提供相应的服务。</p><p>在通信过程中往往都是client先发送请求，而server等待请求然后进行服务。</p><p><img src="/images/image-20210402143629366.png"></p><hr><p>c/s架构示例，（面向连接）</p><p><img src="/images/image-20210402144056505.png"></p><p>服务器要先与客户端进行连接，TCP三次握手，三次握手成功之后，才可以相互发送数据，结束时，TCP四次挥手。</p><hr><p><strong>suerver工作过程</strong></p><p>打开通信通道告诉本地主机，它愿意在一特定端口（如80）上接收客户请求，</p><p>等待客户请求到达该端口，</p><p>接收客户请求，并发送应答信号，激活一新的线程处理这个客户请求，</p><p>服务完成后，关闭新线程与客户的通信链路。</p><p><strong>client工作过程</strong></p><p>打开一通信通道并连接到服务器特定端口，</p><p>向服务器发送服务请求，等待并接收应答，</p><p>根据需求继续提出请求，</p><p>请求结束后关闭通信通道并终止。</p><hr><h1 id="2-UDP编程"><a href="#2-UDP编程" class="headerlink" title="2.UDP编程"></a>2.UDP编程</h1><h2 id="1-编程准备-字节序、地址转换"><a href="#1-编程准备-字节序、地址转换" class="headerlink" title="1.编程准备-字节序、地址转换"></a>1.编程准备-字节序、地址转换</h2><h3 id="1-字节序概述"><a href="#1-字节序概述" class="headerlink" title="1.字节序概述"></a>1.字节序概述</h3><p>是指多字节数据的存储顺序。</p><p><strong>分类：</strong></p><p>​        小端格式：将低位字节数据存储在低地址。</p><p>​        大端格式：将高位字节数据存储在低地址。</p><p><strong>注意：</strong></p><p>​        LSB:低地址。</p><p>​        MSB:高地址。</p><p><img src="/images/image-20210402151122456.png"></p><p><strong>如何判断当期机器的字节序：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">un</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">char</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">un</span> <span class="title">myun</span>;</span></span><br><span class="line">myun.a = <span class="number">0x12345678</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = %#x\n&quot;</span>, myun.a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b = %#x\n&quot;</span>, myun.b);</span><br><span class="line"><span class="keyword">if</span> (myun.b == <span class="number">0x78</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;小端存储模式\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;大端存储模式\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-字节序转换函数"><a href="#2-字节序转换函数" class="headerlink" title="2.字节序转换函数"></a>2.字节序转换函数</h3><p><strong>特点：</strong></p><ol><li>网络协议指定通信字节序为大端存储。</li><li>只有在字节数据处理时才需要考虑字节序。</li><li>运行在同一台计算机上的进程互相通信时，一般不用考虑字节序。</li><li>异构计算机之间通讯，需要转换自己的字节序为网络字节序。</li></ol><p><strong>在需要字节转换的时候一般调用特定字节序转换函数。</strong></p><blockquote><p>host —&gt; network</p><p>1——htonl</p><p>2——htons</p><p>network —&gt; host</p><p>3——ntohl</p><p>4——ntohs</p></blockquote><h4 id="1-htonl"><a href="#1-htonl" class="headerlink" title="1.htonl"></a>1.htonl</h4><p><strong>头文件：</strong></p><p>​        #include&lt;arpa/inet.h&gt;</p><p>​        uint32_t htonl(uint32_t hostint32);</p><p><strong>功能：</strong></p><p>​        将32位主机字节序数据转换成网络字节序数据</p><p><strong>参数：</strong></p><p>​        hostint32:待转换的32位主机字节序数据。</p><p><strong>返回值：</strong><br>        成功：返回网络字节序的值.</p><h4 id="2-htons"><a href="#2-htons" class="headerlink" title="2.htons"></a>2.htons</h4><p><strong>头文件：</strong></p><p>​        #include&lt;arpa/inet.h&gt;</p><p>​        uint16_t htons(uint16_t hostint16);</p><p><strong>功能：</strong></p><p>​        将16位主机字节序数据转换成网络字节序数据</p><p><strong>参数：</strong></p><p>​        uint16_t: unsigned short int </p><p>​        hostint16:待转换的16位主机字节序数据。</p><p><strong>返回值：</strong><br>        成功：返回网络字节序的值。</p><h4 id="3-ntohl"><a href="#3-ntohl" class="headerlink" title="3.ntohl"></a>3.ntohl</h4><p><strong>头文件：</strong></p><p>​        #include&lt;arpa/inet.h&gt;</p><p>​        uint32_t ntosl(uint32_t hostint32);</p><p><strong>功能：</strong></p><p>​        将32位网络字节序数据主机字节序数据。</p><p><strong>参数：</strong></p><p>​        uint32_t: unsigned  int </p><p>​        netint32:待转换的32位网络字节序数据。</p><p><strong>返回值：</strong><br>        成功：返回主机字节序的值。</p><h4 id="4-ntohs"><a href="#4-ntohs" class="headerlink" title="4.ntohs"></a>4.ntohs</h4><p><strong>头文件：</strong></p><p>​        #include&lt;arpa/inet.h&gt;</p><p>​        uint16_t ntosl(uint16_t hostint16);</p><p><strong>功能：</strong></p><p>​        将16位网络字节序数据主机字节序数据。</p><p><strong>参数：</strong></p><p>​        uint32_t: unsigned  short int </p><p>​        netint32:待转换的16位网络字节序数据。</p><p><strong>返回值：</strong><br>        成功：返回主机字节序的值。</p><hr><p>案例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Linux</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0x123456789</span>;</span><br><span class="line">    <span class="keyword">short</span> b = <span class="number">0x1234</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%#x\n&quot;</span>,htonl(a));<span class="comment">//0x785612</span></span><br><span class="line">    <span class="comment">//转化为网络字节序变成了大端存储模式</span></span><br><span class="line">    <span class="comment">//c语言%#x是指带格式的16进制输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%#x\n&quot;</span>,htons(a));<span class="comment">//0x3412</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-地址转换函数"><a href="#3-地址转换函数" class="headerlink" title="3.地址转换函数"></a>3.地址转换函数</h3><p>人为识别的ip地址是点分十进制数串形式，但是计算机或者网络中识别的ip地址是整形数据，所以需要进行转化。</p><h4 id="1-inet-pton函数"><a href="#1-inet-pton函数" class="headerlink" title="1.inet_pton函数"></a>1.inet_pton函数</h4><p>字符串 ip地址转整型数据</p><p><strong>头文件：</strong></p><p>​        #include&lt;arpa/inet.h&gt;</p><p>int inet_pton(int famliy,const char &amp;strptr, void *addrptr)</p><p>人为识别的时候，ip地址就是一串字符串。让网络或者识别的时候，要将他转化为整型数据。用四字节的整数来保存整个ip地址。</p><p><strong>功能：</strong></p><p>​        将点分十进制的数转换成32位无符号整数。</p><p><strong>参数;</strong></p><p>​        family 协议族</p><pre><code>             AF_INET   IPV4网络协议</code></pre><p>​                AF_INET6 IPV6网络协议</p><p>​        strptr 点分十进制数串 </p><p>​        addrptr 32位无符号整数的地址</p><p><strong>返回值：</strong></p><p>​        成功返回1、失败返回其他</p><hr><p>案例：</p><p>​    </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ip_str = <span class="string">&quot;192.168.3.103&quot;</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ip_int = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *ip_p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//将点分十进制ip地址转化为32位无符号整型数据</span></span><br><span class="line">    inet_pton(AF_INET ,ip_str,&amp;ip_int);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ip_net = %d\n&quot;</span>,ip_net);</span><br><span class="line">    ip_p = (<span class="keyword">char</span> *)&amp;ip_int;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in_uint = %d,%d,%d,%d\n&quot;</span>,*ip_p,*(ip_p+<span class="number">1</span>),*(ip_p+<span class="number">2</span>),*(ip_p+<span class="number">3</span>));</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="/images/image-20210403100508157.png"></p><hr><h4 id="2-inet-ntop函数"><a href="#2-inet-ntop函数" class="headerlink" title="2.inet_ntop函数"></a>2.inet_ntop函数</h4><p>整型数据转字符串格式ip地址</p><p><strong>头文件：</strong></p><p>​    #include&lt;arpa/inet.h&gt;</p><p>const char *inet_ntop(int family,const void *addrptr,char *strptr,size_t len);</p><p><strong>功能：</strong></p><p>​    将32位无符号整数转换为点分十进制数串。</p><p><strong>参数：</strong><br>    family 协议族</p><p>​    addrptr 32位无符号整数</p><p>​    strptr点分十进制数串</p><p>​    len strptr缓冲区长度</p><p>​                len 的宏定义</p><p>​                #define INET_ADDRSTRLEN 16     //for IPV4</p><p>​                #define INET_ADDRSTRLEN 46     //for IPV6</p><p><strong>返回值：</strong></p><p>​    成功：则返回字符串首地址。</p><hr><p>案例;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> ip_net[] = &#123;<span class="number">192.168</span><span class="number">.3</span><span class="number">.103</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> ip_str[<span class="number">16</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    inet_ntop(AF_INET,&amp;ip_int,ip_str,<span class="number">16</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ip_s = %s\n&quot;</span>,ip_str);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果:</p><p><img src="/images/image-20210403101223448.png"></p><hr><h4 id="3-inet-addr-和ine-ntoa"><a href="#3-inet-addr-和ine-ntoa" class="headerlink" title="3.inet_addr()和ine_ntoa()"></a>3.inet_addr()和ine_ntoa()</h4><p>只能用在IPV4的ip地址的转换中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">in_addr_t</span> <span class="title">inet_addr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cp)</span></span>;</span><br><span class="line">功能：</span><br><span class="line">    将点分十进制ip地址转化为整型数据。</span><br><span class="line">参数：</span><br><span class="line">    cp:点分十进制ip地址</span><br><span class="line">返回值：</span><br><span class="line">    成功：整型数据</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">inet_ntoa</span><span class="params">(struct in_addr in)</span></span>;</span><br><span class="line">功能：</span><br><span class="line">    将整型数据转化为点分十进制的ip地址</span><br><span class="line">参数：</span><br><span class="line">    in:保存ip地址的结构体</span><br><span class="line">返回值:</span><br><span class="line">成功：点分十进制ip地址。</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-UDP介绍、编程流程"><a href="#2-UDP介绍、编程流程" class="headerlink" title="2.UDP介绍、编程流程"></a>2.UDP介绍、编程流程</h2><h3 id="1-UDP概述"><a href="#1-UDP概述" class="headerlink" title="1.UDP概述"></a>1.UDP概述</h3><p><strong>UDP协议：</strong></p><p>​    面向无连接的用户数据协议，在传输数据前不需要先建立连接，目的主机的运输层收到UDP报文后，不需要给出任何确认。</p><p><strong>UDP特点：</strong></p><ol><li>相比TCP速度稍快。</li><li>简单的请求/应答应用程序可以使用UDP.</li><li>对于海量的数据传输不应该使用UDP.</li><li>广播和多播应用必须使用 UDP。</li></ol><p><strong>UDP应用：</strong></p><p>​    DNS(域名解析)、NFS(网络文件系统)、RTP(流媒体)等。</p><p>​    一般语音和视频通话都是使用UDP来通信的</p><h3 id="2-网络的编程接口socket"><a href="#2-网络的编程接口socket" class="headerlink" title="2.网络的编程接口socket"></a>2.网络的编程接口socket</h3><p><strong>网络通信要解决的是不用主机进程间的通信。</strong></p><ol><li><p>首要问题是网络间进程标识问题。</p></li><li><p>以及多重协议的识别问题。</p><p>​    20世纪80年代初，加州大学Berkeley分校在BSD(一个UNIX OS版本)系统内实现了TPC/IP协议；其网络程序编程开发接口为socket。</p></li></ol><p>随着UNIX以及类UNIX的操作系统的广泛应用，socket成为最流行的网络程序开发接口。</p><p>(Linux操作系统就是类UNIX操作系统。)</p><p><strong>socket作用：</strong></p><p>​    提供不同主机上进程之间的通信。</p><p><strong>socket特点:</strong></p><ol><li>socket也成”套接字”。</li><li>是一种文件描述符，代表了一个通信管道的一个端点。</li><li>类似于对文件的操作一样（读写操作），可以使用read、write、close等函数对socket套接字进行网络数据的收取和发送等操作。</li><li>得到socket套接字（描述符）的方法调用socket()。</li></ol><p><strong>socket的分类：</strong></p><p>SOCK_STREAM，流式套接字，用于TCP。</p><p>SOCK_DGRAM，数据报套接字，用于UDP。</p><p>SOCK_ROW，原始套接字，对于其他层次的协议操作时需要使用这个类型。</p><h3 id="3-UDP编程c-s架构"><a href="#3-UDP编程c-s架构" class="headerlink" title="3.UDP编程c/s架构"></a>3.UDP编程c/s架构</h3><p><img src="/images/image-20210403161617968.png"></p><p>（左边UDP客户端                                                                 右边UDP服务器     ）</p><p>（服务器永远是被动的，客户端是主动的。）</p><p><strong>UDP网络编程流程：</strong></p><p>​    <strong>服务器：</strong></p><p>​            创建套接字socket()</p><p>​            将服务器的IP地址、端口号与套接字进行绑定bind()</p><p>​            (为什么要进行绑定，只有当你进行绑定了之后，服务器所对应的信息才能固定，客户端才能找到服务器。)</p><p>​            接收数据recvfrom()</p><p>​            发送数据sendto()</p><p>​    <strong>客户端：</strong></p><p>​            创建套接字socket()</p><p>​            发送数据sendto()</p><p>​            接收数据recvfrom()</p><p>​            关闭套接字close()</p><h3 id="4-UDP编程-创建套接字"><a href="#4-UDP编程-创建套接字" class="headerlink" title="4.UDP编程-创建套接字"></a>4.UDP编程-创建套接字</h3><p>int socket(int family,int type,int protocol);</p><p><strong>功能：</strong></p><p>​    创建一个用于网络通信的socket套接字（描述符）。</p><p><strong>参数：</strong></p><p>​    family:协议族(AF_INET、AF_INET6、PF_PACKET等)</p><p>​    type:套接字类(SOCK_STREAM、SOCK_DGRAM、SOCK_RAW等)</p><p>​    protocol:协议族类(0、IPPROTO_TCP、IPPROTO_UDP等)</p><p><strong>返回值：</strong></p><p>​    套接字</p><p><strong>特点：</strong></p><p>​     创建套接字时，系统不会分配端口。</p><p>​     创建的套接字默认属性是主动的，即主动发起服务的请求；当作为服务器时，往往需要修改为被动的。</p><p><strong>头文件：</strong></p><p>​    #include&lt;sys/socket.h&gt;</p><h3 id="5-创建UDP套接字demo"><a href="#5-创建UDP套接字demo" class="headerlink" title="5.创建UDP套接字demo"></a>5.创建UDP套接字demo</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//使用socket函数创建套接字</span></span><br><span class="line">    <span class="comment">//创建一个用于UDP网络编程的套接字</span></span><br><span class="line">    <span class="keyword">int</span> socket;</span><br><span class="line">    <span class="keyword">if</span>((socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sockfd = %d\n&quot;</span>,sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line">sockfd = <span class="number">3</span>；</span><br></pre></td></tr></table></figure><h2 id="3-UDP编程-发送-、绑定、接收数据"><a href="#3-UDP编程-发送-、绑定、接收数据" class="headerlink" title="3.UDP编程 - 发送 、绑定、接收数据"></a>3.UDP编程 - 发送 、绑定、接收数据</h2><h3 id="1-IPV4套接字地址结构"><a href="#1-IPV4套接字地址结构" class="headerlink" title="1.IPV4套接字地址结构"></a>1.IPV4套接字地址结构</h3><p>**在网络编程中经常使用的结构体 **sockaddr_in</p><p> <strong>头文件：</strong>#include&lt;netinet/in.h&gt;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  int_addr_t_s_addr;<span class="comment">//4字节</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socketaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sin_family;<span class="comment">//2 协议族</span></span><br><span class="line">    <span class="keyword">in_port_t</span> sin_port;<span class="comment">//2字节 端口号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span><span class="comment">//4个字节 IP地址</span></span><br><span class="line">    <span class="keyword">char</span> sin_zero[<span class="number">8</span>];<span class="comment">//8个字节------填充，不起什么作用，一个char类型的数组。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了使不同格式地址能被传入套接字函数，地址须要强制转换成通用套接字地址结构。</p><p>因为：不同场合使用的结构体不一样，但是调用的函数却是同一个，所以定义一个通用结构体，当在指定场合使用时，再根据要求传入指定的结构体即可。</p><p><strong>通用结构体</strong></p><p>sockaddr</p><p>#include&lt;netinet/in.h&gt;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sa_family;<span class="comment">//2个字节</span></span><br><span class="line">    <span class="keyword">char</span> sa_data[<span class="number">14</span>];<span class="comment">//14个字节</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>​    以上三个结构在Linux系统中已经定义。</p><h3 id="2-两种地址结构使用场合"><a href="#2-两种地址结构使用场合" class="headerlink" title="2.两种地址结构使用场合"></a>2.两种地址结构使用场合</h3><p>在定义源地址和目的地址结构时，选用struct sockaddr_in</p><p>例：</p><p>struct sockaddr_in my_addr;</p><p>当调用编程接口函数，且该函数也需要传入地址结构时需要用struct sockaddr进行强制转换。</p><p>例：</p><p>bind(sockfd,(struct sockaddr*)&amp;my_addr,sizeof(my_addr));</p><h3 id="3-发送数据-sendto函数"><a href="#3-发送数据-sendto函数" class="headerlink" title="3.发送数据-sendto函数"></a>3.发送数据-sendto函数</h3><p>ssize_t sendto(int sockfd const void *buf,</p><p>​                        size_t nbytes,int flags,</p><p>​                        const struct sockaddr *to,</p><p>​                        socklen_t addrlen);</p><p><strong>功能：</strong></p><p>​    向to结构体指针中指定的ip，发送UDP数据。</p><p><strong>参数：</strong></p><p>​    sockfd:套接字</p><p>​    buf:发送数据缓冲区</p><p>​    nbytes:发送数据缓冲区的大小</p><p>​        </p><p>​    flags:一般为0</p><p>​    to:指向目的主机地址结构体的指针</p><p>​    addrlen:to所指向内容的长度</p><p><strong>注意：</strong></p><p>​    to和addrlen确定目的地址</p><p>​    可以发送0长度的UDP数据包</p><p><strong>返回值：</strong></p><p>​    成功：发送数据的字符数</p><p>​    失败：-1</p><h3 id="4-向”网络调试助手”发送消息"><a href="#4-向”网络调试助手”发送消息" class="headerlink" title="4.向”网络调试助手”发送消息"></a>4.向”网络调试助手”发送消息</h3><h3 id="5-绑定-bind函数"><a href="#5-绑定-bind函数" class="headerlink" title="5.绑定 bind函数"></a>5.绑定 bind函数</h3><p>UDP网络程序想要收取数据需要什么条件？</p><p>​    确定的ip地址</p><p>​    确定的port</p><p>怎样完成上面的条件呢？</p><p>​    接收端 使用bind函数，来完成地址结构和socket套接字的绑定，这样ip、port就固定了。</p><p>​    发送端 在sendto函数中指定接收端的ip、port,就可以发送数据了。</p><hr><p>由于服务器是被动的，客户端是主动的，一般先运行服务器，后运行客户端，所以服务器需要固定自己的信息（ip、port），这样客户端才可以找到服务器并与之通信，客户端一般不需要bind绑定，因为系统会自动给客户端分配ip地址和端口号。</p><hr><p>int bind(int sockfd,</p><p>​                    const struct sockaddr * myaddr , socklen_t addrlen);</p><p><strong>功能：</strong></p><p>​    将本地协议地址与sockfd绑定。</p><p><strong>参数：</strong></p><p>​    sockfd: socket套接字</p><p>​    myaddr:指向特定协议的地址结构指针</p><p>​    addrlen:该地址结构的长度</p><p><strong>返回值：</strong></p><p>​    成功：返回0</p><p>​    失败：其他</p><h3 id="6-bind示例"><a href="#6-bind示例" class="headerlink" title="6.bind示例"></a>6.bind示例</h3><h3 id="7-接收数据——recvfrom-函数"><a href="#7-接收数据——recvfrom-函数" class="headerlink" title="7.接收数据——recvfrom 函数"></a>7.接收数据——recvfrom 函数</h3><p>ssize_t recvfrom(int sockfd,void *buf,</p><p>​                            size_t nbytes,int flags,</p><p>​                            struct sockaddr *from,</p><p>​                            socklen_t 8addrlen);</p><p><strong>功能：</strong></p><p>​    接收UDP数据 ，并将源地址信息保存在from指向的结构中。</p><p><strong>参数：</strong></p><p>​    sockfd:套接字</p><p>​    buf:接收数据缓区</p><p>​    flags:套接字标志(常为0)</p><p>​    from:源地址结构体指针，用来保存数据的来源</p><p>​    addrlen:from所指内容的长度</p><p><strong>注意：</strong></p><p>​    通过from和addrlen存放数据来源的信息</p><p>​    from和addrlen可以为NULL,表示不保存数据的来源</p><p><strong>返回值：</strong></p><p>​    成功：接收到的字符数</p><p>​    失败：-1</p><h3 id="8-接收”网络调试助手”的数据"><a href="#8-接收”网络调试助手”的数据" class="headerlink" title="8.接收”网络调试助手”的数据"></a>8.接收”网络调试助手”的数据</h3><h2 id="4-回顾"><a href="#4-回顾" class="headerlink" title="4.回顾"></a>4.回顾</h2><p><strong>UDP编程-client、server</strong></p><p>​    其实在网络编程开发中，clent和server双方既可以有发送数据还可以接收数据；一般认为服务的一方为server,而接受服务的一方为client.</p><p>​    <strong>C/S架构回顾</strong></p><h2 id="5-UDP客户端注意点"><a href="#5-UDP客户端注意点" class="headerlink" title="5.UDP客户端注意点"></a>5.UDP客户端注意点</h2><ol><li>本地ip,本地端口（我是谁）</li><li>目的ip.目的端口（发给谁）</li><li>在客户端代码中，我们只设置了目的ip,目的端口。</li></ol><p><img src="/images/image-20210404105327134.png">                            </p><h2 id="6-UDP服务器注意点"><a href="#6-UDP服务器注意点" class="headerlink" title="6.UDP服务器注意点"></a>6.UDP服务器注意点</h2><ol><li>服务器之所以需要bind是因为它的本地port是需要固定的，而不是随机的。</li><li>服务器也可以主动地给客户端发送数据。</li><li>客户端也可以用bind ，这样客户端的本地端口就是固定的了，但一般不这样做。</li></ol><hr><p>参考视频：<a href="https://www.bilibili.com/video/BV1pX4y1N7T4?p=41">https://www.bilibili.com/video/BV1pX4y1N7T4?p=41</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-计算机网络概述&quot;&gt;&lt;a href=&quot;#1-计算机网络概述&quot; class=&quot;headerlink&quot; title=&quot;1.计算机网络概述&quot;&gt;&lt;/a&gt;1.计算机网络概述&lt;/h1&gt;&lt;h2 id=&quot;1-最早的广域网&quot;&gt;&lt;a href=&quot;#1-最早的广域网&quot; class=&quot;</summary>
      
    
    
    
    <category term="网络编程" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="-C语言" scheme="http://example.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="-计算机" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="-网络编程" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>C语言实现字母数字雨小程序</title>
    <link href="http://example.com/2021/03/31/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%AD%97%E6%AF%8D%E6%95%B0%E5%AD%97%E9%9B%A8%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    <id>http://example.com/2021/03/31/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%AD%97%E6%AF%8D%E6%95%B0%E5%AD%97%E9%9B%A8%E5%B0%8F%E7%A8%8B%E5%BA%8F/</id>
    <published>2021-03-31T12:58:28.000Z</published>
    <updated>2021-03-31T13:00:53.815Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字母数字雨</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//随机数头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//包含easyX图形库 可以使用绘图函数 以及鼠标操作</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;graphics.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;conio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STR_SIZE 20<span class="comment">//没串雨的字符个数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAIN_NUM 128<span class="comment">//雨的数量</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WIDTH 960</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEIGHT 640</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STR_W 15<span class="comment">//字符宽度</span></span></span><br><span class="line"><span class="comment">//结构体封装属性</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rain</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line"><span class="keyword">int</span> speed;</span><br><span class="line"><span class="keyword">char</span> str[STR_SIZE];<span class="comment">//每一串字符语</span></span><br><span class="line">&#125;rain[RAIN_NUM];</span><br><span class="line"><span class="comment">//每一个字符串由字符组成</span></span><br><span class="line"><span class="comment">//写一个函数生成字符</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">createch</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> ch = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//随机产生字符，使用rand函数,</span></span><br><span class="line"><span class="comment">//随机中的随机</span></span><br><span class="line"><span class="keyword">int</span> flag = rand() % <span class="number">3</span>;<span class="comment">// 0 1 2</span></span><br><span class="line"><span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">ch = rand() % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>;<span class="comment">//产生0~9的随机数 加一个&#x27;0&#x27;把数字转化成字符</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">ch = rand() % <span class="number">26</span> + <span class="string">&#x27;a&#x27;</span>;<span class="comment">//随机产生字母 大写 小写 26个字母</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">ch = rand() % <span class="number">26</span> + <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数据的初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GameInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; RAIN_NUM; i++)</span><br><span class="line">&#123;</span><br><span class="line">rain[i].x = i*STR_W;<span class="comment">//每条雨之间的距离等距</span></span><br><span class="line">rain[i].y = rand() % HEIGHT;</span><br><span class="line">rain[i].speed = rand() % <span class="number">5</span> +<span class="number">5</span> ;<span class="comment">//在5 ~ 9之间</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; STR_SIZE; j++)</span><br><span class="line">&#123;</span><br><span class="line">rain[i].str[j] = createch();<span class="comment">//初始化每条雨</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//绘制</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GameDraw</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//双缓冲绘图</span></span><br><span class="line">BeginBatchDraw();</span><br><span class="line"><span class="comment">//清楚屏幕</span></span><br><span class="line">cleardevice();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; RAIN_NUM; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; STR_SIZE; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//设置颜色</span></span><br><span class="line">settextcolor(RGB(<span class="number">0</span>,<span class="number">255</span>-j*<span class="number">13</span>,<span class="number">0</span>));<span class="comment">//由下到上 越来越浅</span></span><br><span class="line"><span class="comment">//out text xy 输出文本到指定的位置</span></span><br><span class="line">outtextxy(rain[i].x,rain[i].y<span class="number">-15</span>*j,rain[i].str[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">EndBatchDraw();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">changeCh</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//找到每一个字符串</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; RAIN_NUM; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; STR_SIZE; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//让字符串的每一个字符，都有可能发生改变，但是不是同一时间发生改变。</span></span><br><span class="line">rain[i].str[rand() % STR_SIZE] = createch();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//让它动起来</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GamePlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; RAIN_NUM; i++)</span><br><span class="line">&#123;</span><br><span class="line">rain[i].y+=rain[i].speed;</span><br><span class="line"><span class="comment">//当它掉出屏幕后 传到上面</span></span><br><span class="line"><span class="keyword">if</span> (rain[i].y-STR_SIZE*STR_W &gt;= HEIGHT)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//让速度重新生成</span></span><br><span class="line">rain[i].speed = rand() % <span class="number">5</span> + <span class="number">5</span>;</span><br><span class="line">rain[i].y = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">changeCh();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下落的过程中，数字字母不断变化</span></span><br><span class="line"><span class="comment">//让程序暂停 原理就是运用死循环</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//判断是否有按键产生</span></span><br><span class="line"><span class="keyword">if</span> (_kbhit() &amp;&amp; _getch() == <span class="string">&#x27; &#x27;</span>)<span class="comment">//有按键返回非0值，否则返回0</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (_getch() != <span class="string">&#x27; &#x27;</span>);<span class="comment">//如果没有输入空格就一直等待</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建一个图形窗口,init初始化 大小 参数 宽高 SHOWCONSOLE显示黑窗口</span></span><br><span class="line">initgraph(WIDTH, HEIGHT);</span><br><span class="line"><span class="comment">//设置随机数种子</span></span><br><span class="line">srand(GetTickCount());<span class="comment">//返回从开机到现在所经过的毫秒数，让所产生的随机数不断的变化。</span></span><br><span class="line">GameInit();</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">GamePlay();</span><br><span class="line">GameDraw();</span><br><span class="line">changeCh();</span><br><span class="line">stop();</span><br><span class="line">&#125;</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考视频：<a href="https://www.bilibili.com/video/BV1kK411M7qo?t=5027">https://www.bilibili.com/video/BV1kK411M7qo?t=5027</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li</summary>
      
    
    
    
    <category term="C语言" scheme="http://example.com/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="-C语言" scheme="http://example.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
</feed>
